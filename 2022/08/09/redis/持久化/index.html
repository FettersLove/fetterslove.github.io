<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>持久化篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="持久化篇">
<meta property="og:type" content="article">
<meta property="og:title" content="持久化篇">
<meta property="og:url" content="http://example.com/2022/08/09/redis/%E6%8C%81%E4%B9%85%E5%8C%96/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="持久化篇">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:27:39.771Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/09/redis/%E6%8C%81%E4%B9%85%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: FettersLove","link":"Link: ","source":"Source: FettersLoveの博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '持久化篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-13 22:27:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">持久化篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="Created 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-13T14:27:39.771Z" title="Updated 2022-11-13 22:27:39">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="持久化篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Redis-如何实现数据不丢失？"><a href="#Redis-如何实现数据不丢失？" class="headerlink" title="Redis 如何实现数据不丢失？"></a>Redis 如何实现数据不丢失？</h2><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。<br>Redis 共有三种数据持久化的方式：</p>
<ul>
<li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><p><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RDB 的优点；</p>
<h2 id="ⅠRDB-快照（snapshotting）"><a href="#ⅠRDB-快照（snapshotting）" class="headerlink" title="ⅠRDB 快照（snapshotting）"></a>ⅠRDB 快照（snapshotting）</h2><h3 id="①概念："><a href="#①概念：" class="headerlink" title="①概念："></a>①概念：</h3></li>
<li><p>RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p>
</li>
<li><p>快照持久化是 Redis 默认采用的持久化方式。</p>
<h3 id="②触发方式"><a href="#②触发方式" class="headerlink" title="②触发方式"></a>②触发方式</h3><p>触发rdb持久化的方式有2种，分别是手动触发和自动触发。</p>
<h4 id="¶-手动触发："><a href="#¶-手动触发：" class="headerlink" title="¶ 手动触发："></a>¶ 手动触发：</h4><p>手动触发分别对应save和bgsave命令</p>
</li>
<li><p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用</p>
</li>
<li>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短<blockquote>
<p><strong>bgsave具体流程如下：</strong></p>
<ol>
<li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li>
<li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li>
<li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li>
<li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li>
</ol>
<p>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence        下的rdb_*相关选项）。<br>bgsave流程图如下所示<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649988149307-6bb18e26-9456-4354-8b7d-1f8e0f6f1470.png#averageHue=%23212121&amp;clientId=u3b371be1-c586-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=456&amp;id=u5b530bb8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=646&amp;originWidth=578&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32206&amp;status=done&amp;style=none&amp;taskId=u597de321-8468-4227-b963-48cc049743a&amp;title=&amp;width=408" alt="image.png"><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43064185/article/details/122035596">
</a></p>
</blockquote>
</li>
</ul>
<h4 id="¶-自动触发"><a href="#¶-自动触发" class="headerlink" title="¶ 自动触发"></a>¶ 自动触发</h4><p>在以下4种情况时会自动触发</p>
<ul>
<li>redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li>
<li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li>
<li>执行debug reload命令重新加载redis时也会触发bgsave操作；</li>
<li><p>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</p>
<h3 id="③RDB-更深入理解"><a href="#③RDB-更深入理解" class="headerlink" title="③RDB 更深入理解"></a>③RDB 更深入理解</h3><p>执行快照时数据能被修改吗？<br>关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong><br><strong>概念</strong></p>
</li>
<li><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。</p>
</li>
<li>只有在发生修改内存数据的情况时，物理内存才会被复制一份。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659423564170-1e1eef97-dee2-4b91-a164-4b7dc371e5f1.png#averageHue=%23f9f7f4&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=199&amp;id=PwWtn&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=707&amp;originWidth=774&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55470&amp;status=done&amp;style=none&amp;taskId=u3664a963-f7aa-4eb7-9557-bfb02777d8d&amp;title=&amp;width=218" alt="image.png">                        <img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659423564133-e4d1d710-c5ff-4af6-8bed-2c8c2cfdc61f.png#averageHue=%23faf9f6&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=ud88e94a3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=707&amp;originWidth=969&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=59927&amp;status=done&amp;style=none&amp;taskId=u308a7143-58cf-4176-a84c-ddce850a332&amp;title=&amp;width=277.0000305175781" alt="image.png"></p>
<ul>
<li>这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。</li>
</ul>
<p>所以，创建 bgsave 子进程后，由于共享父进程的所有内存数据，于是就可以直接读取主线程（父进程）里的内存数据，并将数据写入到 RDB 文件。</p>
<ul>
<li>当主线程（父进程）对这些共享的内存数据也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。</li>
<li>但是，如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 A）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 A’）</strong>，然后<strong>主线程在这个数据副本（键值对 A’）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 A）写入到 RDB 文件</strong>。</li>
</ul>
<p>就是这样，Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。</p>
<blockquote>
<p><strong>会产生的问题：</strong></p>
<ul>
<li>细心的同学，肯定发现了，bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没有办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</li>
<li>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</li>
<li>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</li>
</ul>
<p>另外，写时复制的时候会出现这么个极端的情况。<br>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。<br>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong><br>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p>
</blockquote>
<p>在进行快照操作的这段时间，如果发生服务崩溃怎么办？<br>很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。</p>
<p>可以每秒做一次快照吗？</p>
<blockquote>
<p>对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。</p>
<p>如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。 　　<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649988751186-ec8901c1-8d2a-4687-88ee-7a1bc82fd427.png#averageHue=%23f5f9ea&amp;clientId=u3b371be1-c586-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaabbad03&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1244&amp;originWidth=3292&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=428670&amp;status=done&amp;style=none&amp;taskId=u03ef6f2e-67b8-4ae6-affb-23efef9fd0e&amp;title=" alt="image.png"></p>
<p>所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。</p>
</blockquote>
<p>这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：</p>
<ul>
<li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li>
<li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</li>
</ul>
<p>那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。</p>
<p>但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？且看后文中4.0版本中引入的RDB和AOF的混合方式。<br>为什么要fork子进程而不是用子线程去做<br>如果子线程去做备份的时候没法保证数据的一致性，因为子线程会共享内存，如果需要单独的内存需要重新copy一份内存这样对于性能而言是非常不适合的</p>
<p>这样也能解释为什么要在fork完子进程的时候，要把redis的键值空间设置为禁止rehash<br>，因为redis是采用的渐进式hash的方式，如果处于rehash 无论set 或者get方式都会对旧的空间进行更改，这样就会不断的触发页帧写的异常，而需要分配更多的内存空间，这样对于性能还是受比较多的影响，但是rdb触发并没有判断是否处于rehash状态，所以rdb的方案是在必须执行的条件下，在rdb过程中尽量减少对页帧的修改而不是完全禁止。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659424665766-0fb78334-caaf-4b70-b9c9-631f04479fb4.png#averageHue=%23f9f7f4&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=X0qTu&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=707&amp;originWidth=774&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55420&amp;status=done&amp;style=none&amp;taskId=u1deabaee-2824-486e-a1cc-3afedd366ea&amp;title=&amp;width=296.0000305175781" alt="image.png"></p>
<h3 id="④RDB优缺点"><a href="#④RDB优缺点" class="headerlink" title="④RDB优缺点"></a>④RDB优缺点</h3><p>优点</p>
<ul>
<li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li>
<li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li>
</ul>
<p>缺点</p>
<ul>
<li>RDB方式实时性不够，无法做到秒级的持久化；</li>
<li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li>
<li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li>
<li>版本兼容RDB文件问题；</li>
</ul>
<p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p>
<h2 id="ⅡAOF（append-only-file）日志"><a href="#ⅡAOF（append-only-file）日志" class="headerlink" title="ⅡAOF（append-only file）日志"></a>ⅡAOF（append-only file）日志</h2><p>概念-&gt;为什么采用写后日志-&gt;如何实现aof-&gt;aof重写</p>
<h3 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h3><p>Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong></p>
<blockquote>
<p>PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。<br>而AOF日志采用写后日志，即<strong>先写内存，后写日志</strong>。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649988962678-07f7b0d1-1620-4302-bf51-936f978e493b.png#averageHue=%23f8f7e2&amp;clientId=u3b371be1-c586-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=u57ae3b30&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1789&amp;originWidth=3218&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=429445&amp;status=done&amp;style=none&amp;taskId=u891c58ec-6c84-46c5-ba1b-66cc37bbb11&amp;title=&amp;width=522.0000610351562" alt="image.png"></p>
<h3 id="②为什么采用写后日志？"><a href="#②为什么采用写后日志？" class="headerlink" title="②为什么采用写后日志？"></a>②为什么采用写后日志？</h3><p>Redis要求高性能，采用写日志有两方面好处：</p>
<ul>
<li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前的写操作</strong></li>
</ul>
<p>但这种方式存在潜在风险：</p>
<ul>
<li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li>
<li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。<h3 id="③AOF的三种写回策略"><a href="#③AOF的三种写回策略" class="headerlink" title="③AOF的三种写回策略"></a>③AOF的三种写回策略</h3>先来看看，Redis 写入 AOF 日志的过程，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658046514287-4d692f81-fe56-4195-83d5-b8975994f915.png#averageHue=%23fbf9f6&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=420&amp;id=ueae20460&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=977&amp;originWidth=860&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=74638&amp;status=done&amp;style=none&amp;taskId=u8990f4a3-8baa-41bd-aea5-beed32c25da&amp;title=&amp;width=370.0000305175781" alt="image.png"><br>具体说说：</li>
</ul>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p>我也把这 3 个写回策略的优缺点总结成了一张表格：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658046514278-06da027c-cb6c-44a0-b063-43555ddf8d60.png#averageHue=%23f0eee4&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=253&amp;id=u39761324&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=362&amp;originWidth=857&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=71731&amp;status=done&amp;style=none&amp;taskId=u0dd55520-15d0-41e3-9309-741f6b588a6&amp;title=&amp;width=598.0000610351562" alt="image.png"><br>大家知道这三种策略是怎么实现的吗？<br>深入到源码后，你就会发现这三种策略只是在控制 <strong>fsync() </strong>函数的调用时机。<br>当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659424326811-66975244-80d6-47f0-b2f4-c31f012af7d2.png#averageHue=%23f9f5f2&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=370&amp;id=u74b75b90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=647&amp;originWidth=527&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43161&amp;status=done&amp;style=none&amp;taskId=u0221a56b-f366-447d-8756-5e5b3931288&amp;title=&amp;width=301.0000305175781" alt="image.png"><br>如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 fsync() 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。</p>
<ul>
<li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li>
<li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li>
<li>No 策略就是永不执行 fsync() 函数;<h3 id="④redis-conf中配置AOF👌"><a href="#④redis-conf中配置AOF👌" class="headerlink" title="④redis.conf中配置AOF👌"></a>④redis.conf中配置AOF👌</h3>详细内容默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"> </span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"> </span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"> </span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"> </span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"> </span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
以下是Redis中关于AOF的主要配置信息：</li>
</ul>
<p>appendonly：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p>
<p>appendfilename：这个参数项很好理解了，就是AOF文件的名字。</p>
<p>appendfsync：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。</p>
<p>什么叫“真正执行”呢？还记得Linux操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中I/O队列的操作效率，应用程序提交的I/O操作请求一般是被放置在linux Page Cache中的，然后再由Linux操作系统中的策略自行决定正在写到磁盘上的时机。而Redis中有一个fsync()函数，可以将Page Cache中待写的数据真正写入到物理设备上，而缺点是频繁调用这个fsync()函数干预操作系统的既定策略，可能导致I/O卡顿的现象频繁 。</p>
<p>与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为everysec。</p>
<p>no-appendfsync-on-rewrite：always和everysec的设置会使真正的I/O操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的Redis是没法解决的。为了尽量缓解这个情况，Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache（这段时间Redis还在接受客户端的各种写操作命令）。</p>
<p>auto-aof-rewrite-percentage：上文说到在生产环境下，技术人员不可能随时随地使用“BGREWRITEAOF”命令去重写AOF文件。所以更多时候我们需要依靠Redis中对AOF文件的自动重写策略。Redis中对触发自动重写AOF文件的操作提供了两个设置：auto-aof-rewrite-percentage表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。</p>
<p>auto-aof-rewrite-min-size：参考auto-aof-rewrite-percentage选项的介绍，auto-aof-rewrite-min-size设置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage和auto-aof-rewrite-min-size只是用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右。</p>
<h3 id="⑤AOF-重写机制"><a href="#⑤AOF-重写机制" class="headerlink" title="⑤AOF 重写机制"></a>⑤AOF 重写机制</h3><ul>
<li>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</li>
<li>如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</li>
<li>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</li>
</ul>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<blockquote>
<p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659424665802-0f158b7f-eb3f-49c4-a0a9-e5fe317840dd.png#averageHue=%23f8f3ea&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uae25c102&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=423&amp;originWidth=1667&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=92170&amp;status=done&amp;style=none&amp;taskId=ua85d1661-e8ff-474f-84ce-6b312edcc1d&amp;title=" alt="image.png"><br>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。<br>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。<br>然后，在通过 AOF 日志恢复数据时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p>
</blockquote>
<p>所以，重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件。</p>
<p>这里说一下为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。<br>因为<strong>如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染</strong>，可能无法用于恢复使用。所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p>
<h3 id="⑥AOF-后台重写"><a href="#⑥AOF-后台重写" class="headerlink" title="⑥AOF 后台重写"></a>⑥AOF 后台重写</h3><blockquote>
<p>写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。<br>但是在触发 AOF 重写时，比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写，这时是需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。<br>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。</p>
</blockquote>
<p>所以，Redis 的<strong>重写 AOF**</strong> 过程是由后台子进程 <em>bgrewriteaof</em> 来完成的**，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本（<em>数据副本怎么产生的后面会说</em>），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>AOF重写会阻塞吗？<br>AOF重写过程是由后台进程<strong>bgrewriteaof</strong>来完成的。主线程fork出后台的bgrewriteaof子进程，所以aof在重写时，在fork进程时是会阻塞住主线程的。<br>子进程是怎么拥有主进程一样的数据副本的呢？</p>
<ul>
<li>主进程在通过 fork 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659424665766-0fb78334-caaf-4b70-b9c9-631f04479fb4.png#averageHue=%23f9f7f4&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u156d05d6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=707&amp;originWidth=774&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55420&amp;status=done&amp;style=none&amp;taskId=u1deabaee-2824-486e-a1cc-3afedd366ea&amp;title=&amp;width=260.0000305175781" alt="image.png"></p>
<ul>
<li>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</li>
<li>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>缺页中断</strong>，这个缺页中断是由于违反权限导致的，然后操作系统会在「缺页异常处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制(<em>Copy On Write</em>)</strong>」。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659424665766-42d77f86-beac-450b-9392-ade1cfa0421b.png#averageHue=%23faf9f6&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=u58769d28&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=707&amp;originWidth=969&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=59657&amp;status=done&amp;style=none&amp;taskId=u204d1544-3e86-4f96-81a9-0dfa68be94a&amp;title=&amp;width=349.0000305175781" alt="image.png"><br>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。<br>当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。<br>不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。</p>
<p>所以，有两个阶段会导致阻塞父进程：</p>
<ul>
<li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li>
<li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；<blockquote>
<p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。<br>但是子进程重写过程中，主进程依然可以正常处理命令。<br>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>。</p>
</blockquote>
</li>
</ul>
<p>所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。<br>在重写日志整个过程时，主线程有哪些地方会被阻塞？</p>
<ol>
<li>fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。</li>
<li>主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。</li>
<li>子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。</li>
</ol>
<p>还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？（重写日志时，有新数据写入怎么办）<br>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。<br>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659424665795-2102abc0-f421-4068-a3c8-ff83cdaf42a4.png#averageHue=%23f9f8f3&amp;clientId=u8c49ffa9-bcbc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=352&amp;id=uee417517&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=947&amp;originWidth=1412&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=121562&amp;status=done&amp;style=none&amp;taskId=u1eaaefd8-080d-4cec-a733-82ed7989b17&amp;title=&amp;width=525.0000610351562" alt="image.png"><br>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；<blockquote>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。<br>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。<br>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程</p>
</blockquote>
</li>
</ul>
<h2 id="Ⅲ为什么会有混合持久化？"><a href="#Ⅲ为什么会有混合持久化？" class="headerlink" title="Ⅲ为什么会有混合持久化？"></a>Ⅲ为什么会有混合持久化？</h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是数据恢复不快。</p>
<p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。<br>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658046888525-4811d472-4ffd-417e-be71-03a97b56d10f.png#averageHue=%23fbf0cd&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1db06f95&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=356&amp;originWidth=325&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39512&amp;status=done&amp;style=none&amp;taskId=u206c8f4f-b6a6-47ca-8377-947e4b22a5b&amp;title=" alt="image.png"><br>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。<br>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。<br><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/09/redis/%E6%8C%81%E4%B9%85%E5%8C%96/">http://example.com/2022/08/09/redis/%E6%8C%81%E4%B9%85%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Redis 如何实现数据不丢失？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0RDB-%E5%BF%AB%E7%85%A7%EF%BC%88snapshotting%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">ⅠRDB 快照（snapshotting）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">①概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">②触发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B6-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">¶ 手动触发：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B6-%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">2.2.2.</span> <span class="toc-text">¶ 自动触发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2RDB-%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">③RDB 更深入理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3RDB%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text">④RDB优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1AOF%EF%BC%88append-only-file%EF%BC%89%E6%97%A5%E5%BF%97"><span class="toc-number">3.</span> <span class="toc-text">ⅡAOF（append-only file）日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">①概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">②为什么采用写后日志？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2AOF%E7%9A%84%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">③AOF的三种写回策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3redis-conf%E4%B8%AD%E9%85%8D%E7%BD%AEAOF%F0%9F%91%8C"><span class="toc-number">3.4.</span> <span class="toc-text">④redis.conf中配置AOF👌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4AOF-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">⑤AOF 重写机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5AOF-%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99"><span class="toc-number">3.6.</span> <span class="toc-text">⑥AOF 后台重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">Ⅲ为什么会有混合持久化？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="Created 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="Created 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="Created 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="Created 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/" title="过期删除策略与内存淘汰篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="过期删除策略与内存淘汰篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/" title="过期删除策略与内存淘汰篇">过期删除策略与内存淘汰篇</a><time datetime="2022-08-08T16:00:00.000Z" title="Created 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>