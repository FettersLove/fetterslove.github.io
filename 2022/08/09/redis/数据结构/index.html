<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构篇">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构篇">
<meta property="og:url" content="http://example.com/2022/08/09/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="数据结构篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:29:01.119Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/09/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-13 22:29:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/xxx.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:29:01.119Z" title="更新于 2022-11-13 22:29:01">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="ⅠRedis-常见数据类型以及使用场景分析"><a href="#ⅠRedis-常见数据类型以及使用场景分析" class="headerlink" title="ⅠRedis 常见数据类型以及使用场景分析"></a>ⅠRedis 常见数据类型以及使用场景分析</h2><p>我们都知道 Redis 提供了丰富的数据类型，常见的有五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。<br>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。<br><strong>使用场景就介绍数据类型所对应的</strong></p>
<h3 id="①string"><a href="#①string" class="headerlink" title="①string"></a>①string</h3><p><strong>介绍</strong><br>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657938150802-34efb932-fb99-44bd-8494-a7bd81459103.png#averageHue=%23faf6ec&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=uff79b11e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=724&amp;originWidth=1698&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=168330&amp;status=done&amp;style=none&amp;taskId=ubbeef3ed-33fc-462a-9e31-662bde4449c&amp;title=&amp;width=509.00006103515625" alt="image.png"><br><strong>内部实现</strong><br>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<ol>
<li><strong>SDS讲解</strong></li>
</ol>
<p>a:数据结构<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652455986932-b05c833e-a686-4171-8089-c8006a3fd232.png#averageHue=%23fcefee&amp;clientId=u491e6a16-565a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=ztYMW&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=311&amp;originWidth=700&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46430&amp;status=done&amp;style=none&amp;taskId=u772ca62a-b152-47a0-bf40-8a72cb73b6e&amp;title=&amp;width=560" alt="image.png"><br>b:Redis为什么重新设计一个 SDS 数据结构？<br>C语言没有Java里面的String类型，只能是靠自己的char[]来实现，字符串在 C 语言中的存储方式，想要获取 「Redis」的长度，需要从头开始遍历，直到遇到 ‘\0’ 为止。所以，Redis 没有直接使用 C 语言传统的字符串标识，而是自己构建了一种名为简单动态字符串 SDS（simple dynamic string）的抽象类型，并将 SDS 作为 Redis 的默认字符串。<br>补充c:优点：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>获取字符串长度的时间复杂度是常数时间复杂度O(1)</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。<blockquote>
<ul>
<li>空间预分配：SDS 修改后，len 长度小于 1M，那么将会额外分配与 len 相同长度的未使用空间。如果修改后长度大于 1M，那么将分配1M的使用空间。</li>
<li>惰性空间释放：</li>
</ul>
<p>有空间分配对应的就有空间释放。SDS 缩短时并不会回收多余的内存空间，而是使用 free 字段将多        出来的空间记录下来。如果后续有变更操作，直接使用 free 中记录的空间，减少了内存的分配。</p>
</blockquote>
</li>
</ul>
<ol>
<li><strong>字符串对象</strong>的内部编码（encoding）有 3 种 ：<strong>int、raw和 embstr</strong>。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657938150848-c3142824-f0e3-4a28-8e67-fd211f8148b7.png#averageHue=%23d99045&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=anzyE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=622&amp;originWidth=1570&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=235941&amp;status=done&amp;style=none&amp;taskId=u8edbdeb9-5c66-4ae0-8fed-e984dde710d&amp;title=&amp;width=553.0000610351562" alt="image.png"><br>int<br>如果一个<strong>字符串对象</strong>保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成 long），并将字符串对象的编码设置为int。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657938150706-ef09656b-e6bc-4612-b040-e2aa2be992d1.png#averageHue=%23fae3e3&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=186&amp;id=Qld4g&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=502&amp;originWidth=1198&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79686&amp;status=done&amp;style=none&amp;taskId=uac2d33ba-ff75-49ec-b88a-1ba8102afdd&amp;title=&amp;width=444" alt="image.png"><br>数字最多为19位。<br>注意：只有整数才会使用 int，如果是浮点数， Redis 内部其实先将浮点数转化为字符串值，然后再保存。</p>
<ul>
<li>示例：set k1 123  set k2 123</li>
</ul>
<p>embstr<br>如果字符串对象保存的是一个字符串，<strong>并且这个字符串的长度小于等于 32 字节</strong>（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为embstr， embstr编码是专门用于保存短字符串的一种优化编码方式：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657938150673-bb605ac0-3380-42b4-bf91-7d3c88d92b42.png#averageHue=%23f9ebeb&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=CYgMs&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=261&amp;originWidth=1804&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113365&amp;status=done&amp;style=none&amp;taskId=uc2e1dcbc-6585-4310-92e4-511429b0955&amp;title=" alt="image.png"><br>EMBSTR 顾名思义即：embedded string，表示嵌入式的String。从内存结构上来讲 即字符串 sds结构体与其对应的 redisObject 对象分配在同一块连续的内存空间，字符串sds嵌入在redisObject对象之中一样。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1648362218021-18ad2ea1-f359-4b0e-9454-b1a2558fe87d.png#averageHue=%2368f166&amp;clientId=u4da6a76f-331d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=Kk0Oe&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=588&amp;originWidth=458&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98690&amp;status=done&amp;style=none&amp;taskId=u0153b1e9-ec41-403c-9442-127d287d64a&amp;title=&amp;width=256.39288330078125" alt="image.png"><br>raw<br>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为raw：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657938150738-ea26ee36-5755-4fb0-baeb-4341cae8c301.png#averageHue=%23fbf1f1&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uPyKz&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=510&amp;originWidth=2068&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=144223&amp;status=done&amp;style=none&amp;taskId=ude21c03f-069c-4134-882b-078e72b0192&amp;title=" alt="image.png"><br>与OBJ_ENCODING_EMBSTR编码方式的不同之处在于，此时动态字符串sds的内存与其依赖的redisObject的内存不再连续了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1648362309099-edcf0c34-27ea-4c23-9b62-03610df36a16.png#averageHue=%23e8aa67&amp;clientId=u4da6a76f-331d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=Xd6gA&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=362&amp;originWidth=730&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=78038&amp;status=done&amp;style=none&amp;taskId=u3c83d2b4-89bf-47b6-8c60-51b266bab0a&amp;title=&amp;width=524" alt="image.png"></p>
<p>注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：</p>
<ul>
<li>redis 2.+ 是 32 字节</li>
<li>redis 3.0-4.0 是 39 字节</li>
<li>redis 5.0 是 44 字节<blockquote>
<p>可以看到embstr和raw编码都会使用SDS来保存值，但不同之处在于embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，而raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS。Redis这样做会有很多好处：</p>
<ul>
<li>embstr编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次；</li>
<li>释放 embstr编码的字符串对象同样只需要调用一次内存释放函数；</li>
<li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li>
</ul>
<p>但是 embstr 也有缺点的：</p>
<ul>
<li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>常用命令</strong><br>普通字符串的基本操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key-value 类型的值</span><br><span class="line">&gt; SET name lin</span><br><span class="line">OK</span><br><span class="line"># 根据 key 获得对应的 value</span><br><span class="line">&gt; GET name</span><br><span class="line"><span class="string">&quot;lin&quot;</span></span><br><span class="line"># 判断某个 key 是否存在</span><br><span class="line">&gt; EXISTS <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> 1</span><br><span class="line"># 返回 key 所储存的字符串值的长度</span><br><span class="line">&gt; STRLEN <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> 3</span><br><span class="line"># 删除某个 key 对应的值</span><br><span class="line">&gt; DEL <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> 1</span><br></pre></td></tr></table></figure><br>批量设置 :<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 批量设置 key-value 类型的值</span><br><span class="line">&gt; MSET key1 value1 key2 value2 </span><br><span class="line">OK</span><br><span class="line"># 批量获取多个 key 对应的 value</span><br><span class="line">&gt; MGET key1 key2 </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><br>计数器（字符串的内容为整数的时候可以使用）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key-value 类型的值</span><br><span class="line">&gt; SET number <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"># 将 key 中储存的数字值增一</span><br><span class="line">&gt; INCR <span class="title function_">number</span></span><br><span class="line"><span class="params">(integer)</span> 1</span><br><span class="line"># 将key中存储的数字值加 10</span><br><span class="line">&gt; INCRBY number 10</span><br><span class="line"><span class="params">(integer)</span> 11</span><br><span class="line"># 将 key 中储存的数字值减一</span><br><span class="line">&gt; DECR <span class="title function_">number</span></span><br><span class="line"><span class="params">(integer)</span> 10</span><br><span class="line"># 将key中存储的数字值键 10</span><br><span class="line">&gt; DECRBY number 10</span><br><span class="line"><span class="params">(integer)</span> 0</span><br></pre></td></tr></table></figure><br>过期（默认为永不过期）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key 在 <span class="number">60</span> 秒后过期（该方法是针对已经存在的key设置过期时间）</span><br><span class="line">&gt; EXPIRE name  <span class="number">60</span> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"># 查看数据还有多久过期</span><br><span class="line">&gt; TTL <span class="title function_">name</span> </span><br><span class="line"><span class="params">(integer)</span> 51</span><br><span class="line"></span><br><span class="line">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span><br><span class="line">&gt; SET key  value EX 60</span><br><span class="line">OK</span><br><span class="line">&gt; SETEX key  60 value</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><br>不存在就插入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不存在就插入（not exists）</span><br><span class="line">&gt;SETNX key <span class="title function_">value</span></span><br><span class="line"><span class="params">(integer)</span> 1</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong></p>
<ol>
<li>缓存对象</li>
<li>常规计数</li>
</ol>
<ul>
<li>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量、计算文章的阅读量等等。</li>
</ul>
<ol>
<li>分布式锁</li>
<li>共享 Session 信息<br>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</li>
</ol>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。<br>分布式系统单独存储 Session 流程图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939313906-e02322b4-7c44-4f86-a935-543fa60fa6db.png#averageHue=%23fefefe&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=uea7a48b8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=820&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=67880&amp;status=done&amp;style=none&amp;taskId=u3eb66f2a-3c38-45bd-b91f-c28d9f71e66&amp;title=&amp;width=611.0000610351562" alt="image.png"><br>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。<br>分布式系统使用同一个 Redis 存储 Session 流程图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939313919-4c3e0ea1-c73a-4cda-8ac9-efdef2d2c896.png#averageHue=%23fefefc&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=344&amp;id=u68582f95&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=412&amp;originWidth=473&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=71982&amp;status=done&amp;style=none&amp;taskId=uf2dfb005-ed8a-4c85-b29f-520de28ad6d&amp;title=&amp;width=395.0000305175781" alt="image.png"></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="②list"><a href="#②list" class="headerlink" title="②list"></a>②list</h3><p><strong>介绍</strong><br>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。<br>列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。<br><strong>内部实现</strong><br>List 类型的底层数据结构是由<strong>压缩列表或双向链表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。<br><strong>常用命令</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939602314-7bea6dec-3340-4146-ab68-501aeec0ad3c.png#averageHue=%23fbfafa&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=196&amp;id=u2721563f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=684&amp;originWidth=1936&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=126997&amp;status=done&amp;style=none&amp;taskId=u7797b1a5-72ab-45c2-ab4f-87e7e1660d2&amp;title=&amp;width=555.0000610351562" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"># 将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从<span class="number">0</span>开始</span><br><span class="line">LRANGE key start stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=<span class="number">0</span>则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=<span class="number">0</span>则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong><br>消息队列<br>List 作为消息队列有什么缺陷？<br><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。<br>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。<br>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。<br>详细内容消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。<br>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。<br><em>1、如何满足消息保序需求？</em><br>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。<br>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939645629-f4242a8b-38f0-4a97-b21a-9b51fc7245d1.png#averageHue=%23f1f1f1&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=FAotf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=1642&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=110824&amp;status=done&amp;style=none&amp;taskId=ue02d2007-a0fe-439f-b5d2-091d7356eb6&amp;title=" alt="image.png"></p>
<ul>
<li>生产者使用 LPUSH key value[value…] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li>
<li>消费者使用 RPOP key 依次读取队列的消息，先进先出。</li>
</ul>
<p>不过，在消费者读取数据时，有一个潜在的性能风险点。<br>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。<br>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。<br>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939645826-4303dd7f-27b4-4cf9-84af-ee9037668f75.png#averageHue=%23fcfafa&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=UW0z3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=902&amp;originWidth=1552&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=245237&amp;status=done&amp;style=none&amp;taskId=u9ee4b969-de7c-4d18-a9d4-9d6542adeac&amp;title=&amp;width=438" alt="image.png"><br><em>2、如何处理重复的消息？</em><br>消费者要实现重复消息的判断，需要 2 个方面的要求：</p>
<ul>
<li>每个消息都有一个全局的 ID。</li>
<li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li>
</ul>
<p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。<br>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p>
<blockquote>
<p>LPUSH mq “111000102:stock:99” (integer) 1<br><em>3、如何保证消息可靠性？</em><br>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。<br>为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。<br>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。<br>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p>
</blockquote>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<h3 id="③hash"><a href="#③hash" class="headerlink" title="③hash"></a>③hash</h3><p><strong>介绍</strong><br>Hash 是一个键值对（key - value）集合，其中 value 的形式入： value=[{field1，value1}，…{fieldN，valueN}]。Hash 特别适合用于存储对象。<br>Hash 与 String 对象的区别如下图所示:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939806927-1cadf805-359c-4d93-bbbf-4d414c979018.png#averageHue=%239bd465&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=297&amp;id=u45a599ba&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=888&amp;originWidth=1240&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=182966&amp;status=done&amp;style=none&amp;taskId=u61e54fd7-59ce-4a29-bbc1-898a56d8928&amp;title=&amp;width=415" alt="image.png"><br><strong>内部实现</strong><br>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果<strong>哈希类型元素个数</strong>小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。<br><strong>常用命令</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 存储一个哈希表key的键值</span><br><span class="line">HSET key field value   </span><br><span class="line"># 获取哈希表key对应的field键值</span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line"># 在一个哈希表key中存储多个键值对</span><br><span class="line">HMSET key field value [field value...] </span><br><span class="line"># 批量获取哈希表key中多个field键值</span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"># 删除哈希表key中的field键值</span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"></span><br><span class="line"># 返回哈希表key中field的数量</span><br><span class="line">HLEN key       </span><br><span class="line"># 返回哈希表key中所有的键值</span><br><span class="line">HGETALL key </span><br><span class="line"></span><br><span class="line"># 为哈希表key中field键的值加上增量n</span><br><span class="line">HINCRBY key field n             </span><br></pre></td></tr></table></figure><br><strong>应用场景 </strong><br>以购物车为例，用户id设为key，购物车里的<strong>所有商品</strong>就是用户key对应的值了，每个商品有商品id和购买数量</p>
<h3 id="④set"><a href="#④set" class="headerlink" title="④set"></a>④set</h3><p><strong>介绍</strong><br>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<blockquote>
<p>一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657939997662-15e15598-a722-4a03-8e62-f6f156d78732.png#averageHue=%23fcf6f6&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=295&amp;id=uca82cf4c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=654&amp;originWidth=1268&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=167910&amp;status=done&amp;style=none&amp;taskId=u1d97a284-3564-4d8a-a62d-9c77d8de711&amp;title=&amp;width=571.0000610351562" alt="image.png"><br>Set 类型和 List 类型的区别如下：</p>
<ul>
<li>List 可以存储重复元素，Set 只能存储非重复元素；</li>
<li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li>
</ul>
<p><strong>内部实现</strong><br>Set 类型的底层数据结构是由<strong>整数集合或哈希表</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<p><strong>常用命令</strong><br>set常用操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SADD key member [member ...]</span><br><span class="line"># 从集合key中删除元素</span><br><span class="line">SREM key member [member ...] </span><br><span class="line"># 获取集合key中所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line"># 获取集合key中的元素个数</span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"># 判断member元素是否存在于集合key中</span><br><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line"># 从集合key中随机选出count个元素，元素不从key中删除</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"># 从集合key中随机选出count个元素，元素从key中删除</span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><br>set集合操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong><br>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<blockquote>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。<br>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。<br>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
</blockquote>
<p>点赞<br>Set 类型可以保证一个用户只能点一个赞。<br>补充这里举例子一个场景，key 是文章id，value 是用户id。<br>uid:1 、uid:2、uid:3 三个用户分别对 article:1 文章点赞了。<br> uid:1 用户对文章 article:1 点赞 </p>
<blockquote>
<p>SADD article:1 uid:1 (integer) 1<br> uid:2 用户对文章 article:1 点赞<br>SADD article:1 uid:2 (integer) 1<br> uid:3 用户对文章 article:1 点赞<br>SADD article:1 uid:3 (integer) 1<br>uid:1 取消了对 article:1 文章点赞。<br>SREM article:1 uid:1 (integer) 1<br>获取 article:1 文章所有点赞用户 :<br>SMEMBERS article:1 1) “uid:3” 2) “uid:2”<br>获取 article:1 文章的点赞用户数量：<br>SCARD article:1 (integer) 2<br>判断用户 uid:1 是否对文章 article:1 点赞了：<br>SISMEMBER article:1 uid:1 (integer) 0   返回0说明没点赞，返回1则说明点赞了<br>共同关注<br>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。<br>补充key 可以是用户id，value 则是已关注的公众号的id。<br>uid:1 用户关注公众号 id 为 5、6、7、8、9，uid:2 用户关注公众号 id 为 7、8、9、10、11。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span></span><br><span class="line">&gt; SADD uid:<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="meta"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span></span><br><span class="line">&gt; SADD uid:<span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure><br>uid:1 和 uid:2 共同关注的公众号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取共同关注</span><br><span class="line">&gt; SINTER uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;8&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;9&quot;</span></span><br></pre></td></tr></table></figure><br>给 uid:2 推荐 uid:1 关注的公众号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SDIFF uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><br>验证某个公众号是否同时被 uid:1 或 uid:2 关注:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SISMEMBER uid:<span class="number">1</span> <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span> # 返回<span class="number">0</span>，说明关注了</span><br><span class="line">&gt; SISMEMBER uid:<span class="number">2</span> <span class="number">5</span></span><br><span class="line">(integer) <span class="number">0</span> # 返回<span class="number">0</span>，说明没关注</span><br></pre></td></tr></table></figure><br>抽奖活动<br>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，<strong>可以保证同一个用户不会中奖两次。</strong><br>补充key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;SADD lucky Tom Jerry John Sean Marry Lindy Sary <span class="title function_">Mark</span></span><br><span class="line"><span class="params">(integer)</span> 5</span><br></pre></td></tr></table></figure><br>如果允许重复中奖，可以使用 SRANDMEMBER 命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 抽取 <span class="number">1</span> 个一等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Tom&quot;</span></span><br><span class="line"># 抽取 <span class="number">2</span> 个二等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Mark&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Jerry&quot;</span></span><br><span class="line"># 抽取 <span class="number">3</span> 个三等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Sary&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Jerry&quot;</span></span><br></pre></td></tr></table></figure><br>如果不允许重复中奖，可以使用 SPOP 命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 抽取一等奖<span class="number">1</span>个</span><br><span class="line">&gt; SPOP lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Sary&quot;</span></span><br><span class="line"># 抽取二等奖<span class="number">2</span>个</span><br><span class="line">&gt; SPOP lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jerry&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Mark&quot;</span></span><br><span class="line"># 抽取三等奖<span class="number">3</span>个</span><br><span class="line">&gt; SPOP lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;John&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Sean&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Lindy&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="⑤zset"><a href="#⑤zset" class="headerlink" title="⑤zset"></a>⑤zset</h3><p><strong>介绍</strong></p>
</blockquote>
<ul>
<li>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</li>
<li>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657940423210-938acfac-fe08-45a8-a694-78cff315db1a.png#averageHue=%23fcf9f9&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=241&amp;id=u25df2dcd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=616&amp;originWidth=1226&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=114856&amp;status=done&amp;style=none&amp;taskId=u14077ca3-3454-4e54-848e-743dc0190e1&amp;title=&amp;width=480.00006103515625" alt="image.png"><br><strong>内部实现</strong><br>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong><br><strong>常用命令</strong><br>Zset 常用操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 往有序集合key中加入带分值元素</span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"># 往有序集合key中删除元素</span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"># 返回有序集合key中元素member的分值</span><br><span class="line">ZSCORE key member</span><br><span class="line"># 返回有序集合key中元素个数</span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"># 为有序集合key中元素member的分值加上increment</span><br><span class="line">ZINCRBY key increment member </span><br><span class="line"></span><br><span class="line"># 正序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"># 倒序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure><br>Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong><br>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。<br>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。<br>排行榜<br>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。<br>例子我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># arcticle:1 文章获得了200个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking <span class="number">200</span> arcticle:<span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta"># arcticle:2 文章获得了40个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking <span class="number">40</span> arcticle:<span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta"># arcticle:3 文章获得了100个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking <span class="number">100</span> arcticle:<span class="number">3</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta"># arcticle:4 文章获得了50个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking <span class="number">50</span> arcticle:<span class="number">4</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta"># arcticle:5 文章获得了150个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking <span class="number">150</span> arcticle:<span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><br>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZINCRBY user:xiaolin:ranking <span class="number">1</span> arcticle:<span class="number">4</span></span><br><span class="line"><span class="string">&quot;51&quot;</span></span><br></pre></td></tr></table></figure><br>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZSCORE user:xiaolin:ranking arcticle:<span class="number">4</span></span><br><span class="line"><span class="string">&quot;50&quot;</span></span><br></pre></td></tr></table></figure><br>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># WITHSCORES 表示把 score 也显示出来</span><br><span class="line">&gt; ZREVRANGE user:xiaolin:ranking <span class="number">0</span> <span class="number">2</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;arcticle:1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;200&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;arcticle:5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;150&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;arcticle:3&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure><br>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYSCORE user:xiaolin:ranking <span class="number">100</span> <span class="number">200</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;arcticle:3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;arcticle:5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;150&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;arcticle:1&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;200&quot;</span></span><br></pre></td></tr></table></figure><br>补充电话、姓名排序<br>使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序，我们以 ZRANGEBYLEX （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。<br><strong>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</strong><br><em>1、电话排序</em><br>我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZADD phone <span class="number">0</span> <span class="number">13100111100</span> <span class="number">0</span> <span class="number">13110114300</span> <span class="number">0</span> <span class="number">13132110901</span> </span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; ZADD phone <span class="number">0</span> <span class="number">13200111100</span> <span class="number">0</span> <span class="number">13210414300</span> <span class="number">0</span> <span class="number">13252110901</span> </span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; ZADD phone <span class="number">0</span> <span class="number">13300111100</span> <span class="number">0</span> <span class="number">13310414300</span> <span class="number">0</span> <span class="number">13352110901</span> </span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><br>获取所有号码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;13100111100&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;13110114300&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;13132110901&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line"><span class="number">9</span>) <span class="string">&quot;13352110901&quot;</span></span><br></pre></td></tr></table></figure><br>获取 132 号段的号码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [<span class="number">132</span> (<span class="number">133</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;13252110901&quot;</span></span><br></pre></td></tr></table></figure><br>获取132、133号段的号码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [<span class="number">132</span> (<span class="number">134</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;13352110901&quot;</span></span><br></pre></td></tr></table></figure><br><em>2、姓名排序</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd names <span class="number">0</span> Toumas <span class="number">0</span> Jake <span class="number">0</span> Bluetuo <span class="number">0</span> Gaodeng <span class="number">0</span> Aimini <span class="number">0</span> Aidehua </span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure><br>获取所有人的名字:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names - +</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Aidehua&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Aimini&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Bluetuo&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;Gaodeng&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;Jake&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;Toumas&quot;</span></span><br></pre></td></tr></table></figure><br>获取名字中大写字母A开头的所有人：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [A (B</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Aidehua&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Aimini&quot;</span></span><br></pre></td></tr></table></figure><br>获取名字中大写字母 C 到 Z 的所有人：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [C [Z</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Gaodeng&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Jake&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Toumas&quot;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>新数据类型<br>详细内容## 新数据类型<br>为什么会出现这三种类型：<br>涉及到亿级数据的收集+统计<br>亿级系统中常见的四种统计：</p>
<h3 id="聚合统计："><a href="#聚合统计：" class="headerlink" title="聚合统计："></a>聚合统计：</h3><p>所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p>
<h3 id="排序统计："><a href="#排序统计：" class="headerlink" title="排序统计："></a>排序统计：</h3><p><strong>这就要求集合类型能对元素保序</strong>，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。<br>在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），List 和 Sorted Set 就属于有序集合。<br><strong>List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序</strong>，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<h3 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h3><p>集合元素的取值就只有0和1两种。在钉钉上班签到打卡的场景中，我们只用记录有签到(1)或没签到(0)</p>
<h3 id="基数统计："><a href="#基数统计：" class="headerlink" title="基数统计："></a>基数统计：</h3><p>基数统计就是指统计一个集合中不重复的元素个数。对应到我们刚才介绍的场景中，就是统计网页的 UV。<br>网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在 Redis 的集合类型中，Set 类型默认支持去重，所以看到有去重需求时，我们可能第一时间就会想到用 Set 类型。<br>我们来结合一个例子看一看用 Set 的情况。<br>有一个用户 user1 访问 page1 时，你把这个信息加到 Set 中：<br>SADD page1:uv user1<br>用户 1 再来访问时，Set 的去重功能就保证了不会重复记录用户 1 的访问次数，这样，用户 1 就算是一个独立访客。当你需要统计 UV 时，可以直接用 SCARD 命令，这个命令会返回一个集合中的元素个数。<br>但是，如果 page1 非常火爆，UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID。对于一个搞大促的电商网站而言，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会消耗很大的内存空间。<br>当然，你也可以用 Hash 类型记录 UV。<br>例如，你可以把用户 ID 作为 Hash 集合的 key，当用户访问页面时，就用 HSET 命令（用于设置 Hash 集合元素的值），对这个用户 ID 记录一个值“1”，表示一个独立访客，用户 1 访问 page1 后，我们就记录为 1 个独立访客，如下所示：</p>
<p>HSET page1:uv user1 1<br>即使用户 1 多次访问页面，重复执行这个 HSET 命令，也只会把 user1 的值设置为 1，仍然只记为 1 个独立访客。当要统计 UV 时，我们可以用 HLEN 命令统计 Hash 集合中的所有元素个数。<br>但是，和 Set 类型相似，当页面很多时，Hash 类型也会消耗很大的内存空间。那么，有什么办法既能完成统计，还能节省内存吗？<br>这时候，就要用到 Redis 提供的 HyperLogLog 了。<br>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。<br>在 Redis 中，每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数。你看，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。<br>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。<br>PFADD page1:uv user1 user2 user3 user4 user5<br>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。<br>PFCOUNT page1:uv</p>
<p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我把 Set、Sorted Set、Hash、List、Bitmap、HyperLogLog 的支持情况和优缺点汇总在了下面的表格里，希望你把这张表格保存下来，时不时地复习一下。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651908314109-381291db-53fd-4c7a-a948-5fc3f2976a17.png#clientId=u3acb0c99-da74-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Zb3hH&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1739&amp;originWidth=2866&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2463682&amp;status=done&amp;style=none&amp;taskId=uc3c9203f-42af-41c6-86ef-dcd6f55bdd1&amp;title=" alt="image.png"><br>可以看到，Set 和 Sorted Set 都支持多种聚合统计，不过，对于差集计算来说，只有 Set 支持。Bitmap 也能做多个 Bitmap 间的聚合计算，包括与、或和异或操作。<br>当需要进行排序统计时，List 中的元素虽然有序，但是一旦有新元素插入，原来的元素在 List 中的位置就会移动，那么，按位置读取的排序结果可能就不准确了。而 Sorted Set 本身是按照集合元素的权重排序，可以准确地按序获取结果，所以建议你优先使用它。<br>如果我们记录的数据只有 0 和 1 两个值的状态，Bitmap 会是一个很好的选择，这主要归功于 Bitmap 对于一个数据只用 1 个 bit 记录，可以节省内存。<br>对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，我建议你使用 HyperLogLog。<br>当然，Redis 的应用场景非常多，这张表中的总结不一定能覆盖到所有场景。我建议你也试着自己画一张表，把你遇到的其他场景添加进去。长久积累下来，你一定能够更加灵活地把集合类型应用到合适的实践项目中。</p>
<h3 id="⑥bitmap"><a href="#⑥bitmap" class="headerlink" title="⑥bitmap"></a>⑥bitmap</h3><p><strong>介绍</strong></p>
<ul>
<li>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</li>
<li>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657940963212-c134f267-4e86-40be-9173-9a22a84a4e20.png#averageHue=%23efefef&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua14d8168&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=144&amp;originWidth=1500&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45914&amp;status=done&amp;style=none&amp;taskId=u6b8db264-a8db-473c-95a4-3b990d1fcef&amp;title=" alt="image.png"><br><strong>内部实现</strong><br>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。<br>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。<br><strong>常用命令</strong><br>bitmap 基本操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 设置值，其中value只能是 <span class="number">0</span> 和 <span class="number">1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line"># 获取值</span><br><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line"># 获取指定范围内值为 <span class="number">1</span> 的个数</span><br><span class="line"><span class="meta"># start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure><br>bitmap 运算操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"><span class="meta"># operations 位移操作符，枚举值</span></span><br><span class="line">  AND 与运算 &amp;</span><br><span class="line">  OR 或运算 |</span><br><span class="line">  XOR 异或 ^</span><br><span class="line">  NOT 取反 ~</span><br><span class="line"><span class="meta"># result 计算的结果，会存储在该key中</span></span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="number">0</span>。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定value(<span class="number">0</span>/<span class="number">1</span>)的位置</span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong><br>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。<br>签到统计<br>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。<br>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。<br>补充假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。<br>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。<br>SETBIT uid:sign:100:202206 2 1<br>第二步，检查该用户 6 月 3 日是否签到。<br>GETBIT uid:sign:100:202206 2<br>第三步，统计该用户在 6 月份的签到次数。<br>BITCOUNT uid:sign:100:202206<br>这样，我们就知道该用户在 6 月份的签到情况了。<br>如何统计这个月首次打卡时间呢？<br>Redis 提供了 BITPOS key bitValue [start] [end]指令，返回数据表示 Bitmap 中第一个值为 bitValue 的 offset 位置。<br>在默认情况下， 命令将检测整个位图， 用户可以通过可选的 start 参数和 end 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID = 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：<br>BITPOS uid:sign:100:202206 1<br>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1 。<br>判断用户登陆态<br>Bitmap 提供了 GETBIT、SETBIT 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。<br>只需要一个 key = login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 GETBIT判断对应的用户是否在线。 50000 万 用户只需要 6 MB 的空间。<br>假如我们要判断 ID = 10086 的用户的登陆情况：<br>第一步，执行以下指令，表示用户已登录。<br>SETBIT login_status 10086 1<br>第二步，检查该用户是否登陆，返回值 1 表示已登录。<br>GETBIT login_status 10086<br>第三步，登出，将 offset 对应的 value 设置成 0。<br>SETBIT login_status 10086 0<br>连续签到用户总数<br>补充如何统计出这连续 7 天连续打卡用户总数呢？<br>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。<br>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。<br>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit = 1 就说明该用户 7 天连续打卡。<br>结果保存到一个新 Bitmap 中，我们再通过 BITCOUNT 统计 bit = 1 的个数便得到了连续打卡 3 天的用户总数了。<br>Redis 提供了 BITOP operation destkey key [key …]这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p>
<ul>
<li>opration 可以是 and、OR、NOT、XOR。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</li>
</ul>
<p>举个例子，比如将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计。<br> 与操作 BITOP AND destmap bitmap:01 bitmap:02 bitmap:03  统计 bit 位 =  1 的个数 BITCOUNT destmap<br>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8/8/1024/1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p>
<h3 id="⑦hyperloglog"><a href="#⑦hyperloglog" class="headerlink" title="⑦hyperloglog"></a>⑦hyperloglog</h3><p><strong>介绍</strong></p>
<ul>
<li>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</li>
<li>所以，简单来说 HyperLogLog <strong>提供不精确的去重计数</strong>。</li>
</ul>
<p>通过牺牲准确率来换取空间，对于不要求绝对准确率的场景下可以使用，因为概率算法不直接存储数据本身，通过一定的概率统计方法预估基数值，同时保证误差在一定范围内，由于又不储存数据故此可以大大节约内存。</p>
<blockquote>
<p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。<br>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p>
</blockquote>
<p><strong>内部实现</strong><br>HyperLogLog 的实现涉及到很多数学问题，太费脑子了，我也没有搞懂，如果你想了解一下，课下可以看看这个：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog(opens new window)</a>。<br><strong> 原理说明：</strong>只是进行不重复的基数统计，不是集合也不保存数据，只记录数量而不是具体的内容。<br>HyperLogLog就是一种概率算法的实现。<br><strong>常见命令</strong><br>HyperLogLog 命令很少，就三个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定元素到 HyperLogLog 中</span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"></span><br><span class="line"># 返回给定 HyperLogLog 的基数估算值。</span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"></span><br><span class="line"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong><br>百万级网页 UV 计数<br>Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。<br>所以，非常适合统计百万级以上的网页 UV 的场景。</p>
<blockquote>
<p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。<br>PFADD page1:uv user1 user2 user3 user4 user5<br>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。<br>PFCOUNT page1:uv<br>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。<br>这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p>
</blockquote>
<p><strong>为什么redis集群的最大槽数是16384个？</strong><br>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。浪费带宽<br>在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb<br>因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。<br>(2)redis的集群主节点数量基本不可能超过1000个。<br>集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。(因为16384/2=8192  8192/8/1024=1，所以使用16384的槽位刚刚好)<br>(3)槽位越小，节点少的情况下，压缩比高，容易传输</p>
<h3 id="⑧GEO"><a href="#⑧GEO" class="headerlink" title="⑧GEO"></a>⑧GEO</h3><p><strong>介绍</strong><br>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。<br>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。<br><strong>内部实现</strong><br>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。<br>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。<br>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。<br><strong>常用命令</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"></span><br><span class="line"># 从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"></span><br><span class="line"># 返回两个给定位置之间的距离。</span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"></span><br><span class="line"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure><br><strong>应用场景</strong><br>滴滴叫车<br>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。<br>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。<br>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：<br>GEOADD cars:locations 116.034579 39.030452 33<br>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。<br>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。<br>GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</p>
<h3 id="👌⑨Stream"><a href="#👌⑨Stream" class="headerlink" title="👌⑨Stream"></a>👌⑨Stream</h3><p><strong>介绍</strong><br>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p>
<p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p>
<ul>
<li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li>
<li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li>
</ul>
<p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。<br><strong>常见命令</strong><br>Stream 消息队列操作命令：</p>
<ul>
<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>
<li>XLEN ：查询消息长度；</li>
<li>XREAD：用于读取消息，可以按 ID 读取数据；</li>
<li>XDEL ： 根据消息 ID 删除消息；</li>
<li>DEL ：删除整个 Stream；</li>
<li>XRANGE ：读取区间消息</li>
<li>XREADGROUP：按消费组形式读取消息；</li>
<li>XPENDING 和 XACK：<ul>
<li>XPENDING 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li>
<li>XACK 命令用于向消息队列确认消息处理已完成；</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong><br>消息队列<br>生产者通过 XADD 命令插入一条消息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># * 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span><br><span class="line"># 往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 xiaolin</span><br><span class="line">&gt; XADD mymq * name xiaolin</span><br><span class="line"><span class="string">&quot;1654254953808-0&quot;</span></span><br></pre></td></tr></table></figure><br>插入成功后会返回全局唯一的 ID：”1654254953808-0”。消息的全局唯一 ID 由两部分组成：</p>
<ul>
<li>第一部分“1654254953808”是数据插入时，以毫秒为单位计算的当前服务器时间；</li>
<li>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1654254953808-0”就表示在“1654254953808”毫秒内的第 1 条消息。</li>
</ul>
<p>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不是查询输入ID的消息）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 从 ID 号为 <span class="number">1654254953807</span><span class="number">-0</span> 的消息开始，读取后续的所有消息（示例中一共 <span class="number">1</span> 条）。</span><br><span class="line">&gt; XREAD STREAMS mymq <span class="number">1654254953807</span><span class="number">-0</span></span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;xiaolin&quot;</span></span><br></pre></td></tr></table></figure><br>如果<strong>想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项</strong>，实现类似于 BRPOP 的阻塞读取操作。<br>比如，下面这命令，设置了 BLOCK 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 命令最后的“$”符号表示读取最新的消息</span><br><span class="line">&gt; XREAD BLOCK <span class="number">10000</span> STREAMS mymq $</span><br><span class="line">(nil)</span><br><span class="line">(<span class="number">10.00</span>s)</span><br></pre></td></tr></table></figure><br>Stream 的基础方法，使用 xadd 存入消息和 xread 循环阻塞读取消息的方式可以实现简易版的消息队列，交互流程如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657941776181-dc798275-e90c-4044-aa87-62cfbb410458.png#averageHue=%23ebebeb&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9b9159bb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=123&amp;originWidth=577&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26096&amp;status=done&amp;style=none&amp;taskId=u39feb68e-2677-4c73-ae88-58976febc64&amp;title=" alt="image.png"><br>前面介绍的这些操作 List 也支持的，接下来看看 Stream 特有的功能。<br>Stream 可以以使用 <strong>XGROUP 创建消费组</strong>，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。<br>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个名为 group1 的消费组，<span class="number">0</span><span class="number">-0</span> 表示从第一条消息开始读取。</span><br><span class="line">&gt; XGROUP CREATE mymq group1 <span class="number">0</span><span class="number">-0</span></span><br><span class="line">OK</span><br><span class="line"># 创建一个名为 group2 的消费组，<span class="number">0</span><span class="number">-0</span> 表示从第一条消息开始读取。</span><br><span class="line">&gt; XGROUP CREATE mymq group2 <span class="number">0</span><span class="number">-0</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><br>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span><br><span class="line">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;xiaolin&quot;</span></span><br></pre></td></tr></table></figure><br><strong>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息</strong>。<br>比如说，我们执行完刚才的 XREADGROUP 命令后，再执行一次同样的命令，此时读到的就是空值了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><br>但是，<strong>不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）</strong>。<br>比如说，刚才 group1 消费组里的 consumer1 消费者消费了一条 id 为 1654254953808-0 的消息，现在用 group2 消费组里的 consumer1 消费者消费消息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; XREADGROUP GROUP group2 consumer1 STREAMS mymq &gt;</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;xiaolin&quot;</span></span><br></pre></td></tr></table></figure><br>因为我创建两组的消费组都是从第一条消息开始读取，所以可以看到第二组的消费者依然可以消费 id 为 1654254953808-0 的这一条消息。因此，不同的消费组的消费者可以消费同一条消息。<br>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。<br>例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 让 group2 中的 consumer1 从 mymq 消息队列中消费一条消息</span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer1 COUNT <span class="number">1</span> STREAMS mymq &gt;</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;xiaolin&quot;</span></span><br><span class="line"># 让 group2 中的 consumer2 从 mymq 消息队列中消费一条消息</span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer2 COUNT <span class="number">1</span> STREAMS mymq &gt;</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654256265584-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;xiaolincoding&quot;</span></span><br><span class="line"># 让 group2 中的 consumer3 从 mymq 消息队列中消费一条消息</span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer3 COUNT <span class="number">1</span> STREAMS mymq &gt;</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654256271337-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;Tom&quot;</span></span><br></pre></td></tr></table></figure><br>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？<br>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。<br>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657941776237-e25d7b00-e3fe-4826-922d-3d9371c9650b.png#averageHue=%23fcfcfc&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u82e18720&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=482&amp;originWidth=1170&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=96365&amp;status=done&amp;style=none&amp;taskId=ub690502f-37bb-4c52-9b11-a7d49fed4cd&amp;title=" alt="image.png"><br>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，<strong>消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息</strong>。<br>例如，我们来查看一下 group2 中各个消费者已读取、但尚未确认的消息个数，命令如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; XPENDING mymq group2</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">3</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1654254953808-0&quot;</span>  # 表示 group2 中所有消费者读取的消息最小 ID</span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;1654256271337-0&quot;</span>  # 表示 group2 中所有消费者读取的消息最大 ID</span><br><span class="line"><span class="number">4</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) <span class="string">&quot;consumer3&quot;</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><br>如果想查看某个消费者具体读取了哪些数据，可以执行下面的命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看 group2 里 consumer2 已从 mymq 消息队列中读取了哪些消息</span><br><span class="line">&gt; XPENDING mymq group2 - + <span class="number">10</span> consumer2</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1654256265584-0&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">410700</span></span><br><span class="line">   <span class="number">4</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><br>可以看到，consumer2 已读取的消息的 ID 是 1654256265584-0。<br><strong>一旦消息 1654256265584-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; XACK mymq group2 <span class="number">1654256265584</span><span class="number">-0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><br>当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; XPENDING mymq group2 - + <span class="number">10</span> consumer2</span><br><span class="line">(empty <span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><br>好了，基于 Stream 实现的消息队列就说到这里了，小结一下：</p>
<ul>
<li>消息保序：XADD/XREAD</li>
<li>阻塞读取：XREAD block</li>
<li>重复消息处理：Stream 在使用 XADD 命令，会自动生成全局唯一 ID；</li>
<li>消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息；</li>
<li>支持消费组形式消费数据</li>
</ul>
<p>Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？<br>一个专业的消息队列，必须要做到两大块：</p>
<ul>
<li>消息不丢。</li>
<li>消息可堆积。</li>
</ul>
<p><em>1、Redis Stream 消息会丢失吗？</em><br>使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657941776245-13f308ac-fec6-40d0-87f9-a4b8e254cbfd.png#averageHue=%23eddbda&amp;clientId=u0e0f5fcd-dcf9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uea17c3de&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=396&amp;originWidth=1494&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=116441&amp;status=done&amp;style=none&amp;taskId=u2cb5fbea-e319-481c-8300-1b060809b8b&amp;title=" alt="image.png"><br>Redis Stream 消息队列能不能保证三个环节都不丢失数据？</p>
<ul>
<li>Redis 生产者会不会丢消息？生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。 从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</li>
<li>Redis 消费者会不会丢消息？不会，因为 Stream （ MQ 中间件）会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，但是未被确认的消息。消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。等到消费者执行完业务逻辑后，再发送消费确认 XACK 命令，也能保证消息的不丢失。</li>
<li>Redis 消息中间件会不会丢消息？<strong>会</strong>，Redis 在以下 2 个场景下，都会导致数据丢失：<ul>
<li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li>
<li>主从复制也是异步的，<a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">主从切换时，也存在丢失数据的可能(opens new window)</a>。</li>
</ul>
</li>
</ul>
<p>可以看到，Redis 在队列中间件环节无法保证消息不丢。像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。<br><em>2、Redis Stream 消息可堆积吗？</em><br>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。<br>所以 Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。<br>当指定队列最大长度时，队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。<br>但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上，当消息积压时，无非就是多占用一些磁盘空间。<br>因此，把 Redis 当作队列来使用时，会面临的 2 个问题：</p>
<ul>
<li>Redis 本身可能会丢数据；</li>
<li>面对消息挤压，内存资源会紧张；</li>
</ul>
<p>所以，能不能将 Redis 作为消息队列来使用，关键看你的业务场景：</p>
<ul>
<li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li>
<li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li>
</ul>
<p>补充：Redis 发布/订阅机制为什么不可以作为消息队列？<br>发布订阅机制存在以下缺点，都是跟丢失数据有关：</p>
<ol>
<li>发布/订阅机制没有基于任何数据类型实现，所以不具备「数据持久化」的能力，也就是发布/订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布/订阅机制的数据也会全部丢失。</li>
<li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li>
<li>当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 client-output-buffer-limit pubsub 32mb 8mb 60。</li>
</ol>
<p>所以，发布/订阅机制只适合即使通讯的场景，比如<a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84">构建哨兵集群(opens new window)</a>的场景采用了发布/订阅机制。</p>
<h2 id="Ⅱredis数据结构"><a href="#Ⅱredis数据结构" class="headerlink" title="Ⅱredis数据结构"></a>Ⅱredis数据结构</h2><p>注意，<strong>Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构</strong>。<br>我画了一张 Redis 数据类型（也叫 Redis 对象）和底层数据结构的对应关图，左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 Redis 代码的（还未发布正式版本）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042150021-b5d246c7-19ee-464b-85e1-5f2f224bc038.png#averageHue=%23faf7ed&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=360&amp;id=u64594139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=830&amp;originWidth=1352&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94050&amp;status=done&amp;style=none&amp;taskId=u926c332e-b7f4-4f9c-a7ed-5f73258b5f1&amp;title=&amp;width=586.0000610351562" alt="image.png"></p>
<h3 id="我们平时说redis是字典数据库KV键值对到底是什么"><a href="#我们平时说redis是字典数据库KV键值对到底是什么" class="headerlink" title="我们平时说redis是字典数据库KV键值对到底是什么"></a>我们平时说redis是字典数据库KV键值对到底是什么</h3><ol>
<li>redis 是 key-value 存储系统，其中key类型一般为字符串，value 类型则为redis对象(redisObject)</li>
<li>Redis定义了<strong>redisObjec结构体</strong>来表示string、hash、list、set、zset等数据类型，Redis 中每个对象都是一个 redisObject 结构</li>
</ol>
<p><strong>redisObjec结构的作用：</strong></p>
<ul>
<li>为了便于操作，Redis采用redisObjec结构来统一五种不同的数据类型，这样所有的数据类型就都可以以相同的形式在函数间传递而不用使用特定的类型结构。</li>
<li>同时，为了识别不同的数据类型，redisObjec中定义了type和encoding字段对不同的数据类型加以区别。简单地说，redisObject就是string、hash、list、set、zset的父类。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1648361437557-b6066b96-a526-491b-94b4-c3fd7c4cbf84.png#averageHue=%23eeeeee&amp;clientId=u4da6a76f-331d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=Ohd84&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=628&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=70592&amp;status=done&amp;style=none&amp;taskId=u3bf40ddc-8a65-4f6b-acae-da085504213&amp;title=&amp;width=502.4" alt="image.png"></p>
<ol>
<li>每个键值对都会有一个dictEntry(源码位置：dict.h)，里面指向了key和value的指针，next 指向下一个 dictEntry。key 是字符串，但是 Redis 没有直接使用 C 的字符数组，而是存储在redis自定义的 SDS中。value 既不是直接作为字符串存储，也不是直接存储在 SDS 中，而是存储在redisObject 中。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1648361313947-02064ffa-9620-43d0-b3fb-5e904c6b4876.png#averageHue=%23afacaa&amp;clientId=u4da6a76f-331d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=355&amp;id=rUQrm&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=444&amp;originWidth=621&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=83069&amp;status=done&amp;style=none&amp;taskId=u7a84d8da-35ba-4b5d-8844-78595dbd13e&amp;title=&amp;width=496.8" alt="image.png"></p>
<h3 id="👌键值对数据库是怎么实现的？"><a href="#👌键值对数据库是怎么实现的？" class="headerlink" title="👌键值对数据库是怎么实现的？"></a>👌键值对数据库是怎么实现的？</h3><p>这些键值对是如何保存在 Redis 中的呢？<br>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。<br>Redis 的哈希桶是怎么保存键值对数据的呢？<br>哈希桶存放的是指向键值对数据的指针（dictEntry<em>），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void </em> key 和 void <em> value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void </em> value 指针找到。<br>补充在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。<br>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。<br>举个例子，我这里列出几种 Redis 新增键值对的命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET name <span class="string">&quot;xiaolincoding&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; HSET person name <span class="string">&quot;xiaolincoding&quot;</span> age <span class="number">18</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; RPUSH stu <span class="string">&quot;xiaolin&quot;</span> <span class="string">&quot;xiaomei&quot;</span></span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><br>这些命令代表着：</p>
<ul>
<li>第一条命令：name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>；</li>
<li>第二条命令：person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>；</li>
<li>第三条命令：stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>；</li>
</ul>
<p>我这里画了一张 Redis 保存键值对所涉及到的数据结构。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042276185-f1ceaeac-c70f-401f-be78-6cc703f801d5.png#averageHue=%23f9f6f3&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Gch75&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=662&amp;originWidth=1637&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=127108&amp;status=done&amp;style=none&amp;taskId=u0ce52ac2-e76f-4a93-b7fe-237ce751e0f&amp;title=" alt="image.png"><br>这些数据结构的内部细节，我先不展开讲，后面在讲哈希表数据结构的时候，在详细的说说，因为用到的数据结构是一样的。这里先大概说下图中涉及到的数据结构的名字和用途：</p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 <em>*void </em> key 和 void * value 指针， <em>key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</em>。</li>
</ul>
<p>特别说明下，void <em> key 和 void </em> value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042276078-21083371-6795-40d0-8233-743716e0d48b.png#averageHue=%23eff2df&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=415&amp;id=ujSNY&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=587&amp;originWidth=647&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54078&amp;status=done&amp;style=none&amp;taskId=u85c1f966-bcee-4b88-b9bd-4d9ebf0bc37&amp;title=&amp;width=457" alt="image.png"><br>对象结构里包含的成员变量：</p>
<ul>
<li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li>
<li>encoding，标识该对象使用了哪种底层的数据结构；</li>
<li><strong>ptr，指向底层数据结构的指针</strong>。</li>
</ul>
<p>我画了一张 Redis 键值对数据库的全景图，你就能清晰知道 Redis 对象和数据结构的关系了：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042276275-b708a542-6342-455c-8f57-bcd5c5191412.png#averageHue=%23f8f5ed&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=EPE90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=684&amp;originWidth=1889&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=189181&amp;status=done&amp;style=none&amp;taskId=ude84c003-892c-4197-9604-14b4598a01f&amp;title=" alt="image.png"><br>接下里，就好好聊一下底层数据结构！</p>
<h3 id="①SDS"><a href="#①SDS" class="headerlink" title="①SDS"></a>①SDS</h3><ul>
<li>字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。</li>
<li>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</li>
</ul>
<p><strong>C 语言字符串的缺陷</strong><br>补充既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char<em> 字符数组存在一些缺陷。<br>要了解这一点，得先来看看 char</em> 字符数组的结构。<br>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。<br>比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042615477-f80a045f-d2b2-442a-9322-9d837fd1a41f.png#averageHue=%23e5e7ee&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=zShzv&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=182&amp;originWidth=482&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17158&amp;status=done&amp;style=none&amp;taskId=u3eeb4e15-c9eb-45aa-a23b-c2f24caaa65&amp;title=" alt="image.png"></p>
<ul>
<li>在 C 语言里，对字符串操作时，char <em> 指针只是指向字符数组的起始位置，而<em>*字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</em></em>。</li>
<li>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</li>
</ul>
<p>举个例子，C 语言获取字符串长度的函数 strlen，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042615584-6484bbab-f2da-4a65-a708-85a0938dd701.png#averageHue=%231e1918&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=384&amp;id=j1MyN&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=602&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31811&amp;status=done&amp;style=none&amp;taskId=u98987a53-8ed3-402d-9c3f-9bfbd238d94&amp;title=&amp;width=427" alt="image.png"><br>很明显，<strong>C 语言获取字符串长度的时间复杂度是 O（N）（<em>这是一个可以改进的地方</em></strong>）<br>C 语言字符串用 “\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\0” 字符，这时在操作这个字符串时就会<strong>提早结束</strong>，比如 “xiao\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042615756-9a19fae1-a08e-40c5-afdc-a970e82f3e47.png#averageHue=%230d0b0a&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=UVR2j&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=557&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33477&amp;status=done&amp;style=none&amp;taskId=u765c2f73-cb57-4d42-a816-1ac6e154850&amp;title=" alt="image.png"><br>因此，除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（<em>这也是一个可以改进的地方</em>）</strong><br>另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。<br>举个例子，strcat 函数是可以将两个字符串拼接在一起。<br><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（<em>这是一个可以改进的地方</em></strong>）。<br>而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，<strong>对字符串的操作效率不高</strong>。</p>
<ul>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li>
<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li>
</ul>
<p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。<br><strong>SDS 结构设计</strong><br>补充下图就是 Redis 5.0 的 SDS 的数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042615507-a5516be9-ccc3-4316-91b1-3f248fb59846.png#averageHue=%23eaeaea&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=toQQd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=347&amp;originWidth=407&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27511&amp;status=done&amp;style=none&amp;taskId=u84a772d5-c0e4-4a43-87d5-036c5fb8faa&amp;title=" alt="image.png"><br>结构中的每个成员变量分别介绍下：</p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。<br><strong>O（1）复杂度获取字符串长度</strong><br>Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。<br><strong>二进制安全</strong></p>
<ul>
<li>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。</li>
<li>因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。</li>
<li>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</li>
</ul>
<p><strong>不会发生缓冲区溢出</strong></p>
<ul>
<li>Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 alloc - len 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。<ul>
<li>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</strong>，以满足修改所需的大小。</li>
</ul>
</li>
<li>这样的好处是，能<strong>有效的减少内存分配次数</strong>。</li>
<li>所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。</li>
</ul>
<p><strong>节省内存空间</strong><br>补充SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。<br>Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。<br>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。<br>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看到：</p>
<ul>
<li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li>
<li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li>
</ul>
<p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。<br>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <strong>attribute</strong> ((packed)) ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。<br>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。<br>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"> &#125; test1;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042615650-20bcda21-7372-4281-829d-12b6bb1baf79.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=PqAZd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=182&amp;originWidth=542&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16013&amp;status=done&amp;style=none&amp;taskId=u7d6b2945-3bec-466a-aec1-dd520577792&amp;title=" alt="image.png"><br>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。<br>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 <strong>attribute</strong> ((packed)) 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。<br>比如，我用 <strong>attribute</strong> ((packed)) 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">test2</span>  &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"> &#125; test2;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这时打印的结果是 5（1 个字节 char + 4 字节 int）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658042616693-62b8d731-5772-4fff-9252-649e0b2b6cf5.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=XjB2h&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=197&amp;originWidth=309&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11033&amp;status=done&amp;style=none&amp;taskId=u4d38d2af-f3ee-4cb8-9067-764ebc8d551&amp;title=" alt="image.png"><br>可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。</p>
<h3 id="②链表"><a href="#②链表" class="headerlink" title="②链表"></a>②链表</h3><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。<br><strong>链表节点结构设计</strong>先来看看「链表节点」结构的样子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><br>有前置节点和后置节点，可以看的出，这个是一个双向链表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043573311-993176a4-e204-42b4-b572-03a6242e2015.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=a9BcE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=272&amp;originWidth=1127&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22478&amp;status=done&amp;style=none&amp;taskId=udb23db4d-4c94-4204-885c-3c1d5745736&amp;title=" alt="image.png"><br><strong>链表结构设计</strong><br>不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><br>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。<br>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043573354-a3c72484-26d3-469f-b2fe-11adf72e0589.png#averageHue=%23f9f3f2&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1044e508&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=512&amp;originWidth=1449&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48956&amp;status=done&amp;style=none&amp;taskId=uf811a283-9c25-403a-b41e-793f07f0cd4&amp;title=" alt="image.png"><br><strong>链表的优势与缺陷</strong><br>Redis 的链表实现优点如下：</p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong>；</li>
<li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong>；</li>
<li>listNode 链表节使用 void<em> 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<em>*链表节点可以保存各种不同类型的值</em></em>；</li>
</ul>
<p>链表的缺陷也是有的：</p>
<ul>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li>
<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。<blockquote>
<ul>
<li>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</li>
<li>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</li>
<li>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="③压缩列表"><a href="#③压缩列表" class="headerlink" title="③压缩列表"></a>③压缩列表</h3><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p>接下来，就跟大家详细聊下压缩列表。<br><strong>压缩列表结构设计</strong><br>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043820515-e0b71a13-751f-4e75-890c-934b60a01310.png#averageHue=%23cce1ca&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue5abc222&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=62&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12885&amp;status=done&amp;style=none&amp;taskId=ubbda3dcc-cca2-49b8-9a4b-971e5a6d008&amp;title=" alt="image.png"><br><strong>压缩列表具体字段</strong>（了解即可）压缩列表在表头有三个字段：</p>
<ul>
<li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li>
<li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li>
<li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。<br>另外，压缩列表节点（entry）的构成如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043820396-22c35dae-6e5f-4dec-984f-d7f44694b8b4.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ziyZE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28590&amp;status=done&amp;style=none&amp;taskId=ufd779b8c-bddc-4b8c-a386-7736d0f0e7a&amp;title=" alt="image.png"><br>压缩列表节点包含三部分内容：</p>
<ul>
<li><em><strong>prevlen</strong></em>，记录了「前一个节点」的长度；</li>
<li><em><strong>encoding</strong></em>，记录了当前节点实际数据的类型以及长度；</li>
<li><em><strong>data</strong></em>，记录了当前节点的实际数据；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。<br>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。<br>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p>
<ul>
<li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：</p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节/2字节/5字节的空间</strong>进行编码。</li>
</ul>
<p><strong>连锁更新</strong><br>压缩列表除了查找复杂度高的问题，还有一个问题。<br><strong>压缩列表新增某个元素或修改某个元素时，如果空间不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。<br>类似多米诺效应<br>连锁更新具体例子前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p>
<ul>
<li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043820338-f4b2261b-a837-480f-8bb2-b6f9125752e7.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=JD7Lm&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=144&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18454&amp;status=done&amp;style=none&amp;taskId=u1dd443db-2978-4f59-a651-c272a02537d&amp;title=" alt="image.png"><br>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。<br>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043820390-832d1549-d50a-48ac-8610-0624459becec.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ObAFn&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=204&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26914&amp;status=done&amp;style=none&amp;taskId=ufdac6009-f34a-4585-83ca-e4222ccefc5&amp;title=" alt="image.png"><br>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。<br>多米诺牌的效应就此开始。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658043820576-b0b284d6-0813-4398-ae65-066e2631a292.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=blw0a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=782&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=106165&amp;status=done&amp;style=none&amp;taskId=u01613c1b-b3db-4b10-98c0-0c5979cb6a7&amp;title=" alt="image.png"><br>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。<br>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。<br><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，<br><strong>压缩列表的缺陷</strong></p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p>
<blockquote>
<p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p>
</blockquote>
<h3 id="④哈希表"><a href="#④哈希表" class="headerlink" title="④哈希表"></a>④哈希表</h3><p>前置知识Redis 的哈希表结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><br>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044114380-11f56602-99c9-497d-92e4-f93cdc10cc3c.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=222&amp;id=yKDK2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=587&amp;originWidth=1052&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60736&amp;status=done&amp;style=none&amp;taskId=ua9ebf31e-b21a-4cd5-afb9-67108e299ba&amp;title=&amp;width=397" alt="image.png"><br>哈希表节点的结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希。<br>另外，这里还跟你提一下，dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</p>
</blockquote>
<p><strong>哈希冲突</strong></p>
<blockquote>
<p>哈希表实际上是一个数组，数组里多每一个元素就是一个哈希桶。<br>当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。</p>
</blockquote>
<p>什么是哈希冲突呢？<br>补充举个例子，有一个可以存放 8 个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值 % 8 」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶 1 和桶 6。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044114425-0b5f8060-3931-43e1-8c36-70d3dcdbed38.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=412&amp;id=NmMXM&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=527&amp;originWidth=812&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80437&amp;status=done&amp;style=none&amp;taskId=uc36d3aaa-f8af-436a-a90d-2f04b34c39b&amp;title=&amp;width=635.0000610351562" alt="image.png"><br>此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。<br>因此，<strong>当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突。</strong><br><strong>链式哈希</strong><br>Redis 采用了「<strong>链式哈希</strong>」的方法来解决哈希冲突。<br>链式哈希是怎么实现的？</p>
<ul>
<li><p>实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表，<strong>被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来</strong>，这样就解决了哈希冲突。<br>补充还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1 就会通过 next 指针指向 key9，形成一个单向链表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044114433-1c3bb766-8ac4-41fd-bd95-a7871570f927.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Kmd9q&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=527&amp;originWidth=1067&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=83003&amp;status=done&amp;style=none&amp;taskId=u364acf89-c043-439b-9df0-de834e3d568&amp;title=" alt="image.png"></p>
</li>
<li><p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p>
</li>
</ul>
<p>要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。<br>接下来，看看 Redis 是如何实现的 rehash 的。<br><strong>rehash</strong><br>哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//两个Hash表，交替使用，用于rehash操作</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">    …</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><br>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044114380-62609414-004e-42ec-af81-3608ee4536b7.png#averageHue=%23fbf4f1&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ub14ea007&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=699&amp;originWidth=1502&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=97406&amp;status=done&amp;style=none&amp;taskId=uf91ccff5-c1ad-4c8d-96cc-864bb68a68d&amp;title=" alt="image.png"><br>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。<br>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<ul>
<li><strong>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</strong></li>
<li><strong>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</strong></li>
<li><strong>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</strong><blockquote>
<p>为了方便你理解，我把 rehash 这三个过程画在了下面这张图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044114433-fef44fe0-ff63-445c-9e96-05d805309f44.png#averageHue=%23f8f6f0&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=u39ff3ec6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=699&amp;originWidth=1344&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=93716&amp;status=done&amp;style=none&amp;taskId=u0c4b5850-690d-466a-9830-6ec4f093ba8&amp;title=&amp;width=603.0000610351562" alt="image.png"></p>
</blockquote>
</li>
</ul>
<p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。<br><strong>渐进式 rehash</strong><br>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。<br>渐进式 rehash 步骤如下：</p>
<ul>
<li>给「哈希表 2」 分配空间；</li>
<li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li>
</ul>
<p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p>
<p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p>
<p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p>
<p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。<br><strong>rehash 触发条件</strong><br>介绍了 rehash 那么多，还没说什么时情况下会触发 rehash 操作呢？<br>rehash 的触发条件跟<strong>负载因子（load factor）</strong>有关系。<br>负载因子可以通过下面这个公式计算：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044117324-066cddba-2096-41d6-9f9c-afad2b9b61d9.png#averageHue=%23ead1b4&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u98a26a17&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=77&amp;originWidth=617&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10325&amp;status=done&amp;style=none&amp;taskId=uac43eae8-86a9-443e-8d1b-e3482798f32&amp;title=" alt="image.png"><br>触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong><h3 id="⑤整数集合"><a href="#⑤整数集合" class="headerlink" title="⑤整数集合"></a>⑤整数集合</h3>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。<br><strong>整数集合结构设计</strong><br>整数集合本质上是一块连续内存空间，它的结构定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p>
<ul>
<li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；</li>
</ul>
<p>不同类型的 contents 数组，意味着数组的大小也会不同。</p>
</blockquote>
</li>
</ul>
<p><strong>整数集合的升级操作</strong><br>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。<br>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。<br>升级的例子举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044596494-5ac5770a-5fad-4c49-a351-72b8d7c29552.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=GwmTF&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=444&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19695&amp;status=done&amp;style=none&amp;taskId=u071a4733-430e-4c47-8bf8-45c030aab4a&amp;title=" alt="image.png"><br>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044596613-7173423a-4322-4ea4-8e50-221c4ebd4758.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=LYSQW&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=924&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28899&amp;status=done&amp;style=none&amp;taskId=uee391570-167f-4fa5-8e04-a21d1c68d60&amp;title=" alt="image.png"><br>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044596705-19c46d8a-deb6-401a-9ab1-68ca0edae66e.png#clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=yRfAY&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1023&amp;originWidth=1097&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=156616&amp;status=done&amp;style=none&amp;taskId=uf2237281-0b13-4c15-82e4-6a611a6b429&amp;title=" alt="image.png"><br>整数集合升级有什么好处呢？</p>
<blockquote>
<p>如果要让一个数组同时保存 int16_t、int32_t、int64_t 类型的元素，最简单做法就是直接使用 int64_t 类型的数组。不过这样的话，当如果元素都是 int16_t 类型的，就会造成内存浪费的情况。<br>整数集合升级就能避免这种情况，如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组，只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作。</p>
</blockquote>
<p>因此，整数集合升级的好处是<strong>节省内存资源</strong>。<br>整数集合支持降级操作吗？<br><strong>不支持降级操作</strong>，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了 65535 元素，整数集合的数组还是 int32_t 类型的，并不会因此降级为 int16_t 类型。</p>
<hr>
<h3 id="⑥跳表✊"><a href="#⑥跳表✊" class="headerlink" title="⑥跳表✊"></a>⑥跳表✊</h3><p>Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。<br>Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><br>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。<br>接下来，详细的说下跳表。<br><strong>跳表结构设计</strong><br>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<blockquote>
<p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044596594-e4e9630c-6815-4535-9c56-98a9ced007c6.png#averageHue=%23f8f5f3&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uf4a4c6c0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=287&amp;originWidth=1164&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29556&amp;status=done&amp;style=none&amp;taskId=u4fd97ad4-c98e-4410-94c2-5ed5d72d362&amp;title=" alt="image.png"><br>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p>
<ul>
<li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；</li>
<li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li>
<li>L2 层级只有 1 个节点，也就是节点 3 。</li>
</ul>
<p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。<br>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p>
</blockquote>
<hr>
<p><strong>那跳表节点是怎么实现多层级的呢？</strong><br>这就需要看<strong>「跳表节点」</strong>的数据结构了，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</li>
<li>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</li>
<li>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。<blockquote>
<p>比如，下面这张图，展示了各个节点的跨度。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044596676-bfb51ef2-7db8-4952-a5c6-9c11d0790334.png#averageHue=%23f5f3f0&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaaecded5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=317&amp;originWidth=1947&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65501&amp;status=done&amp;style=none&amp;taskId=u000df285-cc53-4d74-80c7-6090e5b0ee5&amp;title=" alt="image.png"><br>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针就可以完成了。<br><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。<br>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L3），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。<br>另外，图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点的后向指针、权重、元素值都未被用到，所以图中省略了这部分。</p>
</blockquote>
</li>
</ul>
<p>问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍<strong>「跳表」</strong>结构体了，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><br>跳表结构里包含了：</p>
<ul>
<li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li>
<li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li>
<li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li>
</ul>
<p><strong>跳表节点查询过程</strong><br>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<blockquote>
<p>举个例子，下图有个 3 层级的跳表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044598825-7aa1f4be-2e26-4075-93ee-8727dd574b83.png#averageHue=%23fce6cd&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc80645db&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=437&amp;originWidth=2387&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=238513&amp;status=done&amp;style=none&amp;taskId=u75ccd34f-f4d1-4a4b-92af-0242c8b1bba&amp;title=" alt="image.png"><br>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p>
<ul>
<li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li>
<li>但是该层的下一个节点是空节点（ leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li>
<li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li>
<li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li>
</ul>
</blockquote>
<p><strong>跳表节点层数设置</strong><br>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<blockquote>
<p>举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044598734-d7a0545b-75b0-49cf-aa77-28a0316f1a72.png#averageHue=%23faf9f7&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uabbea45d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=287&amp;originWidth=1524&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31057&amp;status=done&amp;style=none&amp;taskId=u6141e207-481c-4354-b859-db6828c27e2&amp;title=" alt="image.png"><br>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。<br><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</strong>。<br>下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044598950-883066cc-46e6-4c02-804d-ffec596f23cc.png#averageHue=%23f8f7f5&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u89d654e4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=287&amp;originWidth=1532&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34132&amp;status=done&amp;style=none&amp;taskId=u6fb50f3b-7d45-488d-9a2b-8527e255292&amp;title=" alt="image.png"></p>
</blockquote>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？跳表何时增加高度</p>
<ul>
<li>[ ] 如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</li>
<li>[ ] Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</li>
<li>[ ] 具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</li>
<li>[ ] 这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</li>
</ul>
<p>为什么使用跳表不使用红黑树</p>
<ul>
<li>按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>
<li>跳表代码容易实现，红黑树不容易实现<h3 id="⑦quicklist"><a href="#⑦quicklist" class="headerlink" title="⑦quicklist"></a>⑦quicklist</h3>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。<br>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</li>
</ul>
<p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p>
<p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong><br><strong>quicklist 结构设计</strong><br>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">//quicklist的链表头</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *tail; </span><br><span class="line">    <span class="comment">//所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNodes的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;       </span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><br>接下来看看，quicklistNode 的结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="comment">//下一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="comment">//quicklistNode指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;              </span><br><span class="line">    <span class="comment">//压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;                </span><br><span class="line">    <span class="comment">//压缩列表的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;        <span class="comment">//ziplist中的元素个数 </span></span><br><span class="line">    ....</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><br>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。<br>我画了一张图，方便你理解 quicklist 数据结构。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044598958-f02fb275-753b-4363-b937-f9cca6da631f.png#averageHue=%23f6f5f2&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud1d28a4e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=944&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26170&amp;status=done&amp;style=none&amp;taskId=uc6369358-e4fc-4436-992f-3ec342f6de5&amp;title=" alt="image.png"><br>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。<br>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h3 id="⑧listpack"><a href="#⑧listpack" class="headerlink" title="⑧listpack"></a>⑧listpack</h3><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p><strong>我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。<br><strong>listpack 结构设计</strong><br>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。<br>我们先看看 listpack 结构：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044598948-09753421-ce9a-492b-9f24-b7728d2d8bec.png#averageHue=%238893a2&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9a1aacdf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=77&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16885&amp;status=done&amp;style=none&amp;taskId=ua95bf85c-59e1-44e7-9f34-9bec5a2f5e1&amp;title=" alt="image.png"><br>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。<br>每个 listpack 节点结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658044600893-ad9ee8f9-4354-40ff-a7c5-5e6ca17cfbaf.png#averageHue=%23faedc8&amp;clientId=ua37e2371-a0dd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udb3ec698&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=317&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35709&amp;status=done&amp;style=none&amp;taskId=u5803cdbe-b3d5-4d14-8c20-557e7b03c28&amp;title=" alt="image.png"><br>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<h1 id="三、布隆过滤器"><a href="#三、布隆过滤器" class="headerlink" title="三、布隆过滤器"></a>三、布隆过滤器</h1><p><strong>①是什么：</strong><br>由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在<br><strong>②特点</strong></p>
<ol>
<li>高效的插入和查询，占用空间少，返回的结果是不确定的</li>
<li>一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在。</li>
<li>布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。</li>
<li>误判只会发生在过滤器没有添加过的元素，对于添加过的元素不会发生误判。</li>
</ol>
<p>结论：有，是可能有，无是肯定无。可以保证的是，如果布隆过滤器判断一个元素不在一个集合中，那这个元素一定不会在集合中<br>Redis实现的布隆过滤器bigkey问题：Redis布隆过滤器是使用String类型实现的，存储的方式是一个bigkey，建议使用时单独部署一个实例，专门存放布隆过滤器的数据，不要和业务数据混用，否则在集群环境下，数据迁移时会导致Redis阻塞问题。<br><strong>③应用场景</strong></p>
<ul>
<li>缓存穿透</li>
<li>黑名单校验</li>
</ul>
<p><strong>④原理：</strong><br><strong>添加key时</strong><br>使用多个hash函数对key进行hash运算得到一个整数索引值，对位数组长度进行取模运算得到一个位置，<br>每个hash函数都会得到一个不同的位置，将这几个位置都置1就完成了add操作。<br><strong>查询key时</strong><br>只要有其中一位是零就表示这个key不存在，但如果都是1，则不一定存在对应的key。<br>结论：<br>有，是可能有<br>无，是肯定无</p>
<p>这种情况也造成了布隆过滤器的删除问题，因为布隆过滤器的每一个 bit 并不是独占的，很有可能多个元素共享了某一位。<br>优点：高效的插入和查询<br>缺点：不能删除元素。<br>因为删掉元素会导致误判率增加，因为hash冲突同一个位置可能存的东西是多个共有的，<br>你删除一个元素的同时可能也把其它的删除了。<br>存在误判：不同的数据可能hash运算出来的结果一致。<br>布谷鸟过滤器解决了不能删除的问题</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/09/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://example.com/2022/08/09/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0Redis-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">ⅠRedis 常见数据类型以及使用场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0string"><span class="toc-number">1.1.</span> <span class="toc-text">①string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1list"><span class="toc-number">1.3.</span> <span class="toc-text">②list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2hash"><span class="toc-number">1.4.</span> <span class="toc-text">③hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3set"><span class="toc-number">1.5.</span> <span class="toc-text">④set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4zset"><span class="toc-number">1.6.</span> <span class="toc-text">⑤zset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%BB%9F%E8%AE%A1%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">聚合统计：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%BB%9F%E8%AE%A1%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">排序统计：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E7%8A%B6%E6%80%81%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.9.</span> <span class="toc-text">二值状态统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%9A"><span class="toc-number">1.10.</span> <span class="toc-text">基数统计：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.11.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5bitmap"><span class="toc-number">1.12.</span> <span class="toc-text">⑥bitmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6hyperloglog"><span class="toc-number">1.13.</span> <span class="toc-text">⑦hyperloglog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7GEO"><span class="toc-number">1.14.</span> <span class="toc-text">⑧GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%8C%E2%91%A8Stream"><span class="toc-number">1.15.</span> <span class="toc-text">👌⑨Stream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Ⅱredis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E8%AF%B4redis%E6%98%AF%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E5%BA%93KV%E9%94%AE%E5%80%BC%E5%AF%B9%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">我们平时说redis是字典数据库KV键值对到底是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%8C%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">👌键值对数据库是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0SDS"><span class="toc-number">2.3.</span> <span class="toc-text">①SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">②链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">③压缩列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">④哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">2.7.</span> <span class="toc-text">⑤整数集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E8%B7%B3%E8%A1%A8%E2%9C%8A"><span class="toc-number">2.8.</span> <span class="toc-text">⑥跳表✊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6quicklist"><span class="toc-number">2.9.</span> <span class="toc-text">⑦quicklist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7listpack"><span class="toc-number">2.10.</span> <span class="toc-text">⑧listpack</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">三、布隆过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-1"><span class="toc-number"></span> <span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">1.</span> <span class="toc-text"> </span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/cover/cover/" title="翻唱"><img src="/1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻唱"/></a><div class="content"><a class="title" href="/2022/08/09/cover/cover/" title="翻唱">翻唱</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><script async src="//at.alicdn.com/t/c/xxx.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 MySQL (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 redis (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 计算机网络 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>