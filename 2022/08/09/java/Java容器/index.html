<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java容器 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java容器">
<meta property="og:type" content="article">
<meta property="og:title" content="Java容器">
<meta property="og:url" content="http://example.com/2022/08/09/java/Java%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="java容器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:21:13.367Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/09/java/Java%E5%AE%B9%E5%99%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java容器',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-13 22:21:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/xxx.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java容器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:21:13.367Z" title="更新于 2022-11-13 22:21:13">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java容器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Ⅰ集合概述"><a href="#Ⅰ集合概述" class="headerlink" title="Ⅰ集合概述"></a>Ⅰ集合概述</h2><h3 id="①Java-集合概览"><a href="#①Java-集合概览" class="headerlink" title="①Java 集合概览"></a>①Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p>
<ul>
<li>一个是 Collection接口，主要用于存放单一元素；<ul>
<li>对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。</li>
</ul>
</li>
<li>另一个是 Map 接口，主要用于存放键值对。</li>
</ul>
<p>Java 集合框架如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647571525662-aaf32cc4-03ed-465c-86ee-91796006cb71.png#averageHue=%23fdfdfd&amp;clientId=u6441117b-7d6c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udcc75149&amp;margin=%5Bobject%20Object%5D&amp;originHeight=646&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufcd66ced-11f3-4ba5-946b-90411ea86d4&amp;title=" alt=""><br>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了AbstractList, NavigableSet等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h3 id="②说说-List-Set-Queue-Map-四者的区别？"><a href="#②说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="②说说 List, Set, Queue, Map 四者的区别？"></a>②说说 List, Set, Queue, Map 四者的区别？</h3><ul>
<li>List(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li>Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li>Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><p>Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
<h3 id="③集合框架底层数据结构总结"><a href="#③集合框架底层数据结构总结" class="headerlink" title="③集合框架底层数据结构总结"></a>③集合框架底层数据结构总结</h3><p>先来看一下 Collection 接口下面的集合。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4></li>
<li><p>Arraylist： Object[] 数组</p>
</li>
<li>Vector：Object[] 数组</li>
<li><p>LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4></li>
<li><p>HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素</p>
</li>
<li>LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li>
<li><p>TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4></li>
<li><p>PriorityQueue: Object[] 数组来实现二叉堆</p>
</li>
<li>ArrayDeque: 可变长的数组 + 双指针</li>
</ul>
<p>再来看看 Map 接口下面的集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>Hashtable： 数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><p>TreeMap： 红黑树（自平衡的排序二叉树）</p>
<h3 id="④如何选用集合"><a href="#④如何选用集合" class="headerlink" title="④如何选用集合?"></a>④如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。<br>当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。</p>
<h3 id="⑤为什么要使用集合？"><a href="#⑤为什么要使用集合？" class="headerlink" title="⑤为什么要使用集合？"></a>⑤为什么要使用集合？</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。<br>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="ⅡCollection-子接口之-List"><a href="#ⅡCollection-子接口之-List" class="headerlink" title="ⅡCollection 子接口之 List"></a>ⅡCollection 子接口之 List</h2><h3 id="①Arraylist-和-Vector-的区别"><a href="#①Arraylist-和-Vector-的区别" class="headerlink" title="①Arraylist 和 Vector 的区别?"></a>①Arraylist 和 Vector 的区别?</h3></li>
<li><p>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；</p>
</li>
<li>Vector 是 List 的古老实现类，底层使用Object[ ] 存储，线程安全的。<h3 id="✊②Arraylist-与-LinkedList-区别"><a href="#✊②Arraylist-与-LinkedList-区别" class="headerlink" title="✊②Arraylist 与 LinkedList 区别?"></a>✊②Arraylist 与 LinkedList 区别?</h3></li>
</ul>
<ol>
<li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> Arraylist 底层使用的是 <strong>Object 数组</strong>；LinkedList 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong><ul>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li>LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</li>
<li><p><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="✊③ArrayList-的扩容机制-以jdk1-7为例"><a href="#✊③ArrayList-的扩容机制-以jdk1-7为例" class="headerlink" title="✊③ArrayList 的扩容机制 以jdk1.7为例"></a>✊③ArrayList 的扩容机制 以jdk1.7为例</h3></li>
<li><p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"> <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以JDK7为例，当添加第一个元素时调用 add 方法 add方法里面调用了ensureCapacityInternal(size + 1)，此时参数<strong>minCapacity </strong>为 1，在 通过Math.max()方法跟默认的容量比较后，minCapacity 为 10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着会进入<strong>ensureExplicitCapacity（）</strong>方法</p>
</li>
</ol>
<ul>
<li>由于此时添加第一个元素的时候，此时数组的长度也就是elementData.length 为 0 （因为还是一个空的 list）。此时，<strong>minCapacity - elementData.length &gt; 0</strong>成立，所以会进入 grow(minCapacity) 方法。<blockquote>
<ul>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>进入grow方法，<strong>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</strong>，由于此时oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = 传进来的参数minCapacity(为 10)。调用Arrays.copyof方法扩容。至此添加第一个元素的过程结束</li>
<li>之后添加的元素直到添加第11个元素才会再次进入grow方法，此时<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong></li>
<li><strong>扩容都是调用</strong>Arrays.copyOf(elementData, newCapacity);方法进行扩容的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">      <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">      <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">     <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">     <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="④CopyOnWriteArrayList"><a href="#④CopyOnWriteArrayList" class="headerlink" title="④CopyOnWriteArrayList"></a>④CopyOnWriteArrayList</h4>引导语<br>在 ArrayList 的类注释上，JDK 就提醒了我们，如果要把 ArrayList 作为共享变量的话，是线程不安全的，推荐我们自己加锁或者使用 Collections.synchronizedList 方法，其实 JDK 还提供了另外一种线程安全的 List，叫做 CopyOnWriteArrayList，这个 List 具有以下特征：</li>
</ol>
<p>线程安全的，多线程环境下可以直接使用，无需加锁；<br>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；<br>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</p>
<p>1 整体架构<br>从整体架构上来说，CopyOnWriteArrayList 数据结构和 ArrayList 是一致的，底层是个数组，只不过 CopyOnWriteArrayList 在对数组进行操作的时候，基本会分四步走：</p>
<p>加锁；<br>从原数组中拷贝出新数组；<br>在新数组上进行操作，并把新数组赋值给数组容器；<br>解锁<br>除了加锁之外，CopyOnWriteArrayList 的底层数组还被 volatile 关键字修饰，意思是一旦数组被修改，其它线程立马能够感知到，代码如下：</p>
<p>private transient volatile Object[] array;<br>1<br>整体上来说，CopyOnWriteArrayList 就是利用锁 + 数组拷贝 + volatile 关键字保证了 List 的线程安全。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zlfing/article/details/109738440">
</a></p>
<h2 id="ⅢCollection-子接口之-Set"><a href="#ⅢCollection-子接口之-Set" class="headerlink" title="ⅢCollection 子接口之 Set"></a>ⅢCollection 子接口之 Set</h2><h3 id="①comparable-和-Comparator-的区别"><a href="#①comparable-和-Comparator-的区别" class="headerlink" title="①comparable 和 Comparator 的区别"></a>①comparable 和 Comparator 的区别</h3><ul>
<li>comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p>
<h3 id="②无序性和不可重复性的含义是什么"><a href="#②无序性和不可重复性的含义是什么" class="headerlink" title="②无序性和不可重复性的含义是什么"></a>②无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。<br>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="③比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#③比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="③比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>③比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。<h2 id="ⅣCollection-子接口之-Queue"><a href="#ⅣCollection-子接口之-Queue" class="headerlink" title="ⅣCollection 子接口之 Queue"></a>ⅣCollection 子接口之 Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#queue-%E4%B8%8E-deque-%E7%9A%84%E5%8C%BA%E5%88%AB"></a>Queue 与 Deque 的区别</h3><strong>Queue 是单端队列</strong>，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。<br>Queue 扩展了 Collection 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Queue 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Deque 是双端队列</strong>，在队列的两端均可以插入或删除元素。<br>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Deque 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
</div>
<p>事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p>
<h3 id="✊讲一下ArrayDeque？"><a href="#✊讲一下ArrayDeque？" class="headerlink" title="✊讲一下ArrayDeque？"></a>✊讲一下ArrayDeque？</h3><p>ArrayDeque实现了双端队列，基于可变长的数组和双指针实现，数组默认大小为16。它的特点有：</p>
<ol>
<li>在两端添加、删除元素的效率较高</li>
<li>根据元素内容查找和删除的效率比较低。</li>
<li>没有索引位置的概念，不能根据索引位置进行操作。</li>
</ol>
<p>ArrayDeque和LinkedList都实现了Deque接口，如果只需要从两端进行操作，ArrayDeque效率更高一些。如果同时需要根据索引位置进行操作，或者经常需要在中间进行插入和删除（LinkedList有相应的 api，如add(int index, E e)），则应该选LinkedList。<br>ArrayDeque和LinkedList都是线程不安全的，可以使用Collections工具类中synchronizedXxx()转换成线程同步。</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraydeque-%E4%B8%8E-linkedlist-%E7%9A%84%E5%8C%BA%E5%88%AB"></a>ArrayDeque 与 LinkedList 的区别</h3><p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li>
<li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li>
<li>ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。</li>
<li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p>
<h3 id="说一说-PriorityQueue"><a href="#说一说-PriorityQueue" class="headerlink" title="说一说 PriorityQueue"></a>说一说 PriorityQueue</h3><p>PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。<br>这里列举其相关的一些要点：</p>
<ul>
<li>PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li>PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li>
<li><p>PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</p>
<h3 id="什么是fail-fast？"><a href="#什么是fail-fast？" class="headerlink" title="什么是fail fast？"></a>什么是fail fast？</h3><p>fast-fail是Java集合的一种错误机制。当多个线程对同一个集合进行操作时，就有可能会产生fast-fail事件。例如：当线程a正通过iterator遍历集合时，另一个线程b修改了集合的内容，此时modCount（记录集合操作过程的修改次数）会加1，不等于expectedModCount，那么线程a访问集合的时候，就会抛出ConcurrentModificationException，产生fast-fail事件。边遍历边修改集合也会产生fast-fail事件。<br>解决方法：</p>
</li>
<li><p>使用Colletions.synchronizedList方法或在修改集合内容的地方加上synchronized。这样的话，增删集合内容的同步锁会阻塞遍历操作，影响性能。 </p>
</li>
<li>使用CopyOnWriteArrayList来替换ArrayList。在对CopyOnWriteArrayList进行修改操作的时候，会拷贝一个新的数组，对新的数组进行操作，操作完成后再把引用移到新的数组。 <h3 id="什么是fail-safe？"><a href="#什么是fail-safe？" class="headerlink" title="什么是fail safe？"></a>什么是fail safe？</h3>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。<br><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br><strong>缺点</strong>：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 <h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2></li>
</ul>
<h2 id="ⅤMap-接口"><a href="#ⅤMap-接口" class="headerlink" title="ⅤMap 接口"></a>ⅤMap 接口</h2><h3 id="①HashMap基础面试题"><a href="#①HashMap基础面试题" class="headerlink" title="①HashMap基础面试题"></a>①HashMap基础面试题</h3><h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，<strong>之后每次扩充，容量变为原来的 2n+1</strong>。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h4 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h4><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现了 Map 接口</td>
<td>实现 Set 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 put()向 map 中添加元素</td>
<td>调用 add()方法向 Set 中添加元素</td>
</tr>
<tr>
<td>HashMap 使用键（Key）计算 hashcode</td>
<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
</div>
<h4 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h4><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647572677747-c5ca47e4-a0a8-489c-bb1c-c469c984f85e.png#averageHue=%232f2f2d&amp;clientId=u6441117b-7d6c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uba7eaa33&amp;margin=%5Bobject%20Object%5D&amp;originHeight=423&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u20091c62-9219-4c79-bfff-1e534c47c9a&amp;title=" alt=""></p>
<ul>
<li>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</li>
<li>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</li>
</ul>
<p><strong>综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h4 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h4><p>当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
<p>在openjdk8中，HashSet的add()方法只是简单的调用了HashMap的put()方法，并且判断了一下返回值以确保是否有重复元素。</p>
<p>也就是说，在openjdk8中，实际上无论HashSet中是否已经存在了某元素，HashSet都会直接插入，只是会在add()方法的返回值处告诉我们插入前是否存在相同元素。<br><strong>hashCode()与 equals() 的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个 equals() 方法返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li>综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与 equals 的区别</strong><br>对于基本类型来说，== 比较的是值是否相等；<br>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；<br>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h4 id="解决hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决hash冲突的办法有哪些？HashMap用的哪种？"></a>解决hash冲突的办法有哪些？HashMap用的哪种？</h4><p>解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。</p>
<ul>
<li>开放定址法也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点。</li>
<li>再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当R1=H1(key1)发生冲突时，再计算R2=H2(key1)，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li>
<li>链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li>
<li><p>建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h4 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h4><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>
</li>
<li><p>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</p>
</li>
<li><p>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</p>
<h3 id="②HashMap深入"><a href="#②HashMap深入" class="headerlink" title="②HashMap深入"></a>②HashMap深入</h3><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h4><p><strong>HashMap的底层数据结构是什么？</strong><br>在JDK1.7 和JDK1.8 中有所差别：<br>在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。<br>在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p>
</li>
<li><p>当链表超过 8 且数组的长度超过 64 才会转红黑树。</p>
</li>
<li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991880301-6c3bc27a-946c-4c90-b690-42274ddde830.png#averageHue=%23f5f1f1&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u46594eb5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=349&amp;originWidth=815&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34550&amp;status=done&amp;style=none&amp;taskId=u0ae44cff-ffe2-47d0-bde8-8a2ba2250bf&amp;title=" alt="image.png"><br>更深入的面试问题，<br><strong>为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</strong><br>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。<br>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。<br><strong><em>不用红黑树，用二叉查找树可以么?</em></strong><br>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。<br><strong>为什么链表改为红黑树的阈值是 8?</strong><br>是因为泊松分布，我们来看作者在源码中的注释：<br>翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松分布</a>，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。</p>
<h5 id="字段结构"><a href="#字段结构" class="headerlink" title="字段结构"></a>字段结构</h5><p><strong>默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？</strong><br>回答这个问题前，我们来先看下HashMap的默认构造函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 容纳键值对的最大值</span></span><br><span class="line">final <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;  </span><br></pre></td></tr></table></figure><br>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length <em> Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。<br>默认的loadFactor是0.75<em>*，0.75是对空间和时间效率的一个平衡选择</em></em>，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p>
<ul>
<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</li>
<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li>
</ul>
<p>我们来追溯下作者在源码中的注释（JDK1.7）：<br>翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p>
<h4 id="2-索引计算"><a href="#2-索引计算" class="headerlink" title="2.索引计算"></a>2.索引计算</h4><p><strong>HashMap 中 key 的存储索引是怎么计算的？</strong><br>jdk1.8是首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过（length-1）&amp;hash计算得到存储的位置。看看源码的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.7</span></span><br><span class="line">方法一：</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode(); <span class="comment">// 为第一步：取hashCode值</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>); </span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);  <span class="comment">//第三步：取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8</span></span><br><span class="line"><span class="type">static</span> final <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;   </span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == null) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     h = key.hashCode() 为第一步：取hashCode值</span></span><br><span class="line"><span class="comment">     h ^ (h &gt;&gt;&gt; 16)  为第二步：高位参与运算</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的 Hash 算法本质上就是三步：<strong>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标</strong>。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991880455-8d5f65bb-24a9-4949-8f23-31434e929308.png#averageHue=%23f7f6f6&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7ecb6f08&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=684&amp;originWidth=1198&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=123665&amp;status=done&amp;style=none&amp;taskId=u57c789b7-947d-4b77-b69f-4d0ae351200&amp;title=" alt="image.png"><br>扩展出以下几个问题，<br><strong>JDK1.8 为什么要 hashcode 异或其右移十六位的值？</strong></p>
<ul>
<li>因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。 从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低16位实现：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)。</li>
<li>这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低位Bit都参与到Hash的计算中，同时不会有太大的开销。</li>
</ul>
<p><strong>为什么 hash 值要与length-1相与？</strong></p>
<ul>
<li>把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。</li>
<li>当 length 总是 2 的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</li>
</ul>
<p><strong>HashMap数组的长度为什么是 2 的幂次方？</strong></p>
<blockquote>
<p>HashMap 为了存取高效，减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现的关键就在把数据存到哪个链表中的算法。<br>数组下标的计算方法是(n - 1) &amp; hash，取余<strong>(%)</strong>操作中如果除数是<strong>2</strong>的幂次则等价<br>于与其除数减一的与<strong>(&amp;)</strong>操作（也就是说 <strong>hash%length==hash&amp;(length-1)</strong>的前提是<br><strong>length </strong>是<strong>2</strong>的 <strong>n </strong>次方；）。<strong>” </strong>并且 采用二进制位操作 <strong>&amp;</strong>，相对于<strong>%</strong>能够提高运算效率，<br>这就解释了 <strong>HashMap </strong>的长度为什么是<strong>2</strong>的幂次方。</p>
</blockquote>
<p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。但是位运算比模运算速度快<br><strong>hash%length==hash&amp;(length-1)</strong>的前提是 <strong>length </strong>是<strong>2</strong>的 <strong>n </strong>次方<br>除此之外，2 的 N 次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空间不浪费。我们来举个例子，看下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991880444-a3782b92-9d1a-4f39-a83f-f1e5dee09061.png#averageHue=%23f6f7f5&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubc0f9c00&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=425&amp;originWidth=383&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=76624&amp;status=done&amp;style=none&amp;taskId=u52c805b8-2e79-462a-ad92-706b1167771&amp;title=" alt="image.png"><br>当 length =15时，6 和 7 的结果一样，这样表示他们在 table 存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，4和5的结果也是一样，这样就会导致查询速度降低。<br>如果我们进一步分析，还会发现空间浪费非常大，以 length=15 为例，在 1、3、5、7、9、11、13、15 这八处没有存放数据。因为hash值在与14（即 1110）进行&amp;运算时，得到的结果最后一位永远都是0，即 0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的。<br><strong>补充数组容量计算的小奥秘</strong><br>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。会取大于或等于这个数的 且最近的2次幂作为 table 数组的初始容量，使用tableSizeFor(int)方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂），也就是说 table 数组的长度总是 2 的次幂。JDK1.8 源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> final <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解释：位或( | )</span></span><br><span class="line"><span class="comment">int n = cap - 1;　让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-put方法"><a href="#3-put方法" class="headerlink" title="3.put方法"></a>3.put方法</h4><p><strong>HashMap 的put方法流程？</strong><br>简要流程如下：</p>
<ul>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果数组不为空<ul>
<li>并且没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果有哈希冲突<ul>
<li>且 key 已经存在，就覆盖掉 value；</li>
<li>key不存在，发现该节点是红黑树，就将这个节点挂在树上；</li>
<li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991880492-11c2f742-63a0-43b0-8d46-42e319b06629.png#averageHue=%23f2e3cb&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u71c53776&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=695&amp;originWidth=665&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=219454&amp;status=done&amp;style=none&amp;taskId=uc604567b-d547-4d9f-9c44-bb95431b7ed&amp;title=" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>详细分析，见JDK1.8HashMap 的 put 方法源码:```c<br> public V put(K key, V value) {<br>     // 对key的hashCode()做hash<br>        return putVal(hash(key), key, value, false, true);<br>    }</p>
<p>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>                   boolean evict) {<br>        Node<K,V>[] tab; Node<K,V> p; int n, i;<br>        // 步骤1：tab为空则创建<br>        if ((tab = table) == null || (n = tab.length) == 0)<br>            n = (tab = resize()).length;<br>        // 步骤2：计算index，并对null做处理<br>        if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>            tab[i] = newNode(hash, key, value, null);<br>        else {<br>            Node<K,V> e; K k;<br>            // 步骤3：节点key存在，直接覆盖value<br>            if (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                e = p;<br>            // 步骤4：判断该链为红黑树<br>            else if (p instanceof TreeNode)<br>                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);<br>            // 步骤5：该链为链表<br>            else {<br>                for (int binCount = 0; ; ++binCount) {<br>                    if ((e = p.next) == null) {<br>                        p.next = newNode(hash, key, value, null);<br>                        //链表长度大于8转换为红黑树进行处理<br>                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st<br>                            treeifyBin(tab, hash);<br>                        break;<br>                    }<br>                    // key已经存在直接覆盖value<br>                    if (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                        break;<br>                    p = e;<br>                }<br>            }<br>            if (e != null) { // existing mapping for key<br>                V oldValue = e.value;<br>                if (!onlyIfAbsent || oldValue == null)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                return oldValue;<br>            }<br>        }<br>        ++modCount;<br>           // 步骤6：超过最大容量 就扩容<br>        if (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        return null;<br>    }</p>
<p>// 第31行treeifyBin方法部分代码<br>final void treeifyBin(Node<K,V>[] tab, int hash) {<br>        int n, index; Node<K,V> e;<br>        // static final int MIN_TREEIFY_CAPACITY = 64;<br>        // 如果大于8但是数组容量小于64，就进行扩容<br>        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>            resize();</p>
<pre><code>&#125;
</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">扩展的问题</span><br><span class="line">**JDK1.7 和1.8 的put方法区别是什么？**</span><br><span class="line">区别在两处：</span><br><span class="line">解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。</span><br><span class="line">链表插入元素时，JDK1.7 使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的，具体原因会在另一篇文章分析。</span><br><span class="line">#### 4.扩容机制</span><br><span class="line">**HashMap 的扩容方式？**</span><br><span class="line">Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 Hashmap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。</span><br><span class="line">那扩容的具体步骤是什么？让我们看看源码。</span><br><span class="line">JDK1.7 的代码：</span><br><span class="line">```c</span><br><span class="line">void resize(int newCapacity) &#123;   //传入新的容量</span><br><span class="line">        Entry[] oldTable = table;    //引用扩容前的Entry数组</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">            threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</span><br><span class="line">        transfer(newTable);                         //！！将数据转移到新的Entry数组里</span><br><span class="line">        table = newTable;                           //HashMap的table属性引用新的Entry数组</span><br><span class="line">        threshold = (int)(newCapacity * loadFactor);//修改阈值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">        Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                src[j] = null;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="type">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                    e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                    newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                    e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (e != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。</p>
<h5 id="JDK1-8的优化"><a href="#JDK1-8的优化" class="headerlink" title="JDK1.8的优化"></a>JDK1.8的优化</h5><p><strong>扩容在JDK1.8中有什么不一样？</strong><br>JDK1.8做了两处优化：</p>
<ol>
<li>resize 之后，元素的位置在原来的位置，或者原来的位置 +oldCap (原来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计算hash ，只需要看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧妙，省去了重新计算 hash 值的时间。如下图所示，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991880405-d4b8effc-20f6-4369-b0c2-cba815d775e7.png#averageHue=%23fdfcfc&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u787fb2f1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=446&amp;originWidth=1632&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=70033&amp;status=done&amp;style=none&amp;taskId=u62fca651-fe9e-4c1c-ac87-812fafa2bc3&amp;title=" alt="image.png">元素在重新计算 hash 之后，因为 n 变为 2倍，那么 n-1 的 mask 范围在高位多 1 bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991882325-b4a0ffc6-2b85-48e8-b249-245b0dfcfa62.png#averageHue=%23f5f5f5&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ucdbdf499&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=1064&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48503&amp;status=done&amp;style=none&amp;taskId=ud5757694-73c3-4cbb-8f8a-e3d4e547276&amp;title=" alt="image.png"></p>
<blockquote>
<ol>
<li>JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8 不会倒置，使用尾插法。</li>
</ol>
<p>下图为 16扩充为 32 的 resize 示意图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991882417-40e3231f-bb6e-49e2-8f6e-271afe2bbc11.png#averageHue=%23f1f1f1&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u970c11e2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=730&amp;originWidth=1268&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=234529&amp;status=done&amp;style=none&amp;taskId=ue1aafcbd-90f9-4681-bbf1-5d3d813215f&amp;title=" alt="image.png"><br>感兴趣的小伙伴可以看下 JDK1.8 的 resize 源码：</p>
</blockquote>
<h4 id="5-HashMap为什么线程不安全？"><a href="#5-HashMap为什么线程不安全？" class="headerlink" title="5.HashMap为什么线程不安全？"></a>5.HashMap为什么线程不安全？</h4><p>第一点:多线程下扩容死循环<br>JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。<br>详细内容下面看看多线程情况下， JDK1.7 扩容死循环问题的分析。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658990393386-f594ecac-05f4-4c2e-9bc5-33e3afb9590c.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=bBht9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=413&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2de8bc81-deb8-4480-b737-2d781d1ec91&amp;title=" alt=""><br>新建一个更大尺寸的hash表，然后把数据从老的hash表中迁移到新的hash表中。重点看下transfer方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">        Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                src[j] = null;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="type">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                    e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                    newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                    e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (e != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>正常的ReHash的过程</strong><br>画了个图做了个演示。</p>
<ul>
<li>我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。</li>
<li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。</li>
<li>接下来的三个步骤是Hash表 resize成4，然后所有的<key,value> 重新rehash的过程</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991037256-a9eb58f8-c885-4b41-bb0f-128dbfc5176b.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=TSRiC&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=462&amp;originWidth=623&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=208218&amp;status=done&amp;style=none&amp;taskId=u7cad244c-cb5a-4888-be11-06479b6425f&amp;title=" alt="image.png"><br>所以能看出来jdk1.7采用的是头插法</p>
<h4 id="并发下的Rehash"><a href="#并发下的Rehash" class="headerlink" title="并发下的Rehash"></a>并发下的Rehash</h4><p><strong>1）假设我们有两个线程。</strong>我用红色和浅蓝色标注了一下。<br>我们再回头看一下我们的 transfer代码中的这个细节：<br><strong>do</strong>{<br> Entry<K,V> next = e.next; // &lt;—假设线程一执行到这里就被调度挂起了<br><strong>int</strong> i = indexFor(e.hash, newCapacity);<br> e.next = newTable[i];<br> newTable[i] = e;<br> e = next;<br>}<strong>while</strong>(e != <strong>null</strong>);<br>而我们的线程二执行完成了。于是我们有下面的这个样子。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991036936-3d791f94-7eaa-4f56-8d85-590c567f4544.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=gBtLY&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=434&amp;originWidth=616&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=131348&amp;status=done&amp;style=none&amp;taskId=u6cebbd74-33a2-4969-846f-9e9aeeb5c5f&amp;title=" alt="image.png"><br>注意，<strong>因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表</strong>。我们可以看到链表的顺序被反转后。<br><strong>2）线程一被调度回来执行。</strong></p>
<ul>
<li><strong>先是执行 newTalbe[i] = e;</strong></li>
<li><strong>然后是e = next，导致了e指向了key(7)，</strong></li>
<li><strong>而下一次循环的next = e.next导致了next指向了key(3)</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991037120-81a6293d-bec4-4e6d-86b8-3221939a1f5b.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=KO62X&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=376&amp;originWidth=591&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=114776&amp;status=done&amp;style=none&amp;taskId=u138dca9b-2304-4c55-a6c9-5fa9b65a366&amp;title=" alt="image.png"><br><strong>3）一切安好。</strong><br>线程一接着工作。<strong>把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991037141-3ad7c91a-3c26-4a67-ac65-8d6df984f905.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=311&amp;id=Ocqpf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=411&amp;originWidth=627&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=148648&amp;status=done&amp;style=none&amp;taskId=u1656a541-0b25-4ee9-997e-87272a9321f&amp;title=&amp;width=474" alt="image.png"><br><strong>4）环形链接出现。</strong><br><strong>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</strong><br><strong>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991036888-189a77bb-09d7-40ae-b893-7ad9f1b42866.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=CJRFe&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=623&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=135714&amp;status=done&amp;style=none&amp;taskId=ud8fc6ba0-fe6f-4438-a029-dc7d24e9126&amp;title=&amp;width=417" alt="image.png"><br><strong>于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。</strong><br>第二点：多线程的put可能导致元素的丢失<br>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。<br>详细内容我们来看下JDK 1.8 中 put 方法的部分源码，重点看黄色部分：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658990394899-3d34dfd5-1ab5-48db-af47-d84059f63093.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=lVkTQ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=950&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc953623e-a745-4cae-bfc6-b75c196b5b5&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658991620117-f9e7fbae-aacb-4302-af22-979e3eaa0e4a.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=57&amp;id=Z1o4e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=100&amp;originWidth=869&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15823&amp;status=done&amp;style=none&amp;taskId=uc7d30379-1890-477c-b606-ebd72cd8bfd&amp;title=&amp;width=496.57142857142856" alt="image.png"><br>我们来演示个例子。<br>假设线程1和线程2同时执行put，线程1执行put(“1”, “A”)，线程2执行put(“5”, “B”)，hash算法就是用key mod 表的长度，表长度为4，在mod 4 以后都冲突在table[1]这里了。注：下面的例子，只演示了 #1 和#2代码的情况，其他代码也会出现类似情况。<br>正常情况下，put完成后，table的状态应该是下图中的任意一个。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658990394533-249c6c08-89f4-4e3e-8888-f699d80a43a1.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=qRuMQ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=334&amp;originWidth=341&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue35165a4-0547-4e9b-9215-71e96a2f285&amp;title=" alt=""><br>下面来看看异常情况，两个线程都执行了#1处的if ((p = tab[i = (n - 1) &amp; hash]) == null)这句代码。<br>此时假设线程1 先执行#2处的tab[i] = newNode(hash, key, value, null);<br>那么table会变成如下状态：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658990394539-61155662-a828-4ca6-b9d2-f4d491004ddd.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=dbvv2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=165&amp;originWidth=321&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u42b0e851-d3d2-40b3-9be0-e1222fb8e88&amp;title=" alt=""><br>紧接着线程2 执行tab[i] = newNode(hash, key, value, null);<br>此时table会变成如下状态:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658990394730-22ade3e7-3b05-4990-a122-2de9865c5f3d.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=YcdUz&amp;margin=%5Bobject%20Object%5D&amp;originHeight=252&amp;originWidth=321&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub251f84b-89ec-44c1-b53c-f8c4c2c5c7c&amp;title=" alt=""><br>这样一来，元素A就丢失了。<br>第三点：put和get并发时，可能导致get为null<br>线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。<br>详细内容我们来看下JDK 1.8 中 resize 方法的部分源码，重点看黄色部分：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658990395083-3adfcd08-5e57-4a9f-91b8-96306c542b3d.png#clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=B5s8c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1193&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud510350e-2ea8-4bd9-80a3-6ffde8bff97&amp;title=" alt=""><br>在代码#1位置，用新计算的容量new了一个新的hash表，#2将新创建的空hash表赋值给实例变量table。<br>注意此时实例变量table是空的，如果此时另一个线程执行get，就会get出null。</p>
<h3 id="③ConcurrentHashMap"><a href="#③ConcurrentHashMap" class="headerlink" title="③ConcurrentHashMap"></a>③ConcurrentHashMap</h3><h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h4><p>ConcurrentHashMap 在 JDK1.7 和 JDK1.8 的实现方式是不同的。<br><strong>先来看下JDK1.7</strong></p>
<ul>
<li>JDK1.7中的ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</li>
<li>其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。</li>
<li>它将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993056948-5d30c61b-8e1d-4ec1-af3c-d61b98d091f1.png#averageHue=%23fbf2df&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=337&amp;id=udf31ff9f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=670&amp;originWidth=1087&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=63655&amp;status=done&amp;style=none&amp;taskId=u86680cdd-57ef-4a86-a273-9730d4be3e0&amp;title=&amp;width=547.0000610351562" alt="image.png"><br>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993312953-72d6daaf-16e8-4972-8194-36210f4609c0.png#averageHue=%2316191a&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=uef548d32&amp;margin=%5Bobject%20Object%5D&amp;originHeight=543&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u962949a3-699c-4d77-b3a8-9ff67468f75&amp;title=&amp;width=547.0000610351562" alt=""><br>Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。<br>存放元素的 HashEntry，也是一个静态内部类，主要的组成如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993313013-9fd8a0ad-36e9-45cd-a3a6-aa3b6c15817b.png#averageHue=%23161a1b&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=253&amp;id=ue27f6fe0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=370&amp;originWidth=758&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0e18664d-4359-4f44-8a1c-c8cf898493a&amp;title=&amp;width=519.0000610351562" alt=""><br>其中，用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下数据获取时的<strong>可见性</strong>！</p>
<p><strong>再来看下JDK1.8</strong></p>
<ul>
<li>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的<strong>数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加低粒度的锁。synchronized只锁定当前链表或红黑二叉树的首节点。</li>
<li>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993056913-e561c03d-3dab-43e4-a74f-f19c011b3352.png#averageHue=%23fcf6eb&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u609f3aa1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=728&amp;originWidth=1001&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61773&amp;status=done&amp;style=none&amp;taskId=u9df3c8c2-98df-46bc-9521-67d1e4213e2&amp;title=" alt="image.png"><br>JDK1.8  中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？★★★★★</p>
<ul>
<li>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</li>
<li>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。<h4 id="2-存取"><a href="#2-存取" class="headerlink" title="2.存取"></a>2.存取</h4><strong>ConcurrentHashMap  的 put 方法执行逻辑是什么？★★★★</strong><br><strong>先来看JDK1.7</strong><br>首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。<br>获取到锁后：</li>
</ul>
<ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>释放 Segment 的锁。</li>
</ol>
<p><strong>再来看JDK1.8</strong><br>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash 值；</li>
<li>判断是否需要进行初始化；</li>
<li>定位到 Node，拿到首节点 f，判断首节点 f：<ul>
<li>如果为  null  ，则通过 CAS 的方式尝试添加；</li>
<li>如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；</li>
<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</li>
</ul>
</li>
<li>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</li>
</ol>
<p><strong>ConcurrentHashMap  的 get 方法执行逻辑是什么？★★★★</strong><br>同样，<strong>先来看JDK1.7</strong></p>
<ul>
<li>首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</li>
<li>由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</li>
</ul>
<p><strong>再来看JDK1.8</strong><br>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash 值，判断数组是否为空；</li>
<li>如果是首节点，就直接返回；</li>
<li>如果是红黑树结构，就从红黑树里面查询；</li>
<li>如果是链表结构，循环遍历判断。</li>
</ol>
<p>ConcurrentHashMap 的 get 方法是否要加锁，为什么？★★★<br>get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。<br>这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993410742-67955f27-1143-47ff-8e14-f528dde9421b.png#averageHue=%2316191b&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u48f27f38&amp;margin=%5Bobject%20Object%5D&amp;originHeight=406&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8ea04b91-88d7-4b09-9278-5efeb66f8ad&amp;title=" alt=""><br>get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗？★★★<br>没有关系。哈希桶数组table用 volatile 修饰主要是保证在数组扩容的时候保证可见性。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993410703-7c611e85-dc8a-4d40-abc8-7c3aaee24792.png#averageHue=%2316191a&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud7ef757a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=218&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2e9a86e4-eb90-42b0-adfa-a44a187d81d&amp;title=" alt=""></p>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h4><h5 id="ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？★★★"><a href="#ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？★★★" class="headerlink" title="ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？★★★"></a>ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？★★★</h5><p>我们先来说value 为什么不能为 null。</p>
<ul>
<li>因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</li>
</ul>
<p>而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。</p>
<blockquote>
<p>我们用<strong>反证法</strong>来推理：<br>假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用ConcurrentHashMap.get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。<br>假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 ConcurrentHashMap.containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回 false 。<br>但是在我们调用 ConcurrentHashMap.get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap.put(key, null)的操作。那么我们调用containsKey方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。<br>至于 ConcurrentHashMap 中的 key 为什么也不能为 null 的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的 key 存在。想要深入了解的小伙伴，可以看这篇文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&amp;mid=2247484354&amp;idx=1&amp;sn=80c92881b47a586eba9c633eb78d36f6&amp;chksm=9796d5bfa0e15ca9713ff9dc6e100593e0ef06ed7ea2f60cb984e492c4ed438d2405fbb2c4ff&amp;scene=21#wechat_redirect">这道面试题我真不知道面试官想要的回答是什么</a></p>
</blockquote>
<h5 id="ConcurrentHashMap-的并发度是什么？★★"><a href="#ConcurrentHashMap-的并发度是什么？★★" class="headerlink" title="ConcurrentHashMap 的并发度是什么？★★"></a>ConcurrentHashMap 的并发度是什么？★★</h5><p>并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。</p>
<ul>
<li>在JDK1.7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数中设置。</li>
<li>如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</li>
<li>如果并发度设置的过小，会带来严重的锁竞争问题；</li>
<li>如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</li>
</ul>
<p>在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。</p>
<h5 id="ConcurrentHashMap-迭代器是强一致性还是弱一致性？★★"><a href="#ConcurrentHashMap-迭代器是强一致性还是弱一致性？★★" class="headerlink" title="ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★"></a>ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★</h5><p>与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。<br>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。<br>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章：<a target="_blank" rel="noopener" href="http://ifeve.com/ConcurrentHashMap-weakly-consistent/">http://ifeve.com/ConcurrentHashMap-weakly-consistent/</a></p>
<h5 id="JDK1-7-与-JDK1-8-中ConcurrentHashMap-的区别？★★★★★"><a href="#JDK1-7-与-JDK1-8-中ConcurrentHashMap-的区别？★★★★★" class="headerlink" title="JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★"></a>JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★</h5><ul>
<li>数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li>
<li>保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用CAS+synchronized保证线程安全。</li>
<li>锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。</li>
<li>链表转化为红黑树：因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。</li>
<li><p>查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。</p>
<h5 id="ConcurrentHashMap-和-Hashtable-的效率哪个更高？为什么？★★★★★"><a href="#ConcurrentHashMap-和-Hashtable-的效率哪个更高？为什么？★★★★★" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★"></a>ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★</h5><p>ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable 给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在 JDK1.8 中采用CAS+synchronized实现线程安全。</p>
<h5 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h5><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。<h5 id="具体说一下Hashtable的锁机制-★★★★★"><a href="#具体说一下Hashtable的锁机制-★★★★★" class="headerlink" title="具体说一下Hashtable的锁机制 ★★★★★"></a>具体说一下Hashtable的锁机制 ★★★★★</h5>Hashtable 是使用 synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993757033-5d17fd53-88b3-494a-949d-4bb5227dafbd.png#averageHue=%23fcf8ec&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=402&amp;id=u1b11a02a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=592&amp;originWidth=821&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae8a26a0-ccb0-475b-a518-3e3c5ab299e&amp;title=&amp;width=558.0000610351562" alt=""><br><strong>多线程下安全的操作 map还有其他方法吗？★★★</strong><br>还可以使用Collections.synchronizedMap方法，对方法进行加同步锁。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658993756936-6df9d3ba-b619-4015-aa1c-7b2cb61095d1.png#averageHue=%23161a1b&amp;clientId=ua09ed129-6bab-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue8e900cd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=635&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub13d3e54-8445-47fc-a02e-753c9293ad7&amp;title=" alt=""><br>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/09/java/Java%E5%AE%B9%E5%99%A8/">http://example.com/2022/08/09/java/Java%E5%AE%B9%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Ⅰ集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">①Java 集合概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%AF%B4%E8%AF%B4-List-Set-Queue-Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">②说说 List, Set, Queue, Map 四者的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">③集合框架底层数据结构总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">1.3.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">1.3.2.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-number">1.3.3.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">1.3.4.</span> <span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.4.</span> <span class="toc-text">④如何选用集合?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">⑤为什么要使用集合？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-List"><span class="toc-number">2.</span> <span class="toc-text">ⅡCollection 子接口之 List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Arraylist-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">①Arraylist 和 Vector 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%8A%E2%91%A1Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">✊②Arraylist 与 LinkedList 区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%8A%E2%91%A2ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-%E4%BB%A5jdk1-7%E4%B8%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">✊③ArrayList 的扩容机制 以jdk1.7为例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3CopyOnWriteArrayList"><span class="toc-number">2.3.1.</span> <span class="toc-text">④CopyOnWriteArrayList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A2Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-Set"><span class="toc-number">3.</span> <span class="toc-text">ⅢCollection 子接口之 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">①comparable 和 Comparator 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">②无序性和不可重复性的含义是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.3.</span> <span class="toc-text">③比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A3Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-Queue"><span class="toc-number">4.</span> <span class="toc-text">ⅣCollection 子接口之 Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-%E4%B8%8E-Deque-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">Queue 与 Deque 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%8A%E8%AE%B2%E4%B8%80%E4%B8%8BArrayDeque%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">✊讲一下ArrayDeque？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">ArrayDeque 与 LinkedList 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-PriorityQueue"><span class="toc-number">4.4.</span> <span class="toc-text">说一说 PriorityQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">什么是fail fast？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-safe%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">什么是fail safe？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">线程安全的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A4Map-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">ⅤMap 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0HashMap%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">①HashMap基础面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.1.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8C-HashSet-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.2.</span> <span class="toc-text">HashMap 和 HashSet 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8C-TreeMap-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.3.</span> <span class="toc-text">HashMap 和 TreeMap 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="toc-number">6.1.4.</span> <span class="toc-text">HashSet 如何检查重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="toc-number">6.1.5.</span> <span class="toc-text">解决hash冲突的办法有哪些？HashMap用的哪种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84key"><span class="toc-number">6.1.6.</span> <span class="toc-text">一般用什么作为HashMap的key?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1HashMap%E6%B7%B1%E5%85%A5"><span class="toc-number">6.2.</span> <span class="toc-text">②HashMap深入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">字段结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.索引计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-put%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">3.put方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">JDK1.8的优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">6.2.4.</span> <span class="toc-text">5.HashMap为什么线程不安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash"><span class="toc-number">6.2.5.</span> <span class="toc-text">并发下的Rehash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2ConcurrentHashMap"><span class="toc-number">6.3.</span> <span class="toc-text">③ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%8F%96"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B6%E4%BB%96"><span class="toc-number">6.3.3.</span> <span class="toc-text">3. 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E4%B8%8D%E6%94%AF%E6%8C%81-key-%E6%88%96%E8%80%85-value-%E4%B8%BA-null-%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？★★★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%98%85%E2%98%85"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">ConcurrentHashMap 的并发度是什么？★★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E8%BF%98%E6%98%AF%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%E2%98%85%E2%98%85"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-7-%E4%B8%8E-JDK1-8-%E4%B8%ADConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E6%95%88%E7%8E%87%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%AB%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">6.3.3.5.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.3.6.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%80%E4%B8%8BHashtable%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">6.3.3.7.</span> <span class="toc-text">具体说一下Hashtable的锁机制 ★★★★★</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.4.</span> <span class="toc-text"> </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">7.</span> <span class="toc-text"> </span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/cover/cover/" title="翻唱"><img src="/1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻唱"/></a><div class="content"><a class="title" href="/2022/08/09/cover/cover/" title="翻唱">翻唱</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><script async src="//at.alicdn.com/t/c/xxx.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 MySQL (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 redis (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 计算机网络 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>