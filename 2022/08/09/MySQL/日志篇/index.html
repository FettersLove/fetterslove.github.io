<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>日志篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="日志篇">
<meta property="og:type" content="article">
<meta property="og:title" content="日志篇">
<meta property="og:url" content="http://example.com/2022/08/09/MySQL/%E6%97%A5%E5%BF%97%E7%AF%87/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="日志篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:24:55.091Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/09/MySQL/%E6%97%A5%E5%BF%97%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '日志篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-13 22:24:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">日志篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:24:55.091Z" title="更新于 2022-11-13 22:24:55">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="日志篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651563738807-6d5e65e4-066b-49f9-bf88-5279538637ef.png#averageHue=%23faf8f7&amp;clientId=u032535be-8a03-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u12fb5d46&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=905&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=42714&amp;status=done&amp;style=none&amp;taskId=u81b8eec0-1a1c-47c3-b3a2-fe5b9e3a462&amp;title=&amp;width=724" alt="image.png"><br>知识点总结：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48825548/article/details/120482321?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_48825548/article/details/120482321?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>
<h2 id="前置：Buffer-Pool"><a href="#前置：Buffer-Pool" class="headerlink" title="前置：Buffer Pool"></a>前置：Buffer Pool</h2><p>MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？<br>当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。<br>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659857613445-aa851468-e696-42bd-9ddd-58fba3cd1927.png#averageHue=%23f2ecd8&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=397&amp;id=u5f78f913&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=969&amp;originWidth=725&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=171411&amp;status=done&amp;style=none&amp;taskId=uee5c74a0-e237-405b-9efd-8de23de0658&amp;title=&amp;width=297.2857360839844" alt="image.png"><br>有了 Buffer Pool后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。<h3 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h3>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</li>
</ul>
<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659857613372-45f0d712-4d9d-4a3a-9e05-372422b1b166.png#averageHue=%23f9ebd8&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=265&amp;id=ud9290bfc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=377&amp;originWidth=812&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=90462&amp;status=done&amp;style=none&amp;taskId=uaaea2cac-dd2d-45fd-9c34-9c7207698a3&amp;title=&amp;width=570.2857666015625" alt="image.png"><br>Undo 页是记录什么？<br>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。<br>查询一条记录，就只需要缓冲一条记录吗？<br>不是的。<br>当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。<br>关于页结构长什么样和索引怎么查询数据的问题可以在这篇找到答案：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw">换一个角度看 B+ 树</a></p>
<h2 id="ⅠUndo日志"><a href="#ⅠUndo日志" class="headerlink" title="ⅠUndo日志"></a>ⅠUndo日志</h2><h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><p>回滚日志，<strong>它保证了事务的 </strong><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">ACID 特性(opens new window)</a><strong>中的原子性（Atomicity）</strong>。</p>
<p>undo log 是一种用于回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。<br>例子&gt; 如下图：</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659857069711-b82ddb28-3530-4632-9a22-026f97e5f531.png#averageHue=%23f8f5ee&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=399&amp;id=EkAtA&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=571&amp;originWidth=352&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75036&amp;status=done&amp;style=none&amp;taskId=u8bed7387-6bf6-4263-b41d-7ca5a6ead09&amp;title=&amp;width=246.00003051757812" alt="image.png"><br>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p>
<p>不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的，具体的每一个操作的 undo log 的格式我就不详细介绍了，感兴趣的可以自己去查查。</p>
</blockquote>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer（回滚） 指针和一个 trx_id 事务id：</p>
<ul>
<li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li>
<li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li>
</ul>
<p>版本链如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659857069785-624456fc-32a7-4164-a7fa-31153d4a4adb.png#averageHue=%23f0ece0&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=240&amp;id=uf998e830&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=457&amp;originWidth=1063&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=166982&amp;status=done&amp;style=none&amp;taskId=ua1330b17-5dea-43e4-a6bd-b72fca2c1e9&amp;title=&amp;width=559.2857666015625" alt="image.png"><br>另外，<strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。<br>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li>
<li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li>
</ul>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<h3 id="②undo-log作用"><a href="#②undo-log作用" class="headerlink" title="②undo log作用"></a>②undo log作用</h3><ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。<br>undo的存储结构（了解）<strong>1. 回滚段与undo页</strong><br>InnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment）。每个回滚段记录了1024 个undo log segment ，而在每个undo log segment段中进行undo页的申请。<br>在InnoDB1.1版本之前（不包括1.1版本），只有一个rollback  segment，因此支持同时在线的事务限制为1024 。虽然对绝大多数的应用来说都已经够用。<br>从1.1版本开始InnoDB支持最大128个rollback segment ，故其支持同时在线的事务限制提高到128<em>1024<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858140470-94a3db7f-9f2b-4fa0-b2e0-a0e417311f0d.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=118&amp;id=YsJC8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=147&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7317&amp;status=done&amp;style=none&amp;taskId=u6d8f0204-bc53-4592-9484-bda16a91c74&amp;title=&amp;width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858155916-44c3bed0-e942-4d62-917b-01d353748617.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=whIt5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=283&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=862093&amp;status=done&amp;style=none&amp;taskId=u65e9b525-a593-493c-89af-c097c4bf463&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858167062-986c2111-43f2-431f-8294-182bd090fa5f.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=224&amp;id=j7Ion&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=280&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=852946&amp;status=done&amp;style=none&amp;taskId=u3e89c6ab-86dc-4df9-bb25-f2b50c4330a&amp;title=&amp;width=608" alt="image.png"><br>生命周期<strong>1. 详细生成过程</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858737869-d00e09cf-b330-4b8a-8c19-1b6d5a64b5f5.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=147&amp;id=cAb77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=184&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=560545&amp;status=done&amp;style=none&amp;taskId=u4ad52361-fdd5-4f1e-ba8b-7221b629cc7&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858741962-5e6baa9c-cfb4-4e42-ad66-109d3dc34b5b.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=51&amp;id=pYDsp&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=64&amp;originWidth=599&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=153749&amp;status=done&amp;style=none&amp;taskId=ue1ac73f3-59fc-453a-8f8b-157fbc4c7e5&amp;title=&amp;width=479.2" alt="image.png"><br><strong>当我们执行INSERT时：</strong><br><strong> </strong><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858763960-c5eaae59-9147-45d2-8730-fcbe0eb6e40c.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=50&amp;id=fLNKU&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=62&amp;originWidth=728&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3714&amp;status=done&amp;style=none&amp;taskId=u9359d936-2fb2-4e27-b6d8-bc13d29a9de&amp;title=&amp;width=582.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858770181-1d6f6994-7bfc-420d-a8d0-774197c99893.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=53&amp;id=iDxNS&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=66&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=201129&amp;status=done&amp;style=none&amp;taskId=u2afe3b09-ed7b-444e-bb09-d9850981092&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858779416-e419b189-466d-42d1-a540-6a25371730c3.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=b0MX6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=238&amp;originWidth=514&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=490449&amp;status=done&amp;style=none&amp;taskId=ub7f9f694-4682-452d-8777-3bac1cd4d3a&amp;title=&amp;width=411.2" alt="image.png"><br><em>*当我们执行UPDATE时：</em></em></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858791093-3d214ad4-e5aa-4414-a05b-e4dea26173b7.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=77&amp;id=iiPBw&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=96&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=292501&amp;status=done&amp;style=none&amp;taskId=uaa166b50-2ab5-4c7e-af01-5d7d9ceca5b&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858798776-20fb5d6d-76d1-4ed4-9663-c3add5724e66.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=iyOmj&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=545&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=528755&amp;status=done&amp;style=none&amp;taskId=u11b3c917-3666-4d01-8c21-1aef98c3649&amp;title=&amp;width=436" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858811273-c726172f-f6bb-4e56-b8ca-a1a9fd1c27cb.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=64&amp;id=W6rtq&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=80&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=243768&amp;status=done&amp;style=none&amp;taskId=u05dd0589-e0c6-481e-935c-5d742510cea&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858818285-5e2e847b-9820-432c-88a3-befa959bffcc.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=45&amp;id=zz1cM&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=56&amp;originWidth=803&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2657&amp;status=done&amp;style=none&amp;taskId=ud11599be-8a4e-4188-a623-460841e5354&amp;title=&amp;width=642.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858822514-620e5377-dbd6-4885-98a4-61ca76627c28.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=157&amp;id=vUXpm&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=162&amp;originWidth=659&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=427983&amp;status=done&amp;style=none&amp;taskId=u61a426be-e9ae-4327-96bb-13ea7e52c99&amp;title=&amp;width=640.2000122070312" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858827726-fa73b091-7933-41e6-aa4c-2ddae49347f4.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=114&amp;id=Dj2ts&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=142&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=432611&amp;status=done&amp;style=none&amp;taskId=ub0e122be-e483-4763-9055-b00015efa7d&amp;title=&amp;width=608" alt="image.png"><br><strong>1. undo log是如何回滚的</strong><br>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ol>
<li>通过undo no=3的日志把id=2的数据删除</li>
<li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li>
<li>通过undo no=1的日志把id=1的数据的name还原成Tom</li>
<li>通过undo no=0的日志把id=1的数据删除</li>
</ol>
<p><strong>2. undo log的删除</strong><br>针对于insert undo log<br>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo   log可以在事务提交后直接删除，不需要进行purge操作。<br>针对于update undo log<br>该undo  log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo  log链表，等待purge线程进行最后的删除。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858865583-4e8b576f-d2b9-4d4f-9ecd-f4b5e65e590f.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=102&amp;id=qakMQ&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=128&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=389972&amp;status=done&amp;style=none&amp;taskId=u35add451-3d54-47ae-8dc9-779dc30e160&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649858897511-8accdf3a-93aa-45fd-be10-20d1811dd85e.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=VPzxE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=344&amp;originWidth=746&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1028600&amp;status=done&amp;style=none&amp;taskId=u6a9d9827-3827-42a4-94ff-b5c05d18a64&amp;title=&amp;width=596.8" alt="image.png"></p>
<h2 id="Ⅱredolog"><a href="#Ⅱredolog" class="headerlink" title="Ⅱredolog"></a>Ⅱredolog</h2><h3 id="①为什么需要redolog"><a href="#①为什么需要redolog" class="headerlink" title="①为什么需要redolog"></a>①为什么需要redolog</h3><blockquote>
<p>Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
</blockquote>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>，<strong>指的是 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上</strong>。<br>InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging），这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo-log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证事务的持久性，这就是redo-log的作用。<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649856830295-43484947-5df3-4365-9395-d85394f4a2e8.png#averageHue=%23f0eae9&amp;clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=xywNs&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=296&amp;originWidth=628&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=745143&amp;status=done&amp;style=none&amp;taskId=ud69aa798-2e1d-4871-9c12-98d29ab636d&amp;title=&amp;width=502.4" alt="image.png"><br>好处是不用每一次操作都实时把数据写盘，就算 crash 后也可以通过redo log 恢复，所以能够实现快速响应 SQL 语句。<br>过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659858394287-14b62058-d704-400f-9a06-69c02908fb9c.png#averageHue=%23f9f4ed&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=265&amp;id=ue54233d0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=651&amp;originWidth=861&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=144244&amp;status=done&amp;style=none&amp;taskId=uc356d1a5-5b5f-439e-bb9a-dde20f814d3&amp;title=&amp;width=350.0000305175781" alt="image.png"><br>什么是WAL(write-ahead log)机制, 好处是什么.&gt; WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写小黑板，等不忙的时候再写账本。</p>
<blockquote>
<p>  具体来说，当有一条update语句要执行的时候，InnoDB 引擎就会先把记录写到 redo log（小黑板）里面，并更新内存，这个时候更新就算完成了。<br>  同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。<br>  与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 100MB，那么这块“小黑板”总共就可以记录 400MB 的操作记录。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651564020508-15cd69d0-28e5-4e3f-8cbe-d6d90cc509d8.png#averageHue=%23c6e2a5&amp;clientId=u032535be-8a03-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=367&amp;id=AOd8D&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=439&amp;originWidth=500&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=144787&amp;status=done&amp;style=none&amp;taskId=u5ac55230-c8cb-4e0c-9b87-c2e585fe62a&amp;title=&amp;width=418" alt="image.png"></p>
<p>write position 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<br>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。<br>  write position 和 checkpoint 之间的是“小黑板”上还空着的部分，可以用来记录新的操作。</p>
<p>  如果 write pos 追上 checkpoint，表示“小黑板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>  有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p>
<p>crash-safe：<br>  可以对照前面赊账记录的例子。只要赊账记录记在了小黑板上或写在了账本上，即使秀才突然被老邢抓走几天，回来后依然可以通过账本和小黑板上的数据明确赊账账目。就是维护数据的持久性。<br>  本质上说，crash-safe 就是落盘处理，将数据存储到了磁盘上，断电重启也不会丢失。</p>
</blockquote>
<h3 id="②什么是redolog"><a href="#②什么是redolog" class="headerlink" title="②什么是redolog"></a>②什么是redolog</h3><p>redo log 是物理日志，记录了某个数据页做了什么修改，对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<h3 id="③redolog常见问题"><a href="#③redolog常见问题" class="headerlink" title="③redolog常见问题"></a>③redolog常见问题</h3><h4 id="1-被修改-Undo-页面，需要记录对应-redo-log-吗？"><a href="#1-被修改-Undo-页面，需要记录对应-redo-log-吗？" class="headerlink" title="1. 被修改 Undo 页面，需要记录对应 redo log 吗？"></a>1. 被修改 Undo 页面，需要记录对应 redo log 吗？</h4><p>需要的。<br>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p>
<p>不过，在修改该 Undo 页面前需要先记录对应的 redo log，所以<strong>先记录修改 Undo 页面的 redo log ，然后再真正的修改 Undo 页面</strong>。</p>
<h4 id="2-redo-log-和-undo-log-区别在哪？"><a href="#2-redo-log-和-undo-log-区别在哪？" class="headerlink" title="2. redo log 和 undo log 区别在哪？"></a>2. redo log 和 undo log 区别在哪？</h4><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659857870482-21326374-ed3e-4a8a-8648-59bb35a79007.png#averageHue=%23faf8f3&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=292&amp;id=u66f7c5e8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=601&amp;originWidth=551&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=102603&amp;status=done&amp;style=none&amp;taskId=ud34363af-7362-4c09-9605-c1ee41f2a01&amp;title=&amp;width=268.0000305175781" alt="image.png"><br>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p>
<h4 id="3-redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><a href="#3-redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？" class="headerlink" title="3. redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？"></a>3. redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</h4><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p>
<p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p>
<p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p>
<p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。<h4 id="4-产生的-redo-log-是直接写入磁盘的吗？"><a href="#4-产生的-redo-log-是直接写入磁盘的吗？" class="headerlink" title="4.产生的 redo log 是直接写入磁盘的吗？"></a>4.产生的 redo log 是直接写入磁盘的吗？</h4>不是的。</li>
</ul>
<p>实际上， 执行一个事务，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/21371548/1659857870320-72addf50-d122-4e58-aabb-5538cd586495.webp#averageHue=%23f1efec&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=438&amp;id=ud8903d32&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1344&amp;originWidth=1398&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8e8a7244-b3d7-4e8a-bb29-2059ae47c6a&amp;title=&amp;width=456" alt=""><br>redo log buffer 默认大小 16 MB，可以通过 innodb_log_Buffer_size 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。</p>
<h3 id="④redo-log-什么时候刷盘？"><a href="#④redo-log-什么时候刷盘？" class="headerlink" title="④redo log 什么时候刷盘？"></a>④redo log 什么时候刷盘？</h3><p>缓存在 redo log buffer里的 redo log 还是在内存中，它什么时候刷新到磁盘？<br>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li>
</ul>
<p>innodb_flush_log_at_trx_commit 参数控制的是什么？<br>单独执行一个更新语句的时候，InnoDB 引擎会自己启动一个事务，在执行更新语句的过程中，生成的 redo log 先写入到 redo log buffer 中，然后等事务提交的时候，再将缓存在 redo log buffer 中的 redo log 按组的方式「顺序写」到磁盘。</p>
<p>上面这种 redo log 刷盘时机是在事务提交的时候，这个默认的行为。</p>
<p>除此之外，InnoDB 还提供了另外两种策略，由参数 innodb_flush_log_at_trx_commit 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p>
<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇(opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
<p>我画了一个图，方便大家理解：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659858237108-c78bfb1c-c50b-4df3-9121-597e32d0962b.png#averageHue=%23f1ead2&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=378&amp;id=u30f29724&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=863&amp;originWidth=951&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=306758&amp;status=done&amp;style=none&amp;taskId=u8b107198-42d9-4fb9-8ef1-1dc30d93683&amp;title=&amp;width=417" alt="image.png"><br>innodb_flush_log_at_trx_commit 为 0 和 2 的时候，什么时候才将 redo log 写入磁盘？<br>InnoDB 的后台线程每隔 1 秒：</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 write() 写到操作系统的 Page Cache，然后调用 fsync() 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li>
</ul>
<p>加入了后台现线程后，innodb_flush_log_at_trx_commit 的刷盘时机如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659858237358-74ced6da-cb44-4bd6-b665-a8d418e7b8fb.png#averageHue=%23f1edd6&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u23420b52&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=863&amp;originWidth=1061&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=416656&amp;status=done&amp;style=none&amp;taskId=ua9db0672-e498-4b5a-94b2-965926e6db6&amp;title=" alt="image.png"><br>这三个参数的应用场景是什么？<br>这三个参数的数据安全性和写入性能的比较如下：</p>
<ul>
<li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li>
<li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li>
</ul>
<p>所以，数据安全性和写入性能是熊掌不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p>
<ul>
<li>在一些对数据安全性要求比较高的场景中，显然 innodb_flush_log_at_trx_commit 参数需要设置为 1。</li>
<li>在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0，这样可以明显地减少日志同步到磁盘的 I/O 操作。</li>
<li>安全性和性能折中的方案就是参数 2，虽然参数 2 没有参数 0 的性能高，但是数据安全性方面比参数 0 强，因为参数 2 只要操作系统不宕机，即使数据库崩溃了，也不会丢失数据，同时性能方便比参数 1 高。<h3 id="⑤redo-log-文件写满了怎么办？"><a href="#⑤redo-log-文件写满了怎么办？" class="headerlink" title="⑤redo log 文件写满了怎么办？"></a>⑤redo log 文件写满了怎么办？</h3>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：ib_logfile0 和 ib_logfile1 。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659858236926-b31fb933-c7eb-4c5d-8f07-0e5a31eb52b3.png#averageHue=%23efefef&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u59b3cf1f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=101&amp;originWidth=350&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11710&amp;status=done&amp;style=none&amp;taskId=u8b0bd2e0-613e-478d-87e6-4648e7379c9&amp;title=" alt="image.png"><br>在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</li>
</ul>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。<br>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659858236953-71ed1e48-3f59-4339-8d34-d920412a8c75.png#averageHue=%23f6f3e9&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u76dc8a97&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=261&amp;originWidth=441&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36916&amp;status=done&amp;style=none&amp;taskId=u82273e2c-38c5-48f2-bf00-72f5b77cd77&amp;title=&amp;width=376.0000305175781" alt="image.png"><br>我们知道 redo log 是为了防止Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。</p>
<p>redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659858237349-b9540ba9-61bf-417d-a7bd-2e57191122ac.png#averageHue=%23efe8e8&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=ueae49ccc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=906&amp;originWidth=1362&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=382902&amp;status=done&amp;style=none&amp;taskId=u03ef2bcc-e51e-4b10-a2aa-bbe488243a4&amp;title=&amp;width=409.00006103515625" alt="image.png"><br>图中的：</p>
<ul>
<li>write pos 和 checkpoint 的移动都是顺时针方向；</li>
<li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。<br>所以，一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p>
<h3 id="⑥REDO日志的好处、特点"><a href="#⑥REDO日志的好处、特点" class="headerlink" title="⑥REDO日志的好处、特点"></a>⑥REDO日志的好处、特点</h3><p><strong>1. 好处</strong><br><strong>redo日志降低了刷盘频率</strong><br><strong>redo日志占用的空间非常小</strong><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649856862466-b297deb7-8eb0-4e96-87f6-32567718b0f7.png#averageHue=%23e9e9e6&amp;clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=39&amp;id=fLnyE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=49&amp;originWidth=801&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34384&amp;status=done&amp;style=none&amp;taskId=u58ff35fd-24f3-4ed0-8fa7-e76819241ca&amp;title=&amp;width=640.8" alt="image.png"><br><strong>2. 特点</strong><br><strong>redo日志是顺序写入磁盘的</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649856923077-628dbcd7-a008-4570-bcf4-9040b5de35c4.png#averageHue=%23f3efea&amp;clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=46&amp;id=VQhWU&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=58&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=176760&amp;status=done&amp;style=none&amp;taskId=u2119e165-f378-4ee4-9ddb-056c9a411c6&amp;title=&amp;width=608" alt="image.png"><br><strong>事务执行过程中，redo log不断记录</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649856930279-15f67492-43f1-4c9f-abd4-5f425b11e7d6.png#averageHue=%23f4f1eb&amp;clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=59&amp;id=CmyrA&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=74&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=225493&amp;status=done&amp;style=none&amp;taskId=u218530bd-d5c5-44eb-87ef-a7961b3b2e3&amp;title=&amp;width=608" alt="image.png"><br>redo log 为什么可以保证crash safe机制，那binlog可以做crash safe吗.先介绍下 crash safe的基本概念<br>它是指MySQL服务器宕机重启后，能够保证：</p>
<ul>
<li>所有已经提交的事务的数据仍然存在。</li>
<li>所有没有提交的事务的数据自动回滚。</li>
</ul>
<p><strong>redo log 是什么？</strong><br>一个固定大小，“循环写”的日志文件，记录的是物理日志——“在某个数据页上做了某个修改”。<br><strong>binlog 是什么？</strong><br>一个无限大小，“追加写”的日志文件，记录的是逻辑日志——“给 ID=2 这一行的 c 字段加1”。</p>
<p>第一点：redo log 可确保 innoDB 判断哪些数据已经刷盘，哪些数据还没有</p>
<ul>
<li>redo log和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。</li>
<li>当数据库 crash 后，想要恢复未刷盘但已经写入 redo log 和 binlog的数据到内存时，binlog是无法恢复的。虽然 binlog拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。</li>
</ul>
<p>举个栗子，binlog 记录了两条日志：</p>
<p>给 ID=2 这一行的 c 字段加1<br>给 ID=2 这一行的 c 字段加1<br>在记录1刷盘后，记录2未刷盘时，数据库 crash。重启后，只通过binlog数据库无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 ID=2 这行数据来说，都不对。<br>但 redo log 不一样，只要刷入磁盘的数据，都会从redo log中抹掉，数据库重启后，直接把 redo log中的数据都恢复至内存就可以了。这就是为什么 redo log具有 crash-safe 的能力，而 binlog不具备。<br>第二点：如果 redo log 写入失败，说明此次操作失败，事务也不可能提交</p>
<ul>
<li>redo log 每次更新操作完成后，就一定会写入日志，如果<strong>写入失败</strong>，说明此次操作失败，事务也不可能提交。</li>
<li>redo log 内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放，就可以恢复数据。</li>
<li><p>这就是为什么 redo log 具有 crash-safe 的能力，而 binlog 不具备。<br>redo的组成Redo log可以简单分为以下两个部分：<br>重做日志的缓冲(redo log buffer) ，保存在内存中，是易失的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857018763-33ec717c-6f0a-4d89-ba31-4e2851dce9fe.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=50&amp;id=K6LNK&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=63&amp;originWidth=759&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=191737&amp;status=done&amp;style=none&amp;taskId=uc4dcc9ee-6979-43ec-a907-b294bc8bc84&amp;title=&amp;width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857023664-ca743e0c-fa8e-4dab-bde0-ae529dff3c50.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=fx6R6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=276&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=840770&amp;status=done&amp;style=none&amp;taskId=ue882445d-d87a-4e3b-88a4-c04502eeb2d&amp;title=&amp;width=608" alt="image.png"><br><strong>参数设置：innodb_log_buffer_size：</strong><br>redo log buffer 大小，默认16M ，最大值是4096M，最小值为1M。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857072215-edb58770-8299-41e8-bf1d-08b8a3fbe37c.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=134&amp;id=cBOel&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=167&amp;originWidth=805&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8137&amp;status=done&amp;style=none&amp;taskId=u5856f0d4-5d90-4cad-bcd1-8d630d628b1&amp;title=&amp;width=644" alt="image.png"><br>重做日志文件(redo log file) ，保存在硬盘中，是持久的。</p>
<h3 id="redo-log日志格式"><a href="#redo-log日志格式" class="headerlink" title="redo log日志格式"></a>redo log日志格式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652174395109-03215e80-92ea-4423-ab8d-497185c09bd1.png#clientId=uc6d7e8c9-8aaf-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=411&amp;id=kXQDM&amp;margin=%5Bobject%20Object%5D&amp;originHeight=810&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue9347261-d52e-4f32-b9cd-a5ea8404499&amp;title=&amp;width=548" alt=""><br>redo log buffer (内存中)是由首尾相连的四个文件组成的，它们分别是：ib_logfile_1、ib_logfile_2、ib_logfile_3、ib_logfile_4。</p>
</li>
<li><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。</p>
</li>
<li>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</li>
<li>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。</li>
<li>如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</li>
<li>有了 redo log，当数据库发生宕机重启后，可通过 redo log将未落盘的数据（check point之后的数据）恢复，保证已经提交的事务记录不会丢失，这种能力称为<strong>crash-safe</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857832925-49d1c430-7169-4f57-a172-34ead4932378.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=158&amp;id=qBxgd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=198&amp;originWidth=759&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=602397&amp;status=done&amp;style=none&amp;taskId=u0cee4032-7319-46af-aa4c-b3435fe1ee8&amp;title=&amp;width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857840051-0192eae0-74f7-4c0b-8141-c7fff718797e.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=PqdPK&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=467&amp;originWidth=266&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=498255&amp;status=done&amp;style=none&amp;taskId=ue66b7dd4-c98c-4b47-aefa-ffce8049619&amp;title=&amp;width=212.8" alt="image.png"><br>如果write pos 追上checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的redo log记录，MySQL 得停下来，清空一些记录，把checkpoint 推进一下。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857852852-5ffc0329-d7f0-43ff-bddd-b39e48e09b77.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=297&amp;id=Tah4d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=371&amp;originWidth=422&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=627726&amp;status=done&amp;style=none&amp;taskId=ue806e8bb-47a4-4967-ba78-d8240f1399f&amp;title=&amp;width=337.6" alt="image.png"><br>redo的整体流程以一个更新事务为例，redo log 流转过程，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857124788-1d1c7143-f3d9-4da4-a3d2-9f95d9124b06.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=196&amp;id=VD1NF&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=245&amp;originWidth=742&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=728676&amp;status=done&amp;style=none&amp;taskId=u0d166957-16de-424c-a790-ee8de4f22fc&amp;title=&amp;width=593.6" alt="image.png"><br>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入<strong>redo log buffer</strong>，记录的是数据被修改后的值<br>第3步：当事务commit时，将redo log buffer中的内容刷新到redo log file，对redo log file采用追加写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857177219-03baf226-014c-42ee-8b9c-850cbfde567d.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=78&amp;id=P2Gqe&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=803&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6815&amp;status=done&amp;style=none&amp;taskId=udafc39ce-5edf-42b4-ba39-d8783969fc3&amp;title=&amp;width=642.4" alt="image.png"><br>redo log的刷盘策略redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以<br>一定的频率刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857214180-3996fa3a-2bd7-4612-8a88-888d47a8382a.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=AqzU2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=635&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=895980&amp;status=done&amp;style=none&amp;taskId=u3d5fe9bd-a13f-4309-8144-468b0c1ec68&amp;title=&amp;width=508" alt="image.png"></p>
<blockquote>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存<br>（page    cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page   cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
</blockquote>
<p>针对这种情况，InnoDB给出innodb_flush_log_at_trx_commit 参数，该参数控制commit提交事务时，如何将redo log buffer 中的日志刷新到redo log file 中。它支持三种策略：<br>设置为0：表示每次事务提交时不进行刷盘操作。（系统默认master  thread每隔1s进行一次重做日志的同步）innobd存储引擎有一个后台线程<br>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（默认值）<br>设置为2 ：表示每次事务提交时都只把redo log buffer 内容写入page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857288357-d5a17573-d4e1-4299-89e9-f20f62922e5f.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=184&amp;id=pnO7D&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=230&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=700655&amp;status=done&amp;style=none&amp;taskId=u557dd7fb-b849-4e67-9dc3-6765f2b66c3&amp;title=&amp;width=608" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857300194-965429aa-52e6-4943-aec6-91edbbacfe1d.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=Q0UUo&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=354&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1078351&amp;status=done&amp;style=none&amp;taskId=u0a3b1ad4-3b55-496a-b424-4c1f0de2f99&amp;title=&amp;width=608" alt="image.png"><br><strong>后台线程！！！！！！！！</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857330133-04cd41b3-d9c0-48d7-9aac-8f571916533c.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=51&amp;id=galFJ&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=64&amp;originWidth=759&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=194774&amp;status=done&amp;style=none&amp;taskId=u6c9f6c52-64ff-4355-82e0-928b8185419&amp;title=&amp;width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857334317-1b7bcb69-6191-43d8-a040-e860e269c520.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=71&amp;id=c6Bl3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=89&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=271190&amp;status=done&amp;style=none&amp;taskId=u65af8ec2-fd03-4105-83bd-c39af7ac407&amp;title=&amp;width=608" alt="image.png"><br>不同刷盘策略演示#### 流程图<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857381036-6d181d9a-145f-43de-9a90-5acef9a9b787.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=495&amp;id=anuEM&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=619&amp;originWidth=847&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77550&amp;status=done&amp;style=none&amp;taskId=u5968c310-5a2b-4cb5-9e99-95b126e3406&amp;title=&amp;width=677.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857458848-71070dda-6d68-429d-b430-6498390e09bf.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=170&amp;id=S7fxv&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=213&amp;originWidth=759&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=648017&amp;status=done&amp;style=none&amp;taskId=u27a116b0-9cdb-4e7f-ba6b-a6413545de5&amp;title=&amp;width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857508244-f3b2a14d-aa27-4663-be36-26ceb7b8216d.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=456&amp;id=bxrcB&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=570&amp;originWidth=736&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1681453&amp;status=done&amp;style=none&amp;taskId=u19a0ddac-b4ef-43ac-9864-2ec8cfd2747&amp;title=&amp;width=588.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857540427-20c9c990-99e2-4304-9f87-133ed0befe1a.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=124&amp;id=Qiw9T&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=155&amp;originWidth=759&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=471594&amp;status=done&amp;style=none&amp;taskId=u3416563b-839c-4c78-a144-6e603d314b7&amp;title=&amp;width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857562774-98259928-f8aa-4a60-928e-e5598b1bf8db.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=456&amp;id=SlIWP&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=570&amp;originWidth=734&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1676893&amp;status=done&amp;style=none&amp;taskId=u60491e40-8389-436a-b86f-6aeaebe65a0&amp;title=&amp;width=587.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857566145-34f94f4a-3bad-4da4-89d0-dac0f9ebfdef.png#clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=130&amp;id=E9kgq&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=163&amp;originWidth=759&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=495926&amp;status=done&amp;style=none&amp;taskId=u3517a214-45ac-446d-911c-148cc869db9&amp;title=&amp;width=607.2" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649857957429-c2468b6a-7b06-49e1-9832-ffd8f45365b4.png#averageHue=%23e7dfc6&amp;clientId=ub50e3b2a-5cc3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=324&amp;id=shxDg&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=405&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1233690&amp;status=done&amp;style=none&amp;taskId=u6edb3d5d-3349-4947-b4d7-efa2435e6fb&amp;title=&amp;width=608" alt="image.png"></p>
<h2 id="Ⅲbinlog"><a href="#Ⅲbinlog" class="headerlink" title="Ⅲbinlog"></a>Ⅲbinlog</h2><p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。<br>为什么有了 binlog， 还要有 redo log？<br>这个问题跟 MySQL 的时间线有关系。</p>
<p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p>
<p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p>
<h3 id="①binlog的概念是什么-起到什么作用"><a href="#①binlog的概念是什么-起到什么作用" class="headerlink" title="①binlog的概念是什么, 起到什么作用?"></a>①binlog的概念是什么, 起到什么作用?</h3><p><strong>概念：</strong></p>
<ul>
<li>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑。记录对MySQL数据库执行修改的所有操作，不会记录select和show语句。可以实现<strong>主从复制</strong>和<strong>数据恢复</strong>两个作用。（在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原）</li>
<li>当需要<strong>恢复数据</strong>时，可以取出某个时间范围内的 binlog 进行重放恢复。</li>
<li>但是 binlog 不可以做 crash safe，因为 crash 之前，binlog <strong>可能没有写入完全</strong> MySQL 就挂了。所以需要配合 <strong>redo log</strong> 才可以进行 crash safe。</li>
</ul>
<h3 id="②binlog-日志的三种格式"><a href="#②binlog-日志的三种格式" class="headerlink" title="②binlog 日志的三种格式"></a>②binlog 日志的三种格式</h3><p>binlog 日志有三种格式</p>
<ul>
<li>Statement：基于SQL语句的复制((statement-based replication,SBR))</li>
<li>Row：基于行的复制。(row-based replication,RBR)</li>
<li>Mixed：混合模式复制。(mixed-based replication,MBR)</li>
</ul>
<p><strong>Statement格式</strong><br>每一条会修改数据的 SQL 都会记录在 binlog 中</p>
<ul>
<li>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</li>
<li>缺点：由于记录的只是执行语句，为了这些语句能在备库上正确运行，还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在备库得到和在主库端执行时候相同的结果。</li>
</ul>
<p><strong>Row格式</strong><br>不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。</p>
<ul>
<li>优点：binlog 中可以不记录执行的 SQL 语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。不会出现某些特定情况下的存储过程、或 function、或trigger的调用和触发无法被正确复制的问题。</li>
<li>缺点:可能会产生大量的日志内容。</li>
</ul>
<p><strong>Mixed格式</strong><br>实际上就是 Statement 与 Row 的结合。一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式。</p>
<h3 id="③redo-log-和-binlog-有什么区别？"><a href="#③redo-log-和-binlog-有什么区别？" class="headerlink" title="③redo log 和 binlog 有什么区别？"></a>③redo log 和 binlog 有什么区别？</h3><p>这两个日志有四个区别。<br><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 Innodb 存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？<br>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。<br>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。<br>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>
<h3 id="④主从复制是怎么实现？"><a href="#④主从复制是怎么实现？" class="headerlink" title="④主从复制是怎么实现？"></a>④主从复制是怎么实现？</h3><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859467091-bb67e3f7-a7e2-4333-ac56-08eda3abd9c5.png#averageHue=%23f5efe3&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u95739a9b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=991&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=141410&amp;status=done&amp;style=none&amp;taskId=ub829d1a6-67d4-461b-83bc-2c01f556c20&amp;title=&amp;width=604.2857666015625" alt="image.png"><br>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ul>
<p>具体详细过程如下：</p>
<ul>
<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859467054-a47073da-3282-45e8-8403-e5f940d5b64f.png#averageHue=%23f8f4f0&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=377&amp;id=uaa48523f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=471&amp;originWidth=451&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65129&amp;status=done&amp;style=none&amp;taskId=uf3ba6c30-907f-4452-b1fd-9ed9061c06b&amp;title=&amp;width=361.0000305175781" alt="image.png"><br>从库是不是越多越好？<br>不是的。</p>
<p>因为从库数量增加，从库连接上来的 I/O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p>
<p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。<br>MySQL 主从复制还有哪些模型？<br>主要有三种：</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。<h3 id="⑤binlog-什么时候刷盘？"><a href="#⑤binlog-什么时候刷盘？" class="headerlink" title="⑤binlog 什么时候刷盘？"></a>⑤binlog 什么时候刷盘？</h3>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</li>
</ul>
<p>MySQL 给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。<br>什么时候 binlog cache 会写到 binlog 文件？<br>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859467097-45bd9af3-a4c0-4627-9bf8-df7eb9348128.png#averageHue=%23f6f3ed&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=u1acb63f8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=461&amp;originWidth=721&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66538&amp;status=done&amp;style=none&amp;taskId=u3ae00ae2-7667-4d3d-bf63-59b1ed42fac&amp;title=&amp;width=413" alt="image.png"><br>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p>
<ul>
<li>图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。</li>
</ul>
<p><strong>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</strong></p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<p>而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p>
<p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="①bin-log和redo-log有什么区别？"><a href="#①bin-log和redo-log有什么区别？" class="headerlink" title="①bin log和redo log有什么区别？"></a>①bin log和redo log有什么区别？</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652169545640-f9493470-8716-4a40-9c4e-391ef55a599e.png#averageHue=%23f3f3f2&amp;clientId=uc6d7e8c9-8aaf-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=405&amp;id=bGCdC&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=605&amp;originWidth=850&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=282472&amp;status=done&amp;style=none&amp;taskId=ud2a8d66a-9fa7-4e64-98e7-98b5b3984f4&amp;title=&amp;width=569" alt="image.png"><br>作用：</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都<br>可以使用。 </li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日<br>志记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指<br>binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
<h3 id="②三个日志讲完了，至此我们可以先小结下，update-语句的执行过程。"><a href="#②三个日志讲完了，至此我们可以先小结下，update-语句的执行过程。" class="headerlink" title="②三个日志讲完了，至此我们可以先小结下，update 语句的执行过程。"></a>②三个日志讲完了，至此我们可以先小结下，update 语句的执行过程。</h3><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。<br>具体更新一条记录 UPDATE t_user SET name = ‘xiaolin’ WHERE id = 1; 的流程如下:</p>
</li>
<li><p>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：</p>
<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在修改该 Undo 页面前需要先记录对应的 redo log，所以<strong>先记录修改 Undo 页面的 redo log ，然后再真正的修改 Undo 页面</strong>。</li>
<li>InnoDB 层开始更新记录，根据 WAL 技术，<strong>先记录修改数据页面的 redo log ，然后再真正的修改数据页面</strong>。修改数据页面的过程是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。<h3 id="②什么是两阶段提交"><a href="#②什么是两阶段提交" class="headerlink" title="②什么是两阶段提交,"></a>②什么是两阶段提交,</h3><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651565431904-2bfddc77-94d4-4078-8c0b-4e526f2c8be9.png#averageHue=%23faf9f7&amp;clientId=u032535be-8a03-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=380&amp;id=F7gNs&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=516&amp;originWidth=729&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=185894&amp;status=done&amp;style=none&amp;taskId=uce59947e-aa27-4fa7-a51a-484c13d9acc&amp;title=&amp;width=536.2857666015625" alt="image.png"><br>从图中可看出，事务的提交过程有两个阶段，就是将redo log的写入拆成了两个步骤：prepare和commit，中间再穿插写入binlog。</li>
</ol>
<p>而两阶段提交就是让这两个状态保持逻辑上的一致。redolog 用于恢复主机故障时的未更新的物理数据，binlog 用于备份操作。两者本身就是两个独立的个体，要想保持一致，就必须使用分布式事务的解决方案来处理。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48825548/article/details/120482321">
</a></p>
<h2 id="Ⅳ-两阶段提交内容"><a href="#Ⅳ-两阶段提交内容" class="headerlink" title="Ⅳ 两阶段提交内容"></a>Ⅳ 两阶段提交内容</h2><h3 id="①为什么需要两阶段提交？"><a href="#①为什么需要两阶段提交？" class="headerlink" title="①为什么需要两阶段提交？"></a>①为什么需要两阶段提交？</h3><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。<br>举个例子，假设 id = 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 UPDATE t_user SET name = ‘xiaolin’ WHERE id = 1; 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p>
<ul>
<li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li>
<li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li>
</ul>
<p>可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。<br><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。<br><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p>
<blockquote>
<p>举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？</p>
<ul>
<li><strong>准备阶段</strong>：裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。</li>
<li><strong>提交阶段</strong>：如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。</li>
</ul>
</blockquote>
<h4 id="两阶段提交的过程是怎样的？"><a href="#两阶段提交的过程是怎样的？" class="headerlink" title="两阶段提交的过程是怎样的？"></a>两阶段提交的过程是怎样的？</h4><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。<br>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859467298-b1173b33-4e0b-4395-a82b-0721459d5bcc.png#averageHue=%23cce78e&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=307&amp;id=u3f09c16d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=842&amp;originWidth=1157&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=202864&amp;status=done&amp;style=none&amp;taskId=u72645a40-8b3d-4f97-9c20-841d2f6e7f5&amp;title=&amp;width=422.2857360839844" alt="image.png"><br>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><p><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件，所以 commit 状态也是会刷盘的）；</p>
<h4 id="异常重启会出现什么现象？"><a href="#异常重启会出现什么现象？" class="headerlink" title="异常重启会出现什么现象？"></a>异常重启会出现什么现象？</h4><p>我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859467329-7042219c-d341-473c-bdf1-d87f4ed7e334.png#averageHue=%23cde58f&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1f5cab82&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=842&amp;originWidth=1175&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=233477&amp;status=done&amp;style=none&amp;taskId=u457fb78b-3eb7-4e8e-8218-84548c9f67c&amp;title=" alt="image.png"><br>不管是时刻 A（已经 redo log，还没写入 binlog），还是时刻 B （已经写入 redo log 和 binlog，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。<br>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p>
</li>
<li><p><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</p>
</li>
<li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li>
</ul>
<p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。<br>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。<br>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?<br>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。<br>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。<br>事务没提交的时候，redo log 会被持久化到磁盘吗？<br>会的。<br>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。<br>也就是说，事务没提交的时候，redo log 也是可能被持久化到磁盘的。<br>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？<br>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。<br>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</p>
<h3 id="②两阶段提交有什么问题？"><a href="#②两阶段提交有什么问题？" class="headerlink" title="②两阶段提交有什么问题？"></a>②两阶段提交有什么问题？</h3><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p>
<ul>
<li><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li>
<li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li>
</ul>
<p>为什么两阶段提交的磁盘 I/O 次数会很高？<br>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：</p>
<ul>
<li>当 sync_binlog = 1 的时候，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；</li>
<li>当 innodb_flush_log_at_trx_commit = 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；</li>
</ul>
<p>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会至少调用 2 次刷盘操作，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。<br>为什么锁竞争激烈？<br>在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。<br>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。</p>
<h4 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h4><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong>，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。<br>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p>
<ul>
<li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li>
<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li>
<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li>
</ul>
<p>上面的<strong>每个阶段都有一个队列</strong>，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859469408-8982f8b1-004f-4d4b-b316-82998d2bbccf.png#averageHue=%2392ac63&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=548&amp;id=ueaff12a9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=828&amp;originWidth=852&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84311&amp;status=done&amp;style=none&amp;taskId=ua42d2578-d699-40b6-8030-603deadd2a4&amp;title=&amp;width=564.2857666015625" alt="image.png"><br>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。<br>有 binlog 组提交，那有 redo log 组提交吗？<br>这个要看 MySQL 版本，MySQL 5.6 没有 redo log 组提交，MySQL 5.7 有 redo log 组提交。<br>在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。<br>所以在 MySQL 5.7 版本中，做了个改进，在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段。<br>这个优化是将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前。通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化。<br>接下来介绍每个阶段的过程，注意下面的过程针对的是“双 1” 配置（sync_binlog 和 innodb_flush_log_at_trx_commit 都配置为 1）。<br>flush 阶段<br>第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower ：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859469829-f5a8dabc-81c6-4d47-9d6c-eeef9c861665.png#averageHue=%23fefefe&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue55014c1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=862&amp;originWidth=1192&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=270808&amp;status=done&amp;style=none&amp;taskId=u04ddc7b7-f539-4f30-be04-9e2dd462369&amp;title=" alt="image.png"><br>接着，获取队列中的事务组，由绿色事务组的 Leader 对 rodo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859469797-019345af-0710-4468-a9a0-5dc564d96a51.png#averageHue=%23fefefb&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u86a91a1b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=494&amp;originWidth=1144&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=186931&amp;status=done&amp;style=none&amp;taskId=u072583e3-cf99-4b79-aae8-307af682502&amp;title=" alt="image.png"><br>完成了 prepare 阶段后，将绿色这一组事务执行过程中产生的 binlog 写入 binlog 文件（调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859469792-c50a96d5-b4d9-4dee-bdf1-336cc5b3e2ae.png#averageHue=%23fefefc&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u443fb310&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=478&amp;originWidth=1392&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=215428&amp;status=done&amp;style=none&amp;taskId=ueb8ae60c-4cf0-4be2-b68c-4c0e359ec61&amp;title=" alt="image.png"><br>从上面这个过程，可以知道 flush 阶段队列的作用是<strong>用于支撑 redo log 的组提交</strong>。<br>如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。<br>sync 阶段<br>绿色这一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是<strong>会等待一段时间</strong>，这个等待的时长由 Binlog_group_commit_sync_delay 参数控制，<strong>目的是为了组合更多事务的 binlog，然后再一起刷盘</strong>，如下过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859470168-92e4f211-1a3d-496a-a92b-6c9b4d04c27c.png#averageHue=%23fefefe&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uf9196fac&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1876&amp;originWidth=1268&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=694957&amp;status=done&amp;style=none&amp;taskId=u9ceed3a6-e856-4c90-b683-e0837cc82c5&amp;title=" alt="image.png"><br>不过，在等待的过程中，如果事务的数量提前达到了 Binlog_group_commit_sync_no_delay_count 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859470965-0a1f7d56-6932-4bb8-a0ec-ee4ab90e4b2e.png#averageHue=%23fbf8f0&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5f3a7721&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=702&amp;originWidth=1910&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=394399&amp;status=done&amp;style=none&amp;taskId=u64e6848c-dd2e-4049-a0b4-6529fcbf74e&amp;title=" alt="image.png"><br>从上面的过程，可以知道 sync 阶段队列的作用是<strong>用于支持 binlog 的组提交</strong>。<br>如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：</p>
<ul>
<li>binlog_group_commit_sync_delay= N，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。</li>
<li>binlog_group_commit_sync_no_delay_count = N，表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。</li>
</ul>
<p>如果在这一步完成后数据库崩溃，由于 binlog 中已经有了事务记录，MySQL会在重启后通过 redo log 刷盘的数据继续进行事务的提交。<br>commit 阶段<br>最后进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659859471225-14256b0c-dff2-4bf9-a1f1-63ba0952dc3a.png#averageHue=%23fefefd&amp;clientId=u4c16ca43-52af-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uee394f6f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1107&amp;originWidth=1020&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=383240&amp;status=done&amp;style=none&amp;taskId=u85bbec8d-6921-451c-82b6-d1e5c02975c&amp;title=" alt="image.png"><br>commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率。</p>
<h3 id="③MySQL-磁盘-I-O-很高，有什么优化的方法？"><a href="#③MySQL-磁盘-I-O-很高，有什么优化的方法？" class="headerlink" title="③MySQL 磁盘 I/O 很高，有什么优化的方法？"></a>③MySQL 磁盘 I/O 很高，有什么优化的方法？</h3><p>现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：</p>
<ul>
<li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。<h2 id="Ⅴ更新一条语句流程"><a href="#Ⅴ更新一条语句流程" class="headerlink" title="Ⅴ更新一条语句流程"></a>Ⅴ更新一条语句流程</h2>具体更新一条记录 UPDATE t_user SET name = ‘xiaolin’ WHERE id = 1; 的流程如下:</li>
</ul>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在修改该 Undo 页面前需要先记录对应的 redo log，所以<strong>先记录修改 Undo 页面的 redo log ，然后再真正的修改 Undo 页面</strong>。</li>
<li>InnoDB 层开始更新记录，根据 WAL 技术，<strong>先记录修改数据页面的 redo log ，然后再真正的修改数据页面</strong>。修改数据页面的过程是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。[</li>
</ol>
<p>](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48825548/article/details/120482321">https://blog.csdn.net/qq_48825548/article/details/120482321</a>)</p>
<h2 id="日志相关问题"><a href="#日志相关问题" class="headerlink" title="日志相关问题"></a>日志相关问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651632858993-93cbd99a-fe8b-495b-9b0f-bc05144e8030.jpeg#averageHue=%23e9ecdf&amp;clientId=uee8de687-a63b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=660&amp;id=u604e3892&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1522&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=68167&amp;status=done&amp;style=none&amp;taskId=u2d8c40d4-4711-4a67-82c5-e3c767a28dd&amp;title=&amp;width=495" alt="image.png"><br>图 1 两阶段提交示意图</p>
<p>接下来，我们就一起分析一下<strong>在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象。</strong><br>如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。到这里，大家都可以理解。<br>大家出现问题的地方，主要集中在时刻 B，也就是 binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？<br>我们先来看一下崩溃恢复时的判断规则。</p>
<ol>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li>
<li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li>
</ol>
<p>这里，时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交。<br>现在，我们继续延展一下这个问题。<br>日志相关问题### 追问 1：MySQL 怎么知道 binlog 是完整的?<br>回答：一个事务的 binlog 是有完整格式的：</p>
<ul>
<li>statement 格式的 binlog，最后会有 COMMIT；</li>
<li>row 格式的 binlog，最后会有一个 XID event。</li>
</ul>
<p>另外，在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性。对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。所以，MySQL 还是有办法验证事务 binlog 的完整性的。</p>
<h3 id="追问-2：redo-log-和-binlog-是怎么关联起来的"><a href="#追问-2：redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="追问 2：redo log 和 binlog 是怎么关联起来的?"></a>追问 2：redo log 和 binlog 是怎么关联起来的?</h3><p>回答：它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p>
<ul>
<li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li>
<li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。<h3 id="追问-3：处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#追问-3：处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?"></a>追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</h3>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。<br>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。<h3 id="追问-4：如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#追问-4：如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h3>回答：其实，两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。<br>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。<br>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。<br>两阶段提交就是为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交。<h3 id="追问-5：不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#追问-5：不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？"></a>追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？</h3>回答：这位同学的意思是，只保留 binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？<br>答案是不可以。<br>如果说<strong>历史原因</strong>的话，那就是 InnoDB 并不是 MySQL 的原生存储引擎。MySQL 的原生引擎是 MyISAM，设计之初就有没有支持崩溃恢复。<br>InnoDB 在作为 MySQL 的插件加入 MySQL 引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。<br>InnoDB 接入了 MySQL 后，发现既然 binlog 没有崩溃恢复的能力，那就用 InnoDB 原有的 redo log 好了。<br>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用 binlog 来实现崩溃恢复的流程，我画了一张示意图，这里就没有 redo log 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651632858998-59e987de-4f34-4198-aa3e-cc4fafcb343f.jpeg#averageHue=%23f1f1ea&amp;clientId=uee8de687-a63b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=tVyBM&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=856&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17367&amp;status=done&amp;style=none&amp;taskId=u55139db0-9f6b-4774-974d-c15f156d2f7&amp;title=" alt="image.png"><br>图 2 只用 binlog 支持崩溃恢复<br>这样的流程下，binlog 还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog 没有能力恢复“数据页”。<br>如果在图中标的位置，也就是 binlog2 写完了，但是整个事务还没有 commit 的时候，MySQL 发生了 crash。<br>重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来；但是对于事务 1 来说，系统已经认为提交完成了，不会再应用一次 binlog1。<br>但是，InnoDB 引擎使用的是 WAL 技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。<br>也就是说在图中这个位置发生崩溃的话，事务 1 也是可能丢失了的，而且是数据页级的丢失。此时，binlog 里面并没有记录数据页的更新细节，是补不回来的。<br>你如果要说，那我优化一下 binlog 的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个 redo log 出来。<br>所以，至少现在的 binlog 能力，还不能支持崩溃恢复。<h3 id="追问-6：那能不能反过来，只用-redo-log，不要-binlog？"><a href="#追问-6：那能不能反过来，只用-redo-log，不要-binlog？" class="headerlink" title="追问 6：那能不能反过来，只用 redo log，不要 binlog？"></a>追问 6：那能不能反过来，只用 redo log，不要 binlog？</h3>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。<br>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog 都是开着的。因为 binlog 有着 redo log 无法替代的功能。<br>一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。<br>一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。<br>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。<br>总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于 binlog，所以“鸠占鹊巢”redo log 还做不到。你看，发展生态是多么重要。<h3 id="追问-7：redo-log-一般设置多大？"><a href="#追问-7：redo-log-一般设置多大？" class="headerlink" title="追问 7：redo log 一般设置多大？"></a>追问 7：redo log 一般设置多大？</h3>回答：redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。<br>所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redo log 设置为 4 个文件、每个文件 1GB 吧。<h3 id="追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？"><a href="#追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？" class="headerlink" title="追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？"></a>追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</h3>回答：这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。<br>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</li>
</ul>
<ol>
<li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</li>
<li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。<h3 id="追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？"><a href="#追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？" class="headerlink" title="追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？"></a>追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</h3>回答：这两个问题可以一起回答。<br>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：<br>复制代码<br>begin;<br>insert into t1 …<br>insert into t2 …<br>commit;<br>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。<br>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。<br>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。<br>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的 IO 消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第 22 篇文章《MySQL 有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。<br>单独执行一个更新语句的时候，InnoDB 会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/09/MySQL/%E6%97%A5%E5%BF%97%E7%AF%87/">http://example.com/2022/08/09/MySQL/%E6%97%A5%E5%BF%97%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%EF%BC%9ABuffer-Pool"><span class="toc-number">1.</span> <span class="toc-text">前置：Buffer Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-Pool-%E7%BC%93%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Buffer Pool 缓存什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0Undo%E6%97%A5%E5%BF%97"><span class="toc-number">2.</span> <span class="toc-text">ⅠUndo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1undo-log%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">②undo log作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1redolog"><span class="toc-number">3.</span> <span class="toc-text">Ⅱredolog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81redolog"><span class="toc-number">3.1.</span> <span class="toc-text">①为什么需要redolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E4%BB%80%E4%B9%88%E6%98%AFredolog"><span class="toc-number">3.2.</span> <span class="toc-text">②什么是redolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2redolog%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">③redolog常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A2%AB%E4%BF%AE%E6%94%B9-Undo-%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BD%95%E5%AF%B9%E5%BA%94-redo-log-%E5%90%97%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 被修改 Undo 页面，需要记录对应 redo log 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-redo-log-%E5%92%8C-undo-log-%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. redo log 和 undo log 区别在哪？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-redo-log-%E8%A6%81%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%B9%9F%E8%A6%81%E5%86%99%E7%A3%81%E7%9B%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E6%AD%A4%E4%B8%80%E4%B8%BE%EF%BC%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">3. redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%A7%E7%94%9F%E7%9A%84-redo-log-%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">3.3.4.</span> <span class="toc-text">4.产生的 redo log 是直接写入磁盘的吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3redo-log-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">④redo log 什么时候刷盘？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4redo-log-%E6%96%87%E4%BB%B6%E5%86%99%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">⑤redo log 文件写满了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5REDO%E6%97%A5%E5%BF%97%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">3.6.</span> <span class="toc-text">⑥REDO日志的好处、特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">redo log日志格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A2binlog"><span class="toc-number">4.</span> <span class="toc-text">Ⅲbinlog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0binlog%E7%9A%84%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88-%E8%B5%B7%E5%88%B0%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">①binlog的概念是什么, 起到什么作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1binlog-%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">②binlog 日志的三种格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2redo-log-%E5%92%8C-binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">③redo log 和 binlog 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">④主从复制是怎么实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4binlog-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">⑤binlog 什么时候刷盘？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0bin-log%E5%92%8Credo-log%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">①bin log和redo log有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E4%B8%89%E4%B8%AA%E6%97%A5%E5%BF%97%E8%AE%B2%E5%AE%8C%E4%BA%86%EF%BC%8C%E8%87%B3%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%85%88%E5%B0%8F%E7%BB%93%E4%B8%8B%EF%BC%8Cupdate-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">②三个日志讲完了，至此我们可以先小结下，update 语句的执行过程。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">5.3.</span> <span class="toc-text">②什么是两阶段提交,</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A3-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9"><span class="toc-number">6.</span> <span class="toc-text">Ⅳ 两阶段提交内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">①为什么需要两阶段提交？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">两阶段提交的过程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%87%8D%E5%90%AF%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">6.1.2.</span> <span class="toc-text">异常重启会出现什么现象？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">②两阶段提交有什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%8F%90%E4%BA%A4"><span class="toc-number">6.2.1.</span> <span class="toc-text">组提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2MySQL-%E7%A3%81%E7%9B%98-I-O-%E5%BE%88%E9%AB%98%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">③MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A4%E6%9B%B4%E6%96%B0%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">Ⅴ更新一条语句流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">日志相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-2%EF%BC%9Aredo-log-%E5%92%8C-binlog-%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%E7%9A%84"><span class="toc-number">8.1.</span> <span class="toc-text">追问 2：redo log 和 binlog 是怎么关联起来的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-3%EF%BC%9A%E5%A4%84%E4%BA%8E-prepare-%E9%98%B6%E6%AE%B5%E7%9A%84-redo-log-%E5%8A%A0%E4%B8%8A%E5%AE%8C%E6%95%B4-binlog%EF%BC%8C%E9%87%8D%E5%90%AF%E5%B0%B1%E8%83%BD%E6%81%A2%E5%A4%8D%EF%BC%8CMySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.2.</span> <span class="toc-text">追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-4%EF%BC%9A%E5%A6%82%E6%9E%9C%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%91%A2%EF%BC%9F%E5%B9%B2%E8%84%86%E5%85%88-redo-log-%E5%86%99%E5%AE%8C%EF%BC%8C%E5%86%8D%E5%86%99-binlog%E3%80%82%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%BE%97%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%E9%83%BD%E5%AE%8C%E6%95%B4%E6%89%8D%E5%8F%AF%E4%BB%A5%E3%80%82%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-5%EF%BC%9A%E4%B8%8D%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%B2%A1%E6%9C%89%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E5%BF%85%E8%A6%81%E4%BA%86%E3%80%82%E5%8F%AA%E7%94%A8-binlog-%E6%9D%A5%E6%94%AF%E6%8C%81%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%8C%E5%8F%88%E8%83%BD%E6%94%AF%E6%8C%81%E5%BD%92%E6%A1%A3%EF%BC%8C%E4%B8%8D%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-6%EF%BC%9A%E9%82%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E5%8F%8D%E8%BF%87%E6%9D%A5%EF%BC%8C%E5%8F%AA%E7%94%A8-redo-log%EF%BC%8C%E4%B8%8D%E8%A6%81-binlog%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">追问 6：那能不能反过来，只用 redo log，不要 binlog？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-7%EF%BC%9Aredo-log-%E4%B8%80%E8%88%AC%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%A4%A7%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">追问 7：redo log 一般设置多大？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-8%EF%BC%9A%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E8%90%BD%E7%9B%98%EF%BC%8C%E6%98%AF%E4%BB%8E-redo-log-%E6%9B%B4%E6%96%B0%E8%BF%87%E6%9D%A5%E7%9A%84%E8%BF%98%E6%98%AF%E4%BB%8E-buffer-pool-%E6%9B%B4%E6%96%B0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE-9%EF%BC%9Aredo-log-buffer-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%85%88%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E5%86%99-redo-log-%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">8.9.</span> <span class="toc-text"> </span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-1"><span class="toc-number"></span> <span class="toc-text"> </span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/cover/cover/" title="翻唱"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻唱"/></a><div class="content"><a class="title" href="/2022/11/14/cover/cover/" title="翻唱">翻唱</a><time datetime="2022-11-14T09:31:07.351Z" title="发表于 2022-11-14 17:31:07">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>