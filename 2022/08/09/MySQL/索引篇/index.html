<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>索引篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="索引篇">
<meta property="og:type" content="article">
<meta property="og:title" content="索引篇">
<meta property="og:url" content="http://example.com/2022/08/09/MySQL/%E7%B4%A2%E5%BC%95%E7%AF%87/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="索引篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:24:44.441Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/09/MySQL/%E7%B4%A2%E5%BC%95%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '索引篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-13 22:24:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">索引篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:24:44.441Z" title="更新于 2022-11-13 22:24:44">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="索引篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Ⅰ索引基础面试题"><a href="#Ⅰ索引基础面试题" class="headerlink" title="Ⅰ索引基础面试题"></a>Ⅰ索引基础面试题</h2><h3 id="①什么是索引？"><a href="#①什么是索引？" class="headerlink" title="①什么是索引？"></a>①什么是索引？</h3><p>补充扯。。。。。<br>索引出现的原因：</p>
<ol>
<li>数据库的每行记录都是存储在磁盘中的块上的，块就是磁道和扇区交错的部分。通常块大小都是512字节，以达到稳定的目的。</li>
<li>假设有100条记录，每行记录占128个字节，那么一个块就可以存储四条记录，100条记录就需要25个块进行存储，如果你要访问特定的记录的话，就至多需要访问25个块。</li>
<li>为了加快数据的访问速度，就需要建立索引，为每行记录添加索引也就是稠密索引，同时索引也会存储在磁盘上。但是索引每行记录占用的字节比较少，一个块中就可以存储多行记录以减少磁盘的io。假设数据库中记录非常多的情况下，就需要建立多级索引，这就是b树和b加树的思想</li>
</ol>
<p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>。<br>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</p>
<h3 id="②索引的三种常见底层数据结构"><a href="#②索引的三种常见底层数据结构" class="headerlink" title="②索引的三种常见底层数据结构"></a>②索引的三种常见底层数据结构</h3><p>了解<br>详细内容三种常见的索引底层数据结构：分别是哈希表、有序数组和搜索树。</p>
<h4 id="a-哈希表"><a href="#a-哈希表" class="headerlink" title="a:哈希表"></a>a:哈希表</h4><ul>
<li><strong>哈希表</strong>是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key， 就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 </li>
<li>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的 一种方法是，拉出一个链表。 </li>
</ul>
<p>例子</p>
<blockquote>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时<br>对应的哈希索引的示意图如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649383353717-c20de990-849e-4261-a9f2-0f44ac30faa6.png#averageHue=%23dce4d1&amp;clientId=uea3fc7bc-4e1d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=295&amp;id=hkcbc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=564&amp;originWidth=806&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=134107&amp;status=done&amp;style=none&amp;taskId=u26cf4416-43a5-4876-b81f-f243daed973&amp;title=&amp;width=421.79998779296875" alt="image.png"><br>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时<br>速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速<br>度是很慢的。<br>你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用<br>户，就必须全部扫描一遍了。 </p>
</blockquote>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如 Memcached 及其他一些<br>NoSQL 引擎。</p>
<h4 id="b-有序数组"><a href="#b-有序数组" class="headerlink" title="b:有序数组"></a>b:有序数组</h4><ul>
<li>如果仅仅看查询效率，有序数组就是最好的数据结构了。</li>
<li>但是，在需要更新数据的时候就麻 烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。 </li>
<li><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人 口信息，这类不会再修改的数据。</p>
<h4 id="c-树"><a href="#c-树" class="headerlink" title="c:树"></a>c:树</h4><p>N 叉树由于读写上的性能优点以及适配磁盘访问模式以及广泛应用在数据库引擎中。</p>
<h3 id="③索引的优缺点？"><a href="#③索引的优缺点？" class="headerlink" title="③索引的优缺点？"></a>③索引的优缺点？</h3><p>优点：</p>
</li>
<li><p><strong>加快数据查找的速度</strong></p>
</li>
<li>为用来<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>或者是分组的字段添加索引，可以加快分组和<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>的速度 </li>
<li>加快表与表之间的连接 </li>
</ul>
<p>缺点：</p>
<ul>
<li>需要占用物理空间，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。<h3 id="④索引的作用？"><a href="#④索引的作用？" class="headerlink" title="④索引的作用？"></a>④索引的作用？</h3>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载<strong>所有</strong>的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</li>
</ul>
<p><strong>思考题：B＋树的存储能力如何？为何说一般查找行记录，最多只需要1~3次磁盘IO</strong><br>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值 也就是说一个深度为3的B+Tree索引可以维护10^3<em>10^3</em>10^3=10亿条记录。<br>实际情况中每个节点不可能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计的时候是将根节点常驻在内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作</p>
<h3 id="⑤什么情况下需要-不需要建索引？"><a href="#⑤什么情况下需要-不需要建索引？" class="headerlink" title="⑤什么情况下需要/不需要建索引？"></a>⑤什么情况下需要/不需要建索引？</h3><p><strong>什么时候适用索引？</strong></p>
<ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<p><strong>什么时候不需要创建索引？</strong></p>
<ul>
<li>WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li><p>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</p>
<h3 id="⑥索引的设计原则"><a href="#⑥索引的设计原则" class="headerlink" title="⑥索引的设计原则"></a>⑥索引的设计原则</h3></li>
<li><p>索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。 </p>
</li>
<li>尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。 </li>
<li>索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。 </li>
<li><p>利用最左前缀原则。 </p>
<h3 id="⑦索引什么时候会失效"><a href="#⑦索引什么时候会失效" class="headerlink" title="⑦索引什么时候会失效"></a>⑦索引什么时候会失效</h3><p>导致索引失效的情况：</p>
</li>
<li><p>对于组合索引，不是使用组合索引最左边的字段，则不会使用索引 </p>
</li>
<li>以%开头的like查询如%abc，无法使用索引；非%开头的like查询如abc%，相当于范围查询，会使用索引<br>like查询以%开头的索引不一定会失效验证准备<br>创建一张users表，表结构如下，表中有999999条数据：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668245920842-8f6b0228-5483-48d1-8f4a-6c4838ed71cb.png#averageHue=%23f8f7f6&amp;clientId=u9e761034-dbd6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u846eb8f3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=329&amp;originWidth=1324&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27644&amp;status=done&amp;style=none&amp;taskId=u475c8486-ca5d-4668-9ed5-9b628673333&amp;title=" alt="image.png"><br>在name字段上创建索引<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668245937196-724699f4-de71-4540-929d-4887fce722d2.png#averageHue=%23f3f2f0&amp;clientId=u9e761034-dbd6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u11e92120&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=147&amp;originWidth=1331&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13272&amp;status=done&amp;style=none&amp;taskId=u295fb878-6ca7-4566-93d8-29a2f63875e&amp;title=" alt="image.png"><br>验证阶段<br>要验证一段SQL语句有没有使用到索引，最好的方法莫过于使用SQL执行计划EXPLAIN了。</li>
</ul>
<p><strong>首先先看一下LIKE查询不以%开头的情况：</strong><br>EXPLAIN SELECT  * FROM users WHERE <code>name</code> LIKE ‘001%’;<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668245980063-2cd95ad3-4f8f-49c7-80f4-d6012514b510.png#averageHue=%23f9f7f6&amp;clientId=u9e761034-dbd6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u926e28a0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=158&amp;originWidth=1858&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19678&amp;status=done&amp;style=none&amp;taskId=u4a4b1853-8ff9-4c40-bc9a-1a5dd01ca4c&amp;title=" alt="image.png"><br>type=range,key=idx_name，说明这段是使用了索引的。</p>
<p><strong>接着再看一下LIKE查询以%开头的情况</strong><br><strong>先看第一段SQL语句：</strong><br>EXPLAIN SELECT * FROM users WHERE <code>name</code> LIKE ‘%001%’<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668246012519-3ac7e58c-c3f6-432e-b0be-2805403ed404.png#averageHue=%23f9f7f6&amp;clientId=u9e761034-dbd6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uba557ef3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=151&amp;originWidth=1859&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19407&amp;status=done&amp;style=none&amp;taskId=u060af351-a032-4887-9bf0-7b6d9494765&amp;title=" alt="image.png"><br>type=ALL，所以这段SQL是没有使用索引的。</p>
<p><strong>再来看第二段SQL语句：</strong><br>EXPLAIN SELECT  <code>name</code> FROM users WHERE <code>name</code> LIKE ‘%001%’;<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668246036539-e9a818ff-2a4d-495e-bf7d-c4425e41f47c.png#averageHue=%23f9f3f2&amp;clientId=u9e761034-dbd6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u194d9bcc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=159&amp;originWidth=1860&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22103&amp;status=done&amp;style=none&amp;taskId=ub296178a-85c9-45d3-8e62-ac25066305e&amp;title=" alt="image.png"><br>type=index，key=idx_name，这个结果说明这段SQL是使用了索引的。</p>
<p><strong>接着看第三段SQL语句：</strong><br>EXPLAIN SELECT  id , <code>name</code> FROM users WHERE <code>name</code> LIKE ‘%001%’;<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668246072770-95752e9c-50e6-42fe-a52b-92f2ed88cd11.png#averageHue=%23f8f7f5&amp;clientId=u9e761034-dbd6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaaa41423&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=146&amp;originWidth=1849&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19292&amp;status=done&amp;style=none&amp;taskId=udaf5e6bf-b81d-4521-8300-882b6a3520a&amp;title=" alt="image.png"><br>第三段SQL语句是在第二段SQL语句的基础上多查询一列id。这个执行结果和第二段是一样的，说明这段也是使用了索引的。</p>
<p><strong>最后看一下第四段SQL语句：</strong><br>EXPLAIN SELECT  id , <code>name</code> , gender FROM users WHERE <code>name</code> LIKE ‘%001%’;</p>
<p>第四段SQL语句是在第三段SQL语句的基础上多查询两列id和gender。执行结果和第一段一样，是没有使用索引的。</p>
<p>验证结果<br>通过以上验证可以发现，LIKE查询 以%开头不一定会让索引失效。</p>
<p>为什么会走索引呢？<br>首先解释一下，执行计划中type=ALL和index。还有key的含义。</p>
<p>type=ALL：全表扫描，遍历整张表去查询匹配的结果，不走索引。<br>type=index：使用索引覆盖，仅仅扫描索引树，比ALL要快。<br>type=range：使用索引进行范围查询时就会用到range访问方法。<br>key：实际使用到的索引，如果为NULL就是没使用索引。<br><strong>LIKE查询以%开头使用了索引的原因就是使用了索引覆盖。</strong><br>针对二级索引MySQL提供了一个优化技术。即从辅助索引中就可以得到查询的记录，就不需要回表再根据聚集索引查询一次完整记录。使用索引覆盖的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作，但是前提是要查询的所有列必须都加了索引。</p>
<p>LIKE查询以%开头会导致全索引扫描或者全表扫描，如果没有索引覆盖的话，查询到的数据会回表，多了一次IO操作，当MySQL预估全表扫描或全索引扫描的时间比走索引花费的时间更少时，就不会走索引。有了索引覆盖就不需要回表了，减少了IO操作，花费的时间更少，所以就使用了索引。</p>
<p><strong>总结</strong><br>LIKE查询 以%开头不一定会让索引失效。如果查询的结果中只包含主键和索引字段则会使用索引，反之则不会。</p>
<ul>
<li>在索引列上使用“IS NULL”或“IS NOT NULL”操作</li>
<li>对索引列进行运算 比如”not”  “&lt;&gt;”  “!=”</li>
<li>查询条件使用or连接，前后没有同时使用索引<h2 id="Ⅱ索引拓展"><a href="#Ⅱ索引拓展" class="headerlink" title="Ⅱ索引拓展"></a>Ⅱ索引拓展</h2><h3 id="①覆盖索引"><a href="#①覆盖索引" class="headerlink" title="①覆盖索引"></a>①覆盖索引</h3>查询的数据列只用从索引中就能够取得，不需要<strong>回表</strong>进行二次查询，也就是说查询列要被所使用的索引覆盖。<br>对于innodb表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。<br>不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</li>
</ul>
<p>查询的字段在B+树只能确定我们要查找记录的主键值，所以如果我们想查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。</p>
<h3 id="②索引下推"><a href="#②索引下推" class="headerlink" title="②索引下推"></a>②索引下推</h3><blockquote>
<p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你<br>可能要问，那些不符合最左前缀的部分，会怎么样呢？<br>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名<br>字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：<br> mysql&gt; select * from tuser where name like ‘张 %’ and age=10 and ismale=1;<br>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第<br>一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。<br>然后呢？<br>当然是判断其他条件是否满足。在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段 值。 </p>
</blockquote>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过<br>程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 </p>
<blockquote>
<p>图 3 和图 4，是这两个过程的执行流程图。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649384269026-0888a90a-b932-4fff-98cd-2b31bf11e6ec.png#averageHue=%23f1f0ea&amp;clientId=uea3fc7bc-4e1d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=UfnSW&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=429&amp;originWidth=1005&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=200255&amp;status=done&amp;style=none&amp;taskId=u8e59fcdc-f014-4257-81bb-98b33948841&amp;title=&amp;width=533.0000610351562" alt="image.png"><br>图 3 无索引下推执行流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649384287056-644a0800-d89e-4eb4-975e-18cda31224de.png#averageHue=%23f0f0ea&amp;clientId=uea3fc7bc-4e1d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=225&amp;id=n7VpC&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=422&amp;originWidth=962&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=205321&amp;status=done&amp;style=none&amp;taskId=u537f0718-6b8c-4a42-b2cc-c0aeae5efec&amp;title=&amp;width=512.0000610351562" alt="image.png"><br>图 4 索引下推执行流程<br>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。<br>图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看<br>age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，<br>需要回表 4 次。<br>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于<br>不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记<br>录回表取数据判断，就只需要回表 2 次。</p>
</blockquote>
<h3 id="③什么是最左匹配原则？"><a href="#③什么是最左匹配原则？" class="headerlink" title="③什么是最左匹配原则？"></a>③什么是最左匹配原则？</h3><ul>
<li>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配，后面的字段不会用到索引。</li>
<li>对(a,b,c)建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。</li>
<li>对(a,b,c,d)建立索引，查询条件为a = 1 and b = 2 and c &gt; 3 and d = 4，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。</li>
</ul>
<p><strong>最左匹配原则的成因</strong><br>mysql创建复合索引的规则是首先对复合索引的最左边，也就是第一个索引数据进行排序，在第一个字段排序的基础上，再对第二个索引字段进行排序。其实就是实现了类似于order by 字段一 再 order by 字段二，这样一种排序规则。那么所以第一个字段是绝对有序的，而第二个字段就是无需的了。因此通常情况下使用第二个字段进行条件判断，就用不到索引了。这也就是mysql为什么会强调 联合索引最左匹配原则的原因。</p>
<p>如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>）。直接执行b = 2这种查询条件无法使用索引。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647571051362-fefed543-f5d9-4ee8-a7e3-85d288c27f2a.png#averageHue=%23f1f1f1&amp;clientId=u1a81d606-b3de-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=pXqe9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=221&amp;originWidth=501&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72420&amp;status=done&amp;style=none&amp;taskId=ubc36a95d-ac53-4c4b-ac13-4fa3a18d900&amp;title=" alt="image.png"><br>当a的值确定的时候，b是有序的。例如a = 1时，b值为1，2是有序的状态。当a = 2时候，b的值为1，4也是有序状态。 当执行a = 1 and b = 2时a和b字段能用到索引。而执行a &gt; 1 and b = 2时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段无法使用索引。</p>
<h3 id="④有什么优化索引的方法"><a href="#④有什么优化索引的方法" class="headerlink" title="④有什么优化索引的方法"></a>④有什么优化索引的方法</h3><p>这里说一下几种常见优化索引的方法：</p>
<ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效；<h4 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h4>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</li>
</ul>
<p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。<br>不过，前缀索引有一定的局限性，例如：</p>
<ul>
<li>order by 就无法使用前缀索引；</li>
<li>无法把前缀索引用作覆盖索引；<h4 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h4>覆盖索引是指 SQL 中 查询的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</li>
</ul>
<p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？<br>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。<br>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p>
<h4 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h4><p>我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？<br>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p>
<p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。<br><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p>
<blockquote>
<p>举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659841299496-0208b7b4-d738-472c-a6fb-6e585a57df86.png#averageHue=%23f7e6d5&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=259&amp;id=fLjDR&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=782&amp;originWidth=1584&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=130138&amp;status=done&amp;style=none&amp;taskId=u6a6aa2b9-5b63-464f-a1d6-ba3c00ed1b0&amp;title=&amp;width=525.0000610351562" alt="image.png"><br>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。<br>而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659841299498-e1a95546-7819-4a20-b70b-2af8e0af98fd.png#averageHue=%23f8e8d9&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=L1lKW&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=832&amp;originWidth=1662&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=149102&amp;status=done&amp;style=none&amp;taskId=u3462edf8-7f55-4ea6-9dcf-3219bd484a4&amp;title=&amp;width=554.0000610351562" alt="image.png"></p>
</blockquote>
<p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。<br>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p>
<h4 id="索引最好设置为-NOT-NULL"><a href="#索引最好设置为-NOT-NULL" class="headerlink" title="索引最好设置为 NOT NULL"></a>索引最好设置为 NOT NULL</h4><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p>
<ul>
<li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li>
<li><p>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式COMPACT，会用 1 字节空间存储 NULL 值列表，如下图的黄色部分：<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659841299383-3d3e6a29-3be4-4c6c-9a70-e8d976071fdd.png#averageHue=%23809678&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=p4v7S&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48322&amp;status=done&amp;style=none&amp;taskId=uaee2d6ac-1ced-4f3b-9af7-66018846af8&amp;title=" alt="image.png"></p>
<h4 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h4><p>用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。<br>我之前写过索引失效的文章，想详细了解的可以去看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">谁还没碰过索引失效呢?(opens new window)</a><br>这里简单说一下，发生索引失效的情况：</p>
</li>
<li><p>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</p>
</li>
<li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。<blockquote>
<p>我上面说的是常见的索引失效场景，实际过程中，可能会出现其他的索引失效场景，这时我们就需要查看执行计划，通过执行计划显示的数据判断查询语句是否使用了索引。<br>如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659841299452-2bffca9c-d061-48d5-94d1-8bbd664bff40.png#averageHue=%23f7f6f6&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=muR04&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=185&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60073&amp;status=done&amp;style=none&amp;taskId=u64cef69c-cc3f-4955-92f5-a59528e50e5&amp;title=" alt="image.png"><br>对于执行计划，参数有：</p>
<ul>
<li>possible_keys 字段表示可能用到的索引；</li>
<li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li>
<li>key_len 表示索引的长度；</li>
<li>rows 表示扫描的数据行数。</li>
<li>type 表示数据扫描类型，我们需要重点看这个。</li>
</ul>
<p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p>
<ul>
<li>All（全表扫描）；</li>
<li>index（全索引扫描）；</li>
<li>range（索引范围扫描）；</li>
<li>ref（非唯一索引扫描）；</li>
<li>eq_ref（唯一索引扫描）；</li>
<li>const（结果只有一条的主键或唯一索引扫描）。</li>
</ul>
<p>在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。<br>range 表示采用了索引范围扫描，一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。<br>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。<br>eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。<br>const 类型表示使用了主键或者唯一索引与常量值进行比较，比如 select name from product where id=1。<br>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。<br>除了关注 type，我们也要关注 extra 显示的结果。<br>这里说几个重要的参考指标：</p>
<ul>
<li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>
<li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="⑤普通索引和唯一索引怎么选"><a href="#⑤普通索引和唯一索引怎么选" class="headerlink" title="⑤普通索引和唯一索引怎么选"></a>⑤普通索引和唯一索引怎么选</h2><blockquote>
<p><strong>changebuffer：</strong><br>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内<br>存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change<br>buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的<br>时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方<br>式就能保证这个数据逻辑的正确性。<br>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，<br>change buffer 在内存中有拷贝，也会被写入到磁盘上。<br>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <strong>merge</strong>。除了访问<br>这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭<br>（shutdown）的过程中，也会执行 merge 操作。 </p>
</blockquote>
<ul>
<li>查询比较 <ul>
<li>查询会以页为单位将数据页加载进内存，不需要一条记录一条记录读取磁盘。然后唯一索引根据 条件查询到记录时就返回结果，普通索引查到第一条记录往后遍历直到不满足条件，由于都在内 存中，不需要磁盘读取那么大开销，带来的额外查询开销忽略不计，所以查询性能几乎一致 </li>
</ul>
</li>
<li>更新比较 <ul>
<li>唯一索引由于更新时要检查唯一性，所以需要将数据页先加载进内存才能判断，此时直接操作内 存，不需要操作change buffer </li>
<li>补充：普通索引若数据再内存中直接内存中更新，否则会将更新操作先记录到change buffer 中，等下一次查询将数据读到内存中再进行change buffer里相关更新操作后将数据返回，这样 一来，再<strong>写多读少的情况下就减少了磁盘IO</strong>，若写完就马上查询，就大可不必用change buffer，不但没提高多少效率还造成维护change buffer额外消耗 将change buffer的操作对应到原始数据页的操作称为merge（可以查询来时读到内存再修改数 据，后台线程也会merge，数据库正常关闭也会merge） </li>
</ul>
</li>
<li>适合场景 <ul>
<li>写多读少，选用普通索引更好，可以利用change buffer进行性能优化减少磁盘IO，将更新操作 记录到change bufer，等查询来了将数据读到内存再进行修改.  </li>
</ul>
</li>
</ul>
<p><strong>如果某次写入使用了 change buffer 机制，之后主机异常重启，是否会丢失 change buffer 和数据。</strong><br>这个问题的答案是不会丢失。虽然是只更新内存，但是在事<br>务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时<br>候，change buffer 也能找回来。</p>
<p>merge 的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应<br>用，得到新版数据页；</li>
<li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。<br>到这里 merge 过程就结束了。这时候，数据页和内存中 change buffer 对应的磁盘位置都<br>还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</li>
</ol>
<p><strong>change buffer 和 redo log</strong><br>插入数据：insert into t(id,k) values(id1,k1),(id2,k2);<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651628130110-75b9eb67-24eb-4b8f-b0a6-f1b0f66d66d9.png#averageHue=%23fdfcf6&amp;clientId=uee8de687-a63b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=293&amp;id=l583d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=798&amp;originWidth=1446&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80406&amp;status=done&amp;style=none&amp;taskId=u0309de32-eb7b-45c8-8376-bba177e5e9b&amp;title=&amp;width=531.2857666015625" alt="image.png"></p>
<p>假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中<br>Page 1 在内存中，直接更新内存<br>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下 我要往 Page 2 插入一行 这个信息<br>将上述两个动作记入 redo log 中<br>查询数据：select * from t where k in (k1, k2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651628136984-341d6149-223b-41ed-98f6-6c9001edef83.png#averageHue=%23fffff9&amp;clientId=uee8de687-a63b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=zfVp4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=886&amp;originWidth=1384&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62246&amp;status=done&amp;style=none&amp;taskId=ua35f3fbd-7fb2-43e6-8790-8f43cbbb08d&amp;title=" alt="image.png"></p>
<p>读 Page 1 的时候，直接从内存返回<br>读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果<br>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗</p>
<h2 id="✊ⅢMySQL中的索引分类"><a href="#✊ⅢMySQL中的索引分类" class="headerlink" title="✊ⅢMySQL中的索引分类"></a>✊ⅢMySQL中的索引分类</h2><h3 id="1-按数据结构分类"><a href="#1-按数据结构分类" class="headerlink" title="1. 按数据结构分类"></a>1. 按数据结构分类</h3><blockquote>
<p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。<br>每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659837829679-1bf67d5d-98b8-435b-afb8-4e433bfb5031.png#averageHue=%23f7cb56&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u778f7ee3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=421&amp;originWidth=811&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=110111&amp;status=done&amp;style=none&amp;taskId=uce722832-5649-4591-b65d-1ae7ffb4856&amp;title=&amp;width=577.0000610351562" alt="image.png"><br>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p>
</blockquote>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li>
</ul>
<p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p>
<h4 id="①哈希索引"><a href="#①哈希索引" class="headerlink" title="①哈希索引"></a>①哈希索引</h4><p>哈希索引是基于<a href="/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，将哈希码的值作为<a href="/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>的key值，将指向数据行的指针作为<a href="/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</p>
<h4 id="✊②B-树索引"><a href="#✊②B-树索引" class="headerlink" title="✊②B+树索引"></a>✊②B+树索引</h4><ul>
<li><strong>概念：</strong><ul>
<li>B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</li>
</ul>
</li>
<li>特点：<ul>
<li><ol>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647571051030-c78872ac-1de2-4d38-a618-0d0742e8cf74.png#averageHue=%23f4f0e9&amp;clientId=u1a81d606-b3de-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=R01cB&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=376&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48084&amp;status=done&amp;style=none&amp;taskId=u541d84c6-1dc0-49f8-8864-d59ed1e3383&amp;title=" alt="image.png"></p>
<ul>
<li>如何找到指定元素：<ul>
<li>进行查找操作时，首先在根节点进行<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>，找到key所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>，找出key所对应的数据项。</li>
</ul>
</li>
</ul>
<p>MySQL 数据库使用最多的索引类型是BTREE索引，底层基于B+树数据结构来实现。</p>
<h5 id="b-树相关面试题"><a href="#b-树相关面试题" class="headerlink" title="b+树相关面试题"></a>b+树相关面试题</h5><p><strong>1.在MySQL中为什么会选用B+tree做索引结构呢？</strong><br>B站咖喱味的视频## 拓展：为什么使用B+树作为mysql索引</p>
<p>数据库的每行记录都是存储在磁盘中的块上的，块就是磁道和扇区交错的部分。通常块大小都是512字节，以达到稳定的目的。<br>假设有100条记录，每行记录占128个字节，那么一个块就可以存储四条记录，100条记录就需要25个块进行存储，如果你要访问特定的记录的话，就至多需要访问25个块。</p>
<p>为了加快数据的访问速度，就需要建立索引，为每行记录添加索引也就是稠密索引，同时索引也会存储在磁盘上。但是索引每行记录占用的字节比较少，一个块中就可以存储多行记录以减少磁盘的io。假设数据库中记录非常多的情况下，就需要建立多级索引，这就是b树和b加树的思想</p>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650283255430-d3186cb8-0eca-44e3-a77f-132b94af9c86.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=293&amp;id=WGco1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=366&amp;originWidth=451&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=89491&amp;status=done&amp;style=none&amp;taskId=u0c171e19-174e-4219-8b1a-4cb6f8e3fd6&amp;title=&amp;width=360.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650283263903-97137ad4-8c61-445d-a451-362e1a9729eb.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=28&amp;id=O9UWg&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=35&amp;originWidth=595&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23266&amp;status=done&amp;style=none&amp;taskId=udf954a74-b594-4519-bea0-ad9c6dc8c93&amp;title=&amp;width=476" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650283305394-76d45fce-4976-4b3f-9fc6-cb0139aac674.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=54&amp;id=eJzN4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=68&amp;originWidth=294&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18945&amp;status=done&amp;style=none&amp;taskId=ua2084c41-c2f2-4f87-ae29-25bb0197456&amp;title=&amp;width=235.2" alt="image.png">轨道号和扇区号定位<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650283349880-79ed0cf3-6627-45eb-bb99-eff0d66a1619.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=29&amp;id=yiCUd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=36&amp;originWidth=522&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19607&amp;status=done&amp;style=none&amp;taskId=u25dd0790-77eb-47db-982c-220c774578a&amp;title=&amp;width=417.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650283180424-022c227c-b321-47c0-8891-fbf068091cb2.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=tPr31&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=589&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82123&amp;status=done&amp;style=none&amp;taskId=u8e1ae0e3-a589-47d7-92fc-fa51360030e&amp;title=" alt="image.png"></p>
<h3 id="数据如何存储在磁盘上"><a href="#数据如何存储在磁盘上" class="headerlink" title="数据如何存储在磁盘上"></a>数据如何存储在磁盘上</h3><p>以块形式将数据存储在磁盘上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650283670057-fcd1ca92-1205-4661-adf3-4dad05bfcce6.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=313&amp;id=kdcFe&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=391&amp;originWidth=666&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=128285&amp;status=done&amp;style=none&amp;taskId=uaa095f0d-d729-4962-884b-728ae96eefc&amp;title=&amp;width=532.8" alt="image.png"><br>假设数据库每行占128字节，块大小512字节<br>所以一个块中可以存储四行</p>
<p>假设一张表中有100条记录，那么就需要25个块。<br>如果要查找特点的记录，就最多需要访问25个块。</p>
<p>这时为数据库准备索引来减少访问的时间<br>为每行记录添加索引就是稠密索引<br>同时索引也会存储在磁盘上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650284155235-441461dc-8b24-44bd-9868-dbba8fc18fe5.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=YAsPz&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=226&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72177&amp;status=done&amp;style=none&amp;taskId=u6a0aeb1e-e8da-4398-9cc1-1218cc9469e&amp;title=&amp;width=180.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650284163321-de3e13cd-8ae8-4182-b238-1b6df47099df.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=30&amp;id=f8reV&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=37&amp;originWidth=561&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20649&amp;status=done&amp;style=none&amp;taskId=u0607b63d-ec3a-4ee1-8f8f-bd7d58c0eb7&amp;title=&amp;width=448.8" alt="image.png"><br>那么100条记录 100/32 约等于4 所以最多只需要访问4+1个块<br>4个索引加上要去访问数据的那个块</p>
<h3 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650284422918-e966ab3b-4fd3-48c4-8d89-6c2c18c9759f.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=326&amp;id=NmZdk&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=407&amp;originWidth=575&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=180215&amp;status=done&amp;style=none&amp;taskId=uc038fa10-7c28-4987-b104-3a081cb65a1&amp;title=&amp;width=460" alt="image.png"><br>指向条目集的指针<br>以上就是B树和B+树索引的思想<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650284681823-c7b8ac0e-c945-4bb7-8f84-a9bb275db1da.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=lruOz&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=354&amp;originWidth=340&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75966&amp;status=done&amp;style=none&amp;taskId=u3b17da69-58b3-491e-93ee-00ad443aafe&amp;title=&amp;width=272" alt="image.png"></p>
<h3 id="M-way-search-tree"><a href="#M-way-search-tree" class="headerlink" title="M-way search tree"></a>M-way search tree</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650285052771-970946f6-bd5e-472b-af4d-1a4d1556d954.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=342&amp;id=jd3ME&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=427&amp;originWidth=554&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119865&amp;status=done&amp;style=none&amp;taskId=ub08f78e6-639a-4763-8ec5-6e202f5a71d&amp;title=&amp;width=443.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650285336282-00c17720-f535-4bff-8098-3fc87239d043.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=373&amp;id=EmT5L&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=466&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=138621&amp;status=done&amp;style=none&amp;taskId=uce293c8e-02d8-4793-9d98-573353e5a0c&amp;title=&amp;width=491.2" alt="image.png"></p>
<p>规则：ex 10-way<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650285735773-3464a6ab-549a-4370-95cd-e7afe92c1c52.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=45&amp;id=aSIhI&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=56&amp;originWidth=586&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14437&amp;status=done&amp;style=none&amp;taskId=ud8aa930b-8e01-48fd-b9d0-759fd3dfbf7&amp;title=&amp;width=468.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650285803473-177fb3f7-391b-474a-a78b-b3459ac23e22.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=123&amp;id=UAcuO&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=550&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52331&amp;status=done&amp;style=none&amp;taskId=ub71c014b-8e70-4bed-94c6-5dd428926c4&amp;title=&amp;width=440" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650285831331-56d8fc48-ab70-49b0-902d-502bc947780d.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=53&amp;id=YN1QC&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=66&amp;originWidth=233&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11084&amp;status=done&amp;style=none&amp;taskId=uef5ac9f7-e1cb-40c8-9a34-3ccfd56fea9&amp;title=&amp;width=186.4" alt="image.png">创建过程自下而上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650286383950-157a6994-c47c-45f1-882a-ecb2b2ef31a4.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=363&amp;id=tktxu&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=454&amp;originWidth=854&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=244042&amp;status=done&amp;style=none&amp;taskId=ubbd98087-859e-43c6-802f-23d9c0e3094&amp;title=&amp;width=683.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650286474759-15dc1759-ce6c-4b59-b7b7-2424176e93d5.png#clientId=ue6991ab5-e7f4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=344&amp;id=ozecu&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=788&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=181095&amp;status=done&amp;style=none&amp;taskId=u86541e63-0350-433e-b256-791766bc3c0&amp;title=&amp;width=630.4" alt="image.png"><br>详细内容—演变过程是如何使用B+树的怎样的索引的数据结构是好的？<br>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。</p>
<p>磁盘是一个慢的离谱的存储设备，有多离谱呢？</p>
<p>内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。<br>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以<strong>操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB</strong>，也就是一次磁盘  I/O 操作会直接读写 8 个扇区。</p>
<p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p>
<p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘  I/O 操作越少，所消耗的时间也就越小。</p>
<p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。<br>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<p>分析完要求后，我们针对每一个数据结构分析一下。</p>
<p>什么是二分查找？<br>索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。</p>
<p>假设我们现在用数组来存储索引，比如下面有一个排序的数组，如果要从中找出数字 3，最简单办法就是从头依次遍历查询，这种方法的时间复杂度是 O(n)，查询效率并不高。因为该数组是有序的，所以我们可以采用二分查找法，比如下面这张采用二分法的查询过程图：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1659838524793-609e5181-249d-4cc0-84f3-04d625ec75b4.jpeg#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=JZkbS&amp;margin=%5Bobject%20Object%5D&amp;originHeight=432&amp;originWidth=981&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0a59a2f4-af8c-4f0c-92fc-b0cb5684acf&amp;title=" alt=""><br>可以看到，二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。</p>
<p>什么是二分查找树？<br>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p>
<p>因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。</p>
<p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p>
<p>就可以设计一个非线形且天然适合二分查找的数据结构呢？</p>
<p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838582658-58112110-7407-4438-b6ee-90e6c3cc7b61.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=c5OVZ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=257&amp;originWidth=612&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufa96c9a0-7089-491c-ab6b-2480499cc97&amp;title=" alt=""><br>怎么样？是不是变成了二叉树，不过它不是普通的二叉树，它是一个<strong>二叉查找树</strong>。<br><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。<br>假设，我们查找索引值为 key 的节点：</p>
<ol>
<li>如果 key 大于根节点，则在右子树中进行查找；</li>
<li>如果 key 小于根节点，则在左子树中进行查找；</li>
<li>如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。</li>
</ol>
<p>二叉查找树查找某个节点的动图演示如下，比如要查找节点 3 ：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838582537-1cbeb669-80e9-419f-b587-4a810ca77672.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=cu3c4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=165&amp;originWidth=253&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue4f34ebe-cbbe-429d-809c-cfdd05756cc&amp;title=" alt=""><br>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。<br>下面是二叉查找树插入某个节点的动图演示：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838582754-a217ea81-ca95-4bc0-8e8d-7357c2719145.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=zMh0N&amp;margin=%5Bobject%20Object%5D&amp;originHeight=197&amp;originWidth=689&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u74de552c-d30b-40fc-b776-fd18f5ee231&amp;title=" alt=""></p>
<p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。<br>那是不是二叉查找树就可以作为索引的数据结构了呢？<br>不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！<br><strong>当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)</strong>，如下动图演示：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838582702-c2e0e9bc-7a15-4f00-9f83-bb1256fefb31.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ZFzld&amp;margin=%5Bobject%20Object%5D&amp;originHeight=253&amp;originWidth=714&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua503a4b8-7a3e-4083-8caf-a211e720744&amp;title=" alt=""><br>由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（<em>假设一个节点的大小「小于」操作系统的最小读写单位块的大小</em>），也就是说<strong>树的高度就等于每次查询数据时磁盘 IO 操作的次数</strong>，所以树的高度越高，就会影响查询性能。<br>二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从 O(logn)降低为 O(n)。<br>而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。<br>什么是自平衡二叉树？<br>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p>
<p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) 。<br>下图是每次插入的元素都是平衡二叉查找树中最大的元素，可以看到，它会维持自平衡：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838764490-74bbd6db-20e6-42b6-9133-54fe5def1fb0.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ApUiQ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=189&amp;originWidth=387&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue6e1de8f-6b8d-4fdd-b32a-e867a09174e&amp;title=" alt=""><br>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，不是本篇的重点重点，大家可以看《数据结构》相关的书籍来了解红黑树的约束条件。<br>下面是红黑树插入节点的过程，这左旋右旋的操作，就是为了自平衡。<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838764739-0a67372a-3fee-4a9d-b83b-99e7e2e30bf9.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=z3lVN&amp;margin=%5Bobject%20Object%5D&amp;originHeight=248&amp;originWidth=747&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udc7b532a-551f-43d4-b616-9979b8ede98&amp;title=" alt=""><br><strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率</strong>。<br>比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659838764561-913682ab-1e58-4a6c-b1ef-c27f8b859a0e.png#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=hM0Ba&amp;margin=%5Bobject%20Object%5D&amp;originHeight=491&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2571034a-c180-484a-b235-4a383cda21e&amp;title=" alt=""><br>根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点 ，如果我们把二叉树改成 M 叉树（M&gt;2）呢？<br>比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659838764498-14c5ce08-4a7e-487f-ae27-6e6bc6c45a75.png#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=J9dUT&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub33fbea2-a4d6-44e5-bae5-e4184a601b5&amp;title=" alt=""><br>因此，<strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。<br>什么是 B 树<br>自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。</p>
<p>为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p>
<p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。<br>假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点，超过这些要求的话，就会分裂节点，比如下面的的动图：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838764477-b3fb7c60-76d7-45da-a59a-345b4c850416.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=PwzJY&amp;margin=%5Bobject%20Object%5D&amp;originHeight=310&amp;originWidth=847&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3b886a5c-38fd-4fbb-8ba0-bbdbbb950de&amp;title=" alt=""><br>我们来看看一棵 3 阶的 B 树的查询过程是怎样的？<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838765220-22a6967f-e7d2-4343-a5f6-67ff5c589c17.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=meC7T&amp;margin=%5Bobject%20Object%5D&amp;originHeight=192&amp;originWidth=385&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u65c805ad-cfcf-482d-96c5-d1efa62a499&amp;title=" alt=""><br>假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：</p>
<ol>
<li>与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；</li>
<li>然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；</li>
<li>走到索引为9的节点，然后我们找到了索引值 9 的节点。</li>
</ol>
<p>可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。</p>
<p>而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。</p>
<p>但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。</p>
<p>而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p>
<p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O  问题，从而导致整体速度下降。<br>什么是 B+ 树？<br>B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659838765199-e9836925-83d3-43d6-bf08-c1b4da08a046.png#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=YnT9M&amp;margin=%5Bobject%20Object%5D&amp;originHeight=671&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u83d51890-e55f-4dc3-8b36-188182722de&amp;title=" alt=""><br>B+ 树与 B 树差异的点，主要是以下这几点：</p>
<ul>
<li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li>
<li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li>
<li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li>
<li>非叶子节点中有多少个子节点，就有多少个索引；</li>
</ul>
<p>下面通过三个方面，比较下 B+ 和 B 树的性能区别。<br><strong>1、单点查询</strong><br>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。</p>
<p>但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。</p>
<p><strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少</strong>。<br><strong>2、插入和删除效率</strong><br>B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快，</p>
<p>比如下面这个动图是删除 B+ 树某个叶子节点节点的过程：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838765212-b0352e19-6d21-45df-a50f-05545ab481c1.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=cFazU&amp;margin=%5Bobject%20Object%5D&amp;originHeight=168&amp;originWidth=408&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5b5d1127-d80a-48c7-9c29-4b9628f7c93&amp;title=" alt=""><br>注意，：B+ 树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说非叶子节点的子节点的个数为 M 阶，而索引的个数为 M-1（这个是维基百科里的定义），因此我本文关于 B+ 树的动图都是基于这个。但是我在前面介绍 B+ 树与 B+ 树的差异时，说的是「非叶子节点中有多少个子节点，就有多少个索引」，主要是 MySQL 用到的 B+ 树就是这个特性。<br>甚至，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 B+ 树根节点的过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838765521-f985cdd9-df80-4aa7-9850-6100636341ed.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=cQPHj&amp;margin=%5Bobject%20Object%5D&amp;originHeight=258&amp;originWidth=439&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54d944bf-89fc-499b-829c-d9ce7c56a98&amp;title=" alt=""><br>B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659838766025-33c530fd-eaa5-4dba-b540-72589a2a3182.gif#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=wveDV&amp;margin=%5Bobject%20Object%5D&amp;originHeight=208&amp;originWidth=324&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u43893288-7c9e-479b-84b9-59aec969009&amp;title=" alt=""><br>B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。</p>
<p>因此，<strong>B+ 树的插入和删除效率更高</strong>。<br><strong>3、范围查询</strong><br>B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p>
<p>因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。</p>
<p>而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</p>
<p>因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。<br><strong>MySQL 中的 B+ 树</strong><br>MySQL 的存储方式根据存储引擎的不同而不同，我们最常用的就是 Innodb 存储引擎，它就是采用了 B+ 树作为了索引的数据结构。<br>下图就是 Innodb 里的 B+ 树：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659838766186-be15afbd-690e-4119-9821-b3f2ceb585a1.png#clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=M5X8D&amp;margin=%5Bobject%20Object%5D&amp;originHeight=509&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4fdf0df0-b112-4b9c-8c04-86e0df51b51&amp;title=" alt=""><br>但是 Innodb 使用的  B+ 树有一些特别的点，比如：</p>
<ul>
<li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li>
<li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li>
</ul>
<p>Innodb 根据索引类型不同，分为聚集和二级索引。他们区别在于，聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。<br>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。<br>更多关于 Innodb 的 B+ 树，可以看我之前写的这篇：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247502059&amp;idx=1&amp;sn=ccbee22bda8c3d6a98237be769a7c89c&amp;scene=21#wechat_redirect">从数据页的角度看 B+ 树</a>。<br>总结</p>
<ul>
<li><p>MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。</p>
</li>
<li><p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。</p>
</li>
<li><p>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。</p>
</li>
<li><p>为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。</p>
</li>
</ul>
<p><strong>而树的高度决定于磁盘  I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</strong></p>
<p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。<br>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：<br>这也是为什么<strong>B+树比B树更适合实现数据库索引</strong></p>
<ul>
<li><strong>更少的IO次数：</strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li><strong>更适合与范围查询</strong>：B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<p><strong>2.B+树与 B 树的区别主要在于： </strong></p>
<ul>
<li>B 树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+树中只有叶子节点存储真实的数据，非 叶节点只存储索引的key值。</li>
<li>B 树中一条记录只会出现一次，不会重复出现，而 B+树的键则可能重复重现——一定会在叶节点出现，也 可能在非叶节点重复出现。 </li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652168120194-2cba9745-70bf-4bea-866c-f29b6f4ed4ef.png#averageHue=%23f4e8de&amp;clientId=uc6d7e8c9-8aaf-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=162&amp;id=NWnV9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=141&amp;originWidth=234&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22009&amp;status=done&amp;style=none&amp;taskId=u1ef1568b-1d9b-4753-888a-b52a02792e9&amp;title=&amp;width=269.1999969482422" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652168072433-e7780b01-be96-494d-aa52-2691dedc0aa0.png#averageHue=%23e8dbd1&amp;clientId=uc6d7e8c9-8aaf-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=177&amp;id=jIG6b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=415&amp;originWidth=767&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=252664&amp;status=done&amp;style=none&amp;taskId=u8fa5b90b-336f-4e0c-ba41-998983323e5&amp;title=&amp;width=326.6000061035156" alt="image.png"></p>
<ul>
<li>B+树的叶节点之间通过链表连接。并且所有的关键字都在叶子节点出现<blockquote>
<ul>
<li>B 树中的非叶节点，记录数比子节点个数少 1；而 B+树中记录数与子节点个数相同。  </li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>3.Hash索引和B+树索引的区别？</strong></p>
<ul>
<li>哈希索引<strong>不支持</strong>排序，因为哈希表是无序的。 </li>
<li>哈希索引<strong>不支持范围查找</strong>。 </li>
<li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。 </li>
<li>因为哈希表中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。 <h4 id="③Full-text-索引"><a href="#③Full-text-索引" class="headerlink" title="③Full-text 索引"></a>③Full-text 索引</h4><strong>概念</strong><br>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</li>
</ul>
<p>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p>
<p>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</p>
<h3 id="2-按物理存储分类"><a href="#2-按物理存储分类" class="headerlink" title="2. 按物理存储分类"></a>2. 按物理存储分类</h3><h4 id="①聚簇索引"><a href="#①聚簇索引" class="headerlink" title="①聚簇索引"></a>①聚簇索引</h4><ol>
<li>InnoDB使用表的主键构造主键索引树，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用链表连接，按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。</li>
<li>对于InnoDB来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引。如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。<h4 id="②二级索引（非聚集索引）"><a href="#②二级索引（非聚集索引）" class="headerlink" title="②二级索引（非聚集索引）"></a>②二级索引（非聚集索引）</h4></li>
</ol>
<ul>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p>
<h3 id="3-按字段特性-逻辑上"><a href="#3-按字段特性-逻辑上" class="headerlink" title="3. 按字段特性 逻辑上"></a>3. 按字段特性 逻辑上</h3><h4 id="①主键索引："><a href="#①主键索引：" class="headerlink" title="①主键索引："></a>①主键索引：</h4><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p>
<h4 id="②唯一索引："><a href="#②唯一索引：" class="headerlink" title="②唯一索引："></a>②唯一索引：</h4><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p>
<p>索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一约束的列可以为null且可以存在多个null值。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。</p>
<h4 id="③普通索引："><a href="#③普通索引：" class="headerlink" title="③普通索引："></a>③普通索引：</h4><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p>
<h4 id="④前缀索引"><a href="#④前缀索引" class="headerlink" title="④前缀索引"></a>④前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。<br><strong>注意点</strong><br>创建前缀索引的关键在于选择足够长的前缀来保证一个高的区分度，否则会导致增加扫描磁盘的次数。<br><strong>所以使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询 ，</strong>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用 前缀索引时需要考虑的一个因素。</p>
<ul>
<li>建立前缀索引的方式：<ul>
<li>建立索引时关注的是区分度，区分度越高越好。依次选取不同长度的前缀来看这个值<blockquote>
<p><strong>遇到前缀的区分 度不够好的情况时，我们要怎么办呢？</strong><br>倒序存储和hash：都不支持范围查询<br>mysql&gt; select field_list from t where id_card = reverse(‘input_id_card_string’);<br>mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);<br>mysql&gt; select field_list from t where id_card_crc=crc32(‘input_id_card_string’) and id_c</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而<br>hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是<br>不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>
<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而<br>hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来<br>看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>
<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来<br>的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。<br>而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-按字段个数分类"><a href="#4-按字段个数分类" class="headerlink" title="4. 按字段个数分类"></a>4. 按字段个数分类</h3><h4 id="①单列索引：建立在单列上的"><a href="#①单列索引：建立在单列上的" class="headerlink" title="①单列索引：建立在单列上的"></a>①单列索引：建立在单列上的</h4><h4 id="②联合索引：建立在多列上的。通过将多个字段组合成一个索引，该索引就被称为联合索引。"><a href="#②联合索引：建立在多列上的。通过将多个字段组合成一个索引，该索引就被称为联合索引。" class="headerlink" title="②联合索引：建立在多列上的。通过将多个字段组合成一个索引，该索引就被称为联合索引。"></a>②联合索引：建立在多列上的。通过将多个字段组合成一个索引，该索引就被称为联合索引。</h4><p>详细内容通过将多个字段组合成一个索引，该索引就被称为联合索引。比如将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name)，创建联合索引的方式如下：<br>CREATE INDEX index_product_no_name ON product(product_no, name);<br>联合索引(product_no, name) 的 B+Tree 示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842702988-b963356c-c5e5-47fc-a096-211a79ad91d1.png#averageHue=%23f9efd7&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=EgeFl&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=571&amp;originWidth=1141&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=178606&amp;status=done&amp;style=none&amp;taskId=ud8ee1b52-f732-488e-ae5f-11eaff615ee&amp;title=" alt="image.png"><br>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。<br>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。<br>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a=1；</li>
<li>where a=1 and b=2 and c=3；</li>
<li>where a=1 and b=2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。<br>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b=2；</li>
<li>where c=3；</li>
<li>where b=2 and c=3；</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。<br>我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842703024-46c88550-b84a-463e-92a5-d67fa119ee77.png#averageHue=%23fbf2db&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=gqjsz&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=902&amp;originWidth=1848&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=282385&amp;status=done&amp;style=none&amp;taskId=uf611e3a1-2117-4d08-9be3-3cd4a22c046&amp;title=" alt="image.png"><br>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行where b = 2这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的 key 是有序的</strong>。<br>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行where a = 2 and b = 7是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。<br>但是，如果执行where a &gt; 1 and b = 2时，a 字段能用到联合索引，而 b 字段用不到联合索引。<strong>因为 a 的值此时是一个范围，不是固定的，在这个范围内 b 值不是有序的，因此 b 字段用不上联合索引</strong>。<br>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（&gt;、&lt;、between、like 包括like ‘林%’这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引</strong>。<br>现在我们知道，对于联合索引（a, b），在执行 select * from table where a &gt; 1 and b = 2 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p>
<ul>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
<p>当你的查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。<br>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。<br>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842702931-653e25d7-fc72-475e-a58f-7e13f6500458.png#averageHue=%23f2f2f2&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=VIc7l&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=282&amp;originWidth=922&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58940&amp;status=done&amp;style=none&amp;taskId=u2ea74050-8e8c-4dd2-8f02-9e528e6dea2&amp;title=" alt="image.png"><br>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。<br>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。<br>这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？<br>select * from order where status = 1 order by create_time asc<br>有的同学会认为，单独给 status 建立一个索引就可以了。<br>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。<br>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。<br>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。<br>注意事项：在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。<br>具体原因为:<br>MySQL使用索引时需要索引有序，如建立了”name，age，school”的联合索引，索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。<br>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。<br>优点：前缀索引能使索引更小，更快的有效办法。<br>缺点：mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p>大家好，我是小林。<br>当我们对一张数据表中的记录进行统计的时候，习惯都会使用 count 函数来统计，但是 count 函数传入的参数有很多种，比如 count(1)、count(<em>)、count(字段) 等。<br>到底哪种效率是最好的呢？是不是 count(</em>) 效率最差？<br>我曾经以为 count(<em>) 是效率最差的，因为认知上 selete </em> from t 会读取所有表中的字段，所以凡事带有 * 字符的就觉得会读取表中所有的字段，当时网上有很多博客也这么说。<br>但是，当我深入 count 函数的原理后，被啪啪啪的打脸了！<br>不多说， 发车！<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842414078-ad94ee61-a618-4303-aba8-eca79eb223bc.png#averageHue=%23f8f8f7&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=276&amp;id=u6e582a58&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=623&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103583&amp;status=done&amp;style=none&amp;taskId=u5969652a-078d-479d-a5a9-6a8bef5127b&amp;title=&amp;width=478.00006103515625" alt="image.png"></p>
<h3 id="哪种-count-性能最好？"><a href="#哪种-count-性能最好？" class="headerlink" title="哪种 count 性能最好？"></a>哪种 count 性能最好？</h3><p>哪种 count 性能最好？<br>我先直接说结论：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842414091-725b61d9-1886-4ca2-b54e-8d6b4ea84f8d.png#averageHue=%23f2da91&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=150&amp;id=u516c9b81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=307&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=108457&amp;status=done&amp;style=none&amp;taskId=udd1bc8cc-e941-4ae3-b49d-8935edabe75&amp;title=&amp;width=529.0000610351562" alt="image.png"><br>要弄明白这个，我们得要深入 count 的原理，以下内容基于常用的 innodb 存储引擎来说明。<br>count() 是什么？<br>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。<br>假设 count() 函数的参数是字段名，如下：<br>select count(name) from t<em>order;<br>这条语句是统计「 t_order 表中，name 字段不为 NULL 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。<br>再来假设 count() 函数的参数是数字 1 这个表达式，如下：<br>select count(1) from t_order;<br>这条语句是统计「 t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。<br>1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录。<br>count(主键字段) 执行过程是怎样的？<br>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。<br>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。<br>InnoDB 是通过 B+ 树来保持记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。<br>用下面这条语句作为例子：<br>//id 为主键值 select count(id) from t_order;<br>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842414110-6ce265d9-3be2-43c7-a080-9681b618ff71.png#averageHue=%23f2f1f1&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=u9143c6f2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=128541&amp;status=done&amp;style=none&amp;taskId=ub7cb14ac-f6c0-4af2-8676-83a02799457&amp;title=&amp;width=619.0000610351562" alt="image.png"><br>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842414082-8b0dc675-e43f-40d0-9e2c-5819ed3f0af2.png#averageHue=%23f2efef&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=145&amp;id=u242706c2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=286&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101920&amp;status=done&amp;style=none&amp;taskId=u9b6468b0-e9c5-4d09-ab16-0006ab6a280&amp;title=&amp;width=548.0000610351562" alt="image.png"><br>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。<br>count(1) 执行过程是怎样的？<br>用下面这条语句作为例子：<br>select count(1) from t_order;<br>如果表里只有主键索引，没有二级索引时。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842414098-f818e8ee-5490-45b0-b1e3-5ba2c9a7bdd6.png#averageHue=%23f2f1f1&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u194634e7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113469&amp;status=done&amp;style=none&amp;taskId=u8e8842e0-8170-463d-83bf-90272280008&amp;title=" alt="image.png"><br>那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。<br>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。<br>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842416922-6b2d63c5-7a1b-4de5-b292-4d7c734352bf.png#averageHue=%23f3f1f1&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u640dacd9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=311&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=111287&amp;status=done&amp;style=none&amp;taskId=u009c07a4-0d16-405b-a3a7-5b7026bacae&amp;title=" alt="image.png"><br>count(<em>) 执行过程是怎样的？<br>看到 </em> 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？<br>对于 selete <em> 这条语句来说是这个意思，但是在 count(</em>) 中并不是这个意思。<br><strong>count(*) 其实等于 count(0)</strong>，也就是说，当你使用 count(<em>) 时，MySQL 会将 </em> 参数转化为参数 0 来处理。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842416927-ad250896-5cd0-4d54-b75d-334fe23ed390.png#averageHue=%23f6efee&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0e3046c0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=320&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=109823&amp;status=done&amp;style=none&amp;taskId=u78f5fe92-d7ea-40ec-b433-41495cc0a0e&amp;title=" alt="image.png"><br>所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。<br>在 MySQL 5.7 的官方手册中有这么一句话：<br>_InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</em><br><em>翻译：InnoDB以相同的方式处理SELECT COUNT（*）和SELECT COUNT（1）操作，没有性能差异。</em><br>而且 MySQL 会对 count(<em>) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。<br>只有当没有二级索引的时候，才会采用主键索引来进行统计。<br>count(字段) 执行过程是怎样的？<br>count(字段) 的执行效率相比前面的 count(1)、 count(</em>)、 count(主键字段) 执行效率是最差的。<br>用下面这条语句作为例子：<br>// name不是索引，普通字段 select count(name) from t_order;<br>对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842416941-c4ca29ec-d549-4c8b-bbcf-efe6203aad07.png#averageHue=%23f6f5f4&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u14aba4e4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=105014&amp;status=done&amp;style=none&amp;taskId=ufd63fcdf-af06-4553-97e0-d4afebe1dea&amp;title=" alt="image.png"><br>小结<br>count(1)、 count(<em>)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。<br>所以，如果要执行 count(1)、 count(</em>)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。<br>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<h3 id="为什么要通过遍历的方式来计数？"><a href="#为什么要通过遍历的方式来计数？" class="headerlink" title="为什么要通过遍历的方式来计数？"></a>为什么要通过遍历的方式来计数？</h3><p>你可以会好奇，为什么 count 函数需要通过遍历的方式来统计记录个数？<br>我前面将的案例都是基于 Innodb 存储引擎来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。<br>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。<br>而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。<br>举个例子，假设表 t_order 有 100 条记录，现在有两个会话并行以下语句：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842417016-24146a37-1897-40e8-8930-43fa60409610.png#averageHue=%23eee6d4&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=333&amp;id=u2858823e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=654&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=133834&amp;status=done&amp;style=none&amp;taskId=uee009949-4ea1-4022-881f-26cbd7c9256&amp;title=&amp;width=550.0000610351562" alt="image.png"><br>在会话 A 和会话 B的最后一个时刻，同时查表 t_order 的记录总个数，可以发现，显示的结果是不一样的。所以，在使用 InnoDB 存储引擎时，就需要扫描表来统计具体的记录。<br>而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。</p>
<h3 id="如何优化-count-？"><a href="#如何优化-count-？" class="headerlink" title="如何优化 count(*)？"></a>如何优化 count(*)？</h3><p>如果对一张大表经常用 count(<em>) 来做统计，其实是很不好的。<br>比如下面我这个案例，表 t_order 共有 1200+ 万条记录，我也创建了二级索引，但是执行一次 select count(</em>) from t_order 要花费差不多 5 秒！<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842416965-64b71028-0ddb-4eba-8368-bd3fc2722301.png#averageHue=%23f8f6f6&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u8bb0f151&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=428&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=102223&amp;status=done&amp;style=none&amp;taskId=uf51eeb52-12e6-44dd-8c8d-d522f9b9e63&amp;title=" alt="image.png"><br>面对大表的记录统计，我们有没有什么其他更好的办法呢？<br>第一种，近似值<br>如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842419143-13e55387-90ad-4347-8a66-01804f67a325.png#averageHue=%23fefbfb&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9cc05a8b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=148969&amp;status=done&amp;style=none&amp;taskId=ub9c99a61-509f-456c-97f7-818ec341a27&amp;title=" alt="image.png"><br>这时，我们就可以使用 show table status 或者 explain 命令来表进行估算。<br>执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659842419175-21f937db-a7be-40e7-a3bc-a7693b3c44de.png#averageHue=%23f7f5f4&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ueb59b3d3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=604&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=150700&amp;status=done&amp;style=none&amp;taskId=ueed8ee70-c3d9-46cf-986a-23b6c5e7004&amp;title=" alt="image.png"><br>第二种，额外表保存计数值<br>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。<br>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/09/MySQL/%E7%B4%A2%E5%BC%95%E7%AF%87/">http://example.com/2022/08/09/MySQL/%E7%B4%A2%E5%BC%95%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Ⅰ索引基础面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">①什么是索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">②索引的三种常见底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">a:哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">b:有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E6%A0%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">c:树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">③索引的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">④索引的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81-%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">⑤什么情况下需要&#x2F;不需要建索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.6.</span> <span class="toc-text">⑥索引的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">1.7.</span> <span class="toc-text">⑦索引什么时候会失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1%E7%B4%A2%E5%BC%95%E6%8B%93%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">Ⅱ索引拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.</span> <span class="toc-text">①覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">2.2.</span> <span class="toc-text">②索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">③什么是最左匹配原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">④有什么优化索引的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.1.</span> <span class="toc-text">前缀索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.2.</span> <span class="toc-text">覆盖索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E6%98%AF%E8%87%AA%E5%A2%9E%E7%9A%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">主键索引最好是自增的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E8%AE%BE%E7%BD%AE%E4%B8%BA-NOT-NULL"><span class="toc-number">2.4.4.</span> <span class="toc-text">索引最好设置为 NOT NULL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">2.4.5.</span> <span class="toc-text">防止索引失效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A4%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E9%80%89"><span class="toc-number">3.</span> <span class="toc-text">⑤普通索引和唯一索引怎么选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%8A%E2%85%A2MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">✊ⅢMySQL中的索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">1. 按数据结构分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">①哈希索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%8A%E2%91%A1B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">✊②B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E6%A0%91%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">b+树相关面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A"><span class="toc-number">4.3.</span> <span class="toc-text">数据如何存储在磁盘上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.</span> <span class="toc-text">多级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-way-search-tree"><span class="toc-number">4.5.</span> <span class="toc-text">M-way search tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2Full-text-%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">③Full-text 索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%89%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB"><span class="toc-number">4.6.</span> <span class="toc-text">2. 按物理存储分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.1.</span> <span class="toc-text">①聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">4.6.2.</span> <span class="toc-text">②二级索引（非聚集索引）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%89%E5%AD%97%E6%AE%B5%E7%89%B9%E6%80%A7-%E9%80%BB%E8%BE%91%E4%B8%8A"><span class="toc-number">4.7.</span> <span class="toc-text">3. 按字段特性 逻辑上</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">4.7.1.</span> <span class="toc-text">①主键索引：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">4.7.2.</span> <span class="toc-text">②唯一索引：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">4.7.3.</span> <span class="toc-text">③普通索引：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">4.7.4.</span> <span class="toc-text">④前缀索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB"><span class="toc-number">4.8.</span> <span class="toc-text">4. 按字段个数分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9C%A8%E5%8D%95%E5%88%97%E4%B8%8A%E7%9A%84"><span class="toc-number">4.8.1.</span> <span class="toc-text">①单列索引：建立在单列上的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9C%A8%E5%A4%9A%E5%88%97%E4%B8%8A%E7%9A%84%E3%80%82%E9%80%9A%E8%BF%87%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%BB%84%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%AF%A5%E7%B4%A2%E5%BC%95%E5%B0%B1%E8%A2%AB%E7%A7%B0%E4%B8%BA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E3%80%82"><span class="toc-number">4.8.2.</span> <span class="toc-text">②联合索引：建立在多列上的。通过将多个字段组合成一个索引，该索引就被称为联合索引。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">count(*) 和 count(1) 有什么区别？哪个性能最好？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E7%A7%8D-count-%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">哪种 count 性能最好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%9A%E8%BF%87%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AE%A1%E6%95%B0%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么要通过遍历的方式来计数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-count-%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">如何优化 count(*)？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-1"><span class="toc-number"></span> <span class="toc-text"> </span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/" title="过期删除策略与内存淘汰篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="过期删除策略与内存淘汰篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/" title="过期删除策略与内存淘汰篇">过期删除策略与内存淘汰篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>