<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>锁篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="锁篇">
<meta property="og:type" content="article">
<meta property="og:title" content="锁篇">
<meta property="og:url" content="http://fetterslove.github.io/2022/08/09/MySQL/%E9%94%81%E7%AF%87/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="锁篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:24:40.488Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://fetterslove.github.io/2022/08/09/MySQL/%E9%94%81%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '锁篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-13 22:24:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/xxx.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">锁篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:24:40.488Z" title="更新于 2022-11-13 22:24:40">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="锁篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Ⅰ锁的划分"><a href="#Ⅰ锁的划分" class="headerlink" title="Ⅰ锁的划分"></a>Ⅰ锁的划分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649829094741-2ec90a4a-4a9d-4a12-8f39-d87523a27741.png#averageHue=%23fbfbfb&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=723&amp;id=fToOy&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=904&amp;originWidth=714&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2586998&amp;status=done&amp;style=none&amp;taskId=ub9ed9fbf-fbce-4da1-bc48-5daa2548b0e&amp;title=&amp;width=571.2" alt="image.png"></p>
<h3 id="一、从数据操作的类型划分：读锁、写锁"><a href="#一、从数据操作的类型划分：读锁、写锁" class="headerlink" title="一、从数据操作的类型划分：读锁、写锁"></a>一、从数据操作的类型划分：读锁、写锁</h3><p>读锁：也称为共享锁、英文用S(shared lock) 表示。针对同一份数据，多个事务的读操作可以同时进行而不会相互阻塞的。<br>写锁：也称为排他锁、英文用X (exclusive lock)表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。<br>需要注意的是对于InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
<h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649829348269-cf855e1a-79f0-4ffb-9267-cea027d44e59.png#averageHue=%23eae3d7&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=436&amp;id=JiDps&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=545&amp;originWidth=783&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=356584&amp;status=done&amp;style=none&amp;taskId=u0c3c1117-7021-4212-8e8f-1bbe71a4e40&amp;title=&amp;width=626.4" alt="image.png"></p>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649829470106-52d9d9bc-7ea2-482d-91e9-27923bb1e111.png#averageHue=%23ebe6de&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=355&amp;id=FhWJU&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=444&amp;originWidth=790&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=310271&amp;status=done&amp;style=none&amp;taskId=u4c18a62c-d36f-494d-bfc1-f5c82e55352&amp;title=&amp;width=632" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649829476734-1ff5c49f-9751-49a0-8df1-741301c92a39.png#averageHue=%23f6f6f5&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=75&amp;id=gXVsL&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=94&amp;originWidth=778&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43132&amp;status=done&amp;style=none&amp;taskId=ud2c86a54-86ff-4ef9-ade6-54b371575cf&amp;title=&amp;width=622.4" alt="image.png"></p>
<h3 id="二、根据加锁的粒度或者范围"><a href="#二、根据加锁的粒度或者范围" class="headerlink" title="二、根据加锁的粒度或者范围"></a>二、根据加锁的粒度或者范围</h3><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659853430118-21d8ad34-fb03-4ae1-90af-894fee6ee0e7.png#averageHue=%23f8f5f3&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=427&amp;id=Hs04L&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=589&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=141370&amp;status=done&amp;style=none&amp;taskId=u95634d98-4373-484c-80e1-7d9625c3dc5&amp;title=&amp;width=522.0000610351562" alt="image.png"></p>
<h4 id="①全局锁"><a href="#①全局锁" class="headerlink" title="①全局锁"></a>①全局锁</h4><p>全局锁是怎么用的？<br>要使用全局锁，则要执行这条命：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock </span><br></pre></td></tr></table></figure><br>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables </span><br></pre></td></tr></table></figure><br>当然，当会话断开了，全局锁会被自动释放。<br>全局锁应用场景是什么？<br>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<p>举个例子大家就知道了。</p>
<p>在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。<br>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更新，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。<br>那么，有可能出现这样的顺序：</p>
<ol>
<li>先备份了用户表的数据；</li>
<li>然后有用户发起了购买商品的操作；</li>
<li>接着再备份商品表的数据。</li>
</ol>
<p>也就是在备份用户表和商品表之间，有用户购买了商品。</p>
<p>这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。</p>
<p>所以，在全库逻辑备份期间，加上全局锁，就不会出现上面这种情况了。<br>加全局锁又会带来什么缺点呢？<br>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。<br>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？<br>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h4 id="②表级锁"><a href="#②表级锁" class="headerlink" title="②表级锁"></a>②表级锁</h4><p>MySQL 表级锁有哪些？具体怎么用的。<br>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；<h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5>先来说说<strong>表锁</strong>。<br>该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎，并且表锁是开销最小的策略（因为锁的粒度比较大）。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来的最大的问题就是出现锁资源争用的概念也会最高，导致并发率大大下降<br>LOCK TABLES t READ ：InnoDB存储引擎会对表t 加表级别的S锁。<br>LOCK TABLES t WRITE ：InnoDB存储引擎会对表t 加表级别的X锁。</li>
</ul>
<hr>
<p>详细内容如果我们想对学生表（t_student）加表锁，可以使用下面的命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表级别的共享锁，也就是读锁；</span></span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表级别的独占锁，也就是写锁；</span></span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure><br>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：<br>unlock tables<br>另外，当会话退出后，也会释放所有表锁。<br>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p>
<h5 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h5><p>再来说说<strong>元数据锁</strong>（MDL）。</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
<blockquote>
<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。<br>MDL 不需要显示调用，那它是在什么时候释放的?<br>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。<br>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？<br>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
</blockquote>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而<strong>意向锁</strong>就是其中的一种表锁。</p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>意向锁分为两种：<br><strong>意向共享锁</strong>（intention shared lock,<strong> IS</strong>）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）<br> — 事务要获取某些行的S 锁，必须先获得表的IS 锁。<br>SELECT column FROM table … LOCK IN SHARE MODE;<br><strong>意向排他锁</strong>（intention exclusive lock, <strong>IX</strong>）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）<br> — 事务要获取某些行的X 锁，必须先获得表的IX 锁。<br>SELECT column FROM table … FOR UPDATE;<br>即：意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/ 排他锁之前，<br>InooDB 会先获取该数据行所在数据表的对应意向锁。</p>
<hr>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span></span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span></span><br><span class="line">select ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><br><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<em>lock tables … read</em>）和独占表锁（<em>lock tables … write</em>）发生冲突。</strong></p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h5 id="AUTO-INC（自增）-锁"><a href="#AUTO-INC（自增）-锁" class="headerlink" title="AUTO-INC（自增） 锁"></a>AUTO-INC（自增） 锁</h5><p>最后，说说 <strong>AUTO-INC 锁</strong>。</p>
<p>在为某个字段声明 AUTO_INCREMENT 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。<br>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。<br>一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。<br>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；</li>
<li>当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；</li>
<li>当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li>
</ul>
<p>不过，当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p>
<h4 id="③行级锁"><a href="#③行级锁" class="headerlink" title="③行级锁"></a>③行级锁</h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。<br>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<p>前面也提到，普通的 select 语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用下面这两个方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对读取的记录加共享锁</span></span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读取的记录加独占锁</span></span><br><span class="line">select ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><br>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。</p>
<hr>
<p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎实现。<br>优点：锁粒度小，发生锁冲突概率低，可以实现的并发度高。<br>缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。<br>Innodb于myisam最大不同有两点：一是支持事务，二是采用了行级锁。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830350469-6d45120a-e94c-4c3e-bcda-ce5101a80813.png#averageHue=%23f5f3ec&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=166&amp;id=Qjmio&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=207&amp;originWidth=301&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43900&amp;status=done&amp;style=none&amp;taskId=ua439e2c2-4b49-4d68-92f6-c872725b156&amp;title=&amp;width=240.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830357940-8b88baa3-3883-4604-a047-f0160b352bab.png#averageHue=%23f5f4f1&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=359&amp;id=To3FE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=487&amp;originWidth=434&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113075&amp;status=done&amp;style=none&amp;taskId=u1e324dfc-11c2-4020-9734-8e55f7b0466&amp;title=&amp;width=320.1999969482422" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830375901-a18f8fb1-2df7-4160-a76d-dd19a2a7ade3.png#averageHue=%23fafafa&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=151&amp;id=oitpy&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=189&amp;originWidth=794&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50390&amp;status=done&amp;style=none&amp;taskId=u721a0cb7-3a2a-448e-9ba9-fbfb1aba569&amp;title=&amp;width=635.2" alt="image.png"></p>
<h5 id="1-记录锁（Record-Locks）"><a href="#1-记录锁（Record-Locks）" class="headerlink" title="1. 记录锁（Record Locks）"></a>1. 记录锁（Record Locks）</h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830412355-5d3a37b1-d9df-4240-a640-6d27c1cdf91d.png#averageHue=%23d1d8ba&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=179&amp;id=uxVPT&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=224&amp;originWidth=690&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=619559&amp;status=done&amp;style=none&amp;taskId=u03210215-0698-4a5b-8b2d-ce3394d6f9f&amp;title=&amp;width=552" alt="image.png"><br>举例如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830423704-94ae6b79-0fea-400f-9ef8-943cda7fc82d.png#averageHue=%23f4f4f4&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=294&amp;id=YPdJE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=368&amp;originWidth=732&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1079704&amp;status=done&amp;style=none&amp;taskId=u2e32c06d-4f82-4d55-9dbc-a13211d4018&amp;title=&amp;width=585.6" alt="image.png"><br>记录锁是有S锁和X锁之分的，称之为S型记录锁和X型记录锁。<br>不同的记录之间是不冲突的。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可  以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不  可以继续获取X型记录锁。<h5 id="2-间隙锁（Gap-Locks）"><a href="#2-间隙锁（Gap-Locks）" class="headerlink" title="2. 间隙锁（Gap Locks）"></a>2. 间隙锁（Gap Locks）</h5>MySQL 在REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC 方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为：LOCK_GAP ，我们可以简称为gap锁。比如，把id值为8的那条记录加一个gap锁的示意图如下。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830540923-edb07c7f-cc1e-420a-af4e-537e9c5245e9.png#averageHue=%23e5ceab&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=yLs6S&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=359&amp;originWidth=856&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=156623&amp;status=done&amp;style=none&amp;taskId=uff42f499-2e48-447c-b451-99a7f94328c&amp;title=&amp;width=684.8" alt="image.png"><br>图中id值为8的记录加了gap锁，意味着不允许别的事务在id值为8的记录前边的间隙插入新记录，其实就是id列的值(3,   8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入   操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。<br>gap锁的提出仅仅是为了防止插入幻影记录而提出的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830640521-599370a6-d6eb-4870-8743-7c1d60af73e3.png#averageHue=%23f8f8f8&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=kZH3k&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=237&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=721971&amp;status=done&amp;style=none&amp;taskId=uf4ccd3cc-dddc-4668-9766-29ae10cfeac&amp;title=&amp;width=608" alt="image.png"><br>如果再开一个会话，在3-8之间添加数据会阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830677615-716a81eb-4eb7-4a21-a5d5-ab2936787600.png#averageHue=%230c0c0c&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=127&amp;id=gyBU1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=159&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=484402&amp;status=done&amp;style=none&amp;taskId=u8ca1626d-70c5-4c6d-aea1-c842f009d00&amp;title=&amp;width=608" alt="image.png"><h5 id="3-临键锁（Next-Key-Locks）"><a href="#3-临键锁（Next-Key-Locks）" class="headerlink" title="3. 临键锁（Next-Key Locks）"></a>3. 临键锁（Next-Key Locks）</h5>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB就提出了一种称之为Next-Key Locks 的锁，官方的类型名称为：LOCK_ORDINARY ，我们也可以简称为next-key锁。Next-Key Locks是在存储引擎innodb 、事务级别在可重复读的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649830727494-d406c472-6063-4c8e-8e9b-57af1d10bbf5.png#averageHue=%23f2f1eb&amp;clientId=u20113b0d-de5a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=fQ956&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=333&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1014384&amp;status=done&amp;style=none&amp;taskId=u86e59688-923b-48da-8952-3a7122732a4&amp;title=&amp;width=608" alt="image.png"><br>begin;<br>select * from student where id &lt;=8 and id &gt; 3 for update;<h5 id="4-插入意向锁（Insert-Intention-Locks）"><a href="#4-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="4. 插入意向锁（Insert Intention Locks）"></a>4. 插入意向锁（Insert Intention Locks）</h5>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁（next-key锁<br>也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert<br>操作时产生。<h4 id="④页锁"><a href="#④页锁" class="headerlink" title="④页锁"></a>④页锁</h4>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销  介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong><br>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。<h3 id="三、从对待锁的态度划分-乐观锁、悲观锁"><a href="#三、从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="三、从对待锁的态度划分:乐观锁、悲观锁"></a>三、从对待锁的态度划分:乐观锁、悲观锁</h3>乐观锁与悲观锁<br>为什么需要锁<br>在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&amp;spm=1001.2101.3001.7020">乐观锁</a>和悲观锁，可以在一定程度上解决并发访问。<h4 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1. 悲观锁（Pessimistic Locking）"></a>1. 悲观锁（Pessimistic Locking）</h4>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身  的锁机制来实现，从而保证数据操作的排它性。<br>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上   锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当   其他线程想要访问数据时，都需要阻塞挂起。Java中synchronized 和ReentrantLock 等独占锁就是悲观锁思想的实现。<h4 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2. 乐观锁（Optimistic Locking）"></a>2. 乐观锁（Optimistic Locking）</h4>先进行业务操作，不到最后一步不进行加锁，乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新   的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用版本号机制或者CAS机制实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。<h5 id="①乐观锁的版本号机制"><a href="#①乐观锁的版本号机制" class="headerlink" title="①乐观锁的版本号机制"></a>①乐观锁的版本号机制</h5>在表中设计一个版本字段version ，第一次读的时候，会获取version 字段的取值。然后对数据进行更新或删除操作时，会执行UPDATE … SET version=version+1 WHERE version=version 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</li>
</ul>
<h5 id="②乐观锁的时间戳机制"><a href="#②乐观锁的时间戳机制" class="headerlink" title="②乐观锁的时间戳机制"></a>②乐观锁的时间戳机制</h5><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行  比较，如果两者一致则更新成功，否则就是版本冲突。<br>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或  者时间戳），从而证明当前拿到的数据是否最新。</p>
<h4 id="3-两种锁的适用场景"><a href="#3-两种锁的适用场景" class="headerlink" title="3. 两种锁的适用场景"></a>3. 两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ol>
<li>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读- 写和写- 写的冲突。</li>
</ol>
<h2 id="ⅡMySQL-是怎么加锁的？"><a href="#ⅡMySQL-是怎么加锁的？" class="headerlink" title="ⅡMySQL 是怎么加锁的？"></a>ⅡMySQL 是怎么加锁的？</h2><p>大家好，我是小林。<br>在前一篇文章我讲了下 MySQL 的全局锁、表级锁和行级别锁，其中行级锁只提了概念，并没有具体说。<br>因为行级锁加锁规则比较复杂，不同的场景，加锁的形式还不同，所以这次就来好好介绍下行级锁。<br>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。<br>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。<br>那到底是什么场景呢？今天，我们就以下面这个表来进行实验说明。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855594616-1f16a47b-1a8d-45f0-97da-cc10a0ca0884.png#averageHue=%23fbfbfb&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1d1032b9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=143&amp;originWidth=336&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3971&amp;status=done&amp;style=none&amp;taskId=u238ec4fb-470b-496d-8c98-e52fa6deca9&amp;title=" alt="image.png"><br>其中，id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。<br>注意，<strong>我的 MySQL 的版本是 8.0.26，不同版本的加锁规则可能是不同的</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855594667-c7429579-fd1b-4303-9753-d70756ea1b22.png#averageHue=%23f7f6f5&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=510&amp;id=uf17e1194&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=888&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94391&amp;status=done&amp;style=none&amp;taskId=u505d5471-b7e6-4b4f-98d7-ab97058551a&amp;title=&amp;width=620.0000610351562" alt="image.png"></p>
<h3 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h3><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p>
<ul>
<li><strong>当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」</strong>。</li>
<li><strong>当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」</strong>。</li>
</ul>
<p>接下里用两个案例来说明。<br>先看看记录是存在的。<br>来看下面这个例子：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855594684-704ef3de-426d-4661-88e7-a8f16880b9ad.png#averageHue=%23f1e6c0&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u19d3ca07&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=482&amp;originWidth=947&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52323&amp;status=done&amp;style=none&amp;taskId=u87bb7e4b-814b-4ef9-b781-513ddc26bc9&amp;title=" alt="image.png"><br>会话1加锁变化过程如下：</p>
<ol>
<li>加锁的基本单位是 next-key lock，因此会话1的加锁范围是(8, 16];</li>
<li>但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 <strong>next-key lock 退化成记录锁，因此最终加锁的范围是 id = 16 这一行</strong>。</li>
</ol>
<p>所以，会话 2 在修改 id=16 的记录时会被锁住，而会话 3 插入 id=9 的记录可以被正常执行。<br>接下来，看看记录不存在的情况<br>来看看，下面这个例子：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855594554-fb7605ef-3333-4064-9d16-ebcc65c8b43d.png#averageHue=%23ece1bc&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2f43eeca&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=482&amp;originWidth=947&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58828&amp;status=done&amp;style=none&amp;taskId=u25d5518e-3520-4560-9a92-2cef69251bc&amp;title=" alt="image.png"><br>会话1加锁变化过程如下：</p>
<ol>
<li>加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是(8, 16];</li>
<li>但是由于查询记录不存在，next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。</li>
</ol>
<p>所以，会话 2 要往这个间隙里面插入 id=9 的记录会被锁住，但是会话 3 修改 id =16 是可以正常执行的，因为 id = 16 这条记录并没有加锁。</p>
<h3 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h3><p>范围查询和等值查询的加锁规则是不同的。<br>举个例子，下面这两条查询语句，查询的结果虽然是一样的，但是加锁的范围是不一样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t_test where id=<span class="number">8</span> <span class="keyword">for</span> update;</span><br><span class="line">select * from t_test where id&gt;=<span class="number">8</span> and id&lt;<span class="number">9</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><br>做个实验就知道了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855594649-26a6ba72-dfd1-46eb-9e8a-ddc3d27581aa.png#averageHue=%23e9ddba&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udf55eed2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79381&amp;status=done&amp;style=none&amp;taskId=u93dc5b6d-868a-45cf-a349-c1842ff6eb5&amp;title=" alt="image.png"><br>会话 1 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id = 8，因此 next-key lock(4,8]，但是由于 id 是唯一索引，且该记录是存在的，因此会退化成记录锁，也就是只会对 id = 8 这一行加锁；</li>
<li>由于是范围查找，就会继续往后找存在的记录，也就是会找到 id = 16 这一行停下来，然后加 next-key lock (8, 16]，但由于 id = 16 不满足 id &lt; 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。</li>
</ol>
<p>所以，会话 1 这时候主键索引的锁是记录锁 id=8 和间隙锁(8, 16)。<br>会话 2 由于往间隙锁里插入了 id = 9 的记录，所以会被锁住了，而 id = 8 是被加锁的，因此会话 3 的语句也会被阻塞。<br>由于 id = 16 并没有加锁，所以会话 4 是可以正常被执行。</p>
<h3 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h3><p>当我们用非唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p>
<ul>
<li><strong>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁</strong>。</li>
<li><strong>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</strong></li>
</ul>
<p>接下里用两个案例来说明。<br>我们先来看看查询的值存在的情况。<br>比如下面这个例子：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855596108-3aac9a05-5789-4c37-87c1-ab17430b6f1f.png#averageHue=%23f8f2f0&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=436&amp;id=u039c4e54&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=804&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=106822&amp;status=done&amp;style=none&amp;taskId=ub499ad59-de6c-46c9-9ff3-1220e84718d&amp;title=&amp;width=586.0000610351562" alt="image.png"><br>会话 1 加锁变化过程如下：</p>
<ol>
<li>先会对普通索引 b 加上 next-key lock，范围是(4,8];</li>
<li>然后因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。</li>
</ol>
<p>所以，会话1的普通索引 b 上共有两个锁，分别是 next-key lock (4,8] 和间隙锁 (8,16) 。<br>那么，当会话 2 往间隙锁里插入 id = 9 的记录就会被锁住，而会话 3 和会话 4 是因为更改了 next-key lock 范围里的记录而被锁住的。<br>然后因为 b = 16 这条记录没有加锁，所以会话 5 是可以正常执行的。</p>
<blockquote>
<p><strong>TIP</strong><br>之前有读者反馈说，他自己做实验，发现插入 b = 4 这条记录会被阻塞，和我说的 next-key lock (4,8] 有点矛盾。<br>其实测试锁的范围是开区间还是闭区间不能用 insert 语句测试，而是要用 update 语句去测试。<br>因为 insert 加的锁是比较特殊的，<strong>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，那 Insert 语句应该被阻塞，并生成一个插入意向锁</strong>。<br>插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，然后插入意向锁和间隙锁是冲突的，所以插入 b = 4 这条记录就发生阻塞了。具体 insert 语句是怎么加锁的，可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/deadlock.html#insert-%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84">MySQL 死锁了，怎么办？(opens new window)</a><br>而用 update 语句来更新 b = 4 的这条记录，加的是记录锁，你测试的时候，会发现更新 b = 4 的这条记录是能更新成功的，所以 b = 4 这条并没有加锁，因此 next-key lock 的范围是 (4,8] ，是没问题。</p>
</blockquote>
<p>接下来，我们看看查询的值不存在的情况<br>直接看案例：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855596014-20285e30-baff-479f-939b-48f81e205029.png#averageHue=%23e9e4c9&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udeb75707&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=557&amp;originWidth=917&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=129308&amp;status=done&amp;style=none&amp;taskId=u3ec1c347-8acb-4b0b-8f96-382fea33306&amp;title=" alt="image.png"><br>会话 1 加锁变化过程如下：</p>
<ol>
<li>先会对普通索引 b 加上 next-key lock，范围是(8,16];</li>
<li>但是由于查询的记录是不存在的，所以不会再额外加个间隙锁，但是 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。</li>
</ol>
<p>会话 2 因为往间隙锁里插入了 b = 9 的记录，所以会被锁住，而 b = 16 是没有被加锁的，因此会话 3 的语句可以正常执行。</p>
<h3 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h3><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁</strong>。<br>来看下面这个案例：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659855596029-fe82cf15-14bf-4e91-9b81-f844ab0ce931.png#averageHue=%23f6eeeb&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ucd337023&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=678&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98139&amp;status=done&amp;style=none&amp;taskId=uf1154a92-808b-4fad-a01f-330e6b1f9cc&amp;title=" alt="image.png"><br>会话 1 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 b = 8，因此 next-key lock(4,8]，但是由于 b 不是唯一索引，并不会退化成记录锁。</li>
<li>但是由于是范围查找，就会继续往后找存在的记录，也就是会找到 b = 16 这一行停下来，然后加 next-key lock (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。</li>
</ol>
<p>所以，会话 1 的普通索引 b 有两个 next-key lock，分别是 (4,8] 和(8, 16]。这样，你就明白为什么会话 2 、会话 3 、会话 4 的语句都会被锁住了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次我以 <strong><em>MySQL 8.0.26</em></strong> 版本做了几个实验，让大家了解了唯一索引和非唯一索引的行级锁的加锁规则。<br>这里需要注意的是，不同的版本加锁规则可能会有所不同。我这里总结下， 我这个 MySQL 版本的行级锁的加锁规则。<br>唯一索引等值查询：</p>
<ul>
<li>当查询的记录是存在的，next-key lock 会退化成「记录锁」。</li>
<li>当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。</li>
</ul>
<p>非唯一索引等值查询：</p>
<ul>
<li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li>
<li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li>
</ul>
<p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p>
<ul>
<li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。</li>
<li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li>
</ul>
<p>这些加锁规则其实很好总结的，大家自己可以用我文中的案例测试一遍，看一下你的 MySQL 版本和我的 MySQL 版本的加锁规则有什么不同。<br>加锁规则## 加锁规则<br>首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，<strong>这个规则有以下两条前提说明：</strong></p>
<ol>
<li>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13。</li>
<li>如果大家在验证中有发现 bad case 的话，请提出来，我会再补充进这篇文章，使得一起学习本专栏的所有同学都能受益。</li>
</ol>
<p>因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。<br><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol>
<li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p>我还是以上篇文章的表 t 为例，和你解释一下这些规则。表 t 的建表语句和初始化语句如下。<br>复制代码<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651894063125-10dea1b5-ff56-47c4-be61-e0be67d0f186.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=212&amp;id=YyZFH&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=449&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13742&amp;status=done&amp;style=none&amp;taskId=u171b7ba0-fd4e-4c59-a417-e8d0b254a81&amp;title=&amp;width=359.2" alt="image.png"><br>接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能会“毁三观”，也建议你读完文章后亲手实践一下。</p>
<h3 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h3><p>第一个例子是关于等值条件操作间隙：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893901297-3871443c-bf63-4ca9-9db3-a37c1f5912f2.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=gwEtW&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=313&amp;originWidth=936&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31058&amp;status=done&amp;style=none&amp;taskId=ueffd6602-f3fa-485b-b812-4124115716d&amp;title=" alt="image.png"><br>图 1 等值查询的间隙锁<br>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<ol>
<li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li>
<li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li>
</ol>
<p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p>
<h3 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h3><p>第二个例子是关于覆盖索引上的锁：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893901395-7ccd2af9-886a-4687-bf7a-f48a626bc720.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=TqVHV&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=462&amp;originWidth=1244&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50829&amp;status=done&amp;style=none&amp;taskId=u796bb1f5-a9fa-47fd-bd35-ccf80fa7c3c&amp;title=" alt="image.png"><br>图 2 只加在非唯一索引上的锁<br>看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。<br>这里 session A 要给索引 c 上 c=5 的这一行加上读锁。</p>
<ol>
<li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</li>
<li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</li>
<li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</li>
<li>根据原则 2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li>
</ol>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。<br>需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。<br>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c=5 lock in share mode。你可以自己验证一下效果。</p>
<h3 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h3><p>第三个例子是关于范围查询的。<br>举例之前，你可以先思考一下这个问题：对于我们这个表 t，下面这两条查询语句，加锁范围相同吗？<br>复制代码<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651894300946-51e8aa02-f41d-4d99-9146-ba164747cab6.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=56&amp;id=KUudc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=70&amp;originWidth=554&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5444&amp;status=done&amp;style=none&amp;taskId=u6eb3b1f2-6c57-4e36-8107-30b7698b741&amp;title=&amp;width=443.2" alt="image.png"><br>你可能会想，id 定义为 int 类型，这两个语句就是等价的吧？其实，它们并不完全等价。<br>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让 session A 执行第二个查询语句，来看看加锁效果。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893901716-e5797456-47a0-4033-94b7-27e734ee5c81.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=JmHSm&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=718&amp;originWidth=1244&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72388&amp;status=done&amp;style=none&amp;taskId=u8c1d3139-82cb-4538-8277-3422f30d6e2&amp;title=" alt="image.png"><br>图 3 主键索引上范围查询的锁<br>现在我们就用前面提到的加锁规则，来分析一下 session A 会加什么锁呢？</p>
<ol>
<li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li>
<li>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</li>
</ol>
<p>所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果你就能理解了。<br>这里你需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><p>接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。<br>需要注意的是，与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893901712-aba85012-48b7-444f-9e64-85bdb1d0c837.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=wdNiL&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=550&amp;originWidth=1246&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54082&amp;status=done&amp;style=none&amp;taskId=u20e40614-e5f7-4285-ab17-f9dbfd6d09d&amp;title=" alt="image.png"><br>图 4 非唯一索引范围锁<br>这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。<br>所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。<br>这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。</p>
<h3 id="案例五：唯一索引范围锁-bug"><a href="#案例五：唯一索引范围锁-bug" class="headerlink" title="案例五：唯一索引范围锁 bug"></a>案例五：唯一索引范围锁 bug</h3><p>前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中 bug 的案例。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893901721-ed6188ac-7b01-455a-a6c4-bd38a08454c0.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=r79Cw&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=590&amp;originWidth=1250&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57554&amp;status=done&amp;style=none&amp;taskId=ub918bf04-c00a-4c76-be09-16f824fb132&amp;title=" alt="image.png"><br>图 5 唯一索引范围锁的 bug<br>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。<br>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。<br>所以你看到了，session B 要更新 id=20 这一行，是会被锁住的。同样地，session C 要插入 id=16 的一行，也会被锁住。<br>照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个 bug。<br>我也曾找社区的专家讨论过，官方 bug 系统上也有提到，但是并未被 verified。所以，认为这是 bug 这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。</p>
<h3 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h3><p>接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表 t 插入一条新记录。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651894530747-6b6db23d-6fea-4ddf-8bc5-fcd0e0350191.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=30&amp;id=z5fcj&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=38&amp;originWidth=393&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2204&amp;status=done&amp;style=none&amp;taskId=u573e2e40-8804-4cfd-bd8c-26bf968a695&amp;title=&amp;width=314.4" alt="image.png"><br>新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。那么，这时候索引 c 上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893902493-66bed29d-9e69-42fa-a6f0-22d3e1e2a3f0.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=gWKBt&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=856&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72863&amp;status=done&amp;style=none&amp;taskId=ufc3f9b11-495c-4f42-850a-74d493434bd&amp;title=" alt="image.png"><br>图 6 非唯一索引等值的例子<br>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。<br>图中我画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，我用 (c=10,id=30) 这样的形式，来表示索引上的一行。<br>现在，我们来看一下案例六。<br>这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893902726-fee2b240-3946-4ca9-936a-e35b707b1bd6.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=kBluN&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=556&amp;originWidth=1248&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50662&amp;status=done&amp;style=none&amp;taskId=u9130bc78-78dd-4e2e-91a5-bcebf6c42b6&amp;title=" alt="image.png"><br>图 7 delete 示例<br>这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。<br>然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。<br>也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893902804-709f38ae-09df-4aba-813e-9786c1ffd279.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Dhcd0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=856&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=87764&amp;status=done&amp;style=none&amp;taskId=uf41ae9dd-233a-46b1-8b6d-25edd9d36fb&amp;title=" alt="image.png"><br>图 8 delete 加锁效果示例<br>这个蓝色区域左右两边都是虚线，表示开区间，即 (c=5,id=5) 和 (c=15,id=15) 这两行上都没有锁。</p>
<h3 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h3><p>例子 6 也有一个对照案例，场景如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893902924-5ee227b0-0526-4236-a4cc-e7c0c8747133.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Zhln5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=318&amp;originWidth=954&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29607&amp;status=done&amp;style=none&amp;taskId=u8fb1fd59-1664-48b5-b9a4-dbd94e3dfa6&amp;title=" alt="image.png"><br>图 9 limit 语句加锁<br>这个例子里，session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。<br>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。<br>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893903022-59de2144-6b04-4836-ba17-f595331a64bb.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=BfFzI&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=856&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=88164&amp;status=done&amp;style=none&amp;taskId=ubc3d2e01-c66b-4541-9e24-b6ce2ac8ac8&amp;title=" alt="image.png"><br>图 10 带 limit 2 的加锁效果<br>可以看到，(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。<br>这个例子对我们实践的指导意义就是，<strong>在删除数据的时候尽量加 limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><p>前面的例子中，我们在分析的时候，是按照 next-key lock 的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock 实际上是间隙锁和行锁加起来的结果。<br>你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893903847-adf31ea3-42a0-4eb5-8184-c28b7a1d6400.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=KgXG4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=650&amp;originWidth=1106&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=68523&amp;status=done&amp;style=none&amp;taskId=ud62906b2-72c4-4111-9fe7-542fc812659&amp;title=" alt="image.png"><br>图 11 案例八的操作序列<br>现在，我们按时间顺序来分析一下为什么是这样的结果。</p>
<ol>
<li>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li>
<li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</li>
<li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li>
</ol>
<p>你可能会问，session B 的 next-key lock 不是还没申请成功吗？<br>其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。<br>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里我再次说明一下，我们上面的所有案例都是在可重复读隔离级别 (repeatable-read) 下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。<br>在最后的案例中，你可以清楚地知道 next-key lock 实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。<br>其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。<br>另外，在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。<br>也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。<br>不过，我希望你学过今天的课程以后，可以对 next-key lock 的概念有更清晰的认识，并且会用加锁规则去判断语句的加锁范围。<br>在业务需要使用可重复读隔离级别的时候，能够更细致地设计操作数据库的语句，解决幻读问题的同时，最大限度地提升系统并行处理事务的能力。<br>经过这篇文章的介绍，你再看一下上一篇文章最后的思考题，再来尝试分析一次。<br>我把题目重新描述和简化一下：还是我们在文章开头初始化的表 t，里面有 6 条记录，图 12 的语句序列中，为什么 session B 的 insert 操作，会被锁住呢？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651893903821-619a9d8e-054f-4c3c-a849-3fa393854310.png#clientId=ub7e7a10a-73cd-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=dC1U2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=942&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27789&amp;status=done&amp;style=none&amp;taskId=u126f06a8-8d8e-489a-bfd5-221c06ecdda&amp;title=" alt="image.png"><br>图 12 锁分析思考题<br>另外，如果你有兴趣多做一些实验的话，可以设计好语句序列，在执行之前先自己分析一下，然后实际地验证结果是否跟你的分析一致。<br>对于那些你自己无法解释的结果，可以发到评论区里，后面我争取挑一些有趣的案例在文章中分析。<br>你可以把你关于思考题的分析写在留言区，也可以分享你自己设计的锁验证方案，我会在下一篇文章的末尾选取有趣的评论跟大家分享。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h3 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h3><p>上期的问题，我在本期继续作为了课后思考题，所以会在下篇文章再一起公布“答案”。<br>这里，我展开回答一下评论区几位同学的问题。</p>
<ul>
<li>@令狐少侠 说，以前一直认为间隙锁只在二级索引上有。现在你知道了，有间隙的地方就可能有间隙锁。</li>
<li>@浪里白条 同学问，如果是 varchar 类型，加锁规则是什么样的。<br>回答：实际上在判断间隙的时候，varchar 和 int 是一样的，排好序以后，相邻两个值之间就有间隙。</li>
<li>有几位同学提到说，上一篇文章自己验证的结果跟案例一不同，就是在 session A 执行完这两个语句：</li>
</ul>
<p>复制代码<br>begin;<br>begin;<br>select <em> from t where d=5 for update; /</em>Q1<em>/<br>select </em> from t where d=5 for update; /<em>Q1</em>/<br>以后，session B 的 update 和 session C 的 insert 都会被堵住。这是不是跟文章的结论矛盾？<br>其实不是的，这个例子用的是反证假设，就是假设不堵住，会出现问题；然后，推导出 session A 需要锁整个表所有的行和所有间隙。</p>
<h2 id="Ⅲupdate-没加索引会锁全表？"><a href="#Ⅲupdate-没加索引会锁全表？" class="headerlink" title="Ⅲupdate 没加索引会锁全表？"></a>Ⅲupdate 没加索引会锁全表？</h2><p>大家好，我是小林。<br>昨晚在群划水的时候，看到有位读者说了这么一件事。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856023906-b51862c1-a491-4ced-8006-8a8bcdd807e0.png#averageHue=%23e8e7e3&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=471&amp;id=ueacf32da&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=634&amp;originWidth=750&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=220471&amp;status=done&amp;style=none&amp;taskId=ub5e28576-fc80-4e74-9739-1a03efb90c1&amp;title=&amp;width=557.2857666015625" alt="image.png"><br>大概就是，在线上执行一条 update 语句修改数据库数据的时候，where 条件没有带上索引，导致业务直接崩了，被老板教训了一波<br>这次我们就来看看：</p>
<ul>
<li>为什么会发生这种的事故？</li>
<li>又该如何避免这种事故的发生？</li>
</ul>
<p>说个前提，接下来说的案例都是基于 InnoDB 存储引擎，且事务的隔离级别是可重复读。</p>
<h3 id="为什么会发生这种的事故？"><a href="#为什么会发生这种的事故？" class="headerlink" title="为什么会发生这种的事故？"></a>为什么会发生这种的事故？</h3><p>InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</p>
<p>因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。</p>
<p>当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p>
<p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。<br>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p>
<p>这里举个例子，这里有一张数据库表，其中 id 为主键索引。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856023698-9c72e26c-1b4c-46b6-acc6-b6cf55f8c8b7.png#averageHue=%23f6f4eb&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6bce2b9e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=542&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22033&amp;status=done&amp;style=none&amp;taskId=u50720f5e-8d52-4003-ab4a-0788becae95&amp;title=" alt="image.png"><br>假设有两个事务的执行顺序如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856023819-d1cd7af3-7113-4876-8463-39a019a72b81.png#averageHue=%23f4f2ea&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u26b84911&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=722&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48193&amp;status=done&amp;style=none&amp;taskId=u8d8457a7-ae49-401f-a13e-9b0e1c1535d&amp;title=" alt="image.png"><br>可以看到，事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id = 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。</p>
<p>但是，<strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。</p>
<p>假设有两个事务的执行顺序如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856023777-e12b5408-8d33-481e-9949-87be98205e54.png#averageHue=%23f4eee7&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0f8f3525&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=722&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45617&amp;status=done&amp;style=none&amp;taskId=u3799bf9d-3f3c-4450-9def-8b5ef705a31&amp;title=" alt="image.png"><br>可以看到，这次事务 B 的 update 语句被阻塞了。</p>
<p>这是因为事务 A的 update 语句中 where 条件没有索引列，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856023772-5279880f-a5b3-417e-ab0f-cc7ded16ef88.png#averageHue=%23f7eed5&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u64364802&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=107&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14106&amp;status=done&amp;style=none&amp;taskId=u6be6829b-36db-4cbd-a864-e13a00d8520&amp;title=" alt="image.png"><br>因此，当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 select … from语句，其他语句都会被锁住不能执行，业务会因此停滞，接下来等着你的，就是老板的挨骂。</p>
<p>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？<br>并不是。<br><strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。<br>PS：网上很多资料说，update 没加锁索引会加表锁，这是不对的，所以我在标题里加了个问号。Innodb 源码里面在扫码记录的时候，都是针对索引项这个单位去加锁的， update 不带索引就是全表扫扫描，也就是表里的索引项都加锁，所以大家误以为加了表锁。所以，大家要清楚 innodb 不会对select、insert、delete、update语句加表锁的。</p>
<h3 id="又该如何避免这种事故的发生？"><a href="#又该如何避免这种事故的发生？" class="headerlink" title="又该如何避免这种事故的发生？"></a>又该如何避免这种事故的发生？</h3><p>我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。<br>官方的解释： If set to 1, MySQL aborts UPDATE or DELETE statements that do not use a key in the WHERE clause or a LIMIT clause. (Specifically, UPDATE statements must have a WHERE clause that uses a key or a LIMIT clause, or both. DELETE statements must have both.) This makes it possible to catch UPDATE or DELETE statements where keys are not used properly and that would probably change or delete a large number of rows. The default value is 0.<br>大致的意思是，当 sql_safe_updates 设置为 1 时。<br>update 语句必须满足如下条件之一才能执行成功：</p>
<ul>
<li>使用 where，并且 where 条件中必须有索引列；</li>
<li>使用 limit；</li>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
<p>delete 语句必须满足以下条件能执行成功：</p>
<ul>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
<p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 force index([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>不要小看一条 update 语句，在生产机上使用不当可能会导致业务停滞，甚至崩溃。<br>当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。<br>我们可以打开 MySQL sql_safe_updates 参数，这样可以预防 update 操作时 where 条件没有带上索引列。<br>如果发现即使在 where 条件中带上了列索引列，优化器走的还是全标扫描，这时我们就要使用 force index([index_name]) 可以告诉优化器使用哪个索引。<br>这次就说到这啦，下次要小心点，别再被老板挨骂啦。</p>
<h2 id="Ⅳ-MySQL-死锁了，怎么办？"><a href="#Ⅳ-MySQL-死锁了，怎么办？" class="headerlink" title="Ⅳ MySQL 死锁了，怎么办？"></a>Ⅳ MySQL 死锁了，怎么办？</h2><p>大家好，我是小林。<br>说个很早之前自己遇到过数据库死锁问题。<br>有个业务主要逻辑就是新增订单、修改订单、查询订单等操作。然后因为订单是不能重复的，所以当时在新增订单的时候做了幂等性校验，做法就是在新增订单记录之前，先通过 select … for update 语句查询订单是否存在，如果不存在才插入订单记录。<br>而正是因为这样的操作，当业务量很大的时候，就可能会出现死锁。<br>接下来跟大家聊下<strong>为什么会发生死锁，以及怎么避免死锁</strong>。</p>
<h3 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h3><p>本次案例使用存储引擎 Innodb，隔离级别为可重复读（RR）。<br>接下来，我用实战的方式来带大家看看死锁是怎么发生的。<br>我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_order` (</span><br><span class="line">  `id` <span class="type">int</span> NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `order_no` <span class="type">int</span> DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `create_date` datetime DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_order` (`order_no`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB ;</span><br></pre></td></tr></table></figure><br>然后，先 t_order 表里现在已经有了 6 条记录：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856128415-abceb8c9-32f8-417e-b052-1c2965bd4210.png#averageHue=%23f3f3f3&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc1c35bd1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=650&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33755&amp;status=done&amp;style=none&amp;taskId=u0811f100-8b79-48e2-a554-02d0aa27fdf&amp;title=" alt="image.png"><br>假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856128532-13841047-acbd-4cf1-b9d0-c4e0ef120acc.png#averageHue=%23f6e5d5&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2bbdf80e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=497&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=205694&amp;status=done&amp;style=none&amp;taskId=uaf14cbce-39a9-47cd-8316-863c145dc2c&amp;title=" alt="image.png"><br>可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。</p>
<p>这里在查询记录是否存在的时候，使用了 select … for update 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。</p>
<p>如果没有使用 select … for update 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856128568-b773b83f-6d5c-4ca5-9150-13ade0c3741e.png#averageHue=%23f2c244&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3d0e13ba&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=592&amp;originWidth=1000&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=198952&amp;status=done&amp;style=none&amp;taskId=u9e1d3b40-8f80-485f-8503-40735ec47cc&amp;title=" alt="image.png"></p>
<h3 id="为什么会产生死锁？"><a href="#为什么会产生死锁？" class="headerlink" title="为什么会产生死锁？"></a>为什么会产生死锁？</h3><p>可重复读隔离级别下，是存在幻读的问题。<br><strong>Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。</p>
<ul>
<li>Record Loc，记录锁，锁的是记录本身；</li>
<li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li>
</ul>
<p>普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line"><span class="comment">//对读取的记录加共享锁</span></span><br><span class="line">select ... lock in share mode;</span><br><span class="line">commit; <span class="comment">//锁释放</span></span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line"><span class="comment">//对读取的记录加排他锁</span></span><br><span class="line">select ... <span class="keyword">for</span> update;</span><br><span class="line">commit; <span class="comment">//锁释放</span></span><br></pre></td></tr></table></figure><br>行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。</p>
<p>比如，下面事务 A 查询语句会锁住(2, +∞]范围的记录，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856128397-6f7a7ba3-8b2e-4dee-bb44-928b57d6e008.png#averageHue=%23cee2cd&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua64b472c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=842&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=37631&amp;status=done&amp;style=none&amp;taskId=u77ed581b-6bce-4e2c-8dd2-b4c3651d0c3&amp;title=" alt="image.png"><br>next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成记录锁或间隙锁，我之前也写一篇加锁规则，详细可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html">MySQL 是怎么加锁的？(opens new window)</a></p>
<p>需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。</p>
<p>所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞，我有个读者就因为干了这个事情，然后被老板教育了一波，详细可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/update_index.html">update 没加索引会锁全表？(opens new window)</a><br>回到前面死锁的例子。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856128530-ccd99234-3fb5-464c-a8ca-2e9fcd0b1395.png#averageHue=%23f6e5d5&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u763fab38&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=497&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=205694&amp;status=done&amp;style=none&amp;taskId=ua6729991-7a0f-4ebe-bccb-4fa03a8ef84&amp;title=" alt="image.png"><br>事务 A 在执行下面这条语句的时候：<br>select id from t_order where order_no = 1007 for update;<br>因为 order_no 不是唯一索引，所以行锁的类型是间隙锁，于是间隙锁的范围是（1006, +∞）。那么，当事务 B 往间隙锁里插入 id = 1008 的记录就会被锁住。</p>
<p>因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁。<br>Insert into t<em>order (order_no, create_date) values (1008, now());<br><strong>插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select … for update 语句并不会相互影响</strong>。<br>案例中的事务 A 和事务 B 在执行完后 select … for update 语句后都持有范围为(1006,+∞）的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。<br>为什么间隙锁与间隙锁之间是兼容的？<br>在MySQL官网上还有一段非常关键的描述：<br>_Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from Inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</em><br>这段话表明间隙锁在本质上是不区分共享间隙锁或互斥间隙锁的，而且间隙锁是不互斥的，即两个事务可以同时持有包含共同间隙的间隙锁。<br>这里的共同间隙包括两种场景：</p>
<ul>
<li>其一是两个间隙锁的间隙区间完全一样；</li>
<li>其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。</li>
</ul>
<p><strong>间隙锁本质上是用于阻止其他事务在该间隙内插入新记录，而自身事务是允许在该间隙内插入数据的</strong>。也就是说间隙锁的应用场景包括<strong>并发读取、并发更新、并发删除和并发插入</strong>。<br>插入意向锁是什么？<br>注意！插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁。<br>在MySQL的官方文档中有以下重要描述：<br><em>An Insert intention lock is a type of gap lock set by Insert operations prior to row Insertion. This lock signals the intent to Insert in such a way that multiple transactions Inserting into the same index gap need not wait for each other if they are not Inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to Insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with Insert intention locks prior to obtaining the exclusive lock on the Inserted row, but do not block each other because the rows are nonconflicting.</em><br>这段话表明尽管<strong>插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作</strong>。<br>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。<br>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。<br>另外，我补充一点，插入意向锁的生成时机：</p>
<ul>
<li>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，那 Insert 语句应该被阻塞，并生成一个插入意向锁 。<h3 id="Insert-语句是怎么加行级锁的？"><a href="#Insert-语句是怎么加行级锁的？" class="headerlink" title="Insert 语句是怎么加行级锁的？"></a>Insert 语句是怎么加行级锁的？</h3>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。<br>什么是隐式锁？<br>当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</li>
</ul>
<p>隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景。</p>
<ul>
<li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；</li>
<li><p>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；</p>
<h4 id="1、记录之间加有间隙锁"><a href="#1、记录之间加有间隙锁" class="headerlink" title="1、记录之间加有间隙锁"></a>1、记录之间加有间隙锁</h4><p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，那 Insert 语句应该被阻塞，并生成一个插入意向锁。<br>举个例子，现在 t_order 表中，只有这些数据，<strong>order_no 是二级索引</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856129413-cf9f96a5-d6a5-407a-bc8f-6bca0ab2b9a4.png#averageHue=%23f3f3f3&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u110a59b7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=254&amp;originWidth=642&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32509&amp;status=done&amp;style=none&amp;taskId=u8980b5a8-c0fb-4f8b-930e-4eacb85a347&amp;title=" alt="image.png"><br>现在，事务 A 执行了下面这条语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_order where order_no = <span class="number">1006</span> <span class="keyword">for</span> update;</span><br><span class="line">Empty <span class="title function_">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span><br></pre></td></tr></table></figure>
<p>接着，我们执行 select * from performance_schema.data_locks\G; 语句 ，确定事务 A 加了什么类型的锁，这里只关注在记录上加锁的类型。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856130619-c65b8468-ad26-4f9c-846a-a69bb5217c5b.png#averageHue=%230e1119&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubd579bc4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1310&amp;originWidth=1248&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=813779&amp;status=done&amp;style=none&amp;taskId=u1a51876f-1d36-4c43-ab6e-1d1420be5e4&amp;title=" alt="image.png"><br>可以看到，加的是 X 型的锁（排他锁），但是具体是记录锁、间隙锁、next-key 锁呢？注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。<br>首先通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p>
</li>
<li><p>如果 LOCK_MODE 为 X，说明是 next-key 锁；</p>
</li>
<li>如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；</li>
<li>如果 LOCK_MODE 为 X, GAP，说明是间隙锁；</li>
</ul>
<p>因此，本次的例子加的是 next-key 锁（记录锁+间隙锁），锁范围是（1005, +∞]。<br>然后，有个事务 B 在这个间隙锁中，插入了一个记录，那么此时该事务 B 就会被阻塞：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 事务 B 插入一条记录</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span><br><span class="line"></span><br><span class="line">mysql&gt; insert into <span class="title function_">t_order</span><span class="params">(order_no, create_date)</span> <span class="title function_">values</span><span class="params">(<span class="number">1010</span>,now())</span>;</span><br><span class="line">### 阻塞状态。。。。</span><br></pre></td></tr></table></figure><br>接着，我们执行 select * from performance_schema.data_locks\G; 语句 ，确定事务 B 加了什么类型的锁，这里只关注在记录上加锁的类型。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856130308-71ea2cd6-16ed-41a3-b89c-62711d59753e.png#averageHue=%230e1119&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uea8a9fa6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=660&amp;originWidth=1270&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=426714&amp;status=done&amp;style=none&amp;taskId=uf818ad42-d8f3-4e94-9ada-eb41e3dcec1&amp;title=" alt="image.png"><br>可以看到，事务 B 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 A 生成的 next-key 锁（记录锁+间隙锁）范围（1005, +∞] 中插入了一条记录，所以事务 B 的插入操作生成了一个插入意向锁（LOCK_MODE: X,INSERT_INTENTION）。</p>
<h4 id="2、遇到唯一键冲突"><a href="#2、遇到唯一键冲突" class="headerlink" title="2、遇到唯一键冲突"></a>2、遇到唯一键冲突</h4><p>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录」（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。</p>
<p>至于是行级锁的类型是记录锁，还是 next-key 锁，跟是「主键冲突」还是「唯一二级索引冲突」有关系。</p>
<p>如果主键值重复：</p>
<ul>
<li>当隔离级别为<strong>读已提交</strong>时，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li>
<li>当隔离级别是<strong>可重复读</strong>（默认隔离级别），插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li>
</ul>
<p>如果唯一二级索引列重复：</p>
<ul>
<li><strong>不论是哪个隔离级别</strong>，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。对的，没错，即使是读已提交隔离级别也是加 next-key 锁，这是读已提交隔离级别中为数不多的给记录添加间隙锁的场景。因为如果不添加间隙锁的话，会让唯一二级索引中出现多条唯一二级索引列值相同的记录，这就违背了 UNIQUE 的约束。</li>
</ul>
<p>下面举个「唯一二级索引冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。<br>t_order 表中的 order_no 字段为唯一二级索引，并且已经存在 order_no 值为 1001 的记录，此时事务 A，插入了 order_no 为 1001 的记录，就出现了报错。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856132508-2b98bbe6-a882-4268-8170-75873abeca3f.png#averageHue=%23b3b5b5&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue2dafaf6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=336&amp;originWidth=2156&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=301419&amp;status=done&amp;style=none&amp;taskId=ub82b9b85-885a-428a-ac2e-3256ad148a2&amp;title=" alt="image.png"><br>但是除了报错之外，还做一个很重要的事情，就是对 order_no 值为 1001 这条记录加上了 <strong>S 型的 next-key 锁</strong>。<br>我们可以执行 select * from performance_schema.data_locks\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856132527-d106670c-061e-4509-bd97-ab4e2e35d124.png#averageHue=%230e1118&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udb17fcf4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=628&amp;originWidth=1196&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=372887&amp;status=done&amp;style=none&amp;taskId=u955ded22-30a0-4126-bf8e-33ecd97baf9&amp;title=" alt="image.png"><br>可以看到，index_order 二级索引中的 1001（LOCK_DATA） 记录的锁类型为 S 型的 next-key 锁。注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是记录锁的话，LOCK_MODE 会显示 S, REC_NOT_GAP。</p>
<p>此时，事务 B 执行了 select <em> from t_order where order_no = 1001 for update; 就会阻塞，因为这条语句想加 X 型的锁，是与 S 型的锁是冲突的，所以就会被阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856132400-7dd9e748-1274-4944-a39b-9b4e5f730ae3.png#averageHue=%23f8e7cd&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud41ddb76&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=611&amp;originWidth=991&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=156092&amp;status=done&amp;style=none&amp;taskId=u0124e6ea-ee6b-4dba-bfbe-8bc306d6903&amp;title=" alt="image.png"><br>我们也可以从 performance_schema.data_locks 这个表中看到，事务 B 的状态（LOCK_STATUS）是等待状态，加锁的类型 X 型的记录锁（LOCK_MODE: X,REC_NOT_GAP ）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856132917-f868e85c-109e-49f2-9fc6-f51e84bc3c43.png#averageHue=%230e1119&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u188e49aa&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=654&amp;originWidth=1204&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=416887&amp;status=done&amp;style=none&amp;taskId=ue4579302-9aad-4390-ad15-2ff4fe1775e&amp;title=" alt="image.png"><br>上面的案例是针对唯一二级索引重复而插入失败的场景。<br>接下来，分析两个事务执行过程中，执行了相同的 insert 语句的场景。<br>现在 t_order 表中，只有这些数据，<strong>order_no 为唯一二级索引</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856133428-6747b014-b909-45c1-b48a-ccdba1b39572.png#averageHue=%23f3f3f3&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9f1cc4d2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=254&amp;originWidth=642&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32509&amp;status=done&amp;style=none&amp;taskId=u8797adbe-70e3-45a9-a740-7696eda4eab&amp;title=" alt="image.png"><br>在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时<em>*事务 B 的 Insert 语句会发生阻塞</em></em>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856133796-49170dd2-9d67-474a-a85e-b5236cd8e7d5.png#averageHue=%23f5e7d0&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u01b0172c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=376&amp;originWidth=681&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=87501&amp;status=done&amp;style=none&amp;taskId=u3d3b35d5-e8e5-490d-b1c2-263e6284742&amp;title=" alt="image.png"><br>两个事务的加锁过程：</p>
<ul>
<li>事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；</li>
<li>接着，事务 B 也插入 order_no 为 1006 的记录，由于事务 A 已经插入 order_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交，<strong>事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态</strong>。</li>
</ul>
<p>我们可以执行 select <em> from performance<em>schema.data_locks\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。<br>先看事务 A 对 order_no 为 1006 的记录加了什么锁？<br>从下图可以看到，<strong>事务 A 对 order_no 为 1006 记录加上了类型为 X 型的记录锁</strong>（</em>注意，这个是在执行事务 B 之后才产生的锁，没执行事务 B 之前，该记录还是隐式锁_）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856136754-1106d164-67a8-4c68-9908-39dd7a3b55b5.png#averageHue=%230e1119&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uf562ff8a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1288&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=388451&amp;status=done&amp;style=none&amp;taskId=uc6ee4e5a-50cd-4cf0-bca1-3276ea5de15&amp;title=" alt="image.png"><br>然后看事务 B 想对 order_no 为 1006 的记录加什么锁？<br>从下图可以看到，<strong>事务 B 想对 order_no 为 1006 的记录加 S 型的 next-key 锁，但是由于事务 A 在该记录上持有了 X 型的记录锁，这两个锁是冲突的，所以导致事务 B 处于等待状态</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856136743-9fbfc5b8-6de4-4231-b6e4-7680c6966116.png#averageHue=%230e1119&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u32486a38&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1204&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=369747&amp;status=done&amp;style=none&amp;taskId=uc9b84345-e61f-4ae7-8247-f9d8d2357a9&amp;title=" alt="image.png"><br>从这个实验可以得知，并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。<br>但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会<strong>被阻塞</strong>，<em>*因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的</em></em>，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。<br>如果 order_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的，就如前面的这个例子。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856136294-65d8f676-584c-4eff-aa22-003291e4a316.png#averageHue=%23f2c244&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u231fcf10&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=592&amp;originWidth=1000&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=198952&amp;status=done&amp;style=none&amp;taskId=u9339e79c-b524-4f1f-9537-132759a6ac6&amp;title=" alt="image.png"></p>
<h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。<br>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p>
<ul>
<li><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。当发生超时后，就出现下面这个提示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856136188-ae49580d-c7c8-41cb-9027-673f18cd479f.png#averageHue=%2312141c&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u790122a7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=31&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25384&amp;status=done&amp;style=none&amp;taskId=u102d0582-b46d-4b25-a0fc-77e287f16c3&amp;title=" alt="image.png"></p>
<ul>
<li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。当检测到死锁后，就会出现下面这个提示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659856136412-fa3280f3-d441-4824-b2e6-9ae552e14dbd.png#averageHue=%2312141d&amp;clientId=uadf23417-eae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u330e9806&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=28&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22950&amp;status=done&amp;style=none&amp;taskId=u66183336-d123-4c14-9039-2389aac88fe&amp;title=" alt="image.png"><br>上面这个两种策略是「当有死锁发生时」的避免方式。<br>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一下来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p>
<hr>
<p>最后说个段子：<br>面试官: 解释下什么是死锁?<br>应聘者: 你录用我,我就告诉你<br>面试官: 你告诉我,我就录用你<br>应聘者: 你录用我,我就告诉你<br>面试官: 卧槽滚！<br><strong>………..</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://fetterslove.github.io">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fetterslove.github.io/2022/08/09/MySQL/%E9%94%81%E7%AF%87/">http://fetterslove.github.io/2022/08/09/MySQL/%E9%94%81%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://fetterslove.github.io" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0%E9%94%81%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-text">Ⅰ锁的划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-text">一、从数据操作的类型划分：读锁、写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">写操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B9%E6%8D%AE%E5%8A%A0%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E6%88%96%E8%80%85%E8%8C%83%E5%9B%B4"><span class="toc-text">二、根据加锁的粒度或者范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">①全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">②表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AUTO-INC%EF%BC%88%E8%87%AA%E5%A2%9E%EF%BC%89-%E9%94%81"><span class="toc-text">AUTO-INC（自增） 锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">③行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-text">1. 记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-text">2. 间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-text">3. 临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="toc-text">4. 插入意向锁（Insert Intention Locks）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E9%A1%B5%E9%94%81"><span class="toc-text">④页锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86-%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">三、从对待锁的态度划分:乐观锁、悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89"><span class="toc-text">1. 悲观锁（Pessimistic Locking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89"><span class="toc-text">2. 乐观锁（Optimistic Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-text">①乐观锁的版本号机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%BA%E5%88%B6"><span class="toc-text">②乐观锁的时间戳机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3. 两种锁的适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">ⅡMySQL 是怎么加锁的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-text">唯一索引等值查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">唯一索引范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-text">非唯一索引等值查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">非唯一索引范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">案例一：等值查询间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E9%94%81"><span class="toc-text">案例二：非唯一索引等值锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-text">案例三：主键索引范围锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%9B%9B%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-text">案例四：非唯一索引范围锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%94%EF%BC%9A%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81-bug"><span class="toc-text">案例五：唯一索引范围锁 bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%85%AD%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%AD%98%E5%9C%A8%E2%80%9D%E7%AD%89%E5%80%BC%E2%80%9D%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">案例六：非唯一索引上存在”等值”的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%83%EF%BC%9Alimit-%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81"><span class="toc-text">案例七：limit 语句加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%85%AB%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">案例八：一个死锁的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%9C%9F%E9%97%AE%E9%A2%98%E6%97%B6%E9%97%B4"><span class="toc-text">上期问题时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A2update-%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%EF%BC%9F"><span class="toc-text">Ⅲupdate 没加索引会锁全表？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E7%9A%84%E4%BA%8B%E6%95%85%EF%BC%9F"><span class="toc-text">为什么会发生这种的事故？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%99%E7%A7%8D%E4%BA%8B%E6%95%85%E7%9A%84%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-text">又该如何避免这种事故的发生？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A3-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">Ⅳ MySQL 死锁了，怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F"><span class="toc-text">死锁的发生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">为什么会产生死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">Insert 语句是怎么加行级锁的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%97%B4%E5%8A%A0%E6%9C%89%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">1、记录之间加有间隙锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%81%87%E5%88%B0%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81"><span class="toc-text">2、遇到唯一键冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">如何避免死锁？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/cover/cover/" title="翻唱"><img src="/1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻唱"/></a><div class="content"><a class="title" href="/2022/08/09/cover/cover/" title="翻唱">翻唱</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><script async src="//at.alicdn.com/t/c/xxx.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 java (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 MySQL (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 redis (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 计算机网络 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://fetterslove.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>