<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HTTP篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP篇">
<meta property="og:url" content="http://fetterslove.github.io/2022/08/09/%E8%AE%A1%E7%BD%91/HTTP%E7%AF%87/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="计算机网络">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:17:58.311Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://fetterslove.github.io/2022/08/09/%E8%AE%A1%E7%BD%91/HTTP%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTTP篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-13 22:17:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/xxx.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HTTP篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:17:58.311Z" title="更新于 2022-11-13 22:17:58">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HTTP篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、HTTP常见面试题"><a href="#一、HTTP常见面试题" class="headerlink" title="一、HTTP常见面试题"></a>一、HTTP常见面试题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651461268890-51f432ca-17d6-4cb6-ba01-50d152aa238c.png#averageHue=%23fcf8f4&amp;clientId=u4ab6ccf6-f116-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=674&amp;id=udb823b4b&amp;name=image.png&amp;originHeight=1614&amp;originWidth=1646&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=304651&amp;status=done&amp;style=none&amp;taskId=u250408e1-f272-431b-be2f-356f9b6737a&amp;title=&amp;width=687" alt="image.png"></p>
<h3 id="ⅠHTTP基本概念"><a href="#ⅠHTTP基本概念" class="headerlink" title="ⅠHTTP基本概念"></a>ⅠHTTP基本概念</h3><h4 id="①HTTP-是什么？"><a href="#①HTTP-是什么？" class="headerlink" title="①HTTP 是什么？"></a>①HTTP 是什么？</h4><p><strong>HTTP </strong>是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和 规范」。</p>
<h4 id="②HTTP-常⻅的状态码，有哪些？✊"><a href="#②HTTP-常⻅的状态码，有哪些？✊" class="headerlink" title="②HTTP 常⻅的状态码，有哪些？✊"></a>②HTTP 常⻅的状态码，有哪些？✊</h4><p>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。<br>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p>4xx 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。<h4 id="③http报文格式详解✊"><a href="#③http报文格式详解✊" class="headerlink" title="③http报文格式详解✊"></a>③http报文格式详解✊</h4>HTTP有两种报文：请求报文和响应报文。<h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5>请求报文由三部分组成：请求行、首部行、空行、实体主体。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650349647173-6cdfa2aa-3f05-428c-865b-662fb20c8247.png#averageHue=%23bcbcbc&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=305&amp;id=u334f2f4b&amp;originHeight=467&amp;originWidth=824&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u697d9ab4-48aa-43ea-84c6-1ba48083c86&amp;title=&amp;width=538" alt=""></li>
</ul>
<ol>
<li><p><strong>请求行</strong></p>
<p>请求行有三个字段：方法、URL、HTTP版本<br>（1）方法：可以取不同的值，包括GET、POST、HEAD、PUT和DELETE等。绝大部分HTTP请求报文使用GET方法。<br>（2）URL：请求对象的标识。示例中请求对象标识就是：/dir1/dir2/hello.html<br>（3）HTTP版本：略。示例中HTTP版本为1.1。</p>
</li>
<li><p><strong>首部行</strong></p>
</li>
</ol>
<p>首部行由多组键值对（首部字段名：首部字段值）组成。下面分析示例：<br>Host：指明请求对象所在主机。示例中主机为www.test.com。<br>Connection：浏览器告知服务器是否使用持续连接。示例中close代表不使用持续连接。</p>
<blockquote>
<p>User-agent：指明用户代理，即浏览器类型。示例中浏览器类型为Mozilla/5.0。<br>Accept-language：指明用户希望得到请求对象的语言版本。示例中zh-cn代表中文版本。</p>
</blockquote>
<ol>
<li><strong>空行</strong></li>
</ol>
<p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。</p>
<ol>
<li><strong>实体主体（body）</strong></li>
</ol>
<ul>
<li>使用GET方法时，请求数据为空；</li>
<li>而使用POST方法时才使用请求数据，举例说明：</li>
</ul>
<p>当用户提交表单时，HTTP使用POST方法，则实体体内包含的就是用户在表单的输入值。</p>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><p>响应报文由三部分组成：状态行、首部行、空行、实体体。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650349526695-619f9cda-2401-4fbb-9e58-4b908cde842f.png#averageHue=%23b9b9b9&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u55476c58&amp;originHeight=468&amp;originWidth=797&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1105e6a1-5746-4b88-b84f-2c91d54a147&amp;title=&amp;width=493" alt=""></p>
<p><strong>1、状态行：</strong><br>状态行有三个字段：状态码及状态信息、HTTP版本<br>（1）HTTP版本：略。<br>（2）状态码及状态信息：下面列出常见状态码及状态信息</p>
<ul>
<li>200   OK：请求成功，信息在返回的响应报文中。</li>
<li>301   Moved Permanently：请求对象被永久转移了，新的URL定义在响应报文的首部行Location中。客户端自动获取新的URL。</li>
<li>404   Not Found：被请求的文档不在服务器上。</li>
<li>505   HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
<p><strong>2、首部行</strong><br>同样的，首部行由多组键值对（首部字段名：首部字段值）组成。下面分析示例：<br>Connection：服务器通知客户，发送完报文后是否持续该TCP连接。示例中close代表发送完报文后关闭该TCP连接。<br>Content-Length：被发送对象中的字节数。<br>Content-Type：实体体中对象类型。示例中 text/html 代表HTML文件。<br>Date：服务器产生并发送该响应报文的日期时间。<br>Server：指明产生响应报文的服务器类型，类似于请求报文首部行中User-agent字段。示例中为Apache Web服务器。<br>Last-Modified：对象创建或者最后修改的日期时间。<br><strong>3、实体体</strong><br>服务器响应客户端的数据对象，在请求示例中，请求对象为hello.html，那么该实体体内容就是hello.html。</p>
<h4 id="④http-常⻅字段有哪些？"><a href="#④http-常⻅字段有哪些？" class="headerlink" title="④http 常⻅字段有哪些？"></a>④http 常⻅字段有哪些？</h4><p><em>Host </em>字段<br>客户端发送请求时，⽤来指定服务器的域名。<br><em>Connection </em>字段<br>Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。<br>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。<br>Connection: keep-alive<br>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。<br><em>Content-Length </em>字段<br>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。<br><em>Content-Type </em>字段<br>Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。<br><em>Content-Encoding </em>字段<br>Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650349837059-dba81b53-543c-464a-9824-eeebcf0a3f34.png#averageHue=%23f5edd0&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u7267e0a4&amp;name=image.png&amp;originHeight=302&amp;originWidth=677&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=127659&amp;status=done&amp;style=none&amp;taskId=uee2f93cd-ec77-4ab8-adbd-2d5f1bd339f&amp;title=&amp;width=530" alt="image.png"><br>Content-Encoding: gzip<br>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。<br>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。<br>Accept-Encoding: gzip, deflate</p>
<h3 id="ⅡGET与POST"><a href="#ⅡGET与POST" class="headerlink" title="ⅡGET与POST"></a>ⅡGET与POST</h3><h4 id="①GET与POST区别"><a href="#①GET与POST区别" class="headerlink" title="①GET与POST区别"></a>①GET与POST区别</h4><p><strong>请方缓产编</strong><br>请求参数—方法的url—缓存—产生的数据包—编码</p>
<ul>
<li>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</li>
</ul>
<p>POST 的语义是根据请求数据对指定的资源做出处理，具体的处理方式视资源类型而不同。POST         不安全，不幂等，（大部分实现）不可缓存。<br>补充注意， 上面是从 RFC 规范定义的语义来分析的。<br>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p>
<ul>
<li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li>
<li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li>
</ul>
<p>曾经有个笑话，有人写了个博客，删除博客用的是GET请求，他觉得没人访问就连鉴权都没做。然后Google服务器爬虫爬了一遍，他所有博文就没了。。。<br>如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。<br>因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。<br>所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。<br>GET 请求可以带 body 吗？<br>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。<br>另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p>
<ul>
<li>GET请求参数通过URL传递，请求的数据会附在 URL 之后（放在请求行中），以 ? 分割 URL 和传输数据，多个参数用 &amp; 连接。POST的参数放在请求体中，因为 POST 方法的请求信息是放置在请求数据中的，所以它的请求信息是没有长度限制的。</li>
<li>GET 方法的 URL 一般都具有长度限制，但是需要注意的是 HTTP 协议中并未规定 GET 请求的长度。这个长度限制主要是由浏览器和 Web 服务器所决定的，并且各个浏览器对长度的限制也各不相同。</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体，服务器响应200 ok(返回数据)。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>它们都是HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的协议，所以 GET/POST 实际上都是 TCP 链接。区分出来就是为了方便管理。<br>补充&gt; 既然 GET 和 POST 的底层都是 TCP，那么为什么 HTTP 还要特别将它们区分出来呢？<blockquote>
<p>其实可以想象一下，如果我们直接使用 TCP 进行数据的传输，那么无论是单纯获取资源的请求还是修改服务器资源的请求在外观上看起来都是 TCP 链接，这样就非常不利于进行管理。所以在 HTTP 协议中，就会对这些不同的请求设置不同的类别进行管理，例如单纯获取资源的请求就规定为 GET、修改服务器资源的请求就规定为 POST，并且也对它们的请求报文的格式做出了相应的要求（例如请求参数 GET 位于 URL 而 POST 则位于请求数据中）。</p>
<p>当然，如果我们想将 GET 的请求参数放置在请求数据中或者将 POST 的请求数据放置在 URL 中，这是完全可以的，虽然这样子做并不符合 HTTP 的规范。但是这样子做是否能得到我们期望的响应数据呢？答案是未必，这取决于服务器的行为。</p>
<p>以 GET 方法在请求数据中放置请求参数为例，有些服务器会将请求数据中的参数读出，在这种情况下我们依然能获得我们期望的响应数据；而有些服务器则会选择直接忽略，这种情况下我们就无法获取期望的响应数据了。</p>
<p>所以，对于 GET 和 POST 的区别，总结来说就是：它们的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。</p>
</blockquote>
</li>
</ul>
<h4 id="②GET-和-POST-方法都是安全和幂等的吗？"><a href="#②GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="②GET 和 POST 方法都是安全和幂等的吗？"></a>②GET 和 POST 方法都是安全和幂等的吗？</h4><p>先说明下安全和幂等的概念：</p>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<p>如果从 RFC 规范定义的语义来看：</p>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存位书签</strong>。</li>
<li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p>
<h3 id="ⅢHTTP缓存技术"><a href="#ⅢHTTP缓存技术" class="headerlink" title="ⅢHTTP缓存技术"></a>ⅢHTTP缓存技术</h3><h4 id="①HTTP-缓存有哪些实现方式？"><a href="#①HTTP-缓存有哪些实现方式？" class="headerlink" title="①HTTP 缓存有哪些实现方式？"></a>①HTTP 缓存有哪些实现方式？</h4></li>
<li><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。</p>
</li>
<li>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的<strong>头部</strong>有不少是针对缓存的字段。</li>
</ul>
<p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p><strong>是什么</strong><br>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<blockquote>
<p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650350134003-838915b8-0085-4268-86b9-92031c30c040.png#averageHue=%23f8f2f1&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=158&amp;id=u15dc2301&amp;name=image.png&amp;originHeight=652&amp;originWidth=1882&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=249770&amp;status=done&amp;style=none&amp;taskId=u05288d05-ae47-487f-ab00-92ff676885c&amp;title=&amp;width=457" alt="image.png"></p>
</blockquote>
<p><strong>如何实现</strong><br>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li>Cache-Control， 是一个相对时间；</li>
<li>Expires，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control的优先级高于 Expires</strong> 。</p>
<p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><strong>是什么</strong><br>在浏览器使用开发者工具的时候，会看到过某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650350133995-953c7a1c-661b-4714-98e6-31838c551bc6.png#averageHue=%23f7f5f3&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=488&amp;id=u4bab795a&amp;name=image.png&amp;originHeight=1127&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=212936&amp;status=done&amp;style=none&amp;taskId=u1445cbec-cb9e-4ffe-b390-c1105540c3f&amp;title=&amp;width=440" alt="image.png"><br>上图就是一个协商缓存的过程，所以<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p>
</blockquote>
</li>
</ul>
<p><strong>如何实现</strong><br>协商缓存可以基于两种头部来实现。<br>第一种：<strong>请求头部</strong>中的 If-Modified-Since 字段与<strong>响应头部</strong>中的 Last-Modified 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 Last-Modified：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 Etag：唯一标识响应资源；</li>
<li>请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。<blockquote>
<p>使用 ETag 字段实现的协商缓存的过程如下；</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li>
<li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
<li>服务器再次收到请求后，<strong>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</strong>：<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li>
</ul>
</blockquote>
</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。<br>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。<br>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<h3 id="ⅣHTTP特性"><a href="#ⅣHTTP特性" class="headerlink" title="ⅣHTTP特性"></a>ⅣHTTP特性</h3><h4 id="①HTTP-1-1-的优点"><a href="#①HTTP-1-1-的优点" class="headerlink" title="①HTTP(1.1) 的优点"></a>①HTTP(1.1) 的优点</h4><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。<br><em>1. </em>简单<br>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，<br><em>2. </em>灵活和易于扩展 </p>
<ul>
<li>HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。 </li>
<li>同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。 </li>
<li>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的 QUIC。 </li>
</ul>
<p><em>3. </em>应⽤⼴泛和跨平台<br>互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购 物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。</p>
<h4 id="②HTTP-1-1-有哪些缺点"><a href="#②HTTP-1-1-有哪些缺点" class="headerlink" title="②HTTP(1.1)有哪些缺点"></a>②HTTP(1.1)有哪些缺点</h4><p><em>1. </em>⽆状态双刃剑 </p>
<ul>
<li>⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的 负担。</li>
<li><p>⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。 </p>
<blockquote>
<p>例如登录-&gt;添加购物⻋-&gt;下单-&gt;结算-&gt;⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有 关联的，每次都要问⼀遍身份信息。这样每操作⼀次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是酸爽！ </p>
</blockquote>
</li>
<li><p>对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ <strong>Cookie </strong>技术。 </p>
</li>
<li>Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。 </li>
</ul>
<p><em>2. </em>明⽂传输双刃剑<br>通过打开f12控制台或使用抓包工具就可以看见相关的信息了<br>好处：方面阅读信息<br>坏处：信息毫无隐私可言容易被窃取<br><em>3. </em>不安全<br>通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。<br>不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。<br>⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。</p>
<h4 id="③那你再说下-HTTP-1-1-的性能如何？"><a href="#③那你再说下-HTTP-1-1-的性能如何？" class="headerlink" title="③那你再说下 HTTP/1.1 的性能如何？"></a>③那你再说下 HTTP/1.1 的性能如何？</h4><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使⽤了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>⾥。 </p>
<h5 id="1-⻓连接"><a href="#1-⻓连接" class="headerlink" title="1. ⻓连接"></a>1. ⻓连接</h5><ul>
<li>早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），增加了通信开销。 </li>
<li>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>⻓连接</strong>的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的重复建⽴和断开所造成的额外开销，减轻了服务器端的负载。 </li>
<li>持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。 </li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647566280378-d26a3e66-58e0-4f79-8ec7-f4b2d52fc2fb.png#averageHue=%23f5f3f1&amp;clientId=u8e6115f2-f264-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=356&amp;id=u948e56c2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=665&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=308092&amp;status=done&amp;style=none&amp;taskId=uf1614507-0df2-4ae1-bcac-56a9e66c9f2&amp;title=&amp;width=552" alt="image.png"></p>
<h5 id="2-管道⽹络传输"><a href="#2-管道⽹络传输" class="headerlink" title="2. 管道⽹络传输"></a>2. 管道⽹络传输</h5><ul>
<li>即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第 ⼆个请求出去，可以减少整体的响应时间。 </li>
<li>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</li>
</ul>
<p>所以，<strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<blockquote>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接⾥⾯，先发送 A 请求，然后等待服务器做 出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647566343327-6e0bb876-ddf8-4fb1-bae1-0d9a4c7364b7.png#averageHue=%23faf9f9&amp;clientId=u8e6115f2-f264-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=526&amp;id=ue884eb91&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=658&amp;originWidth=606&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=118755&amp;status=done&amp;style=none&amp;taskId=ua5b2a3e8-513b-4b28-8b7e-78a8b3e4817&amp;title=&amp;width=484.8" alt="image.png"></p>
</blockquote>
<h5 id="3-队头阻塞"><a href="#3-队头阻塞" class="headerlink" title="3. 队头阻塞"></a>3. 队头阻塞</h5><p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。<br>因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致 客户端⼀直请求不到数据，这也就是「队头阻塞」。总之 HTTP/1.1 的性能⼀般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647566510331-c7b39b16-1e0c-41e1-b14c-2463637d0b94.png#averageHue=%23f8f4ef&amp;clientId=u8e6115f2-f264-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=579&amp;id=u59fbc366&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=724&amp;originWidth=662&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=168496&amp;status=done&amp;style=none&amp;taskId=u2d52459c-6ba9-4e4a-8438-cecbde4adaa&amp;title=&amp;width=529.6" alt="image.png"></p>
<h3 id="ⅤHTTPS✊"><a href="#ⅤHTTPS✊" class="headerlink" title="ⅤHTTPS✊"></a>ⅤHTTPS✊</h3><h4 id="①HTTPS-是如何建立连接的？其间交互了什么？https的连接过程"><a href="#①HTTPS-是如何建立连接的？其间交互了什么？https的连接过程" class="headerlink" title="①HTTPS 是如何建立连接的？其间交互了什么？https的连接过程"></a>①HTTPS 是如何建立连接的？其间交互了什么？https的连接过程</h4><p>SSL/TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p>
<p>SSL/TLS 的「握手阶段」涉及<strong>四次</strong>通信，可见下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652767785192-d07ce5b3-771d-4e60-ace0-1041a3a2d36d.png#averageHue=%23fcf6e5&amp;clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1303&amp;id=IDwh7&amp;name=image.png&amp;originHeight=2807&amp;originWidth=1545&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1369686&amp;status=done&amp;style=none&amp;taskId=ua8e7b173-1eb1-4f4b-aeb1-a3339c52d2b&amp;title=&amp;width=717" alt="image.png"><br>SSL/TLS 协议建立的详细流程：<br><em>1. ClientHello</em><br>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。<br>在这一步，客户端主要向服务器发送以下信息：<br>（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。<br>（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。<br><em>2. SeverHello</em><br>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：<br>（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br><strong>（4）服务器的数字证书。</strong><br><em>3.客户端回应</em><br>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。<br>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：<br>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。<br>（2）<strong>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</strong><br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。<br>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。<br><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。<br><em>4. 服务器的最后回应</em><br>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。<br>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>
<blockquote>
<p>数字证书的工作流程<br>我也画了一张图，方便大家理解：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658458709449-32dc022a-3d68-4910-888e-823236723513.png#averageHue=%23e1d6a2&amp;clientId=u6dc524c5-d932-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=367&amp;id=n9qle&amp;name=image.png&amp;originHeight=577&amp;originWidth=779&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=362582&amp;status=done&amp;style=none&amp;taskId=ud1415ba0-9255-4a51-910f-12268030aab&amp;title=&amp;width=495.00006103515625" alt="image.png"><br>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>
</blockquote>
<h4 id="②客户端校验数字证书的流程是怎样的？"><a href="#②客户端校验数字证书的流程是怎样的？" class="headerlink" title="②客户端校验数字证书的流程是怎样的？"></a>②客户端校验数字证书的流程是怎样的？</h4><p>接下来，详细说一下实际中数字证书签发和验证流程。<br>如下图图所示，为数字证书签发和验证流程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851948294-29038a02-1356-490c-8a67-5b1c821f3f90.png#averageHue=%23f7f3eb&amp;clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=nUKU9&amp;name=image.png&amp;originHeight=740&amp;originWidth=1337&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=302911&amp;status=done&amp;style=none&amp;taskId=u4ff6ef86-073c-4794-b0a6-fbdae2a7b62&amp;title=" alt="image.png"><br>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature（证书签名），也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。<br>补充但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851948150-a848c5d0-7f84-479f-81ad-5b867485d0de.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=VXplK&amp;name=image.png&amp;originHeight=217&amp;originWidth=567&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49216&amp;status=done&amp;style=none&amp;taskId=u11e9659d-15db-470c-a9ca-a5c7c4b35ba&amp;title=" alt="image.png"><br>对于这种三级层级关系的证书的验证过程如下：</p>
</li>
<li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p>
</li>
<li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</li>
<li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</li>
</ul>
<p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。<br>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851948267-f6b51de7-bd03-42db-a0be-69bbbf1a69b3.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=faxlW&amp;name=image.png&amp;originHeight=891&amp;originWidth=707&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=127318&amp;status=done&amp;style=none&amp;taskId=u37d6a485-b67f-4515-945c-cc0ee5e0cf7&amp;title=" alt="image.png"><br>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851948303-0366c395-8c5c-44df-8b5f-24d15e843e4b.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=YVC18&amp;name=image.png&amp;originHeight=534&amp;originWidth=867&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=240019&amp;status=done&amp;style=none&amp;taskId=uba8bbdef-ebf1-4a50-9869-c8ffa6c24db&amp;title=" alt="image.png"><br>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851948276-aa979ff2-c308-4d52-bdc6-5794c445f06b.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=pfdfk&amp;name=image.png&amp;originHeight=452&amp;originWidth=1478&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=149739&amp;status=done&amp;style=none&amp;taskId=u5c63c07d-e1c6-4319-96c5-231699b1ae0&amp;title=" alt="image.png"><br>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？<br><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p>
<h4 id="③ssl原理👌"><a href="#③ssl原理👌" class="headerlink" title="③ssl原理👌"></a>③ssl原理👌</h4><p>RSA 算法的缺陷<strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。<br>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。<br>为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓。<br>HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。<br>其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。<br>我在上一篇已经介绍了 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">RSA 握手的过程(opens new window)</a>，今天这一篇就「从理论再到实战抓包」介绍 <strong>ECDHE 算法</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061663655-cff70fbd-9a1c-4f91-80c6-5d0d33c6947f.png#averageHue=%23eff1f4&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=482&amp;id=ubdd6a341&amp;name=image.png&amp;originHeight=1566&amp;originWidth=1388&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=351233&amp;status=done&amp;style=none&amp;taskId=u284d660d-07f0-4ea3-ae1d-9e3af7906d1&amp;title=&amp;width=427.00006103515625" alt="image.png"></p>
<hr>
<p><strong>离散对数</strong><br>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。<br>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。</p>
<blockquote>
<p>是不是听到这个数学概念就怂了？不怕，这次不会说离散对数推到的过程，只简单提一下它的数学公式。<br>离散对数是「离散 + 对数」的两个数学概念的组合，所以我们先来复习一遍对数。<br>要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。<br>举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061663353-cd1d6188-015e-449a-8d00-ae5760012c5c.png#averageHue=%23e7dda8&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u80201dcd&amp;name=image.png&amp;originHeight=257&amp;originWidth=437&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53630&amp;status=done&amp;style=none&amp;taskId=ua18f841b-3877-4e9e-9f5d-0df1ff4ba45&amp;title=" alt="image.png"><br>那么对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6，计算过程如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061663382-61db7129-5fce-409e-8665-90a04c9fff24.png#averageHue=%23f8f5ee&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7c5438fd&amp;name=image.png&amp;originHeight=279&amp;originWidth=702&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=51557&amp;status=done&amp;style=none&amp;taskId=ud849760d-9f47-4e76-a4d7-30bf611cf20&amp;title=" alt="image.png"><br>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，<br>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。离散对数的概念如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061663500-e51375e5-4967-4448-a882-d925d012ec83.png#averageHue=%23ede0bd&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7cd245ce&amp;name=image.png&amp;originHeight=227&amp;originWidth=692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104925&amp;status=done&amp;style=none&amp;taskId=u6e21052f-714a-4636-9ffd-8297a8a6ab4&amp;title=" alt="image.png"><br>上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。<br><strong>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</strong></p>
</blockquote>
<hr>
<p><strong>DH 算法</strong><br>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。<br>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。<br>然后小红和小明各自生成一个随机整数作为<strong>私钥</strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。<br>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出<strong>公钥</strong>：</p>
<ul>
<li>小红的公钥记作 A，A = G ^ a ( mod P )；</li>
<li>小明的公钥记作 B，B = G ^ b ( mod P )；</li>
</ul>
<p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。<br>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。<br>然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061663605-d19b8d57-0815-40fd-b320-148df9371c76.png#averageHue=%23f5f4b2&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue78c59c5&amp;name=image.png&amp;originHeight=429&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=132593&amp;status=done&amp;style=none&amp;taskId=u194a0887-2273-42b4-afdb-545210c6bb6&amp;title=" alt="image.png"><br>这个 K 就是小红和小明之间用的<strong>对称加密密钥</strong>，可以作为会话密钥使用。<br>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。<br>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。</p>
<hr>
<p><strong>DHE 算法</strong><br>根据私钥生成的方式，DH 算法分为两种实现：</p>
<ul>
<li>static DH 算法，这个是已经被废弃了；</li>
<li>DHE 算法，现在常用的；</li>
</ul>
<p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。<br>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <strong>static DH 算法不具备前向安全性</strong>。<br>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。<br>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为<strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」</strong>。</p>
<hr>
<p><strong>ECDHE 算法</strong><br>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。<br>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。<br>小红和小明使用 ECDHE 密钥交换算法的过程：</p>
<ul>
<li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li>
<li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li>
<li>双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li>
</ul>
<p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p>
<hr>
<p><strong>ECDHE 握手过程</strong><br>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。<br>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061665965-ddbe79ab-9365-4930-a360-6279a6d84616.png#averageHue=%23c6cade&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1b726704&amp;name=image.png&amp;originHeight=362&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=382969&amp;status=done&amp;style=none&amp;taskId=uf6f5c1c4-57ca-4d2b-bad7-e72c5231a3f&amp;title=" alt="image.png"><br>细心的小伙伴应该发现了，<strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。<br>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。<br>接下来，分析每一个 ECDHE 握手过程。<br><strong>TLS 第一次握手</strong><br>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061665910-8ad1180e-027f-4144-9ca3-551d8bebc4c5.png#averageHue=%23e9e8e7&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u47c24a64&amp;name=image.png&amp;originHeight=476&amp;originWidth=917&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=231904&amp;status=done&amp;style=none&amp;taskId=u101e46f2-6e97-49cf-a115-cfd3fa0b58b&amp;title=" alt="image.png"><br><strong>TLS 第二次握手</strong><br>服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（<em>Server Random</em>）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061666015-e220b70b-572c-4fc7-a0df-192ad8069ced.png#averageHue=%23e9e6e6&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ucfc977a2&amp;name=image.png&amp;originHeight=445&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=218668&amp;status=done&amp;style=none&amp;taskId=u3a67aa49-de93-4b73-9b37-c320193c2fc&amp;title=" alt="image.png"><br>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。<br>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p>
<ul>
<li>密钥协商算法使用 ECDHE；</li>
<li>签名算法使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li>
<li>摘要算法使用 SHA384；</li>
</ul>
<p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061665880-515168e0-9eac-4bc0-ad59-644698db022e.png#averageHue=%23f1f0f0&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua28582c2&amp;name=image.png&amp;originHeight=256&amp;originWidth=1015&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=106905&amp;status=done&amp;style=none&amp;taskId=u3c76ae23-4c64-4f66-81e0-aba0c2f100b&amp;title=" alt="image.png"><br>这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061665963-dfcbc21d-e580-4d8a-b249-b13d78683a64.png#averageHue=%23efeded&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua44903f8&amp;name=image.png&amp;originHeight=343&amp;originWidth=1000&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=164937&amp;status=done&amp;style=none&amp;taskId=uc627c15a-898c-497a-b1bb-a7a5c15da46&amp;title=" alt="image.png"><br>这个过程服务器做了三件事：</p>
<ul>
<li>选择了<strong>名为 x25519 的椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>
</ul>
<p>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。<br>随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061669012-c1dc9fe6-e689-4d11-bf4f-313362025a0f.png#averageHue=%23f2f2f2&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u98ed42a0&amp;name=image.png&amp;originHeight=116&amp;originWidth=707&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50836&amp;status=done&amp;style=none&amp;taskId=uc79eb2ee-e984-42db-bfd0-0a4b69822cc&amp;title=" alt="image.png"><br>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。<br><strong>TLS 第三次握手</strong><br>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。<br>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥</strong>，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061669064-a1682f38-57b9-4abc-8840-166149d1f14c.png#averageHue=%23eeebeb&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u8a170ca5&amp;name=image.png&amp;originHeight=235&amp;originWidth=880&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113710&amp;status=done&amp;style=none&amp;taskId=u44c4b7f1-c4d6-4f18-8126-6dd0268139d&amp;title=" alt="image.png"><br>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，<strong>但实际应用中，x 还不是最终的会话密钥</strong>。<br>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？<br><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。<br>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。<br>算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061669048-497d8ecb-603a-4e25-8f59-91885cf530ac.png#averageHue=%23f7f7f5&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6a02dd89&amp;name=image.png&amp;originHeight=118&amp;originWidth=777&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53802&amp;status=done&amp;style=none&amp;taskId=u858ba33e-b36a-4e5e-90cc-e5f591aa3ba&amp;title=" alt="image.png"><br>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659061668962-af404965-edda-49e7-9741-9cb09b965a3b.png#averageHue=%23f7f7f5&amp;clientId=u46bf6d88-797b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u43e3122b&amp;name=image.png&amp;originHeight=122&amp;originWidth=794&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=56493&amp;status=done&amp;style=none&amp;taskId=uc137221b-add2-4365-876c-2a104e5dcfd&amp;title=" alt="image.png"><br><strong>TLS 第四次握手</strong><br>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p>
<hr>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>RSA 和 ECDHE 握手过程的区别：</p>
<ul>
<li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li>
<li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；</li>
<li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li>
</ul>
<hr>
<h4 id="④HTTP-与-HTTPS-有哪些区别？"><a href="#④HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="④HTTP 与 HTTPS 有哪些区别？"></a>④HTTP 与 HTTPS 有哪些区别？</h4><ol>
<li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP 层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</li>
<li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。</li>
<li>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。 </li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 <h4 id="⑤HTTPS-解决了-HTTP-的哪些问题？"><a href="#⑤HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="⑤HTTPS 解决了 HTTP 的哪些问题？"></a>⑤HTTPS 解决了 HTTP 的哪些问题？</h4>HTTP 由于是明文传输，所以安全上存在以下三个风险：</li>
</ol>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650350875452-8d6748bd-4aa3-4777-8b69-2f3e7a972c95.png#averageHue=%23d4d9d5&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=uf5b81068&amp;name=image.png&amp;originHeight=275&amp;originWidth=596&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77363&amp;status=done&amp;style=none&amp;taskId=uad6a8250-0d91-4565-b7fd-de10e6db171&amp;title=&amp;width=526" alt="image.png"><br>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<p>可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。<br>HTTPS 是如何解决上⾯的三个⻛险的？</p>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<p><em>1. 混合加密</em><br>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650350967084-bd96be4c-8cf3-496e-aea0-11cf463abf4f.png#averageHue=%23f3dd9b&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=u723be3e9&amp;name=image.png&amp;originHeight=471&amp;originWidth=613&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=246207&amp;status=done&amp;style=none&amp;taskId=ue264ccfe-192b-41ef-ad0e-3faf0c7524a&amp;title=&amp;width=453" alt="image.png"><br>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<p><em>2. 摘要算法+数字签名</em><br><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。<br>摘要算法</p>
<ul>
<li>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</li>
<li>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</li>
<li>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851053014-810aa66c-2393-41d6-9a19-1e9b1071fd17.png#averageHue=%23f7f4ea&amp;clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=325&amp;id=ueb304f81&amp;name=image.png&amp;originHeight=636&amp;originWidth=1276&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=245192&amp;status=done&amp;style=none&amp;taskId=u8446140e-c4b4-478b-aa56-c32a988bbde&amp;title=&amp;width=653.0000610351562" alt="image.png"><br>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<blockquote>
<p>举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。<br>但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。<br>那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p>
</blockquote>
<p>数字签名（公钥，私钥）<br>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p>
<ul>
<li>一个是公钥，这个是可以公开给所有人的；</li>
<li>一个是私钥，这个必须由本人管理，不可泄露。</li>
</ul>
<p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。<br>流程的不同，意味着目的也不相同：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。<br>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。<br>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657851053043-ecbc49f8-d23c-41fc-a365-6cbaf5ff8b02.png#averageHue=%23faf9f4&amp;clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uc52ad979&amp;name=image.png&amp;originHeight=652&amp;originWidth=1282&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=219722&amp;status=done&amp;style=none&amp;taskId=ubb4534c5-8b25-4aa7-9cf4-037aa96c067&amp;title=&amp;width=545.0000610351562" alt="image.png"><br>引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥，你老师持有着公钥。<br>这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。</p>
</blockquote>
<p><em>3. 数字证书</em><br>前面我们知道：</p>
<ul>
<li>可以通过哈希算法来保证消息的完整性；</li>
<li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li>
</ul>
<p>但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？<br>所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650350967301-93893cb3-3218-4700-9f34-bbfed195b644.png#averageHue=%23dfd395&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=307&amp;id=u97d415cb&amp;name=image.png&amp;originHeight=577&amp;originWidth=779&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=371816&amp;status=done&amp;style=none&amp;taskId=u20968e18-253c-4b17-a104-796cea154e7&amp;title=&amp;width=414" alt="image.png"><br>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。<br>数字证书的工作流程，我也画了一张图，方便大家理解：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1658458709449-32dc022a-3d68-4910-888e-823236723513.png#averageHue=%23e1d6a2&amp;clientId=u6dc524c5-d932-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=367&amp;id=u681ac3e9&amp;name=image.png&amp;originHeight=577&amp;originWidth=779&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=362582&amp;status=done&amp;style=none&amp;taskId=ud1415ba0-9255-4a51-910f-12268030aab&amp;title=&amp;width=495.00006103515625" alt="image.png"><br>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。<br>详细内容还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。<br>但是我们还可以自己伪造出一对公私钥啊！<br>你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。<br>但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是你父亲写的请假条，又允许你请假了。<br>好家伙，为了一个请假，真的是斗智斗勇。<br>后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。<br>正所谓魔高一丈，道高一尺。<br>既然伪造公私钥那么随意，所以你爸把他的公钥注册到<strong>警察局</strong>，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个<strong>数字证书，也就是说这个数字证书包含你爸爸的公钥。</strong><br>这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。<br>老师拿到了数字证书后，<strong>首先会去警察局验证这个数字证书是否合法</strong>，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。<br><strong>由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的</strong>，于是老师就可以安心的用这个公钥解密出清教条，如果能解密出，就证明是你爸爸写的请假条。<br>正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。<br>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<h3 id="ⅥHTTP-1-1、HTTP-2、HTTP-3-演变✊"><a href="#ⅥHTTP-1-1、HTTP-2、HTTP-3-演变✊" class="headerlink" title="ⅥHTTP/1.1、HTTP/2、HTTP/3 演变✊"></a>ⅥHTTP/1.1、HTTP/2、HTTP/3 演变✊</h3><h4 id="①说说-HTTP-1-1-相⽐-HTTP-1-0-提⾼了什么性能？"><a href="#①说说-HTTP-1-1-相⽐-HTTP-1-0-提⾼了什么性能？" class="headerlink" title="①说说 HTTP/1.1 相⽐ HTTP/1.0 提⾼了什么性能？"></a>①说说 HTTP/1.1 相⽐ HTTP/1.0 提⾼了什么性能？</h4><p>HTTP/1.1 相⽐ HTTP/1.0 性能上的改进： </p>
<ul>
<li>使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。 </li>
<li>⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 减少整体的响应时间。 <h4 id="②HTTP-1-1的性能瓶颈："><a href="#②HTTP-1-1的性能瓶颈：" class="headerlink" title="②HTTP/1.1的性能瓶颈："></a>②HTTP/1.1的性能瓶颈：</h4>1.请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；<br>2.发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；<br>3.服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直接收不到数据，也就是队头阻塞；<br>4.没有请求优先级控制；<br>5.请求只能从客户端开始，服务器只能被动响应。<h4 id="③那上⾯的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？"><a href="#③那上⾯的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？" class="headerlink" title="③那上⾯的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？"></a>③那上⾯的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h4><h5 id="1-头部压缩"><a href="#1-头部压缩" class="headerlink" title="1. 头部压缩"></a>1. 头部压缩</h5>HTTP 协议的报文是由「Header + Body」构成的，对于 Body 部分，HTTP/1.1 协议可以使用头字段 「Content-Encoding」指定 Body 的压缩方式，比如用 gzip 压缩，这样可以节约带宽，但报文中的另外一部分 Header，是没有针对它的优化手段。<blockquote>
<p>HTTP/1.1 报文中 Header 部分存在的问题：</p>
<ul>
<li>含很多固定的字段，比如Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要<strong>压缩</strong>；</li>
<li>大量的请求和响应的报文里有很多字段值都是重复的，这样会使得大量带宽被这些冗余的数据占用了，所以有必须要<strong>避免重复性</strong>；</li>
<li>字段是 ASCII 编码的，虽然易于人类观察，但效率低，所以有必要改成<strong>二进制编码</strong>；</li>
</ul>
</blockquote>
</li>
</ul>
<p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。<br>比如使用HPACK算法来压缩头部<br>压缩头部的详细内容HTTP/2 对 Header 部分做了大改造，把以上的问题都解决了。<br>HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法，HPACK 算法主要包含三个组成部分：</p>
<ul>
<li>静态字典；</li>
<li>动态字典；</li>
<li>Huffman 编码（压缩算法）；</li>
</ul>
<p>客户端和服务器两端都会建立和维护「<strong>字典</strong>」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong>。</p>
<h3 id="静态表编码"><a href="#静态表编码" class="headerlink" title="静态表编码"></a>静态表编码</h3><p>HTTP/2 为高频出现在头部的字符串和字段建立了一张<strong>静态表</strong>，它是写入到 HTTP/2 框架里的，不会变化的，静态表里共有 61 组，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853819267-6ec0c7ba-4486-4f4b-a79e-ab1aaa76c11a.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u42d06d91&amp;name=image.png&amp;originHeight=850&amp;originWidth=635&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=218361&amp;status=done&amp;style=none&amp;taskId=ueb48c736-80d8-4fbb-aabb-899dbb674ef&amp;title=" alt="image.png"><br>表中的 Index 表示索引（Key），Header Value 表示索引对应的 Value，Header Name 表示字段的名字，比如 Index 为 2 代表 GET，Index 为 8 代表状态码 200。<br>你可能注意到，表中有的 Index 没有对应的 Header Value，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。<br>这么说有点抽象，我们来看个具体的例子，下面这个 server 头部字段，在 HTTP/1.1 的形式如下：<br>server: nghttpx\r\n<br>算上冒号空格和末尾的\r\n，共占用了 17 字节，<strong>而使用了静态表和 Huffman 编码，可以将它压缩成 8 字节，压缩率大概 47 %</strong>。<br>我抓了个 HTTP/2 协议的网络包，你可以从下图看到，高亮部分就是 server 头部字段，只用了 8 个字节来表示 server 头部数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853819342-91296135-ce8a-433c-beba-da502090d488.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9d61cc51&amp;name=image.png&amp;originHeight=500&amp;originWidth=1726&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=335454&amp;status=done&amp;style=none&amp;taskId=ue9f27afc-f7a7-4618-bea5-0d58c3905d3&amp;title=" alt="image.png"><br>根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 01，所以整个头部格式如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853819129-e09c603a-184f-4a39-b595-d7ac7933a4c9.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ucca5bdf4&amp;name=image.png&amp;originHeight=348&amp;originWidth=752&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94813&amp;status=done&amp;style=none&amp;taskId=u7375fc57-71c2-4d24-b3f0-6a86010f7fd&amp;title=" alt="image.png"><br>HTTP/2 头部由于基于<strong>二进制编码</strong>，就不需要冒号空格和末尾的\r\n作为分隔符，于是改用表示字符串长度（Value Length）来分割 Index 和 Value。<br>接下来，根据这个头部格式来分析上面抓包的 server 头部的二进制数据。<br>首先，从静态表中能查到 server 头部字段的 Index 为 54，二进制为 110110，再加上固定 01，头部格式第 1 个字节就是 01110110，这正是上面抓包标注的红色部分的二进制数据。<br>然后，第二个字节的首个比特位表示 Value 是否经过 Huffman 编码，剩余的 7 位表示 Value 的长度，比如这次例子的第二个字节为 10000110，首位比特位为 1 就代表 Value 字符串是经过 Huffman 编码的，经过 Huffman 编码的 Value 长度为 6。<br>最后，字符串 nghttpx 经过 Huffman 编码后压缩成了 6 个字节，Huffman 编码的原理是将高频出现的信息用「较短」的编码表示，从而缩减字符串长度。<br>于是，在统计大量的 HTTP 头部后，HTTP/2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，可以在 RFC7541 文档找到这张<strong>静态 Huffman 表</strong>，我就不把表的全部内容列出来了，我只列出字符串 nghttpx 中每个字符对应的 Huffman 编码，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853819148-8b4cced2-a2c9-403e-8dee-b93d15f249fe.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5ef577a1&amp;name=image.png&amp;originHeight=452&amp;originWidth=617&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=59485&amp;status=done&amp;style=none&amp;taskId=u627623ad-a0eb-4198-8b3b-e8dd10caecc&amp;title=" alt="image.png"><br>通过查表后，字符串 nghttpx 的 Huffman 编码在下图看到，共 6 个字节，每一个字符的 Huffman 编码，我用相同的颜色将他们对应起来了，最后的 7 位是补位的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853819118-bc798bd0-9fdb-4679-8bbe-f57139c6b149.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue75afdf3&amp;name=image.png&amp;originHeight=99&amp;originWidth=722&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46259&amp;status=done&amp;style=none&amp;taskId=u10bc4081-fef3-4ed1-a21a-5a1e15a31af&amp;title=" alt="image.png"><br>最终，server 头部的二进制数据对应的静态头部格式如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853820848-cdf3f3c5-6f43-4567-90b3-e7bf52c4f9c1.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u44a5d761&amp;name=image.png&amp;originHeight=812&amp;originWidth=947&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=236624&amp;status=done&amp;style=none&amp;taskId=u30658b24-cb51-49ed-90c3-6f2b8fed6df&amp;title=" alt="image.png"></p>
<h3 id="动态表编码"><a href="#动态表编码" class="headerlink" title="动态表编码"></a>动态表编码</h3><p>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，它的 Index 从 62 起步，会在编码解码的时候随时更新。<br>比如，第一次发送时头部中的「user-agent 」字段数据有上百个字节，经过 Huffman 编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62。<strong>那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据</strong>。<br>所以，使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。<br>因此，随着在同一 HTTP/2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。<br>理想很美好，现实很骨感。动态表越大，占用的内存也就越大，如果占用了太多内存，是会影响服务器性能的，因此 Web 服务器都会提供类似 http2_max_requests 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP/2 连接来释放内存。<br>综上，HTTP/2 头部的编码通过「静态表、动态表、Huffman 编码」共同完成的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657853820836-0feacfe9-5dbe-43e7-9ce9-d4f0666895ae.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue5ea7e15&amp;name=image.png&amp;originHeight=339&amp;originWidth=1117&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=189157&amp;status=done&amp;style=none&amp;taskId=u230dfe3a-8ea2-48fe-ae26-28748c27bb5&amp;title=" alt="image.png"></p>
<h5 id="2-二进制格式"><a href="#2-二进制格式" class="headerlink" title="2. 二进制格式"></a>2. 二进制格式</h5><ul>
<li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</li>
<li>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351310887-0dabbfef-60dc-4f87-9a7e-b6855033f482.png#averageHue=%23e3ded9&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=257&amp;id=u292edd0d&amp;name=image.png&amp;originHeight=564&amp;originWidth=1111&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183065&amp;status=done&amp;style=none&amp;taskId=u2a622da4-2311-48a3-89a2-9e0c0757959&amp;title=&amp;width=507" alt="image.png"></p>
<p>补充&gt; 比如状态码 200 ，在 HTTP/1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：110010 110000 110000），如图：</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351311285-b92f53ce-6a65-40ea-bae5-db02e09bb78c.png#clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=378&amp;id=fQtVV&amp;name=image.png&amp;originHeight=1454&amp;originWidth=2436&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=469814&amp;status=done&amp;style=none&amp;taskId=uc6cbde3c-0c26-419a-8376-23d14b93410&amp;title=&amp;width=633" alt="image.png"><br>在 HTTP/2 是用数字 200 表示（二进制：11001000），如图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351311371-0a7fcf63-9de7-41ea-b80c-f24183901cf7.png#clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=351&amp;id=AkQNI&amp;name=image.png&amp;originHeight=1424&amp;originWidth=2622&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=472502&amp;status=done&amp;style=none&amp;taskId=u63a4f304-6189-4391-9475-641f8c0364f&amp;title=&amp;width=646" alt="image.png"></p>
</blockquote>
<h5 id="3-并发传输"><a href="#3-并发传输" class="headerlink" title="3. 并发传输"></a><em>3. 并发传输</em></h5><p>我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。<br>而 HTTP/2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1662552433390-e6e94271-277e-4b0d-becc-8d1d5e902d9f.png#averageHue=%235b99d5&amp;clientId=u850fb9e4-c8da-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=479&amp;id=u7ffef7be&amp;name=image.png&amp;originHeight=535&amp;originWidth=464&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155920&amp;status=done&amp;style=none&amp;taskId=uff3f80d4-d3d1-4700-8a32-61ac0a60797&amp;title=&amp;width=415.0000305175781" alt="image.png"></p>
<ul>
<li>从上图可以看到，1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。</li>
<li><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。<blockquote>
<p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1662552433672-5245d296-fbf6-4566-a80b-1c181b2d544c.png#averageHue=%23e8e6e4&amp;clientId=u850fb9e4-c8da-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ucdfc8d5d&amp;name=image.png&amp;originHeight=228&amp;originWidth=787&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98598&amp;status=done&amp;style=none&amp;taskId=u670433a2-a3ee-4e44-8e5a-2b656f32d3a&amp;title=" alt="image.png"></p>
</blockquote>
</li>
</ul>
<p>数据流详解</p>
<ul>
<li>在 HTTP/2 中每个请求或响应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号（Stream ID），<strong>不同 Stream 的帧(frame)是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</li>
<li>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li>
<li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351310696-f5f8bf71-07a0-4e26-bbfe-a4f8e9e4dc3a.png#clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=SMHCN&amp;name=image.png&amp;originHeight=598&amp;originWidth=1482&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=100405&amp;status=done&amp;style=none&amp;taskId=uf8eff75a-7525-431e-bfa5-b38f4a54c67&amp;title=&amp;width=542" alt="image.png"></p>
<p>为了理解 HTTP/2 的并发是怎样实现的，我们先来理解 HTTP/2 中的 Stream、Message、Frame 这 3 个概念。<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657854152614-7e32cc77-9004-48e4-9174-953dc247d28d.png#clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=can1W&amp;name=image.png&amp;originHeight=535&amp;originWidth=464&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155920&amp;status=done&amp;style=none&amp;taskId=ueb11f002-6c4f-418d-8b61-874c521350e&amp;title=" alt="image.png"><br>你可以从上图中看到：<br>Stream表示一个请求<strong>和</strong>响应</p>
<ul>
<li>1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</li>
<li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</li>
<li>Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</li>
</ul>
<p>因此，我们可以得出 2 个结论：HTTP 消息可以由多个 Frame 构成，以及 1 个 Frame 可以由多个 TCP 报文构成。<br>在 HTTP/2 连接上，<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p>
<h5 id="4-服务器推送"><a href="#4-服务器推送" class="headerlink" title="4. 服务器推送"></a>4. 服务器推送</h5><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p>
<blockquote>
<p>比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351311625-b3a055a8-cc75-4bc5-9256-e6770a4bdbf4.png#averageHue=%23f7f7f7&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=uc5526f25&amp;name=image.png&amp;originHeight=402&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49116&amp;status=done&amp;style=none&amp;taskId=u43f3164c-79a2-4a6b-b5a9-c34f93a1c2a&amp;title=&amp;width=522" alt="image.png"><br>如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p>
</blockquote>
<h4 id="④HTTP-2-有什么缺陷？-可以看下述有详细的讲解"><a href="#④HTTP-2-有什么缺陷？-可以看下述有详细的讲解" class="headerlink" title="④HTTP/2 有什么缺陷？(可以看下述有详细的讲解)"></a>④HTTP/2 有什么缺陷？(可以看下述有详细的讲解)</h4><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，<strong>只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</strong><br><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong><br>例子举个例子，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1650351462789-1690f1a3-7b60-4248-9d8c-afa0e03b1609.gif#clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=oPjQ8&amp;originHeight=502&amp;originWidth=521&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u30fd503a-0ecc-4dc1-90d1-905d98ffe10&amp;title=" alt=""><br>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。<br>所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<h4 id="③HTTP-3-做了哪些优化？"><a href="#③HTTP-3-做了哪些优化？" class="headerlink" title="③HTTP/3 做了哪些优化？"></a>③HTTP/3 做了哪些优化？</h4><p>前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p>
<ul>
<li>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等相应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li>
<li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li>
</ul>
<p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351562403-261c57ec-9eaf-4b7a-8744-14e67dda93f9.png#averageHue=%23d0d492&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u0055327b&amp;name=image.png&amp;originHeight=366&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=158562&amp;status=done&amp;style=none&amp;taskId=u796e761e-8e3c-4127-b400-3b6f303540a&amp;title=&amp;width=679" alt="image.png"><br>UDP 发生是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题<br>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。<br><strong>QUIC 有以下 3 个特点。</strong></p>
<h5 id="1、无队头阻塞"><a href="#1、无队头阻塞" class="headerlink" title="1、无队头阻塞"></a>1、无队头阻塞</h5><p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。<br>由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。<br>不过 QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。<br>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。<br>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。<strong>因此不存在队头阻塞问题</strong>。</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351562609-13cb6ee9-48b7-4891-a6a2-9ad6bfafc8b9.png#averageHue=%23bbb7a3&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=ue6e51392&amp;name=image.png&amp;originHeight=504&amp;originWidth=700&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=216836&amp;status=done&amp;style=none&amp;taskId=u0d2d4ada-0240-45c7-ae72-e9ebd827488&amp;title=&amp;width=455" alt="image.png"></p>
</blockquote>
<h5 id="2、更快的连接建立"><a href="#2、更快的连接建立" class="headerlink" title="2、更快的连接建立"></a>2、更快的连接建立</h5><ul>
<li>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</li>
<li>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</li>
<li>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</li>
</ul>
<p>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1651480815000-e39cc13a-10ca-42d4-b5eb-d0f78bc5a628.gif#averageHue=%23f9f9f9&amp;clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=utRiE&amp;originHeight=381&amp;originWidth=600&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc04b7814-a4a6-4a7a-ba73-a7c83abc92d&amp;title=" alt=""></p>
<h5 id="3、连接迁移"><a href="#3、连接迁移" class="headerlink" title="3、连接迁移"></a>3、连接迁移</h5><ul>
<li><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
</li>
<li><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
</li>
</ul>
<p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351562734-f5cc49d8-46a2-44bc-b65d-0f2cf512ef99.png#averageHue=%23dbd1c8&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=u96ebb144&amp;name=image.png&amp;originHeight=327&amp;originWidth=700&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119078&amp;status=done&amp;style=none&amp;taskId=u3322b97a-f357-4af2-aafe-af08e7d70c7&amp;title=&amp;width=546" alt="image.png"><br>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。<br>所以，HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。<br>接着就看下述！！！</p>
<h2 id="二、HTTP-3-强势来袭✊"><a href="#二、HTTP-3-强势来袭✊" class="headerlink" title="二、HTTP/3 强势来袭✊"></a>二、HTTP/3 强势来袭✊</h2><p>HTTP/3 现在还没正式推出，不过自 2017 年起， HTTP/3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。<br>所以，这次 HTTP/3 介绍不会涉及到包格式，只说它的特性。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480814514-44600702-9be0-4326-a3c2-008cb15f1a08.png#averageHue=%23fcfcfc&amp;clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=YkVLe&amp;originHeight=589&amp;originWidth=926&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4eb48d79-7261-43e1-8a45-d057170dee5&amp;title=" alt=""></p>
<hr>
<p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。<br><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong><br>有没有什么解决方案呢？既然是 TCP 协议自身的问题，那干脆放弃 TCP 协议，转而使用 UDP 协议作为传输层协议，这个大胆的决定， HTTP/3 协议做了！<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657854262741-6c1f714d-edbd-4d74-9a95-aa2d3ac58e6d.png#averageHue=%23d8cf5f&amp;clientId=uce657f4e-0d26-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=A0Wvj&amp;name=image.png&amp;originHeight=366&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=179959&amp;status=done&amp;style=none&amp;taskId=u0fefeae8-01e5-4ce7-8718-9c7defb9b3c&amp;title=" alt="image.png"></p>
<h3 id="ⅠHTTP-2存在的缺陷"><a href="#ⅠHTTP-2存在的缺陷" class="headerlink" title="ⅠHTTP/2存在的缺陷"></a>ⅠHTTP/2存在的缺陷</h3><p>HTTP/2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP/1.1 的性能，而美中不足的是 HTTP/2 协议是基于 TCP 实现的，于是存在的缺陷有三个。</p>
<ul>
<li>队头阻塞；</li>
<li>TCP 与 TLS 的握手时延迟；</li>
<li><p>网络迁移需要重新连接；</p>
<h4 id="①队头阻塞"><a href="#①队头阻塞" class="headerlink" title="①队头阻塞"></a>①队头阻塞</h4></li>
<li><p>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</p>
</li>
<li>因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。<blockquote>
<p>举个例子，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1651480813595-015050a4-3f9b-4b7a-a72e-4901aee95afd.gif#averageHue=%23f6f4f3&amp;clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ORZka&amp;originHeight=502&amp;originWidth=521&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7696d465-a102-4fb0-8b5e-cfe41483dad&amp;title=" alt=""><br>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。</p>
</blockquote>
</li>
</ul>
<h4 id="②TCP-与-TLS-的握手时延迟"><a href="#②TCP-与-TLS-的握手时延迟" class="headerlink" title="②TCP 与 TLS 的握手时延迟"></a>②TCP 与 TLS 的握手时延迟</h4><p>发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1651480813651-d8444cae-75f2-4a91-bd3b-1a681bc69454.gif#averageHue=%23f6f2ed&amp;clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=443&amp;id=bbQR9&amp;originHeight=693&amp;originWidth=777&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u17c3ab9e-a786-47e2-a5b5-7a26e491e81&amp;title=&amp;width=497.00006103515625" alt=""><br>另外， TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生”减速”效果。</p>
<h4 id="③网络迁移需要重新连接"><a href="#③网络迁移需要重新连接" class="headerlink" title="③网络迁移需要重新连接"></a>③网络迁移需要重新连接</h4><ul>
<li>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</li>
</ul>
<p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP/2 在怎么设计都无法逃脱。要解决这个问题，就必须把<strong>传输层协议替换成 UDP</strong>，这个大胆的决定，HTTP/3 做了！<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651480814426-76c19339-bda8-495f-a308-127e816a5c2b.jpeg#averageHue=%23dcd1c9&amp;clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Lpq49&amp;originHeight=327&amp;originWidth=700&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u288ed105-a409-4f15-a319-ec12c803ff9&amp;title=" alt=""></p>
<hr>
<h3 id="ⅡQUIC-协议的特点"><a href="#ⅡQUIC-协议的特点" class="headerlink" title="ⅡQUIC 协议的特点"></a>ⅡQUIC 协议的特点</h3><p>我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。<br>而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。<br>当然，HTTP/3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在<strong>「应用层」</strong>实现了 <strong>QUIC 协议</strong>，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。<br>QUIC 协议的优点有很多，这里举例几个，比如：</p>
<ul>
<li>无队头阻塞；</li>
<li>更快的连接建立；</li>
<li>连接迁移；<h4 id="①无队头阻塞"><a href="#①无队头阻塞" class="headerlink" title="①无队头阻塞"></a>①无队头阻塞</h4>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。<br>由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。<br>不过 QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。<br>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。<br>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。<strong>因此不存在队头阻塞问题</strong>。<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650351562609-13cb6ee9-48b7-4891-a6a2-9ad6bfafc8b9.png#averageHue=%23bbb7a3&amp;clientId=u101e6d59-e57c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=USZWg&amp;name=image.png&amp;originHeight=504&amp;originWidth=700&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=216836&amp;status=done&amp;style=none&amp;taskId=u0d2d4ada-0240-45c7-ae72-e9ebd827488&amp;title=&amp;width=455" alt="image.png"></p>
</blockquote>
</li>
</ul>
<h4 id="②更快的连接建立"><a href="#②更快的连接建立" class="headerlink" title="②更快的连接建立"></a>②更快的连接建立</h4><ul>
<li>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</li>
<li>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</li>
<li>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</li>
</ul>
<p>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1651480815000-e39cc13a-10ca-42d4-b5eb-d0f78bc5a628.gif#averageHue=%23f9f9f9&amp;clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=rC5lM&amp;originHeight=381&amp;originWidth=600&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc04b7814-a4a6-4a7a-ba73-a7c83abc92d&amp;title=" alt=""></p>
<h4 id="③连接迁移"><a href="#③连接迁移" class="headerlink" title="③连接迁移"></a>③连接迁移</h4><ul>
<li><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
</li>
<li><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
</li>
</ul>
<hr>
<h3 id="ⅢHTTP-3-协议"><a href="#ⅢHTTP-3-协议" class="headerlink" title="ⅢHTTP/3 协议"></a>ⅢHTTP/3 协议</h3><p>了解完 QUIC 协议的特点后，我们再来看看 HTTP/3 协议在 HTTP 这一层做了什么变化。<br>HTTP/3 同 HTTP/2 一样采用二进制帧的结构，不同的地方在于 HTTP/2 的二进制帧里需要定义 Stream，而 HTTP/3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP/3 的帧的结构也变简单了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480815271-a14f2331-c31c-4019-8ac8-07b06fb530b1.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=x2LQc&amp;originHeight=590&amp;originWidth=1727&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2b5bd7c-7811-44d2-b496-a42d7b4f54a&amp;title=" alt=""><br>从上图可以看到，HTTP/3 帧头只有两个字段：类型和长度。<br>根据帧类型的不同，大体上分为数据帧和控制帧两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。<br>HTTP/3 在头部压缩算法这一方便也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP/2 中的 HPACK 编码方式相似，HTTP/3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。<br>对于静态表的变化，HTTP/2 中的 HPACK 的静态表只有 61 项，而 HTTP/3 中的 QPACK 的静态表扩大到 91 项。<br>HTTP/2 和 HTTP/3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。<br>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。<br>可以看到，<strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。<br>HTTP/3 的 QPACK 解决了这一问题，那它是如何解决的呢？<br>QUIC 会有两个特殊的单向流，所谓的单项流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p>
<ul>
<li>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li>
<li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li>
</ul>
<p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>
<hr>
<p><strong>期待，HTTP/3 正式推出的那一天！</strong><br><strong>聊聊 QUIC 是如何实现可靠传输的？又是如何解决上面 TCP 协议四个方面的缺陷</strong>？</p>
<h3 id="Ⅳ如何用UDP实现可靠传输"><a href="#Ⅳ如何用UDP实现可靠传输" class="headerlink" title="Ⅳ如何用UDP实现可靠传输"></a>Ⅳ如何用UDP实现可靠传输</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772966367-332a2c61-6031-427f-bb92-3adf3f4555eb.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=501&amp;id=FwMia&amp;originHeight=798&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0b4a284c-3d49-4d44-8c13-575882aec7f&amp;title=&amp;width=678" alt=""></p>
<h4 id="①QUIC-是如何实现可靠传输的？"><a href="#①QUIC-是如何实现可靠传输的？" class="headerlink" title="①QUIC 是如何实现可靠传输的？"></a>①QUIC 是如何实现可靠传输的？</h4><p>要基于 UDP 实现的可靠传输协议，那么就要在应用层下功夫，也就是要设计好协议的头部字段。<br>拿 HTTP/3 举例子，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772966475-07abdab4-554c-494e-aad1-669101513f88.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=qhSkG&amp;originHeight=371&amp;originWidth=554&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4d53fa8f-f93f-44df-b19e-b97a4e4af43&amp;title=&amp;width=390" alt=""><br>整体看的视角是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772966689-ef745b01-af91-4998-b48f-f04e1e42f4de.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=CjIld&amp;originHeight=516&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u304a6f40-fb98-48e2-b1d7-3273798573e&amp;title=&amp;width=520.0000610351562" alt=""><br>接下来，分别对每一个 Header 做个介绍。</p>
</blockquote>
<h5 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h5><p>Packet Header 首次建立连接时和日常传输数据时使用的 Header 是不同的。</p>
<blockquote>
<p>如下图，注意我没有把 Header 所有字段都画出来，只是画出了重要的字段：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772966304-cd7076fb-60d2-49dc-a371-5b958f1a862d.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=tbs1k&amp;originHeight=471&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud86dfa5d-e577-4651-86f7-986f328c66c&amp;title=&amp;width=571.0000610351562" alt=""></p>
</blockquote>
<p>Packet Header<br>细分这两种：</p>
<ul>
<li>Long Packet Header 用于首次建立连接。</li>
<li>Short Packet Header 用于日常传输数据。</li>
</ul>
<p>QUIC 也是需要三次握手来建立连接的，主要目的是为了确定连接 ID。<br>建立连接时，连接 ID 是由服务器根据客户端的 Source Connection ID 字段生成的，这样后续传输时，双方只需要固定住 Destination Connection ID（连接 ID ），从而实现连接迁移功能。所以，你可以看到日常传输数据的 Short Packet Header 不需要在传输 Source Connection ID 字段了。<br>Short Packet Header 中的 Packet Number 是每个报文独一无二的编号，它是严格递增的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772966372-7f7dfbe1-484c-4d4a-8013-537277521a52.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=276&amp;id=auLdE&amp;originHeight=592&amp;originWidth=990&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uda1d8f33-1afe-46d4-a7cd-2650468b8a1&amp;title=&amp;width=462.00006103515625" alt=""><br>为什么要这么设计呢？<br>我们先来看看  TCP 的问题，TCP 在重传报文时的序列号和原始报文的序列号是一样的，也正是由于这个特性，引入了 TCP 重传的歧义问题。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772971640-56dc6987-6a0f-4be6-b4d1-23dbda501543.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=sMsxq&amp;originHeight=396&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue544843e-d5ae-4ab5-8a5d-9f8e37c1671&amp;title=" alt=""><br>TCP 重传的歧义问题<br>比如上图，当 TCP 发生超时重传后，客户端发起重传，然后接收到了服务端确认 ACK 。由于客户端原始报文和重传报文序列号都是一样的，那么服务端针对这两个报文回复的都是相同的 ACK。<br>这样的话，客户端就无法判断出是原始报文的响应还是重传报文的响应，这样在计算 RTT（往返时间） 时应该选择从发送原始报文开始计算，还是重传原始报文开始计算呢？</p>
<ul>
<li>如果算成原始报文的响应，但实际上是重传报文的响应（上图右），会导致采样 RTT 变大；</li>
<li>如果算成重传报文的响应，但实际上是原始报文的响应（上图左），又很容易导致采样 RTT 过小；</li>
</ul>
<p>RTT 计算不精确的话，那么 RTO （超时时间）也就不精确，因为 RTO 是基于 RTT 来计算的，RTO 计算不准确可能导致重传的概率事件增大。<br>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的，这样就能更加精确计算出报文的 RTT。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772971667-1dce02e5-c30f-4a9f-bed9-ddde13c414f0.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=MD4Sb&amp;originHeight=360&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud13cbc88-bd87-4ae5-a813-f656308dcfc&amp;title=" alt=""><br>如果 ACK 的 Packet Number 是 N+M，就根据重传报文计算采样 RTT。如果 ACK 的 Pakcet Number 是 N，就根据原始报文的时间计算采样 RTT，没有歧义性的问题。<br>另外，还有一个好处，<strong>QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</strong>。<br>待发送端超过一定时间没收到 Packet N 的确认报文后，会将需要重传的数据包放到待发送队列，重新编号比如数据包 Packet N+M 后重新发送给接收端，对重传数据包的处理跟发送新的数据包类似，这样就不会因为丢包重传将当前窗口阻塞在原地，从而解决了队头阻塞问题。<br>所以，Packet Number 单调递增的两个好处：</p>
<ul>
<li>可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；</li>
<li>可以支持乱序确认，防止因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；<h5 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h5><blockquote>
<p>一个 Packet 报文中可以存放多个 QUIC Frame。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772972004-654ca0ec-9598-42e2-af75-74dc8a408c35.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=293&amp;id=oSnV2&amp;originHeight=482&amp;originWidth=696&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue49a2811-f05a-4789-af21-611f57c4bcf&amp;title=&amp;width=423" alt=""><br>每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。<br>我这里只举例  Stream 类型的 Frame 格式，Stream 可以认为就是一条 HTTP 请求，它长这样：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772972417-11bd8f4f-935a-439b-81ac-7b23ba6a5fab.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ZZP4j&amp;originHeight=606&amp;originWidth=660&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6b8aa8d4-1c02-440e-9027-50e2d1f3b69&amp;title=&amp;width=300.0000305175781" alt=""></p>
</blockquote>
</li>
</ul>
<p>它里面有：</p>
<ul>
<li>Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别；</li>
<li>Offset 作用：类似于 TCP 协议中的 Seq 序号，<strong>保证数据的顺序性和可靠性</strong>；</li>
<li>Length 作用：指明了 Frame 数据的长度。</li>
</ul>
<p>在前面介绍 Packet Header 时，说到 Packet Number 是严格递增，即使重传报文的 Packet Number 也是递增的，既然重传数据包的 Packet N+M 与丢失数据包的 Packet N 编号并不一致，我们怎么确定这两个数据包的内容一样呢？<br>所以引入 Frame Header 这一层，<strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p>
<blockquote>
<p>举个例子，下图中，数据包 Packet N 丢失了，后面重传该数据包的编号为 Packet N+2，丢失的数据包和重传的数据包 Stream ID 与 Offset 都一致，说明这两个数据包的内容一致。这些数据包传输到接收端后，接收端能根据 Stream ID 与 Offset 字段信息将  Stream x 和 Stream x+y 按照顺序组织起来，然后交给应用程序处理。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772973427-9011c1e4-7e34-4779-ac16-d497a4f93187.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uhJPY&amp;originHeight=312&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u969526c3-8c5b-4a5e-9bef-1bd7d57ab75&amp;title=" alt=""></p>
</blockquote>
<p>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。</p>
<h4 id="②QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#②QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="②QUIC 是如何解决 TCP 队头阻塞问题的？"></a>②QUIC 是如何解决 TCP 队头阻塞问题的？</h4><h5 id="什么是-TCP-队头阻塞问题？"><a href="#什么是-TCP-队头阻塞问题？" class="headerlink" title="什么是 TCP 队头阻塞问题？"></a>什么是 TCP 队头阻塞问题？</h5><p>TCP 队头阻塞的问题要从两个角度看，一个是<strong>发送窗口的队头阻塞</strong>，另外一个是<strong>接收窗口的队头阻塞</strong>。<br><em>先来说说发送窗口的队头阻塞。</em><br>详细内容TCP 发送出去的数据，都是需要按序确认的，只有在数据都被按顺序确认完后，发送窗口才会往前滑动。<br>举个例子，比如下图的发送方把发送窗口内的数据全部都发出去了，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772973876-3e69e172-0571-4f00-96f9-e0c5d9b69fd2.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ddg6R&amp;originHeight=297&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u214c1fd6-c9ab-4f29-b82d-5b789699494&amp;title=" alt=""><br>可用窗口耗尽<br>接着，当发送方收到对第 32~36 字节的 ACK 确认应答后，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来第 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772973805-3b710f7c-ab3c-44fe-9d03-59bfeb7b3291.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=EDZyC&amp;originHeight=274&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubde576da-d5ea-43ad-8938-112ea06c887&amp;title=" alt=""><br>32 ~ 36 字节已确认<br>但是如果某个数据报文丢失或者其对应的 ACK 报文在网络中丢失，会导致发送方无法移动发送窗口，这时就无法再发送新的数据，只能超时重传这个数据报文，直到收到这个重传报文的 ACK，发送窗口才会移动，继续后面的发送行为。<br>举个例子，比如下图，客户端是发送方，服务器是接收方。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772974701-f33d6abc-2432-4892-a3d8-d15853455612.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=QwtsO&amp;originHeight=446&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u61af77a7-7e6e-4dc0-8378-db255926cc0&amp;title=" alt=""><br>客户端发送了第 5～9 字节的数据，但是第 5 字节的 ACK 确认报文在网络中丢失了，那么即使客户端收到第 6～9 字节的 ACK 确认报文，发送窗口也不会往前移动。<br><strong>此时的第 5 字节相当于“队头”，因为没有收到“队头”的 ACK 确认报文，导致发送窗口无法往前移动，此时发送方就无法继续发送后面的数据，相当于按下了发送行为的暂停键，这就是发送窗口的队头阻塞问题</strong>。<br><em>再来说说接收窗口的队头阻塞。</em><br>详细内容接收方收到的数据范围必须在接收窗口范围内，如果收到超过接收窗口范围的数据，就会丢弃该数据，比如下图接收窗口的范围是 32 ～ 51 字节，如果收到第 52 字节以上数据都会被丢弃。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772974598-c28a37a0-b74f-43c1-8e5e-a27d6e5cf2da.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=YLbEK&amp;originHeight=376&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3c217dfc-72ea-4215-aa67-ccc055e7a74&amp;title=" alt=""><br>接收窗口<br>接收窗口什么时候才能滑动？当接收窗口收到有序数据时，接收窗口才能往前滑动，然后那些已经接收并且被确认的「有序」数据就可以被应用层读取。<br>但是，当接收窗口收到的数据不是有序的，比如收到第 33～40 字节的数据，由于第 32 字节数据没有收到， 接收窗口无法向前滑动，那么即使先收到第 33～40 字节的数据，这些数据也无法被应用层读取的。只有当发送方重传了第 32 字节数据并且被接收方收到后，接收窗口才会往前滑动，然后应用层才能从内核读取第 32～40 字节的数据。<br>好了，至此发送窗口和接收窗口的队头阻塞问题都说完了，这两个问题的原因都是因为 TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留。</p>
<ul>
<li>停留「发送窗口」会使得发送方无法继续发送数据。</li>
<li>停留「接收窗口」会使得应用层无法读取新的数据。</li>
</ul>
<p>其实也不能怪 TCP 协议，它本来设计目的就是为了保证数据的有序性。</p>
<h5 id="HTTP-2-的队头阻塞"><a href="#HTTP-2-的队头阻塞" class="headerlink" title="HTTP/2  的队头阻塞"></a>HTTP/2  的队头阻塞</h5><p>详细内容HTTP/2 通过抽象出 Stream 的概念，实现了 HTTP 并发传输，一个 Stream 就代表 HTTP/1.1 里的请求和响应。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772980790-807e1e61-30bc-4c90-8895-62490f2f43d0.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=410&amp;id=SFNcD&amp;originHeight=565&amp;originWidth=694&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue8aaeaed-4d44-4ac6-ac77-0913823bf42&amp;title=&amp;width=504.00006103515625" alt=""><br>HTTP/2<br>在 HTTP/2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。<br><strong>但是 HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772981841-493af2b5-5f72-4352-b038-9f2779be849b.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=jA17P&amp;originHeight=377&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub03d6828-139f-4f82-9039-661270f716b&amp;title=" alt=""></p>
<h5 id="没有队头阻塞的-QUIC"><a href="#没有队头阻塞的-QUIC" class="headerlink" title="没有队头阻塞的 QUIC"></a>没有队头阻塞的 QUIC</h5><p>QUIC 也借鉴 HTTP/2 里的 Stream 的概念，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream)。<br>但是 <strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。<br>假如 Stream2 丢了一个 UDP 包，也只会影响 Stream2 的处理，不会影响其他 Stream，与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1652772982554-60bc0820-5045-4001-8124-f655317a6032.jpeg#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=lRSsF&amp;originHeight=377&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc7127775-6a10-4577-9475-c52ec65c178&amp;title=&amp;width=593.0000610351562" alt=""></p>
<h4 id="③QUIC-是如何做流量控制的？"><a href="#③QUIC-是如何做流量控制的？" class="headerlink" title="③QUIC 是如何做流量控制的？"></a>③QUIC 是如何做流量控制的？</h4><p>TCP 流量控制是通过让「接收方」告诉「发送方」，它（接收方）的接收窗口有多大，从而让「发送方」根据「接收方」的实际接收能力控制发送的数据量。<br>在前面说到，TCP 的接收窗口在收到有序的数据后，接收窗口才能往前滑动，否则停止滑动；TCP 的发送窗口在收到对已发送数据的顺序确认 ACK后，发送窗口才能往前滑动，否则停止滑动。</p>
<p>QUIC 是基于 UDP 传输的，而 UDP 没有流量控制，因此 QUIC 实现了自己的流量控制机制。不过，<strong>QUIC 的滑动窗口滑动的条件跟 TCP 有所差别的</strong>。<br>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p>
<ul>
<li><strong>Stream 级别的流量控制</strong>：每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li>
<li><p><strong>Connection 流量控制</strong>：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</p>
<h5 id="Stream-级别的流量控制"><a href="#Stream-级别的流量控制" class="headerlink" title="Stream 级别的流量控制"></a>Stream 级别的流量控制</h5><p>回想一下 TCP，当发送方发送 seq1、seq2、seq3 报文，由于 seq2 报文丢失了，接收方收到 seq1 后会 ack1，然后接收方收到 seq3 后还是回 ack1（因为没有收到 seq2），这时发送窗口无法往前滑动。<br>但是，<strong>QUIC 就不一样了，即使中途有报文丢失，发送窗口依然可以往前滑动</strong>，具体怎么做到的呢？我们来看看。<br>最开始，接收方的接收窗口初始状态如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772983445-ae5c658c-59fa-44d6-b147-5c4d8e91b838.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=211&amp;id=uI0Xm&amp;originHeight=253&amp;originWidth=741&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u61bca390-38ee-4309-8762-13eed15ff81&amp;title=&amp;width=617.0000610351562" alt=""><br>接着，接收方收到了发送方发送过来的数据，有的数据被上层读取了，有的数据丢包了，此时的接收窗口状况如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772983914-27e8f27f-f9e6-4b4b-b1f0-ea94ed30893c.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=YM5D5&amp;originHeight=331&amp;originWidth=741&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub7421f21-588c-4ee7-9aed-2977e5f7c2d&amp;title=&amp;width=543" alt=""><br>可以看到，<strong>接收窗口的左边界取决于接收到的最大偏移字节数</strong>，此时的接收窗口 = 最大窗口数 - 接收到的最大偏移数，这里就跟 TCP 不一样了。<br>那接收窗口触发的滑动条件是什么呢？看下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772983865-97ed3615-ee23-46e6-9299-9f3dc6558048.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=404&amp;id=TGrd2&amp;originHeight=778&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3ea7ffe5-00a2-4797-bbc4-7066eefbf18&amp;title=&amp;width=561.0000610351562" alt=""><br>接收窗口触发的滑动<br><strong>当图中的绿色部分数据超过最大接收窗口的一半后，最大接收窗口向右移动，同时给对端发送「窗口更新帧」。当发送方收到接收方的窗口更新帧后，发送窗口也会往前滑动，即使中途有丢包，依然也会滑动</strong>，这样就防止像 TCP 那样在出现丢包的时候，导致发送窗口无法移动，从而避免了无法继续发送数据。<br>在前面我们说过，<strong>每个 Stream 都有各自的滑动窗口，不同 Stream 互相独立，队头的 Stream A 被阻塞后，不妨碍 StreamB、C的读取</strong>。而对于 TCP 而言，其不知道将不同的 Stream 交给上层哪一个请求，因此同一个Connection内，Stream A 被阻塞后，StreamB、C 必须等待。<br>经过了解完 QUIC 的流量控制机制后，对于队头阻塞问题解决得更加彻底。<br><strong>QUIC 协议中同一个 Stream 内，滑动窗口的移动仅取决于接收到的最大字节偏移（尽管期间可能有部分数据未被接收）</strong>，而对于 TCP 而言，窗口滑动必须保证此前的 packet 都有序的接收到了，其中一个 packet 丢失就会导致窗口等待。</p>
<h5 id="Connection-流量控制"><a href="#Connection-流量控制" class="headerlink" title="Connection 流量控制"></a>Connection 流量控制</h5><p>而对于 Connection 级别的流量窗口，其接收窗口大小就是各个 Stream 接收窗口大小之和。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772983921-4a2f612d-cc84-4824-9e97-6f667ad129fb.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=hVrsZ&amp;originHeight=459&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7727c558-7907-4a7c-9aff-f5bfd601a89&amp;title=" alt=""><br>Connection 流量控制<br>上图所示的例子，所有 Streams 的最大窗口数为 120，其中：</p>
</li>
<li><p>Stream 1 的最大接收偏移为 100，可用窗口 = 120 - 100 = 20</p>
</li>
<li>Stream 2 的最大接收偏移为 90，可用窗口 = 120 - 90 = 30</li>
<li>Stream 3 的最大接收偏移为 110，可用窗口 = 120 - 110 = 10</li>
</ul>
<p>那么整个 Connection 的可用窗口 = 20 + 30 + 10 = 60<br>可用窗口 = Stream 1 可用窗口 + Stream 2 可用窗口 + Stream 3 可用窗口</p>
<h4 id="④QUIC-对拥塞控制改进"><a href="#④QUIC-对拥塞控制改进" class="headerlink" title="④QUIC 对拥塞控制改进"></a>④QUIC 对拥塞控制改进</h4><p>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（我们熟知的慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法，相当于将 TCP 的拥塞控制算法照搬过来了，QUIC 是如何改进 TCP 的拥塞控制算法的呢？<br>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，所以 TCP 拥塞控制算法迭代速度是很慢的。而 <strong>QUIC 可以随浏览器更新，QUIC 的拥塞控制算法就可以有较快的迭代速度</strong>。<br>TCP 更改拥塞控制算法是对系统中所有应用都生效，无法根据不同应用设定不同的拥塞控制策略。但是因为 QUIC 处于应用层，所以就<strong>可以针对不同的应用设置不同的拥塞控制算法</strong>，这样灵活性就很高了。</p>
<h4 id="⑤QUIC-更快的连接建立"><a href="#⑤QUIC-更快的连接建立" class="headerlink" title="⑤QUIC 更快的连接建立"></a>⑤QUIC 更快的连接建立</h4><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手（1RTT），再 TLS 握手（2RTT），所以需要 3RTT 的延迟才能传输数据，就算 Session 会话服用，也需要至少 2 个 RTT。<br>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。<br>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。<br>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772984578-e279d14f-7296-4535-9de5-54493528fefc.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=670&amp;id=ZVftW&amp;originHeight=1266&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufafa667d-cd6a-42d1-9864-67737a6af07&amp;title=&amp;width=476.00006103515625" alt=""></p>
<h4 id="⑥QUIC-是如何迁移连接的？"><a href="#⑥QUIC-是如何迁移连接的？" class="headerlink" title="⑥QUIC 是如何迁移连接的？"></a>⑥QUIC 是如何迁移连接的？</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652772985177-cf83631f-5182-4082-b1c7-4dddf155148a.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=It4ky&amp;originHeight=228&amp;originWidth=821&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5fec705-f30a-468d-9e5c-bee27fb9b04&amp;title=" alt=""><br>图片<br>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。<br>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。<br>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<h2 id="三、优化-HTTP-1-1-协议的思路。"><a href="#三、优化-HTTP-1-1-协议的思路。" class="headerlink" title="三、优化 HTTP/1.1 协议的思路。"></a>三、优化 HTTP/1.1 协议的思路。</h2><p>我们可以从下面这三种优化思路来优化 HTTP/1.1 协议：</p>
<ul>
<li><em>尽量避免发送 HTTP 请求</em>；</li>
<li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；</li>
<li><em>减少服务器的 HTTP 响应的数据大小</em>；</li>
</ul>
<p>下面，就针对这三种思路具体看看有哪些优化方法。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768804704-51a6f7cb-be86-47e5-999d-88332652cd88.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6f664363&amp;name=image.png&amp;originHeight=1442&amp;originWidth=2760&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=647522&amp;status=done&amp;style=none&amp;taskId=u5a8835b9-d345-42fb-a048-bb8940610e3&amp;title=" alt="image.png"></p>
<hr>
<h3 id="Ⅰ如何避免发送-HTTP-请求？"><a href="#Ⅰ如何避免发送-HTTP-请求？" class="headerlink" title="Ⅰ如何避免发送 HTTP 请求？"></a>Ⅰ如何避免发送 HTTP 请求？</h3><ul>
<li>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。</li>
<li>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。<br>补充那缓存是如何做到的呢？<br>客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。<br>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本地磁盘的速度肯定比网络请求快得多，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768795031-35ebc93b-0c45-4cd9-9223-e136db63c2a6.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=621&amp;id=QQO6j&amp;name=image.png&amp;originHeight=1127&amp;originWidth=977&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=269425&amp;status=done&amp;style=none&amp;taskId=u5e7ff292-bfe7-4cbf-b553-3ab48d613ed&amp;title=&amp;width=538" alt="image.png"><br>聪明的你可能想到了，万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？<br>放心，这个问题 HTTP 设计者早已考虑到。<br>所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。</li>
</ul>
<p>如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？<br>很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？<br>只需要客户端在重新发送请求时，在请求的 Etag 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。<br>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。<br>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器<strong>仅返回不含有包体的 304 Not Modified 响应</strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768795140-a8bfe307-97ef-445d-86a1-dad399037d2f.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=598&amp;id=DJ59v&amp;name=image.png&amp;originHeight=1127&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=371699&amp;status=done&amp;style=none&amp;taskId=u1e2b04dc-3668-444c-b22c-1f9e05cf472&amp;title=&amp;width=540" alt="image.png"><br>缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。</p>
<h3 id="Ⅱ如何减少-HTTP-请求次数？"><a href="#Ⅱ如何减少-HTTP-请求次数？" class="headerlink" title="Ⅱ如何减少 HTTP 请求次数？"></a>Ⅱ如何减少 HTTP 请求次数？</h3><p>减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：</p>
<ul>
<li><em>减少重定向请求次数</em>；</li>
<li><em>合并请求</em>；</li>
<li><em>延迟发送请求</em>；<h4 id="①减少重定向请求次数"><a href="#①减少重定向请求次数" class="headerlink" title="①减少重定向请求次数"></a>①减少重定向请求次数</h4>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；<br>补充&gt; 我们先来看看什么是<strong>重定向请求</strong>？<blockquote>
<p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。<br>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。</p>
</blockquote>
</li>
</ul>
<p>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768794912-98c35913-201d-40de-8b33-975a56489381.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=407&amp;id=EK4cp&amp;name=image.png&amp;originHeight=605&amp;originWidth=750&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=125800&amp;status=done&amp;style=none&amp;taskId=uc53e5ee9-19a4-4f51-abac-49b38a01614&amp;title=&amp;width=504" alt="image.png"><br>如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768794877-a4207a4d-1093-41f2-8ce2-60a5dcb40211.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=402&amp;id=njirT&amp;name=image.png&amp;originHeight=605&amp;originWidth=750&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=105223&amp;status=done&amp;style=none&amp;taskId=ua2a735c4-2f22-4c37-8e80-8791ae52ed0&amp;title=&amp;width=498" alt="image.png"><br>而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768803374-d156b233-9ff2-4c15-b722-889557a9b04c.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=LJk8h&amp;name=image.png&amp;originHeight=485&amp;originWidth=750&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84813&amp;status=done&amp;style=none&amp;taskId=u8de43bd4-556c-4ce6-96fa-bd8c83e9c51&amp;title=&amp;width=509" alt="image.png"><br>除了 302 重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768804216-a7db6796-b299-4e5c-81ed-7b8eb0a5fa50.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ypKRw&amp;name=image.png&amp;originHeight=512&amp;originWidth=917&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=230491&amp;status=done&amp;style=none&amp;taskId=u1244ccea-9c12-4c18-9a7a-8414bb06819&amp;title=" alt="image.png"><br>其中，301 和 308 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。</p>
<h4 id="②合并请求"><a href="#②合并请求" class="headerlink" title="②合并请求"></a>②合并请求</h4><p>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；<br>补充</p>
<ul>
<li>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着<strong>减少了重复发送的 HTTP 头部</strong>。</li>
<li>另外由于 HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会<strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间</strong>。<blockquote>
<p>接下来，具体看看合并请求的几种方式。<br>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 CSS Image Sprites 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768804234-ead4d028-c56c-46e8-9ae3-e3d2a949f0b6.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=HxNpQ&amp;name=image.png&amp;originHeight=628&amp;originWidth=1502&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=215417&amp;status=done&amp;style=none&amp;taskId=u799af03d-9d22-4b2f-bd14-c06fc860c42&amp;title=&amp;width=557" alt="image.png"><br>这种方式就是<strong>通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销</strong>。<br>除了将小图片合并成大图片的方式，还有服务端使用 webpack 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。<br>另外，还可以将图片的二进制数据用 base64 编码后，以 URL 的形式潜入到 HTML 文件，跟随 HTML 文件一并发送.<br>&lt;image src=”data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA … /&gt;<br>这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652768803878-b08f74f7-d390-4176-a4d8-b3aef13b9015.png#clientId=u25c32a85-e1cc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=Elcps&amp;name=image.png&amp;originHeight=531&amp;originWidth=1042&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155752&amp;status=done&amp;style=none&amp;taskId=ua6639fcb-6493-4691-90d9-0c46606e004&amp;title=&amp;width=532" alt="image.png"><br>可以看到，<strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求</strong>。<br>但是这样的合并请求会带来新的问题，<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗。</p>
</blockquote>
</li>
</ul>
<h4 id="③延迟发送请求"><a href="#③延迟发送请求" class="headerlink" title="③延迟发送请求"></a>③延迟发送请求</h4><ul>
<li>一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「<strong>按需获取</strong>」的方式，来减少第一时间的 HTTP 请求次数。</li>
<li><p>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p>
<h3 id="Ⅲ如何减少-HTTP-响应的数据大小？"><a href="#Ⅲ如何减少-HTTP-响应的数据大小？" class="headerlink" title="Ⅲ如何减少 HTTP 响应的数据大小？"></a>Ⅲ如何减少 HTTP 响应的数据大小？</h3><p>对响应的资源进行<strong>压缩</strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。<br>压缩的方式一般分为 2 种，分别是：</p>
</li>
<li><p><em>无损压缩</em>；</p>
</li>
<li><em>有损压缩</em>；<h4 id="①无损压缩"><a href="#①无损压缩" class="headerlink" title="①无损压缩"></a>①无损压缩</h4>无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。<blockquote>
<p>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding 字段告诉服务器：<br>Accept-Encoding: gzip, deflate, br<br>服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 content-encoding 字段告诉客户端该资源使用的压缩算法。<br>content-encoding: gzip </p>
</blockquote>
</li>
</ul>
<h4 id="②有损压缩"><a href="#②有损压缩" class="headerlink" title="②有损压缩"></a>②有损压缩</h4><p>与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近。<br>有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。</p>
<blockquote>
<p>可以通过 HTTP 请求头部中的 Accept 字段里的「 q 质量因子」，告诉服务器期望的资源质量。<br>Accept: audio/*; q=0.2, audio/basic </p>
</blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这次主要从 3 个方面介绍了优化 HTTP/1.1 协议的思路。</p>
<p>第⼀个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第⼀个请求的响应后，可以将其缓存在本地磁 盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候 带上响应数据的摘要，服务器⽐对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。<br>第⼆个思路是，减少 HTTP 请求的次数，有以下的⽅法： </p>
<ol>
<li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少᯿定向请求的次数； </li>
<li>将多个⼩资源合并成⼀个⼤资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连 接数ᰁ，进⽽省去 TCP 握⼿和慢启动的⽹络消耗； </li>
<li>按需访问资源，只访问当前⽤户看得到/⽤得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同⼀时间的 HTTP 请求次数。<br>第三思路是，通过压缩响应资源，降低传输资源的⼤⼩，从⽽提⾼传输效率，所以应当选择更优秀的压缩算法。<h2 id="👌四、深入HTTPS"><a href="#👌四、深入HTTPS" class="headerlink" title="👌四、深入HTTPS"></a>👌四、深入HTTPS</h2><h3 id="ⅠHTTPS-RSA-握手解析"><a href="#ⅠHTTPS-RSA-握手解析" class="headerlink" title="ⅠHTTPS RSA 握手解析"></a>ⅠHTTPS RSA 握手解析</h3>详细内容我前面讲，简单给大家介绍了的 HTTPS 握手过程，但是还不够细！<br>只讲了比较基础的部分，所以这次我们再来深入一下 HTTPS，用<strong>实战抓包</strong>的方式，带大家再来窥探一次 HTTPS。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479762947-07f3c9a8-799d-4adf-a0ad-f2eb0f773ec8.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=363&amp;id=kcGWw&amp;originHeight=1110&amp;originWidth=1824&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0acf54b3-a35c-4c4e-b94a-4de9d20edac&amp;title=&amp;width=597" alt=""></li>
</ol>
<hr>
<h4 id="①TLS-握手过程"><a href="#①TLS-握手过程" class="headerlink" title="①TLS 握手过程"></a>①TLS 握手过程</h4><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。<br>所以安全上存在以下三个风险：</p>
<ul>
<li><em>窃听风险</em>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><em>篡改风险</em>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><em>冒充风险</em>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479762205-58960f94-6df0-43be-b248-9095ef48c78d.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=PkuoT&amp;originHeight=275&amp;originWidth=596&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u60f67a7f-7172-40b3-8162-81437bdaa0a&amp;title=" alt=""><br>TLS 协议是如何解决 HTTP 的风险的呢？</p>
<ul>
<li><em>信息加密</em>： HTTP 交互信息是被加密的，第三方就无法被窃取；</li>
<li><em>校验机制</em>：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li>
<li><em>身份证书</em>：证明淘宝是真的淘宝网；</li>
</ul>
<p>可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479763057-3866738c-e5e1-4eb4-803b-59d57c3fcdcf.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=647&amp;id=hRyZJ&amp;originHeight=1260&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u95a2635d-49f1-44b7-87e9-df678bda4ec&amp;title=&amp;width=556" alt=""><br>上图简要概述了 TLS 的握手过程，其中每一个「框」都是一个记录（<em>record</em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。<br>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。<br>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。<br>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。<br>接下来，我们就以最简单的 RSA 密钥交换算法，来看看它的 TLS 握手过程。</p>
<hr>
<h4 id="②RSA-握手过程"><a href="#②RSA-握手过程" class="headerlink" title="②RSA 握手过程"></a>②RSA 握手过程</h4><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。<br>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。<br>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历来四次握手：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479762564-1551f6ad-64d4-4399-b84f-014cd595d7bf.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=CYqqc&amp;originHeight=380&amp;originWidth=1083&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue1cab88a-0e77-4488-ae8a-ecd624a9cae&amp;title=" alt=""><br>对应 Wireshark 的抓包，我也画了一幅图，你可以从下图很清晰地看到该过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479763725-e1962f6e-257f-472d-a812-9dd27e89896b.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=kRv01&amp;originHeight=2957&amp;originWidth=1859&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u509693af-c671-48d3-bfcf-2d677227751&amp;title=" alt=""><br>那么，接下来针对每一个 TLS 握手做进一步的介绍。</p>
<h5 id="TLS-第一次握手"><a href="#TLS-第一次握手" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h5><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479763417-8076ddf7-4d04-4c29-bf12-bcdfad75b6a5.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=hZM5q&amp;originHeight=353&amp;originWidth=734&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u96e82e06-df96-4188-9f12-b264bac2ed3&amp;title=&amp;width=659" alt=""><br>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>
<h5 id="TLS-第二次握手"><a href="#TLS-第二次握手" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h5><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（<em>Server Random</em>）</strong>。<br>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479763955-b76939b5-fed5-4dbf-a3c1-b731d38c48d1.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=nstlE&amp;originHeight=310&amp;originWidth=682&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae007a46-a8d5-464b-a321-3512b1f9930&amp;title=" alt=""></p>
<blockquote>
<p>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。<br>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p>
<ul>
<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>
<li>摘要算法 SHA256 用于消息认证和产生随机数；</li>
</ul>
</blockquote>
<p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。<br>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。<br>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479764092-6df5578c-71b0-4d57-b819-c34ecdc7e6b0.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=R30Dc&amp;originHeight=202&amp;originWidth=751&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1bbe17de-6955-4403-abe7-46a6e30046c&amp;title=" alt=""><br>随后，服务端发了「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479766165-5b61966d-5b98-4142-a637-0de3f2032f93.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=XbkgG&amp;originHeight=98&amp;originWidth=594&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u507e18c3-9327-4e43-95c4-fd698b84af9&amp;title=" alt=""></p>
<h5 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h5><p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p>
<h6 id="数字证书和-CA-机构"><a href="#数字证书和-CA-机构" class="headerlink" title="数字证书和 CA 机构"></a>数字证书和 CA 机构</h6><p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p>
<ul>
<li>公钥；</li>
<li>持有者信息；</li>
<li>证书认证机构（CA）的信息；</li>
<li>CA 对这份文件的数字签名及使用的算法；</li>
<li>证书有效期；</li>
<li>还有一些其他额外信息；</li>
</ul>
<p>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。<br>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？<br>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。<br>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p>
<h6 id="数字证书签发和验证流程"><a href="#数字证书签发和验证流程" class="headerlink" title="数字证书签发和验证流程"></a>数字证书签发和验证流程</h6><p>如下图图所示，为数字证书签发和验证流程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479766485-01eb0910-270c-4b41-81f9-f57c86de6e5a.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=JsBRd&amp;originHeight=740&amp;originWidth=1337&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u258568b6-c91a-4d62-ab47-282869b1cf6&amp;title=" alt=""><br>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
<h6 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h6><p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479766666-247d5e63-043a-4d71-a5a5-b9d7d0b24ad9.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=QaORa&amp;originHeight=217&amp;originWidth=567&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub53d0d6d-2fda-4e57-b1f5-2cc063676b8&amp;title=" alt=""><br>对于这种三级层级关系的证书的验证过程如下：</p>
</li>
<li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p>
</li>
<li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</li>
<li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</li>
</ul>
<p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。<br>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479766778-4bd6575b-8d9d-412e-a9dc-03026dd6eba8.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=664&amp;id=Mc9u1&amp;originHeight=891&amp;originWidth=707&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u415f3721-2faf-4dea-a53d-4dea8c70396&amp;title=&amp;width=527" alt=""><br>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479767139-a067f413-7335-4990-8d10-b3e3a4cae4ad.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=362&amp;id=ViekE&amp;originHeight=534&amp;originWidth=867&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5ecc8aee-e396-4379-a145-a126c68d400&amp;title=&amp;width=588" alt=""><br>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479767203-ad8bb93e-22b3-4d36-b536-02288e1f694d.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=173&amp;id=JB4RZ&amp;originHeight=452&amp;originWidth=1478&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4f18f402-a671-45be-a2d7-28247a6b69f&amp;title=&amp;width=565" alt=""><br>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？<br>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>
<h5 id="TLS-第三次握手"><a href="#TLS-第三次握手" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h5><p>客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的<strong>随机数 (<em>pre-master</em>)</strong>，用服务器的 RSA 公钥加密该随机数，通过「<strong>Change Cipher Key Exchange</strong>」消息传给服务端。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479767698-98852719-067e-4fb0-a95f-ba634ca39734.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=W5jiY&amp;originHeight=190&amp;originWidth=836&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u04724166-13a8-422b-801e-361c9e18ffb&amp;title=" alt=""><br>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。<br>至此，<strong>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong>。<br>于是，双方根据已经得到的三个随机数，生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。<br>生成完会话密钥后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479768026-15632718-014a-4d8d-88c3-bb1bb095597c.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=jStT9&amp;originHeight=95&amp;originWidth=630&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u15bef019-bc75-4ff5-8ed7-dc3d251dc1e&amp;title=" alt=""><br>然后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479768284-70ab404d-e893-450f-b3dc-406bbe362584.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=aRcin&amp;originHeight=103&amp;originWidth=635&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uefb61905-0cd6-43cc-85ea-00d10f6aecc&amp;title=" alt=""><br>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>
<h5 id="TLS-第四次握手"><a href="#TLS-第四次握手" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h5><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。<br>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p>
<hr>
<h4 id="RSA-算法的缺陷"><a href="#RSA-算法的缺陷" class="headerlink" title="RSA 算法的缺陷"></a>RSA 算法的缺陷</h4><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。<br>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。<br>为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓。</p>
<h3 id="ⅡHTTPS-ECDHE-握手解析"><a href="#ⅡHTTPS-ECDHE-握手解析" class="headerlink" title="ⅡHTTPS ECDHE 握手解析"></a>ⅡHTTPS ECDHE 握手解析</h3><p>详细内容HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。<br>其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479941180-91a72cca-173e-454e-9313-8410874146de.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=480&amp;id=xNhrH&amp;originHeight=1566&amp;originWidth=1388&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u449d6d65-26d1-42c5-a08f-e1fb385c130&amp;title=&amp;width=425" alt=""></p>
<hr>
<h4 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h4><p>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。<br>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。</p>
<p>离散对数是「离散 + 对数」的两个数学概念的组合。<br>要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。<br>举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479940869-5eb0369f-796f-47d7-aecb-3bfb69490382.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=U55hz&amp;originHeight=257&amp;originWidth=437&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u835e2e41-02cc-4a51-9ae6-2987480c9d9&amp;title=" alt=""><br>那么对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6，计算过程如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479940868-9206e676-c6e2-416f-a482-b6283c4976e6.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=sUYaM&amp;originHeight=279&amp;originWidth=702&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u037a782e-0d42-41eb-ab28-3fd8c5ac8c0&amp;title=&amp;width=507" alt=""><br>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，<br>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。离散对数的概念如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479940962-aa95b1e3-aff9-4242-a1bc-ddf045fe3ca9.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=H4xxp&amp;originHeight=227&amp;originWidth=692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1624e6f6-eccf-4e34-b32c-9fdfab36fad&amp;title=" alt=""><br>上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。<br><strong>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</strong></p>
<hr>
<h4 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h4><p>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。<br>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480210806-016e8653-b330-4ea2-b1b7-e887b8494815.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=55&amp;id=Kq1fg&amp;name=image.png&amp;originHeight=69&amp;originWidth=286&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7371&amp;status=done&amp;style=none&amp;taskId=ud14b6b0b-b1a2-47ec-9dda-9616621accb&amp;title=&amp;width=228.8" alt="image.png">也就是a和p<br>然后小红和小明各自生成一个随机整数作为<strong>私钥（对数，指数）</strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。<br>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出<strong>公钥</strong>：</p>
<ul>
<li>小红的公钥记作 A，A = G ^ a ( mod P )；</li>
<li>小明的公钥记作 B，B = G ^ b ( mod P )；</li>
</ul>
<p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。<br>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。<br>然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479941025-c8b92cb5-848e-4521-9e51-b6275f69d53c.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=WGcs0&amp;originHeight=429&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua350ff4a-9217-4efb-a2b1-7060b7f97bb&amp;title=&amp;width=635" alt=""><br>这个 K 就是小红和小明之间用的<strong>对称加密密钥</strong>，可以作为会话密钥使用。<br>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。<br>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。</p>
<hr>
<h4 id="DHE-算法"><a href="#DHE-算法" class="headerlink" title="DHE 算法"></a>DHE 算法</h4><p>根据私钥生成的方式，DH 算法分为两种实现：</p>
<ul>
<li>static DH 算法，这个是已经被废弃了；</li>
<li>DHE 算法，现在常用的；</li>
</ul>
<p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。<br>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <strong>static DH 算法不具备前向安全性</strong>。<br>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。<br>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为<strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」</strong>。</p>
<hr>
<h4 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h4><p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。<br>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。<br>小红和小明使用 ECDHE 密钥交换算法的过程：</p>
<ul>
<li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li>
<li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li>
<li>双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li>
</ul>
<p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p>
<hr>
<h4 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h4><p>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。<br>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479942157-5534c99a-50ed-4ab3-a905-8d643e833a14.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=BG7Lg&amp;originHeight=362&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u48eb7e6b-21d0-4db9-b66f-eae3fdaffa9&amp;title=" alt=""><br>细心的小伙伴应该发现了，<strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。<br>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。<br>接下来，分析每一个 ECDHE 握手过程。</p>
<h5 id="TLS-第一次握手-1"><a href="#TLS-第一次握手-1" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h5><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479942945-2ed2e0c0-b288-4ef2-aa4a-a0fecb7a38ac.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=276&amp;id=Msugu&amp;originHeight=476&amp;originWidth=917&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u51dc4cc6-be45-424a-afa8-d1e96a9245a&amp;title=&amp;width=531" alt=""></p>
<h5 id="TLS-第二次握手-1"><a href="#TLS-第二次握手-1" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h5><p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（<em>Server Random</em>）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479942980-ce8dc9f5-d9bb-4fc8-860f-df350c8263e0.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=RdDaL&amp;originHeight=445&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2883b76a-2c42-44ee-9a0f-a24705bd412&amp;title=&amp;width=571" alt=""><br>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。<br>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p>
<ul>
<li>密钥协商算法使用 ECDHE；</li>
<li>签名算法使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li>
<li>摘要算法使用 SHA384；</li>
</ul>
<p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479942960-54fc2103-d807-4157-bdfd-a172e6bd5b48.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=166&amp;id=uG1zo&amp;originHeight=256&amp;originWidth=1015&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uaa313ed4-4a4d-4985-9a99-721eeaece35&amp;title=&amp;width=658" alt=""><br>这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479943194-1ab94fe4-96fb-40d5-bb65-ee99a10583d2.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=GA10p&amp;originHeight=343&amp;originWidth=1000&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua249648b-d1b5-443c-910d-3dc09a04997&amp;title=&amp;width=666" alt=""><br>这个过程服务器做了三件事：</p>
<ul>
<li>选择了<strong>名为 x25519 的椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>
</ul>
<p>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。<br>随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479944331-75a4b1fa-1400-4512-8828-5eef0d8f9b03.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=KOptt&amp;originHeight=116&amp;originWidth=707&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u37600090-645f-450f-be3a-c4d76d29fb4&amp;title=" alt=""><br>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。</p>
<h5 id="TLS-第三次握手-1"><a href="#TLS-第三次握手-1" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h5><p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。<br>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥</strong>，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479947360-5907630e-065c-4aa8-bce3-857382d038d8.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=aanod&amp;originHeight=235&amp;originWidth=880&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u24db2275-e465-44bd-9e26-26f44891e83&amp;title=" alt=""><br>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，<strong>但实际应用中，x 还不是最终的会话密钥</strong>。<br>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？<br><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。<br>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。<br>算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479947270-4b379374-7afc-4aae-8cc8-4bacf8e847cf.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=txkOe&amp;originHeight=118&amp;originWidth=777&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0e6cbccb-69c3-4aa0-927b-074341316ad&amp;title=" alt=""><br>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651479947277-30387f5a-bb9a-4a26-9382-a4825445feb2.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=No8X0&amp;originHeight=122&amp;originWidth=794&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue49e0bb0-9b91-405e-988d-ccdc4d28f9f&amp;title=" alt=""></p>
<h5 id="TLS-第四次握手-1"><a href="#TLS-第四次握手-1" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h5><p>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p>
<hr>
<p>总结<br>RSA 和 ECDHE 握手过程的区别：</p>
<ul>
<li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li>
<li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；</li>
<li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；<h3 id="ⅢHttps如何优化"><a href="#ⅢHttps如何优化" class="headerlink" title="ⅢHttps如何优化"></a>ⅢHttps如何优化</h3>由裸数据传输的 HTTP 协议转成加密数据传输的 HTTPS 协议，给应用数据套了个「保护伞」，提高安全性的同时也带来了性能消耗。<br>因为 HTTPS 相比 HTTP 协议多一个 TLS 协议握手过程，<strong>目的是为了通过非对称加密握手协商或者交换出对称加密密钥</strong>，这个过程最长可以花费掉 2 RTT，接着后续传输的应用数据都得使用对称加密密钥来加密/解密。<br>为了数据的安全性，我们不得不使用 HTTPS 协议，至今大部分网址都已从 HTTP 迁移至 HTTPS 协议，因此针对 HTTPS 的优化是非常重要的。<br>这次，就从多个角度来优化 HTTPS。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480770117-37d3709f-2469-4bda-b76f-b46653002550.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=697&amp;id=u38f68a85&amp;originHeight=979&amp;originWidth=824&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2b536bf6-4e97-4d87-9a89-f6bdfefa802&amp;title=&amp;width=587" alt=""></li>
</ul>
<hr>
<h4 id="分析性能损耗"><a href="#分析性能损耗" class="headerlink" title="分析性能损耗"></a>分析性能损耗</h4><p>既然要对 HTTPS 优化，那得清楚哪些步骤会产生性能消耗，再对症下药。<br>产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<p>对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。<br>而第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗，比如：</p>
<ul>
<li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li>
<li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li>
<li>双方计算 Pre-Master，也就是对称加密密钥；</li>
</ul>
<p>为了大家更清楚这些步骤在 TLS 协议握手的哪一个阶段，我画出了这幅图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480770248-f263d594-f463-4acf-a6f4-5cddb22c0a36.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=666&amp;id=u5933d48b&amp;originHeight=1260&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u751cbbc2-d444-433e-a814-2bbddcba30f&amp;title=&amp;width=572" alt=""></p>
<hr>
<h4 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h4><p>软件都是跑在物理硬件上，硬件越牛逼，软件跑的也越快，所以如果要优化 HTTPS 优化，最直接的方式就是花钱买性能参数更牛逼的硬件。<br>但是花钱也要花对方向，<strong>HTTPS 协议是计算密集型，而不是 I/O 密集型</strong>，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上。<br>一个好的 CPU，可以提高计算性能，因为 HTTPS 连接过程中就有大量需要计算密钥的过程，所以这样可以加速 TLS 握手过程。<br>另外，如果可以，应该选择可以<strong>支持 AES-NI 特性的 CPU</strong>，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。<br>如果你的服务器是 Linux 系统，那么你可以使用下面这行命令查看 CPU 是否支持 AES-NI 指令集：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480769966-18271c07-2c4b-4ba5-a696-32f1ebd3f7a4.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue158168e&amp;originHeight=220&amp;originWidth=812&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9a8d6cdf-fb6a-41e6-8cb9-dae177f4bb9&amp;title=" alt=""><br>如果我们的 CPU 支持 AES-NI 特性，那么对于对称加密的算法应该选择 AES 算法。否则可以选择 ChaCha20 对称加密算法，因为 ChaCha20 算法的运算指令相比 AES 算法会对 CPU 更友好一点。</p>
<hr>
<h4 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h4><p>软件的优化方向可以分层两种，一个是<strong>软件升级</strong>，一个是<strong>协议优化</strong>。<br>先说第一个软件升级，软件升级就是将正在使用的软件升级到最新版本，因为最新版本不仅提供了最新的特性，也优化了以前软件的问题或性能。比如：</p>
<ul>
<li>将 Linux 内核从 2.x 升级到 4.x；</li>
<li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li>
<li>…</li>
</ul>
<hr>
<h4 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h4><p>协议的优化就是对「密钥交换过程」进行优化。</p>
<h5 id="密钥交换算法优化"><a href="#密钥交换算法优化" class="headerlink" title="密钥交换算法优化"></a>密钥交换算法优化</h5><p>TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。<br>总之使用 <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。<br>因此如果可以，尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。<br>ECDHE 算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不同，应该尽量<strong>选择 x25519 曲线</strong>，该曲线是目前最快的椭圆曲线。</p>
<h5 id="TLS-升级"><a href="#TLS-升级" class="headerlink" title="TLS 升级"></a>TLS 升级</h5><p>当然，如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。<br>在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480771962-c35801cf-066d-4db0-a428-7815fcdd0bd4.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9ede6802&amp;originHeight=1290&amp;originWidth=1832&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueebe637f-45f9-444b-b71a-540afa46caf&amp;title=" alt=""><br>上图的右边部分就是 TLS 1.3 的握手过程，可以发现 <strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p>
<hr>
<h4 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h4><p>为了验证的服务器的身份，服务器会在 TSL 握手过程中，把自己的证书发给客户端，以此证明自己身份是可信的。<br>对于证书的优化，可以有两个方向：</p>
<ul>
<li>一个是<strong>证书传输</strong>，</li>
<li><p>一个是<strong>证书验证</strong>；</p>
<h5 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h5><p>要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，<strong>对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多</strong>。</p>
<h5 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h5><p>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。<br>这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。</p>
<h6 id="CRL"><a href="#CRL" class="headerlink" title="CRL"></a>CRL</h6><p>CRL 称为证书吊销列表（<em>Certificate Revocation List</em>），这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480771672-7a82759b-5e87-4059-8588-4fc6024e59d1.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=433&amp;id=u5f40ce15&amp;originHeight=588&amp;originWidth=894&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9f9f3ab2-8670-4946-812e-4729ef00b93&amp;title=&amp;width=658" alt=""><br>但是 CRL 存在两个问题：</p>
</li>
<li><p>第一个问题，由于 CRL 列表是由 CA 维护的，定期更新，如果一个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书，<strong>实时性较差</strong>；</p>
</li>
<li>第二个问题，<strong>随着吊销证书的增多，列表会越来越大，下载的速度就会越慢</strong>，下载完客户端还得遍历这么大的列表，那么就会导致客户端在校验证书这一环节的延时很大，进而拖慢了 HTTPS 连接。<h6 id="OCSP"><a href="#OCSP" class="headerlink" title="OCSP"></a>OCSP</h6>因此，现在基本都是使用 OCSP ，名为在线证书状态协议（<em>Online Certificate Status Protocol</em>）来查询证书的有效性，它的工作方式是<strong>向 CA 发送查询请求，让 CA 返回证书的有效状态</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480772293-ee3fe24a-2076-449d-ba33-3b836f6599a1.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u531c1191&amp;originHeight=569&amp;originWidth=852&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u60bade94-2f94-4e2b-a782-f13fcb8228f&amp;title=" alt=""><br>不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。<br>OCSP 需要向 CA 查询，因此也是要发生网络请求，而且还得看 CA 服务器的“脸色”，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大。<h6 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h6>于是为了解决这一个网络开销，就出现了 OCSP Stapling，其原理是：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480772184-a8deb3eb-97d8-47f2-a579-fd916dae0e12.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5cf561c0&amp;originHeight=345&amp;originWidth=691&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u92fd9a63-c54c-443c-bbda-de11b78c150&amp;title=" alt=""><br>当有客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。</li>
</ul>
<hr>
<h4 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h4><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？<br>这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p>
<ul>
<li>第一种叫 Session ID；</li>
<li><p>第二种叫 Session Ticket；</p>
<h5 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h5><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。<br>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480773019-2dba1639-2740-4f20-abd4-8ee8c7ae75f5.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u137a9c85&amp;originHeight=518&amp;originWidth=1334&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u04585621-c4ff-40d7-b378-7409a4d6249&amp;title=" alt=""><br>但是它有两个缺点：</p>
</li>
<li><p>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</p>
</li>
<li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；<h5 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h5>为了解决 Session ID 的问题，就出现了 Session Ticket，<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。<br>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。<br>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480773952-7df4c559-08f3-4f1b-9a3c-6b2a4bd402e8.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u43d3a3e7&amp;originHeight=605&amp;originWidth=1297&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u73dea114-4e2c-46a2-a218-263cbb04500&amp;title=" alt=""><br>对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。<br>Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。<br>同时应对<strong>重放攻击</strong>也很困难，这里简单介绍下重放攻击工作的原理。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480774880-f44bf018-b4af-4703-b30d-fbfa1941eeba.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=420&amp;id=u79e891a7&amp;originHeight=717&amp;originWidth=1060&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u27309c28-f050-472d-99cd-fac701fcaba&amp;title=&amp;width=621" alt=""><br>假设 Alice 想向 Bob 证明自己的身份。 Bob 要求 Alice 的密码作为身份证明，爱丽丝应尽全力提供（可能是在经过如哈希函数的转换之后）。与此同时，Eve 窃听了对话并保留了密码（或哈希）。<br>交换结束后，Eve（冒充 Alice ）连接到 Bob。当被要求提供身份证明时，Eve 发送从 Bob 接受的最后一个会话中读取的 Alice 的密码（或哈希），从而授予 Eve 访问权限。<br>重放攻击的危险之处在于，如果中间人截获了某个客户端的 Session ID 或 Session Ticket 以及 POST 报文，而一般 POST 请求会改变数据库的数据，中间人就可以利用此截获的报文，不断向服务器发送该报文，这样就会导致数据库的数据被中间人改变了，而客户是不知情的。<br>避免重放攻击的方式就是需要<strong>对会话密钥设定一个合理的过期时间</strong>。<h5 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h5>前面的 Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。<br>而 TLS1.3 更为牛逼，对于重连 TLS1.3 只需要 <strong>0 RTT</strong>，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480774520-d90ba095-b420-4651-aea7-5cf4708b4c11.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=480&amp;id=u44bdc3dd&amp;originHeight=600&amp;originWidth=600&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u32d8eb02-b211-4b2f-86ba-d20639bc23c&amp;title=&amp;width=480" alt=""><br>同样的，Pre-shared Key 也有重放攻击的危险。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651480774510-fc549b59-d41f-4dc9-b51e-58f992c6bda7.png#clientId=u41d3e988-663d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=327&amp;id=udbdee593&amp;originHeight=626&amp;originWidth=1273&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u93b34c56-f821-49ce-a047-b961c6dcd61&amp;title=&amp;width=664" alt=""><br>如上图，假设中间人通过某种方式，截获了客户端使用会话重用技术的 POST 请求，通常 POST 请求是会改变数据库的数据，然后中间人就可以把截获的这个报文发送给服务器，服务器收到后，也认为是合法的，于是就恢复会话，致使数据库的数据又被更改，但是此时用户是不知情的。<br>所以，应对重放攻击可以给会话密钥设定一个合理的过期时间，以及只针对安全的 HTTP 请求如 GET/HEAD 使用会话重用。</li>
</ul>
<hr>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>对于硬件优化的方向，因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择<strong>支持 AES-NI 特性的 CPU</strong>，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。<br>对于软件优化的方向，如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。<br>对于协议优化的方向：</p>
<ul>
<li>密钥交换算法应该选择 <strong>ECDHE 算法</strong>，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。</li>
<li>将 TSL1.2 升级 <strong>TSL1.3</strong>，因为 TSL1.3 的握手过程只需要 1 RTT，而且安全性更强。</li>
</ul>
<p>对于证书优化的方向：</p>
<ul>
<li>服务器应该选用 <strong>ECDSA 证书</strong>，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；</li>
<li>服务器应该开启 <strong>OCSP Stapling</strong> 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；</li>
</ul>
<p>对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。<br>常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。<br>这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。</p>
<h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><p>我想起了我刚工作的时候，第一次接触RPC协议，当时就很懵，<strong>我HTTP协议用的好好的，为什么还要用RPC协议？</strong><br>于是就到网上去搜。<br>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。<br>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。<br>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p>
<h3 id="从-TCP-聊起"><a href="#从-TCP-聊起" class="headerlink" title="从 TCP 聊起"></a>从 TCP 聊起</h3><p>作为一个程序员，假设我们需要在A电脑的进程发一段数据到B电脑的进程，我们一般会在代码里使用socket 进行编程。<br>这时候，我们可选项一般也就<strong>TCP和UDP二选一。TCP可靠，UDP不可靠。</strong>除非是马总这种神级程序员（早期QQ大量使用UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选TCP就对了。<br>类似下面这样。<br>fd = socket(AF_INET,SOCK_STREAM,0);<br>其中SOCK_STREAM，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP协议</strong>。<br>在定义了socket之后，我们就可以愉快的对这个socket进行操作，比如用bind()绑定IP端口，用connect()发起建连。<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1659948267882-3a3b4614-c947-4440-ad8d-1df58fe08a5c.gif#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=jncWV&amp;originHeight=607&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc1a5d750-c8f2-4310-bec0-7877ffc0a1b&amp;title=&amp;width=532.0000610351562" alt=""><br>在连接建立之后，我们就可以使用send()发送数据，recv()接收数据。<br>光这样一个纯裸的TCP连接，就可以做到收发数据了，那是不是就够了？<br>不行，这么用会有问题。</p>
<h3 id="使用纯裸-TCP-会有什么问题"><a href="#使用纯裸-TCP-会有什么问题" class="headerlink" title="使用纯裸 TCP 会有什么问题"></a>使用纯裸 TCP 会有什么问题</h3><p>八股文常背，TCP是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948268352-59d38e32-2bff-424f-80a8-46fa7989782c.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Znf5C&amp;name=image.png&amp;originHeight=540&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57366&amp;status=done&amp;style=none&amp;taskId=uaf8c7aa3-ee7b-4b02-9a2e-0c33080af74&amp;title=" alt="image.png"><br>这三个特点真的概括的<strong>非常精辟</strong>，这个八股文我们没白背。<br>每个特点展开都能聊一篇文章，而今天我们需要关注的是<strong>基于字节流</strong>这一点。<br>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 <strong>01 串</strong>。纯裸TCP收发的这些 01 串之间是<strong>没有任何边界</strong>的，你根本不知道到哪个地方才算一条完整消息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948268342-b82295ae-04f9-46b3-bc9f-1b4b1a4c1198.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=263&amp;id=TsW3B&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=30799&amp;status=done&amp;style=none&amp;taskId=u0034b6b8-8330-437d-ad4d-3b4003062fd&amp;title=&amp;width=632.0000610351562" alt="image.png"><br>正因为这个没有<strong>任何边界</strong>的特点，所以当我们选择使用TCP发送<strong>“夏洛”和”特烦恼”</strong>的时候，接收端收到的就是<strong>“夏洛特烦恼”</strong>，这时候接收端没发区分你是想要表达<strong>“夏洛”+”特烦恼”</strong>还是<strong>“夏洛特”+”烦恼”</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948268364-d20f30a4-656b-4150-91d5-14d6595aff68.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=L4eDo&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=44598&amp;status=done&amp;style=none&amp;taskId=uc73dd8ea-fdbf-41e9-a00d-a5a7c6ec4d2&amp;title=&amp;width=618.0000610351562" alt="image.png"><br>这就是所谓的<strong>粘包问题</strong>，之前也写过一篇专门的<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">文章(opens new window)</a>聊过这个问题。<br>说这个的目的是为了告诉大家，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些<strong>自定义的规则</strong>，用于区分<strong>消息边界</strong>。<br>于是我们会把每条要发送的数据都包装一下，比如加入<strong>消息头</strong>，<strong>消息头里写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的<strong>消息体</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948268399-a6d6abae-3d3a-4a42-b37d-977aecd682bd.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=tGTrg&amp;name=image.png&amp;originHeight=360&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25350&amp;status=done&amp;style=none&amp;taskId=u8a6dbd6d-8388-489d-a95b-4ca40876c48&amp;title=" alt="image.png"><br>而这里头提到的<strong>消息头</strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong><br>每个使用TCP的项目都可能会定义一套类似这样的协议解析标准，他们可能<strong>有区别，但原理都类似</strong>。<br><strong>于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC。</strong></p>
<h3 id="HTTP-和-RPC"><a href="#HTTP-和-RPC" class="headerlink" title="HTTP 和 RPC"></a>HTTP 和 RPC</h3><p>我们回过头来看网络的分层图。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948270835-07b8a058-d0f6-44ec-a9ab-7a46443207d0.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=gln8k&amp;name=image.png&amp;originHeight=576&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57673&amp;status=done&amp;style=none&amp;taskId=u4e2b481b-d48c-440d-bc79-fea8f6b8fa5&amp;title=" alt="image.png"><br><strong>TCP是传输层的协议</strong>，而基于TCP造出来的HTTP和<strong>各类</strong>RPC协议，它们都只是定义了不同消息格式的<strong>应用层协议</strong>而已。<br><strong>HTTP</strong>协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），又叫做<strong>超文本传输协议</strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948271238-881dcfce-7db0-4c75-9132-8a45cca62f1d.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=vZ0BH&amp;name=image.png&amp;originHeight=380&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=51916&amp;status=done&amp;style=none&amp;taskId=u57b110f2-a3a2-49aa-8709-dac0addd748&amp;title=" alt="image.png"><br>而<strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。<br>举个例子，我们平时调用一个<strong>本地方法</strong>就像下面这样。<br> res = localFunc(req)<br>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法remoteFunc，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？<br> res = remoteFunc(req)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948271217-c7bda087-3113-4438-aec5-90d99d3ee62f.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=VLYhh&amp;name=image.png&amp;originHeight=380&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61416&amp;status=done&amp;style=none&amp;taskId=ua9cc38af-077c-46b7-bd2b-002b57a8c8e&amp;title=" alt="image.png"><br>基于这个思路，大佬们造出了非常多款式的RPC协议，比如比较有名的gRPC，thrift。<br>值得注意的是，虽然大部分RPC协议底层使用TCP，但实际上<strong>它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948271236-0b8b9c1f-512d-4ffa-aed8-4891fdb0b8bf.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=pc9uL&amp;name=image.png&amp;originHeight=540&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=42412&amp;status=done&amp;style=none&amp;taskId=u9ea44580-a3e0-41a4-aa25-fa8c7d12e84&amp;title=" alt="image.png"><br>到这里，我们回到文章标题的问题。<br>既然有HTTP协议，为什么还要有RPC？<br>其实，TCP是<strong>70年</strong>代出来的协议，而HTTP是<strong>90年代</strong>才开始流行的。而直接使用裸TCP会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有<strong>80年代</strong>出来的RPC。<br>所以我们该问的不是<strong>既然有HTTP协议为什么要有RPC</strong>，而是<strong>为什么有RPC还要有HTTP协议</strong>。<br>那既然有 RPC 了，为什么还要有HTTP呢？<br>现在电脑上装的各种<strong>联网</strong>软件，比如xx管家，xx卫士，它们都作为<strong>客户端（client）</strong>需要跟<strong>服务端（server）</strong>建立连接收发消息，此时都会用到应用层协议，在这种<strong>client/server (c/s)</strong>架构下，它们可以使用自家造的RPC协议，因为它只管连自己公司的服务器就ok了。<br>但有个软件不同，<strong>浏览器（browser）</strong>，不管是chrome还是IE，它们不仅要能访问自家公司的<strong>服务器（server）</strong>，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP就是那个时代用于统一 <strong>browser/server (b/s)</strong> 的协议。<br>也就是说在多年以前，<strong>HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。很多软件同时支持多端，比如某度云盘，既要支持网页版</strong>，还要支持<strong>手机端和pc端</strong>，如果通信协议都用HTTP的话，那服务器只用同一套就够了。而RPC就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。<br>那这么说的话，<strong>都用HTTP得了，还用什么RPC？</strong><br>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p>
<h3 id="HTTP-和-RPC-有什么区别"><a href="#HTTP-和-RPC-有什么区别" class="headerlink" title="HTTP 和 RPC 有什么区别"></a>HTTP 和 RPC 有什么区别</h3><p>我们来看看RPC和HTTP区别比较明显的几个点。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道<strong>IP地址和端口</strong>。这个找到服务对应的IP端口的过程，其实就是<strong>服务发现</strong>。<br>在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS服务</strong>去解析得到它背后的IP地址，默认80端口。<br>而<strong>RPC</strong>的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如<strong>consul或者etcd，甚至是redis</strong>。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如<strong>CoreDNS</strong>。<br>可以看出服务发现这一块，两者是有些区别，但不太能分高低。<br>底层连接形式<br>以主流的<strong>HTTP1.1</strong>协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。<br>而<strong>RPC</strong>协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948271255-fb265d1b-d68c-4319-bbb6-0fcf6cc77dd0.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=NduU3&amp;name=image.png&amp;originHeight=405&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49661&amp;status=done&amp;style=none&amp;taskId=u6de82c2b-06c0-43e8-b4e8-9ad52b85443&amp;title=" alt="image.png"><br><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池</strong>，比如<strong>go</strong>就是这么干的。<br>可以看出这一块两者也没太大区别，所以也不是关键。</p>
<h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>基于TCP传输的消息，说到底，无非都是<strong>消息头header和消息体body。</strong><br><strong>header</strong>是用于标记一些特殊信息，其中最重要的是<strong>消息体长度</strong>。<br><strong>body</strong>则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如<strong>json，protobuf。</strong><br>这个将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948272881-f10ce0a3-6cfe-48f4-ab74-2b2d04c8dbfc.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=sGncX&amp;name=image.png&amp;originHeight=360&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60838&amp;status=done&amp;style=none&amp;taskId=ubf2d7220-9636-44d2-9f1a-098704d4486&amp;title=" alt="image.png"><br>对于主流的HTTP1.1，虽然它现在叫<strong>超文本</strong>协议，支持音频视频，但HTTP设计初是用于做网页<strong>文本</strong>展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用<strong>json</strong>来<strong>序列化</strong>结构体数据。<br>我们可以随便截个图直观看下。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948272945-922ab477-b345-4129-89ad-73454749278f.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=451&amp;id=QmRpY&amp;name=image.png&amp;originHeight=682&amp;originWidth=886&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=121664&amp;status=done&amp;style=none&amp;taskId=u6f572438-ec99-4023-8500-b901d2c868d&amp;title=&amp;width=586.0000610351562" alt="image.png"><br>可以看到这里面的内容非常多的<strong>冗余</strong>，显得<strong>非常啰嗦</strong>。最明显的，像header里的那些信息，其实如果我们约定好头部的第几位是content-type，就<strong>不需要每次都真的把”content-type”这个字段都传过来</strong>，类似的情况其实在body的json结构里也特别明显。<br>而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948272904-5bb70017-10c9-4910-84f6-fdbc8651c072.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=iaHHj&amp;name=image.png&amp;originHeight=432&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58932&amp;status=done&amp;style=none&amp;taskId=u8fc695ea-53d1-47e1-9b34-3d362cb7b46&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659948272975-98c5135f-accb-4548-82db-b0a546fbade0.png#clientId=uc4819b3b-b6a2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=P7r04&amp;name=image.png&amp;originHeight=422&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75977&amp;status=done&amp;style=none&amp;taskId=u47113961-2f94-4c23-9dbe-ec069a7d432&amp;title=&amp;width=692.0000610351562" alt="image.png"><br>当然上面说的HTTP，其实<strong>特指的是现在主流使用的HTTP1.1</strong>，HTTP2在前者的基础上做了很多改进，所以<strong>性能可能比很多RPC协议还要好</strong>，甚至连gRPC底层都直接用的HTTP2。<br>那么问题又来了，为什么既然有了HTTP2，还要有RPC协议？<br>这个是由于 HTTP2 是2015年出来的。那时候很多公司内部的RPC协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>纯裸TCP是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP和各类RPC协议就是在TCP之上定义的应用层协议。</li>
<li><strong>RPC本质上不算是协议，而是一种调用方式</strong>，而像gRPC和thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，<strong>不一定非得基于TCP协议</strong>。</li>
<li>从发展历史来说，<strong>HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。</strong>很多软件同时支持多端，所以对外一般用HTTP协议，而内部集群的微服务之间则采用RPC协议进行通讯。</li>
<li>RPC其实比HTTP出现的要早，且比目前主流的HTTP1.1<strong>性能</strong>要更好，所以大部分公司内部都还在使用RPC。</li>
<li><strong>HTTP2.0</strong>在<strong>HTTP1.1</strong>的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/Zeb-D/my-review/blob/master/network/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90--TCP%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85.md">
</a></p>
<h2 id="既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 WebSocket？"></a>既然有 HTTP 协议，为什么还要有 WebSocket？</h2><p>平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。<br>从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，<strong>前端发一次 HTTP请 求，网站返回一次 HTTP 响应</strong>。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。<br>但有没有发现，这种情况下，服务器从来就「不会主动」给客户端发一次消息。就像你喜欢的女生从来不会主动找你一样。<br>但如果现在，你在刷网页的时候「右下角」突然弹出一个小广告，提示你【一个人在家偷偷才能玩哦】。<br><strong>求知，好学，勤奋</strong>，这些刻在你 DNA 里的东西都动起来了。<br>你点开后发现。<br>长相平平无奇的古某提示你”道士 9 条狗，全服横着走”。<br>影帝某辉老师跟你说”系兄弟就来砍我”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546960458-061051b7-ed0c-4988-8698-e1c316ea8df4.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=193&amp;id=u05bdde72&amp;name=image.png&amp;originHeight=396&amp;originWidth=396&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=190823&amp;status=done&amp;style=none&amp;taskId=u0f7f7db5-86a8-4d76-809d-7a40be44bda&amp;title=&amp;width=193.00003051757812" alt="image.png"><br>来都来了，你就选了个角色进到了游戏界面里。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546963131-3e98d5a8-b2dc-40d1-81ec-272b3b9a3b64.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=200&amp;id=ub6f4b210&amp;name=image.png&amp;originHeight=1456&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1892582&amp;status=done&amp;style=none&amp;taskId=u59c9038a-21c8-444e-adb4-9864b9f96bf&amp;title=&amp;width=148.28573608398438" alt="image.png"><br>这时候，上来就是一个小怪，从远处走来，然后疯狂拿木棒子抽你。<br><strong>你全程没点任何一次鼠标</strong>。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。<br>这….太暖心了。<br>感动之余，问题就来了，<br>像这种<strong>看起来服务器主动发消息给客户端的场景</strong>，是怎么做到的？<br>在真正回答这个问题之前，我们先来聊下一些相关的知识背景。</p>
<h3 id="使用-HTTP-不断轮询"><a href="#使用-HTTP-不断轮询" class="headerlink" title="使用 HTTP 不断轮询"></a>使用 HTTP 不断轮询</h3><p>其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong><br>最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong><br>这其实时一种「<strong>伪</strong>」服务器推的形式。<br>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。<br>用这种方式的场景也有很多，最常见的就是<strong>扫码登录</strong>。<br>比如，某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于<strong>等太久</strong>。<br>使用HTTP定时轮询<br>但这样，会有两个比较明显的问题：</p>
<ul>
<li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li>
<li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li>
</ul>
<p>使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个 1~2 秒</strong>，页面才跳转。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546960919-f8695364-7ce1-42c3-bb5b-d67b762c2993.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ub02d41ec&amp;name=image.png&amp;originHeight=540&amp;originWidth=1552&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=508465&amp;status=done&amp;style=none&amp;taskId=u3ae6a620-1d0f-4864-92ca-d87b77b2538&amp;title=" alt="image.png"><br>那么问题又来了，<strong>有没有更好的解决方案？</strong><br>有，而且实现起来成本还非常低。</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。<br>如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong><br>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546960329-71ddaca8-a620-4c8c-b0cf-e3b2028f4706.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc919c958&amp;name=image.png&amp;originHeight=792&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=96226&amp;status=done&amp;style=none&amp;taskId=u4c5035ae-45ff-457d-84c8-cf601df02b8&amp;title=" alt="image.png"><br>比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就<strong>秒跳转</strong>，体验很好。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546960716-936d5aab-1761-42c9-8867-7ee4709426da.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u48d7560d&amp;name=image.png&amp;originHeight=650&amp;originWidth=1546&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=375590&amp;status=done&amp;style=none&amp;taskId=u995e9995-0b66-4b54-ae41-5a8f68991ae&amp;title=" alt="image.png"><br>像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长训轮机制</strong>。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546961461-df863e4a-6de5-4551-8107-fbf926d4f7f6.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua1ef9336&amp;name=image.png&amp;originHeight=491&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=81683&amp;status=done&amp;style=none&amp;taskId=u812b548a-53d3-492b-95b3-3de617447f7&amp;title=" alt="image.png"><br>像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的<strong>服务器推送</strong>技术，它还有个毫不沾边的英文名，<strong>comet</strong> 技术，大家听过就好。<br>上面提到的两种解决方案（不断轮询和长轮询），本质上，其实还是客户端主动去取数据。<br>对于像扫码登录这样的<strong>简单场景</strong>还能用用。但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。<br>这就得说下 <strong>WebSocket</strong> 了。</p>
<h3 id="WebSocket是什么"><a href="#WebSocket是什么" class="headerlink" title="WebSocket是什么"></a>WebSocket是什么</h3><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。<br>而现在使用最广泛的HTTP/1.1，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。<br>也就是说，好好的全双工 TCP，被 HTTP/1.1 用成了半双工。<br>为什么？<br>这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。<br>所以，为了更好的支持这样的场景，我们需要另外一个<strong>基于TCP的新协议</strong>。<br>于是新的应用层协议<strong>WebSocket</strong>就被设计出来了。<br>大家别被这个名字给带偏了。虽然名字带了个socket，但其实 <strong>socket 和 WebSocket 之间，就跟雷峰和雷峰塔一样，二者接近毫无关系</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546961644-08ca9785-76c7-4588-ba47-4a0bc361a567.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u45aa0da2&amp;name=image.png&amp;originHeight=576&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62779&amp;status=done&amp;style=none&amp;taskId=u553bf397-30b2-4bee-96ba-1b32b5e8c85&amp;title=" alt="image.png"></p>
<h4 id="怎么建立WebSocket连接"><a href="#怎么建立WebSocket连接" class="headerlink" title="怎么建立WebSocket连接"></a>怎么建立WebSocket连接</h4><p>我们平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是 <strong>HTTP 协议</strong>，一会打开网页游戏，这时候就得切换成我们新介绍的 <strong>WebSocket 协议</strong>。<br>为了兼容这些使用场景。浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p>
<ul>
<li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li>
<li><p>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: WebSocket</span><br><span class="line">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure>
<p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。<br>如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 Sec-WebSocket-Accept 头里，同时带上101状态码，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols\r\n</span><br><span class="line">Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line">Upgrade: WebSocket\r\n</span><br><span class="line">Connection: Upgrade\r\n</span><br></pre></td></tr></table></figure>
<p>HTTP 状态码=200（正常响应）的情况，大家见得多了。101 确实不常见，它其实是指<strong>协议切换</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546962243-56d6900d-e580-4162-b273-79e9c561a647.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u10a65873&amp;name=image.png&amp;originHeight=339&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35909&amp;status=done&amp;style=none&amp;taskId=uec984665-b364-40f4-a145-2fa3f51a3e9&amp;title=" alt="image.png"><br>之后，浏览器也用同样的<strong>公开算法</strong>将base64码转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546963733-a24b5285-e002-4d22-b2e2-8133280ba5c1.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud72cc1f3&amp;name=image.png&amp;originHeight=432&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58813&amp;status=done&amp;style=none&amp;taskId=u452f0658-f41c-43e4-b391-679707f903a&amp;title=" alt="image.png"><br>就这样经历了一来一回两次 HTTP 握手，WebSocket就建立完成了，后续双方就可以使用 webscoket 的数据格式进行通信了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546964261-367869e2-7059-4a37-bfc9-ff49ebb45c2f.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uad358a29&amp;name=image.png&amp;originHeight=990&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=136719&amp;status=done&amp;style=none&amp;taskId=u050a43a0-fdc7-4768-b736-6058062fa32&amp;title=" alt="image.png"></p>
<h4 id="WebSocket抓包"><a href="#WebSocket抓包" class="headerlink" title="WebSocket抓包"></a>WebSocket抓包</h4><p>我们可以用wireshark抓个包，实际看下数据包的情况。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546965833-aef8e5a5-a209-4330-8e93-224074f67f34.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1d10d507&amp;name=image.png&amp;originHeight=487&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=244948&amp;status=done&amp;style=none&amp;taskId=ub4c84fbb-7ea8-44bc-8ccf-b094da4e4b2&amp;title=" alt="image.png"><br>上面这张图，注意画了红框的第2445行报文，是WebSocket的<strong>第一次握手</strong>，意思是发起了一次带有特殊Header的HTTP请求。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546964415-305c2f7c-e364-4065-918a-dbab07c38e92.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud70a0ed6&amp;name=image.png&amp;originHeight=472&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=243534&amp;status=done&amp;style=none&amp;taskId=u16f0ce0a-82fc-4ee7-acf9-542a8ea2db7&amp;title=" alt="image.png"><br>上面这个图里画了红框的4714行报文，就是服务器在得到第一次握手后，响应的<strong>第二次握手</strong>，可以看到这也是个 HTTP 类型的报文，返回的状态码是 101。同时可以看到返回的报文 header 中也带有各种WebSocket相关的信息，比如Sec-WebSocket-Accept。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546965525-530f0aee-7d94-45f8-acfa-80b13e11d8a2.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u35b229fb&amp;name=image.png&amp;originHeight=514&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=274679&amp;status=done&amp;style=none&amp;taskId=u703a3675-ee46-42dc-8255-d7f6e4c9302&amp;title=" alt="image.png"><br>上面这张图就是全貌了，从截图上的注释可以看出，WebSocket和HTTP一样都是基于TCP的协议。<strong>经历了三次TCP握手之后，利用 HTTP 协议升级为 WebSocket 协议</strong>。<br>你在网上可能会看到一种说法：”WebSocket 是基于HTTP的新协议”，<strong>其实这并不对</strong>，因为WebSocket只有在建立连接时才用到了HTTP，<strong>升级完成之后就跟HTTP没有任何关系了</strong>。<br>这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟HTTP一样，都只是个<strong>工具人</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546965206-5cff50a3-65e4-41ce-a2cf-bf48c85e749e.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uac41784d&amp;name=image.png&amp;originHeight=442&amp;originWidth=444&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=127489&amp;status=done&amp;style=none&amp;taskId=u1ec365a9-aeeb-42c7-9b4e-5455195103f&amp;title=" alt="image.png"><br>这就有点”<strong>借壳生蛋</strong>“的那意思。<br>HTTP和WebSocket的关系</p>
<h4 id="WebSocket的消息格式"><a href="#WebSocket的消息格式" class="headerlink" title="WebSocket的消息格式"></a>WebSocket的消息格式</h4><p>上面提到在完成协议升级之后，两端就会用webscoket的数据格式进行通信。<br>数据包在WebSocket中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546965454-ecec3acf-0241-4ec2-9758-afc7e5bb6f17.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6fa53197&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=71069&amp;status=done&amp;style=none&amp;taskId=u4696fa79-b71b-442e-9eb9-a5b7d87231d&amp;title=" alt="image.png"><br>这里面字段很多，但我们只需要关注下面这几个。<br><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p>
</li>
<li><p>等于 1 ，是指text类型（string）的数据包</p>
</li>
<li>等于 2 ，是二进制数据类型（[]byte）的数据包</li>
<li>等于 8 ，是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是字符串”111”，那它的长度就是3。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546966558-da4abca3-2caa-4cf6-a4b8-9cf21185d9a8.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u85a1a5d0&amp;name=image.png&amp;originHeight=432&amp;originWidth=860&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60526&amp;status=done&amp;style=none&amp;taskId=ue830e39a-7da7-4080-bb85-998a5d0a39e&amp;title=" alt="image.png"><br>另外，可以看到，我们存放<strong> payload 长度的字段有好几个</strong>，我们既可以用最前面的7bit, 也可以用后面的7+16bit 或 7+64bit。<br>那么问题就来了。<br>我们知道，在数据层面，大家都是 01 二进制流。我怎么知道<strong>什么情况下应该读 7 bit，什么情况下应该读7+16bit呢？</strong><br>WebSocket会用最开始的7bit做标志位。不管接下来的数据有多大，都<strong>先读最先的7个bit</strong>，根据它的取值决定还要不要再读个 16bit 或 64bit。</p>
<ul>
<li>如果最开始的7bit的值是 0~125，那么它就表示了 <strong>payload 全部长度</strong>，只读最开始的7个bit就完事了。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546966718-41735f32-a696-4297-90f0-96923c8e9ca0.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ub06a5092&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72427&amp;status=done&amp;style=none&amp;taskId=u0adde173-f942-40cc-93df-539b76646a5&amp;title=" alt="image.png"></p>
<ul>
<li>如果是126（0x7E）。那它表示payload的长度范围在 126~65535 之间，接下来还需要<strong>再读16bit</strong>。这16bit会包含payload的真实长度。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546967081-f9c5c6b8-f79b-4d0e-b9b0-598f752d3beb.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2772619e&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=70800&amp;status=done&amp;style=none&amp;taskId=u6855d65d-f29e-490e-87cb-1c91f2d3b68&amp;title=" alt="image.png"></p>
<ul>
<li>如果是127（0x7F）。那它表示payload的长度范围&gt;=65536，接下来还需要<strong>再读64bit</strong>。这64bit会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546967366-5ae8a60f-b63b-4f6f-aca0-739efcca280e.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud01f2711&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=71345&amp;status=done&amp;style=none&amp;taskId=u3e9a9321-6597-46eb-99bc-4c9cfa0ede3&amp;title=" alt="image.png"><br><strong>payload data字段</strong>：这里存放的就是真正要传输的数据，在知道了上面的payload长度后，就可以根据这个值去截取对应的数据。<br>大家有没有发现一个小细节，WebSocket的数据格式也是<strong>数据头（内含payload长度） + payload data</strong> 的形式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546968100-f66ac318-73ac-4555-8365-d411a7257396.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u15237d51&amp;name=image.png&amp;originHeight=193&amp;originWidth=198&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=30410&amp;status=done&amp;style=none&amp;taskId=ud0cfb149-3fa9-4426-a57f-44666608c07&amp;title=" alt="image.png"><br>这是因为 TCP 协议本身就是全双工，但直接使用<strong>纯裸TCP</strong>去传输数据，会有<strong>粘包</strong>的”问题”。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。<br>而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。<br>HTTP 协议和大部分 RPC 协议，以及我们今天介绍的WebSocket协议，都是这样设计的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546968103-bce149f7-1038-4131-acc7-5a4b238efcc1.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue10aa4b2&amp;name=image.png&amp;originHeight=360&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25350&amp;status=done&amp;style=none&amp;taskId=u68287487-492e-4c32-970b-457356d615a&amp;title=" alt="image.png"></p>
<h4 id="WebSocket的使用场景"><a href="#WebSocket的使用场景" class="headerlink" title="WebSocket的使用场景"></a>WebSocket的使用场景</h4><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。<br>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。<br>回到文章开头的问题，在使用 WebSocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1667546968167-aedbba01-eee8-41c4-a65b-33ba22438608.png#clientId=u1ee1c508-e73b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u81f84eed&amp;name=image.png&amp;originHeight=450&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61106&amp;status=done&amp;style=none&amp;taskId=u3b030f02-f9db-4c01-9e4e-544aa43fb51&amp;title=" alt="image.png"></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li>
<li>在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li>
<li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://fetterslove.github.io">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fetterslove.github.io/2022/08/09/%E8%AE%A1%E7%BD%91/HTTP%E7%AF%87/">http://fetterslove.github.io/2022/08/09/%E8%AE%A1%E7%BD%91/HTTP%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://fetterslove.github.io" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">一、HTTP常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">ⅠHTTP基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0HTTP-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">①HTTP 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1HTTP-%E5%B8%B8%E2%BB%85%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%9C%8A"><span class="toc-text">②HTTP 常⻅的状态码，有哪些？✊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%E2%9C%8A"><span class="toc-text">③http报文格式详解✊</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-text">响应报文</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3http-%E5%B8%B8%E2%BB%85%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">④http 常⻅字段有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1GET%E4%B8%8EPOST"><span class="toc-text">ⅡGET与POST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0GET%E4%B8%8EPOST%E5%8C%BA%E5%88%AB"><span class="toc-text">①GET与POST区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1GET-%E5%92%8C-POST-%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">②GET 和 POST 方法都是安全和幂等的吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-text">ⅢHTTP缓存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0HTTP-%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">①HTTP 缓存有哪些实现方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">协商缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A3HTTP%E7%89%B9%E6%80%A7"><span class="toc-text">ⅣHTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0HTTP-1-1-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">①HTTP(1.1) 的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1HTTP-1-1-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9"><span class="toc-text">②HTTP(1.1)有哪些缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E9%82%A3%E4%BD%A0%E5%86%8D%E8%AF%B4%E4%B8%8B-HTTP-1-1-%E7%9A%84%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-text">③那你再说下 HTTP&#x2F;1.1 的性能如何？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E2%BB%93%E8%BF%9E%E6%8E%A5"><span class="toc-text">1. ⻓连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%AE%A1%E9%81%93%E2%BD%B9%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-text">2. 管道⽹络传输</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">3. 队头阻塞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A4HTTPS%E2%9C%8A"><span class="toc-text">ⅤHTTPS✊</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9Fhttps%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">①HTTPS 是如何建立连接的？其间交互了什么？https的连接过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%A1%E9%AA%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">②客户端校验数字证书的流程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2ssl%E5%8E%9F%E7%90%86%F0%9F%91%8C"><span class="toc-text">③ssl原理👌</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">④HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4HTTPS-%E8%A7%A3%E5%86%B3%E4%BA%86-HTTP-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">⑤HTTPS 解决了 HTTP 的哪些问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A5HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3-%E6%BC%94%E5%8F%98%E2%9C%8A"><span class="toc-text">ⅥHTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变✊</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%AF%B4%E8%AF%B4-HTTP-1-1-%E7%9B%B8%E2%BD%90-HTTP-1-0-%E6%8F%90%E2%BE%BC%E4%BA%86%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-text">①说说 HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 提⾼了什么性能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1HTTP-1-1%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%9A"><span class="toc-text">②HTTP&#x2F;1.1的性能瓶颈：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E9%82%A3%E4%B8%8A%E2%BE%AF%E7%9A%84-HTTP-1-1-%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%8CHTTP-2-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">③那上⾯的 HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-text">1. 头部压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81"><span class="toc-text">静态表编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81"><span class="toc-text">动态表编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">2. 二进制格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93"><span class="toc-text">3. 并发传输</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="toc-text">4. 服务器推送</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3HTTP-2-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%8B%E8%BF%B0%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E8%AE%B2%E8%A7%A3"><span class="toc-text">④HTTP&#x2F;2 有什么缺陷？(可以看下述有详细的讲解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2HTTP-3-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">③HTTP&#x2F;3 做了哪些优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">1、无队头阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-text">2、更快的连接建立</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB"><span class="toc-text">3、连接迁移</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP-3-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD%E2%9C%8A"><span class="toc-text">二、HTTP&#x2F;3 强势来袭✊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0HTTP-2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">ⅠHTTP&#x2F;2存在的缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">①队头阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1TCP-%E4%B8%8E-TLS-%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6%E8%BF%9F"><span class="toc-text">②TCP 与 TLS 的握手时延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="toc-text">③网络迁移需要重新连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1QUIC-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">ⅡQUIC 协议的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">①无队头阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-text">②更快的连接建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB"><span class="toc-text">③连接迁移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2HTTP-3-%E5%8D%8F%E8%AE%AE"><span class="toc-text">ⅢHTTP&#x2F;3 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A3%E5%A6%82%E4%BD%95%E7%94%A8UDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">Ⅳ如何用UDP实现可靠传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0QUIC-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-text">①QUIC 是如何实现可靠传输的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Packet-Header"><span class="toc-text">Packet Header</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#QUIC-Frame-Header"><span class="toc-text">QUIC Frame Header</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1QUIC-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-TCP-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-text">②QUIC 是如何解决 TCP 队头阻塞问题的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么是 TCP 队头阻塞问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-2-%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">HTTP&#x2F;2  的队头阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E7%9A%84-QUIC"><span class="toc-text">没有队头阻塞的 QUIC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2QUIC-%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="toc-text">③QUIC 是如何做流量控制的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream-%E7%BA%A7%E5%88%AB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">Stream 级别的流量控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Connection-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">Connection 流量控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3QUIC-%E5%AF%B9%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%94%B9%E8%BF%9B"><span class="toc-text">④QUIC 对拥塞控制改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4QUIC-%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-text">⑤QUIC 更快的连接建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5QUIC-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">⑥QUIC 是如何迁移连接的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BC%98%E5%8C%96-HTTP-1-1-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%9D%E8%B7%AF%E3%80%82"><span class="toc-text">三、优化 HTTP&#x2F;1.1 协议的思路。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%91%E9%80%81-HTTP-%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-text">Ⅰ如何避免发送 HTTP 请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-HTTP-%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9F"><span class="toc-text">Ⅱ如何减少 HTTP 请求次数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%87%8F%E5%B0%91%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="toc-text">①减少重定向请求次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82"><span class="toc-text">②合并请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-text">③延迟发送请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-HTTP-%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-text">Ⅲ如何减少 HTTP 响应的数据大小？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9"><span class="toc-text">①无损压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9"><span class="toc-text">②有损压缩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%91%8C%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5HTTPS"><span class="toc-text">👌四、深入HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0HTTPS-RSA-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">ⅠHTTPS RSA 握手解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0TLS-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">①TLS 握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1RSA-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">②RSA 握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TLS 第一次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TLS 第二次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6"><span class="toc-text">客户端验证证书</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%92%8C-CA-%E6%9C%BA%E6%9E%84"><span class="toc-text">数字证书和 CA 机构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%92%8C%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="toc-text">数字证书签发和验证流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E9%93%BE"><span class="toc-text">证书链</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TLS 第三次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TLS 第四次握手</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA-%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">RSA 算法的缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1HTTPS-ECDHE-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">ⅡHTTPS ECDHE 握手解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0"><span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DH-%E7%AE%97%E6%B3%95"><span class="toc-text">DH 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHE-%E7%AE%97%E6%B3%95"><span class="toc-text">DHE 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ECDHE-%E7%AE%97%E6%B3%95"><span class="toc-text">ECDHE 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ECDHE-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">ECDHE 握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-text">TLS 第一次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-text">TLS 第二次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-text">TLS 第三次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-text">TLS 第四次握手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2Https%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">ⅢHttps如何优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97"><span class="toc-text">分析性能损耗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-text">硬件优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-text">软件优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96"><span class="toc-text">协议优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-text">密钥交换算法优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS-%E5%8D%87%E7%BA%A7"><span class="toc-text">TLS 升级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96"><span class="toc-text">证书优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96"><span class="toc-text">证书传输优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E4%BC%98%E5%8C%96"><span class="toc-text">证书验证优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CRL"><span class="toc-text">CRL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#OCSP"><span class="toc-text">OCSP</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#OCSP-Stapling"><span class="toc-text">OCSP Stapling</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8"><span class="toc-text">会话复用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Session-ID"><span class="toc-text">Session ID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Session-Ticket"><span class="toc-text">Session Ticket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pre-shared-Key"><span class="toc-text">Pre-shared Key</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E4%B8%8ERPC"><span class="toc-text">HTTP与RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-TCP-%E8%81%8A%E8%B5%B7"><span class="toc-text">从 TCP 聊起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%AF%E8%A3%B8-TCP-%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">使用纯裸 TCP 会有什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-RPC"><span class="toc-text">HTTP 和 RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-RPC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">HTTP 和 RPC 有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">传输的内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89-HTTP-%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-WebSocket%EF%BC%9F"><span class="toc-text">既然有 HTTP 协议，为什么还要有 WebSocket？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HTTP-%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2"><span class="toc-text">使用 HTTP 不断轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-text">长轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">WebSocket是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8BWebSocket%E8%BF%9E%E6%8E%A5"><span class="toc-text">怎么建立WebSocket连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket%E6%8A%93%E5%8C%85"><span class="toc-text">WebSocket抓包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-text">WebSocket的消息格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">WebSocket的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/cover/cover/" title="翻唱"><img src="/1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻唱"/></a><div class="content"><a class="title" href="/2022/08/09/cover/cover/" title="翻唱">翻唱</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113173833.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><script async src="//at.alicdn.com/t/c/xxx.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 java (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 MySQL (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 redis (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://fetterslove.github.io/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 计算机网络 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://fetterslove.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>