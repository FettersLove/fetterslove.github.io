<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>TCP篇 | FettersLoveの博客</title><meta name="author" content="FettersLove"><meta name="copyright" content="FettersLove"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP篇">
<meta property="og:url" content="http://example.com/2022/08/09/%E8%AE%A1%E7%BD%91/TCP_IP%E7%AF%87/index.html">
<meta property="og:site_name" content="FettersLoveの博客">
<meta property="og:description" content="计算机网络">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg">
<meta property="article:published_time" content="2022-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T14:18:12.361Z">
<meta property="article:author" content="FettersLove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/09/%E8%AE%A1%E7%BD%91/TCP_IP%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Free" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: FettersLove","link":"链接: ","source":"来源: FettersLoveの博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-13 22:18:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/xxx.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FettersLoveの博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 程序生涯</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 项目</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-face-smile"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/story/"><i class="fa-fw fas fa-star"></i><span> story</span></a></li><li><a class="site-page child" href="/perception/"><i class="fa-fw fas fa-paper-plane"></i><span> 感悟</span></a></li><li><a class="site-page child" href="/cover/"><i class="fa-fw fas fa-headphones"></i><span> 翻唱音乐</span></a></li><li><a class="site-page child" href="/warmBlood/"><i class="fa-fw fas fa-fire"></i><span> 热血</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TCP篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T14:18:12.361Z" title="更新于 2022-11-13 22:18:12">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="TCP篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、TCP-三次握手与四次挥手面试题"><a href="#一、TCP-三次握手与四次挥手面试题" class="headerlink" title="一、TCP 三次握手与四次挥手面试题"></a>一、TCP 三次握手与四次挥手面试题</h2><h3 id="ⅠTCP基本认识"><a href="#ⅠTCP基本认识" class="headerlink" title="ⅠTCP基本认识"></a>ⅠTCP基本认识</h3><h4 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647569136292-17411965-bd17-4f5a-a383-3e384f76cf2f.png#averageHue=%23f2ebe2&amp;clientId=u0bfb4db7-f767-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=369&amp;id=u0d5fa551&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=716&amp;originWidth=912&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=139959&amp;status=done&amp;style=none&amp;taskId=u9dd8988a-7f73-4913-9305-cf24d3f5377&amp;title=&amp;width=469.5982666015625" alt="image.png"><br>序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。<br>确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。⽤来解决不丢包的问题。<br>控制位：<br><em>ACK</em>：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必<br>须设置为 1 。<br><em>RST</em>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。<br><em>SYN</em>：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。<br><em>FIN</em>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</p>
<h4 id="为什么需要-TCP-协议？-TCP-⼯作在哪⼀层？"><a href="#为什么需要-TCP-协议？-TCP-⼯作在哪⼀层？" class="headerlink" title="为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？"></a>为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？</h4><ul>
<li>IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。</li>
<li><p>因为 TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余 和按序的。</p>
<h4 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h4><p>TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。 </p>
</li>
<li><p>⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀ 对多是⽆法做到的；</p>
</li>
<li>可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端； </li>
<li><p>字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当 「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重 复」的报⽂会⾃动丢弃。</p>
<h4 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h4><p>简单来说就是，⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，<br>包括<strong>Socket</strong>、<strong>序列号</strong>和<strong>窗⼝⼤⼩</strong>称为连接。<br>所以我们可以知道，建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。<br><strong>Socket</strong>：由 IP 地址和端⼝号组成<br><strong>序列号</strong>：⽤来解决乱序问题等<br><strong>窗⼝⼤⼩</strong>：⽤来做流量控制</p>
<h4 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h4><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
</li>
<li><p>源地址</p>
</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651539567509-1ac2bb7d-67b4-4b59-ad8c-825ea73fe831.png#averageHue=%23f1d6b8&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ucc7847cd&amp;originHeight=228&amp;originWidth=821&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u02e02e94-20c5-490e-9c56-c608f90f73f&amp;title=" alt=""><br>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。<br>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<h4 id="有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h4><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。<br>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651539567559-85eceb10-1497-4c25-837f-7eff306ae6c5.png#averageHue=%23e8e77f&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1baa8d6e&amp;originHeight=41&amp;originWidth=601&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u091d52f6-543c-4eb2-bed7-e2e7b7a63ba&amp;title=" alt=""><br>对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。<br>补充当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li><strong>文件描述符限制</strong>，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul>
<li><strong>系统级</strong>：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看；</li>
<li><strong>用户级</strong>：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看；</li>
<li><strong>进程级</strong>：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看；</li>
</ul>
</li>
<li><p><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</p>
<h4 id="✊UDP-和-TCP-有什么区别呢？分别的应⽤场景是？"><a href="#✊UDP-和-TCP-有什么区别呢？分别的应⽤场景是？" class="headerlink" title="✊UDP 和 TCP 有什么区别呢？分别的应⽤场景是？"></a>✊UDP 和 TCP 有什么区别呢？分别的应⽤场景是？</h4><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。<br>UDP 协议真的非常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649897896013-1537be17-a57a-4f4e-b54e-b55663b993e4.png#averageHue=%23e0e6ef&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=u97d16b8a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=468&amp;originWidth=783&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u55243f9b-e219-4257-826a-bd2dd3a5c1c&amp;title=&amp;width=509" alt=""></p>
</li>
<li><p>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</p>
</li>
<li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP包。</li>
</ul>
<p><strong>连服可拥首传分</strong><br><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<p><strong>TCP </strong>和<strong> UDP </strong>应⽤场景：<br>由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于： </p>
<ul>
<li>FTP ⽂件传输 </li>
<li>HTTP / HTTPS </li>
</ul>
<p>由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于： </p>
<ul>
<li>包总量较少的通信，如 DNS 、 SNMP 等 </li>
<li>视频、⾳频等多媒体通信 ⼴播通信<h4 id="为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h4>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。<h3 id="Ⅱ-TCP连接建立"><a href="#Ⅱ-TCP连接建立" class="headerlink" title="Ⅱ TCP连接建立"></a>Ⅱ TCP连接建立</h3>先说明三次握手-&gt;对于的socket通信-&gt;引出半连接队列全连接队列-&gt;泛洪以及解决-&gt;溢出场景-&gt;<br>挥手过程-&gt;time_wait</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649904679728-64bf0172-ab76-4040-80ba-e62f03fa1d14.png#averageHue=%23e7f7f4&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=80&amp;id=u7fd3bb5b&amp;name=image.png&amp;originHeight=100&amp;originWidth=739&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14522&amp;status=done&amp;style=none&amp;taskId=uaa4367f8-fd48-4573-8a8a-a1b3f6fb5df&amp;title=&amp;width=591.2" alt="image.png"></p>
<h4 id="①TCP三次握手过程"><a href="#①TCP三次握手过程" class="headerlink" title="①TCP三次握手过程"></a>①TCP三次握手过程</h4><p>三次握手流程-&gt;讲解过程中每一次握手就可以讲解到socket连接过程对应和这次握手丢失会怎么样-&gt;<br>然后开始讲解4.TCP半连接队列于全连接队列知识-&gt;syn泛洪<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1647569564330-46d16916-490c-410f-96a9-b0f6e4800581.png#averageHue=%23f8edd3&amp;clientId=u0bfb4db7-f767-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=451&amp;id=u6b62c26f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=729&amp;originWidth=885&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=123866&amp;status=done&amp;style=none&amp;taskId=ub033beb2-2518-4769-8192-c1d22733c5e&amp;title=&amp;width=547" alt="image.png"><br><strong>记忆：序列号+确认应答号+标志位（syn，ack）发送完成后的状态</strong></p>
<ul>
<li>⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态</li>
<li>客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，该报⽂不 包含应⽤层数据，之后客户端处于 SYN-SENT 状态。 </li>
<li>服务端收到客户端的 SYN 报⽂后，首先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填⼊TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1 。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN_RCVD 状态。也就是半连接队列</li>
<li>客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，会把「确认应答号」字段填⼊ server_isn + 1 然后把该应答报⽂ TCP ⾸部 ACK 标志位 置为 1 ，其次，最后把报⽂发送给服务端，这次报⽂可以携带客 户到服务器的数据，之后客户端处于 ESTABLISHED 状态。</li>
<li>服务器收到客户端的应答报⽂后，从「 SYN 队列」移除放入到「 Accept 队列」；进⼊ ESTABLISHED 状态。 </li>
</ul>
<p>从上⾯的过程可以发现第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，这也是⾯试常问的题。 ⼀旦完成三次握⼿，双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送 数据了。<br>如何在 Linux 系统中查看 TCP 状态？<br>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649898315373-f15230dc-b00c-4a25-8754-1b71ba31a3dd.png#averageHue=%23f1e9d2&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5d5c07c3&amp;originHeight=327&amp;originWidth=1563&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0d2093eb-896d-42f6-95ef-2b569d9428d&amp;title=" alt=""></p>
<h4 id="✊②为什么是三次握⼿？不是两次、四次？"><a href="#✊②为什么是三次握⼿？不是两次、四次？" class="headerlink" title="✊②为什么是三次握⼿？不是两次、四次？"></a>✊②为什么是三次握⼿？不是两次、四次？</h4><p><strong>1.最主要的原因是防止历史连接初始化了连接</strong></p>
<ul>
<li>比如客户端连续发送多个SYN报文的时候，由于网络拥堵，导致了一个旧的syn报文比一个新的syn报文先到达了服务端，此时服务端会回一个syn+ack报文给客户端，<ul>
<li>如果是两次握手连接，那么就不能判断当前连接是否是历史连接，主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。也就是「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态。</li>
<li>三次握手的话就可以在客户端准备<strong>发送第三次报文</strong>的时候，拥有足够的上下文环境来判断当前连接是否是历史连接。<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接；如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接；<br>补充<strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？<br>我先直接说结论，主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。也就是「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态。<br>你想想，两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发起方」此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651540322041-865a948d-9e32-47cb-8f6a-aadab48ce9dc.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=484&amp;id=A6HHm&amp;name=image.png&amp;originHeight=1097&amp;originWidth=1068&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=208213&amp;status=done&amp;style=none&amp;taskId=ud65049ca-1283-4478-a377-0b7e4df2653&amp;title=&amp;width=471" alt="image.png"><br>可以看到，上面这种场景下，「被动发起方」在向「主动发起方」发送数据前，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，妥妥地浪费了「被动发起方」的资源。<br>因此，<strong>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。<br>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</strong><br><strong>2.三次握手可以同步双方的初始序列号</strong><br>序列号是可靠传输的⼀个关键因素，它的作⽤：<br>①接收⽅可以去除重复的数据；<br>②接收⽅可以根据数据包的序列号按序接收；<br>③可以标识发送出去的数据包中， 哪些是已经被对⽅收到的；<blockquote>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651540492356-720d8855-e53f-470d-b8c7-8c1e105fccf4.png#averageHue=%23fbf7f2&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=398&amp;id=u37952dbf&amp;originHeight=947&amp;originWidth=1442&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua54ac941-b210-435d-a285-6a7be6cc5e7&amp;title=&amp;width=606" alt=""><br>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。<br>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3.可以避免资源的浪费</strong><br>如果只有两次握手，由于服务器不清楚客户端是否收到了自己发送的ack确认信号，所以每收到一个syn报文就只能先主动建立一个连接，如果客户端的syn报文阻塞了，重复发送多个syn报文，那么服务器就会建立多个冗余的无效连接。</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。<h4 id="③为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#③为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="③为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>③为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4>主要原因有两个方面：</li>
</ul>
<ol>
<li><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</strong><br>补充接下来，详细说说第一点。<br>假设每次建立连接，客户端和服务端的初始化序列号都是从 0 开始：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651540757204-29d21172-9ba9-4309-b8ce-cc90f344f5e5.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=595&amp;id=y5bcz&amp;name=image.png&amp;originHeight=1112&amp;originWidth=1031&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=597049&amp;status=done&amp;style=none&amp;taskId=ue043bc17-580f-4aa8-accc-4362c52aded&amp;title=&amp;width=552" alt="image.png"><br>过程如下：</li>
</ol>
<ul>
<li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，而此时服务端的进程重启了，于是就会发送 RST 报文来断开连接。</li>
<li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li>
<li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。<blockquote>
<p>比如：客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，而此时服务端的进程重启了，于是就会发送 RST 报文来断开连接。<br>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；<br>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</p>
</blockquote>
</li>
</ul>
<p>可以看到，<strong>如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题</strong>。<br>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有<strong>大概率</strong>因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，比如下图：<br>补充<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651540757198-d14c247d-1c75-49ad-bba2-1183da1544d5.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=B8TfR&amp;name=image.png&amp;originHeight=927&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=531166&amp;status=done&amp;style=none&amp;taskId=u1dad5781-e8a0-41c2-a1e1-12ae62e0bdc&amp;title=" alt="image.png"><br>相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。<br>所以，每次初始化序列号不一样能够很大程度上避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了（因为序列号会有回绕的问题，所以需要用时间戳的机制来判断历史报文，详细看篇：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZQ51SmLopj-4OPhNkSL8Fw">TCP 是如何避免历史报文的？(opens new window)</a>）。（下述）<br>详细说明过程为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？<br>主要原因是为了防止历史报文被下一个相同四元组的连接接收。<br>TCP 四次挥手中的 TIME_WAIT 状态不是会持续 2 MSL 时长，历史报文不是早就在网络中消失了吗？<br>是的，如果能正常四次挥手，由于 TIME_WAIT 状态会持续 2 MSL 时长，历史报文会在下一个连接之前就会自然消失。<br>问题出现：但是来了，我们并不能保证每次连接都能通过四次挥手来正常关闭连接。<br>假设每次建立连接，客户端和服务端的初始化序列号都是从 0 开始：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650589832101-554b3b0e-4644-435a-a4d8-395363f97888.png#clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=582&amp;id=AeHPT&amp;name=image.png&amp;originHeight=1112&amp;originWidth=1031&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=597049&amp;status=done&amp;style=none&amp;taskId=ub5fa8a18-ce63-430d-a12f-a95527f8ec4&amp;title=&amp;width=540" alt="image.png"><br>过程如下：</p>
<ul>
<li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，而此时服务端的进程重启了，于是就会发送 RST 报文来断开连接。</li>
<li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li>
<li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li>
</ul>
<p>可以看到，如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。<br>客户端和服务端的初始化序列号不一样不是也会发生这样的事情吗？<br>是的，即使客户端和服务端的初始化序列号不一样，也会存在收到历史报文的可能。<br>但是我们要清楚一点，历史报文能否被对方接收，还要看该历史报文的序列号是否正好在对方接收窗口内，如果不在就会丢弃，如果在才会接收。<br>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，比如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650589831911-b6b61947-5ce0-4d6f-a938-34202edfbeda.png#clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=530&amp;id=KHOfo&amp;name=image.png&amp;originHeight=927&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=531166&amp;status=done&amp;style=none&amp;taskId=u3a88c6bc-03fa-4c78-946d-fe7510640a1&amp;title=&amp;width=617" alt="image.png"><br>相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。<br>所以，每次初始化序列号不一样能够很大程度上避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了。<br>那客户端和服务端的初始化序列号都是随机的，那还是有可能随机成一样的呀？<br>RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。</p>
<ul>
<li>M是一个计时器，这个计时器每隔 4 微秒加1。</li>
<li>F 是一个 Hash 算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值，要保证 hash 算法不能被外部轻易推算得出。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。<br>懂了，客户端和服务端初始化序列号都是随机生成的话，就能避免连接接收历史报文了。<br>是的，但是也不是完全避免了。<br>为了能更好的理解这个原因，我们先来了解序列号（SEQ）和初始序列号（ISN）。</p>
<ul>
<li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li>
<li><strong>初始序列号</strong>，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</li>
</ul>
<p>给大家抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650589832422-ae5c37ec-a568-463e-bca6-c768b7ba632b.png#clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=LT1uy&amp;name=image.png&amp;originHeight=545&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=888038&amp;status=done&amp;style=none&amp;taskId=u20fc96fc-6085-4b1f-98f5-9128183703d&amp;title=&amp;width=623" alt="image.png"><br>图片<br>通过前面我们知道，<strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。<br>不要以为序列号的上限值是 4GB，就以为很大，很难发生回绕。在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。<br>为了解决这个问题，就需要有 TCP 时间戳。<strong>tcp_timestamps</strong> 参数是默认开启的，开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<blockquote>
<p>试看下面的示例，假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650589831838-0c9fb0b2-109e-4dff-aa11-394673a206b6.png#clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=198&amp;id=f3Ise&amp;name=image.png&amp;originHeight=298&amp;originWidth=956&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=99998&amp;status=done&amp;style=none&amp;taskId=u3417d776-3220-439b-a8b8-36d81d722a4&amp;title=&amp;width=634" alt="image.png"><br>32 位的序列号在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。<br>使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法（PAWS）会将其丢弃。<br>防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
</blockquote>
<p>懂了，客户端和服务端的初始化序列号都是随机生成，能很大程度上避免历史报文被下一个相同四元组的连接接收，然后又引入时间戳的机制，从而完全避免了历史报文被接收的问题。<br>嗯嗯，没错。<br>如果时间戳也回绕了怎么办？    了解</p>
<blockquote>
<p>时间戳的大小是 32 bit，所以理论上也是有回绕的可能性的。<br>时间戳回绕的速度只与对端主机时钟频率有关。<br>Linux 以本地时钟计数（jiffies）作为时间戳的值，不同的增长时间会有不同的问题：</p>
<ul>
<li>如果时钟计数加 1 需要1ms，则需要约 24.8 天才能回绕一半，只要报文的生存时间小于这个值的话判断新旧数据就不会出错。</li>
<li>如果时钟计数提高到 1us 加1，则回绕需要约71.58分钟才能回绕，这时问题也不大，因为网络中旧报文几乎不可能生存超过70分钟，只是如果70分钟没有报文收发则会有一个包越过PAWS（这种情况会比较多见，相比之下 24 天没有数据传输的TCP连接少之又少），但除非这个包碰巧是序列号回绕的旧数据包而被放入接收队列（太巧了吧），否则也不会有问题；</li>
<li>如果时钟计数提高到 0.1 us 加 1 回绕需要 7 分钟多一点，这时就可能会有问题了，连接如果 7 分钟没有数据收发就会有一个报文越过 PAWS，对于TCP连接而言这么短的时间内没有数据交互太常见了吧！这样的话会频繁有包越过 PAWS 检查，从而使得旧包混入数据中的概率大大增加；</li>
</ul>
<p>Linux 在 PAWS 检查做了一个特殊处理，如果一个 TCP 连接连续 24 天不收发数据则在接收第一个包时基于时间戳的 PAWS 会失效，也就是可以 PAWS 函数会放过这个特殊的情况，认为是合法的，可以接收该数据包。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650590086853-7eeba05e-950b-4fa2-a5f3-b503f40d4ca9.png#clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=298&amp;id=MfyMi&amp;name=image.png&amp;originHeight=373&amp;originWidth=903&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=21382&amp;status=done&amp;style=none&amp;taskId=u7dcb7602-ffdf-4167-8e77-d9453c28770&amp;title=&amp;width=722.4" alt="image.png"><br>要解决时间戳回绕的问题，可以考虑以下解决方案：<br>1）增加时间戳的大小，由32 bit扩大到64bit<br>这样虽然可以在能够预见的未来解决时间戳回绕的问题，但会导致新旧协议兼容性问题，像现在的IPv4与IPv6一样<br>2）将一个与时钟频率无关的值作为时间戳，时钟频率可以增加但时间戳的增速不变<br>随着时钟频率的提高，TCP在相同时间内能够收发的包也会越来越多。如果时间戳的增速不变，则会有越来越多的报文使用相同的时间戳。这种趋势到达一定程度则时间戳就会失去意义，除非在可预见的未来这种情况不会发生。<br>3）暂时没想到</p>
</blockquote>
<ol>
<li><strong>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</strong><h4 id="👌④初始序列号-ISN-是如何随机产生的？"><a href="#👌④初始序列号-ISN-是如何随机产生的？" class="headerlink" title="👌④初始序列号 ISN 是如何随机产生的？"></a>👌④初始序列号 ISN 是如何随机产生的？</h4>起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。<br>RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。</li>
</ol>
<ul>
<li>M 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li>F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<h4 id="✊⑤既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#✊⑤既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="✊⑤既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>✊⑤既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><p>我们先来认识下 MTU 和 MSS<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649898826164-38fd4615-ae0c-4514-894d-ad71bf62f3b2.png#averageHue=%23f4f4f4&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4f51e6c7&amp;originHeight=422&amp;originWidth=1067&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d5f7527-9cbf-48ef-b1e5-ef8aff770f1&amp;title=" alt=""></p>
<ul>
<li>MTU：<strong>一个网络包</strong>的最大长度，以太网中一般为 1500 字节；</li>
<li>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p>
<ul>
<li>当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</li>
<li><strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</li>
<li>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</li>
</ul>
<p>因此，可以得知<strong>由 IP 层进行分片传输，是非常没有效率的。</strong><br>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649898826196-11af3142-c155-4e4c-87d4-d8da3ad4309c.png#averageHue=%23ddfbc7&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u71da724c&amp;originHeight=71&amp;originWidth=564&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u563360cd-bad2-4466-b30a-73ebc277fef&amp;title=" alt=""><br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h4 id="⑥握手丢失的过程"><a href="#⑥握手丢失的过程" class="headerlink" title="⑥握手丢失的过程"></a>⑥握手丢失的过程</h4><h5 id="a-第一次握手丢失了，会发生什么？"><a href="#a-第一次握手丢失了，会发生什么？" class="headerlink" title="a.第一次握手丢失了，会发生什么？"></a>a.第一次握手丢失了，会发生什么？</h5><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。<br>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。</p>
<blockquote>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
</blockquote>
<p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？<br>在 Linux 里，客户端的 SYN 报文最大重传次数由 <strong>tcp_syn_retries</strong>内核参数控制，这个参数是可以自定义的，默认值一般是 5。<br>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。<br>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。<br>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。</p>
<h5 id="b-第二次握手丢失了，会发生什么？"><a href="#b-第二次握手丢失了，会发生什么？" class="headerlink" title="b.第二次握手丢失了，会发生什么？"></a>b.第二次握手丢失了，会发生什么？</h5><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。<br>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p><strong>所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？</strong><br>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。<br>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。<br>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<p>所以，我们可以发现，当第二次握手的 SYN、ACK 丢包时，客户端会超时重发 SYN 包，服务端也会超时重传 SYN、ACK 包。</p>
<blockquote>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <strong>tcp_synack_retries</strong>内核参数决定，默认值是 5。<br>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。</li>
</ul>
</blockquote>
<h5 id="c-第三次握手丢失了，会发生什么？"><a href="#c-第三次握手丢失了，会发生什么？" class="headerlink" title="c.第三次握手丢失了，会发生什么？"></a>c.第三次握手丢失了，会发生什么？</h5><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。<br>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。<br>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。<br><strong>实验三：TCP 第三次握手 ACK 丢包 ！！！！！</strong></p>
<blockquote>
<p>为了模拟 TCP 第三次握手 ACK 包丢，我的实验方法是在服务端配置防火墙，屏蔽客户端 TCP 报文中标志位是 ACK 的包，也就是当服务端收到客户端的 TCP ACK 的报文时就会丢弃，iptables 配置命令如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543755481-c46d1fba-860f-4de7-92c9-0a7964177461.jpeg#averageHue=%23565a76&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=156&amp;id=u244191bf&amp;originHeight=354&amp;originWidth=1340&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c9641db-d010-4e59-98ca-6ac0c6fbafd&amp;title=&amp;width=591" alt=""><br>接着，在客户端执行如下 tcpdump 命令：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543755442-86d58a14-cf6f-4355-9100-74e30c10d09e.jpeg#averageHue=%23565975&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=141&amp;id=uea33a226&amp;originHeight=354&amp;originWidth=1560&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc68ac733-9aae-494f-8aa4-bb2558a2748&amp;title=&amp;width=621" alt=""><br>然后，客户端向服务端发起 telnet，因为 telnet 命令是会发起 TCP 连接，所以用此命令做测试：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543755473-44c33547-6bab-478a-a8e0-0f23b7874f43.jpeg#averageHue=%23515371&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=357&amp;id=u10ef8c82&amp;originHeight=498&amp;originWidth=818&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0be183ee-9340-4e45-bccc-37e44e447c7&amp;title=&amp;width=586" alt=""><br>此时，由于服务端收不到第三次握手的 ACK 包，所以一直处于 SYN_RECV 状态：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543755458-2723dbf8-276d-4495-b072-049f610b4f28.jpeg#averageHue=%23525572&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=137&amp;id=u5802a309&amp;originHeight=390&amp;originWidth=1662&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7d06bac8-c13f-4f64-8cad-9b6c2582c24&amp;title=&amp;width=583" alt=""><br>而客户端是已完成 TCP 连接建立，处于 ESTABLISHED 状态：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543755467-a109621a-1f22-4fc7-93a3-004e4cbeca05.jpeg#averageHue=%23515472&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=134&amp;id=ue2281883&amp;originHeight=390&amp;originWidth=1830&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf34bca43-31ac-49d1-a695-aff8469d47e&amp;title=&amp;width=629" alt=""><br>过了 1 分钟后，观察发现服务端的 TCP 连接不见了：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543756721-ea33bcf8-521f-401b-b6fa-1f3328b18286.jpeg#averageHue=%23525673&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=189&amp;id=u6c87673b&amp;originHeight=390&amp;originWidth=1314&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub62124a6-4176-4451-a790-a13c8ea028b&amp;title=&amp;width=638" alt=""><br>过了 30 分钟，客户端依然还是处于 ESTABLISHED 状态：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543756959-5f403bcc-98e0-4ee1-8596-f85bd7d27481.jpeg#averageHue=%23515472&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=129&amp;id=uc1add547&amp;originHeight=390&amp;originWidth=1830&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8be81500-ea5a-4ee7-86f1-6ed6a5920f0&amp;title=&amp;width=606" alt=""><br>接着，在刚才客户端建立的 telnet 会话，输入 123456 字符，进行发送：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543757465-7d11eaa9-4db5-4c12-b28e-13c39e52604e.jpeg#averageHue=%234e506f&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=352&amp;id=u5b0e90c2&amp;originHeight=534&amp;originWidth=862&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7250edff-0eb8-4cd7-a96c-05900c75610&amp;title=&amp;width=569" alt=""><br>持续「好长」一段时间，客户端的 telnet 才断开连接：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543757521-18b81491-fbc9-412c-bd66-c9a9b0e0c00c.jpeg#averageHue=%234d4f6e&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=ua7357481&amp;originHeight=534&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u19dfeb56-94d1-472d-b496-6495c1ba346&amp;title=&amp;width=581" alt=""></p>
<p>以上就是本次的实现三的现象，这里存在两个疑点：</p>
<ul>
<li>为什么服务端原本处于 SYN_RECV 状态的连接，过 1 分钟后就消失了？</li>
<li>为什么客户端 telnet 输入 123456 字符后，过了好长一段时间，telnet 才断开连接？</li>
</ul>
<p>不着急，我们把刚抓的数据包，用 Wireshark 打开分析，显示的时序图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543757489-3990c170-fd9f-4d36-ac1c-bcdbb3b2ec46.jpeg#averageHue=%23abcb69&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=654&amp;id=u8ada7879&amp;originHeight=822&amp;originWidth=779&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud221b26f-6829-4521-a4f1-8cdfdabb9bb&amp;title=&amp;width=620" alt=""><br>上图的流程：</p>
<ul>
<li>客户端发送 SYN 包给服务端，服务端收到后，回了个 SYN、ACK 包给客户端，此时服务端的 TCP 连接处于 SYN_RECV 状态；</li>
<li>客户端收到服务端的 SYN、ACK 包后，给服务端回了个 ACK 包，此时客户端的 TCP 连接处于 ESTABLISHED 状态；</li>
<li>由于服务端配置了防火墙，屏蔽了客户端的 ACK 包，所以服务端一直处于 SYN_RECV 状态，没有进入 ESTABLISHED 状态，tcpdump 之所以能抓到客户端的 ACK 包，是因为数据包进入系统的顺序是先进入 tcpudmp，后经过 iptables；</li>
<li>接着，服务端超时重传了 SYN、ACK 包，重传了 5 次后，也就是<strong>超过 tcp_synack_retries 的值（默认值是 5），然后就没有继续重传了，此时服务端的 TCP 连接主动中止了，所以刚才处于 SYN_RECV 状态的 TCP 连接断开了</strong>，而客户端依然处于ESTABLISHED 状态；</li>
<li>虽然服务端 TCP 断开了，但过了一段时间，发现客户端依然处于ESTABLISHED 状态，于是就在客户端的 telnet 会话输入了 123456 字符；</li>
<li>此时由于服务端已经断开连接，<strong>客户端发送的数据报文，一直在超时重传，每一次重传，RTO 的值是指数增长的，所以持续了好长一段时间，客户端的 telnet 才报错退出了，此时共重传了 15 次。</strong></li>
</ul>
<p>通过这一波分析，刚才的两个疑点已经解除了：</p>
<ul>
<li>服务端在重传 SYN、ACK 包时，超过了最大重传次数 tcp_synack_retries，于是服务端的 TCP 连接主动断开了。</li>
<li>客户端向服务端发送数据包时，由于服务端的 TCP 连接已经退出了，所以数据包一直在超时重传，共重传了 15 次， telnet 就断开了连接。</li>
</ul>
</blockquote>
<p><strong>TCP 第一次握手的 SYN 包超时重传最大次数是由 tcp_syn_retries 指定，TCP 第二次握手的 SYN、ACK 包超时重传最大次数是由 tcp_synack_retries 指定，那 TCP 建立连接后的数据包最大超时重传次数是由什么参数指定呢？</strong><br>TCP 建立连接后的数据包传输，最大超时重传次数是由 <strong>tcp_retries2</strong> 指定，默认值是 15 次，如下：<br>$ cat /proc/sys/net/ipv4/tcp_retries2 15<br>如果 15 次重传都做完了，TCP 就会告诉应用层说：“搞不定了，包怎么都传不过去！”<br><strong>那如果客户端不发送数据，什么时候才会断开处于 ESTABLISHED 状态的连接？</strong><br>这里就需要提到 TCP 的 <strong>保活机制</strong>。这个机制的原理是这样的：<br>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个「探测报文」，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。<br>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：<br>net.ipv4.tcp_keepalive_time=7200 net.ipv4.tcp_keepalive_intvl=75   net.ipv4.tcp_keepalive_probes=9 </p>
<ul>
<li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651543758200-12df3d82-3902-4a5d-b686-575c3fc09265.jpeg#averageHue=%23f7f7b3&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u206ff3c9&amp;originHeight=303&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3000fc3e-08d9-41de-84fb-aa2d9063bf6&amp;title=" alt=""><br>这个时间是有点长的，所以如果我抓包足够久，或许能抓到探测报文。</p>
<blockquote>
<p>实验三的实验小结<br>在建立 TCP 连接时，如果第三次握手的 ACK，服务端无法收到，则服务端就会短暂处于 SYN_RECV 状态，而客户端会处于 ESTABLISHED 状态。<br>由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 tcp_synack_retries 值（默认值 5 次）后，服务端就会断开 TCP 连接。<br>而客户端则会有两种情况：</p>
<ul>
<li>如果客户端没发送数据包，一直处于 ESTABLISHED 状态，然后经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接，于是客户端连接就会断开连接。</li>
<li>如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 tcp_retries2 值（默认值 15 次）后，客户端就会断开 TCP 连接。</li>
</ul>
</blockquote>
<h4 id="⑦-什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#⑦-什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="⑦ 什么是 SYN 攻击？如何避免 SYN 攻击？"></a>⑦ 什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p><em>SYN 攻击</em><br>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务器不能为正常用户服务。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649898979656-ab11bd10-3ec6-457e-aa1e-fc288dccb7e9.png#averageHue=%23f5f2e5&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u89ae4bcc&amp;originHeight=348&amp;originWidth=500&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua42cda1d-ca80-4291-baa3-acbbee1e3da&amp;title=" alt=""><br>这里给出几种防御 SYN 攻击的方法：</p>
<ul>
<li>增大半连接队列；</li>
<li>开启 tcp_syncookies 功能</li>
<li>减少 SYN+ACK 重传次数<h5 id="方式一：增大半连接队列"><a href="#方式一：增大半连接队列" class="headerlink" title="方式一：增大半连接队列"></a>方式一：增大半连接队列</h5><blockquote>
<p>在前面源码和实验中，得知<strong>要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列</strong>。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</p>
</blockquote>
</li>
</ul>
<h5 id="方式二：开启-tcp-syncookies-功能"><a href="#方式二：开启-tcp-syncookies-功能" class="headerlink" title="方式二：开启 tcp_syncookies 功能"></a>方式二：开启 tcp_syncookies 功能</h5><p>开启 tcp_syncookies 功能的方式也很简单，修改 Linux 内核参数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649902871403-efd569da-1d78-410d-b47b-aae400cf49f3.png#averageHue=%23282c34&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=DB9gF&amp;name=image.png&amp;originHeight=456&amp;originWidth=1788&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72428&amp;status=done&amp;style=none&amp;taskId=u49c373ac-5dc8-4210-9541-229f4ae6a1f&amp;title=" alt="image.png"></p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li>
<li>计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li>
<li><p>最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</p>
<h5 id="方式三：减少-SYN-ACK-重传次数"><a href="#方式三：减少-SYN-ACK-重传次数" class="headerlink" title="方式三：减少 SYN+ACK 重传次数"></a>方式三：减少 SYN+ACK 重传次数</h5><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。<br>那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649902871808-4882fb0e-f01f-4373-b4ff-568d89d4b291.png#averageHue=%23282c34&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=151&amp;id=AbJew&amp;name=image.png&amp;originHeight=456&amp;originWidth=1888&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=70119&amp;status=done&amp;style=none&amp;taskId=u34847dde-13d6-4aae-9c8d-75412d7c83b&amp;title=&amp;width=627" alt="image.png"></p>
<h4 id="⑧-TCP半连接队列与全连接队列"><a href="#⑧-TCP半连接队列与全连接队列" class="headerlink" title="⑧ TCP半连接队列与全连接队列"></a>⑧ TCP半连接队列与全连接队列</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651544680143-029e752d-46d4-40b8-b4cb-75ddd1e21883.jpeg#averageHue=%23efeff3&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=KDpVi&amp;originHeight=925&amp;originWidth=1692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3c5eb06b-fada-4b18-8ae2-f87a6c885d6&amp;title=" alt=""></p>
<h5 id="a-什么是-TCP-半连接队列和全连接队列？"><a href="#a-什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="a: 什么是 TCP 半连接队列和全连接队列？"></a>a: 什么是 TCP 半连接队列和全连接队列？</h5><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
</li>
<li><p>半连接队列，也称 SYN 队列；</p>
</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649902431692-95602de5-a92b-4ad5-a6fd-43a572224de0.png#averageHue=%23fcfcfb&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=485&amp;id=UZWnG&amp;name=image.png&amp;originHeight=1083&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101020&amp;status=done&amp;style=none&amp;taskId=u4605eb9e-e6b5-4aef-871e-2e107bebfab&amp;title=&amp;width=485" alt="image.png"><br>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</p>
<hr>
<h5 id="b-实战-TCP-全连接队列溢出"><a href="#b-实战-TCP-全连接队列溢出" class="headerlink" title="b: 实战 - TCP 全连接队列溢出"></a>b: 实战 - TCP 全连接队列溢出</h5><p><strong>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649902546239-0f5877f5-8788-423c-ab67-36bf72652bc1.png#averageHue=%23faf4e8&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=J51vj&amp;name=image.png&amp;originHeight=347&amp;originWidth=839&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41009&amp;status=done&amp;style=none&amp;taskId=u40d338ad-b21e-4365-a4ce-94879dfcfc4&amp;title=&amp;width=530" alt="image.png"><br>Linux 有个参数可以指定当 TCP 全连接队列满了会使用什么策略来回应客户端。<br>实际上，丢弃连接只是 Linux 的默认行为，我们还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649902647307-432aea22-a36b-47ab-a128-c3f9e6213981.png#averageHue=%23282c34&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=171&amp;id=HpYxQ&amp;name=image.png&amp;originHeight=456&amp;originWidth=1816&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60390&amp;status=done&amp;style=none&amp;taskId=u8ff2c45d-94b6-4dcd-bc5d-acd64b4d773&amp;title=&amp;width=682" alt="image.png"><br><strong>tcp_abort_on_overflow</strong> 共有两个值分别是 0 和 1，其分别表示：</p>
<ul>
<li>0 ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；直接丢弃</li>
<li>1 ：如果全连接队列满了，server 发送一个 reset 包给 client，表示废掉这个握手过程和这个连接；发送RST报文</li>
</ul>
<p>如果要想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 connection reset by peer 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。<br>通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。<br>举个例子，当 TCP 全连接队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次<strong>重发</strong>。如果服务器上的进程只是<strong>短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。</strong><br>所以，tcp_abort_on_overflow 设为 0 可以提高连接建立的成功率，只有你非常肯定 TCP 全连接队列会长期溢出时，才能设置为 1 以尽快通知客户端。<br>如何增大 TCP 全连接队列呢？<br>是的，当发现 TCP 全连接队列发生溢出的时候，我们就需要增大该队列的大小，以便可以应对客户端大量的请求。<br><strong>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong>。<br><strong>如果持续不断地有连接因为 TCP 全连接队列溢出被丢弃，就应该调大 backlog 以及 somaxconn 参数。</strong></p>
<h5 id="c-实战-TCP-半连接队列溢出"><a href="#c-实战-TCP-半连接队列溢出" class="headerlink" title="c: 实战 - TCP 半连接队列溢出"></a>c: 实战 - TCP 半连接队列溢出</h5><p>如何模拟 TCP 半连接队列溢出场景？<br>模拟 TCP 半连接溢出场景不难，实际上就是对服务端一直发送 TCP SYN 包，但是不回第三次握手 ACK，这样就会使得服务端有大量的处于 SYN_RECV 状态的 TCP 连接。<br>这其实也就是所谓的 SYN 洪泛、SYN 攻击、DDos 攻击。<br>如果 SYN 半连接队列已满，只能丢弃连接吗？<br>并不是这样，<strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong>，当开启了 syncookies 功能就不会丢弃连接。<br>syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649903024171-44ba594b-1f58-41fe-b552-c85ff979321e.png#averageHue=%23f8f5ed&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Wtt14&amp;name=image.png&amp;originHeight=392&amp;originWidth=899&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50543&amp;status=done&amp;style=none&amp;taskId=uc4e204dd-8135-4de0-bfaa-28bfb021b28&amp;title=" alt="image.png"><br>syncookies 参数主要有以下三个值：</p>
<ul>
<li>0 值，表示关闭该功能；</li>
<li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li>
<li>2 值，表示无条件开启功能；<blockquote>
<p>“syncookies 启用后就不需要半链接了？那请求的数据会存在哪里？”<br>syncookies = 1 时，半连接队列满后，后续的请求就不会存放到半连接队列了，而是在第二次握手的时候，服务端会计算一个 cookie 值，放入到 SYN +ACK 包中的序列号发给客户端，客户端收到后并回 ack ，服务端就会校验连接是否合法，合法就直接把连接放入到全连接队列。</p>
</blockquote>
</li>
</ul>
<p>那么在应对 SYN 攻击时，只需要设置为 1 即可：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649903024627-51a4b428-522f-425a-bd54-bd83a6572613.png#averageHue=%23282c34&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=zPXWC&amp;name=image.png&amp;originHeight=456&amp;originWidth=1788&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72428&amp;status=done&amp;style=none&amp;taskId=u090acbbe-684f-4b55-8795-b64a1e584ca&amp;title=" alt="image.png"><br>如何调整 SYN 半连接队列大小？<br>要想增大半连接队列，不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大 accept 队列。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</p>
<blockquote>
<p>增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657718803949-b33a166b-fc0e-40d8-ac99-ac693930546c.png#averageHue=%23302d56&amp;clientId=ue3ec5420-203d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=153&amp;id=I6Aej&amp;name=image.png&amp;originHeight=328&amp;originWidth=954&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=132817&amp;status=done&amp;style=none&amp;taskId=u8c764122-0238-405b-b9a2-39064d78496&amp;title=&amp;width=446.00006103515625" alt="image.png"><br>增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1657718803947-ec4f6d69-5c71-424f-9473-c6fa9ae6991f.png#averageHue=%23302d56&amp;clientId=ue3ec5420-203d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=SJ1NN&amp;name=image.png&amp;originHeight=364&amp;originWidth=784&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=109166&amp;status=done&amp;style=none&amp;taskId=u4be575cd-a12c-453b-a81f-e86866b5866&amp;title=&amp;width=480.00006103515625" alt="image.png"></p>
</blockquote>
<h4 id="⑨TCP-快速建立连接"><a href="#⑨TCP-快速建立连接" class="headerlink" title="⑨TCP 快速建立连接"></a>⑨TCP 快速建立连接</h4><p>客户端在向服务端发起 HTTP GET 请求时，一个完整的交互过程，需要 2.5 个 RTT (从客户端到服务器一个往返的时间) 的时延。<br>由于第三次握手是可以携带数据的，这时如果在第三次握手发起 HTTP GET 请求，需要 2 个 RTT 的时延。<br>但是在下一次（不是同个 TCP 连接的下一次）发起 HTTP GET 请求时，经历的 RTT 也是一样，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650422060986-0961373c-a96e-477b-abef-77599db85059.png#averageHue=%23f7f7f5&amp;clientId=uebd955b7-5167-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=430&amp;id=Vcfac&amp;name=image.png&amp;originHeight=1061&amp;originWidth=1046&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=102801&amp;status=done&amp;style=none&amp;taskId=u9957b8f0-9078-45d4-9d2e-3508d2d3314&amp;title=&amp;width=424" alt="image.png"><br>在 Linux 3.7 内核版本中，提供了<strong> TCP Fast Open</strong> 功能，这个功能可以减少 TCP 连接建立的时延。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650422060335-c30ed8fc-5278-41f1-8158-300f0e156b0e.png#averageHue=%23f7f6f4&amp;clientId=uebd955b7-5167-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=531&amp;id=nP0Jw&amp;name=image.png&amp;originHeight=918&amp;originWidth=1052&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103104&amp;status=done&amp;style=none&amp;taskId=u1a439667-a793-4d45-9206-031ac3560e7&amp;title=&amp;width=609" alt="image.png"></p>
<ul>
<li>在第一次建立连接的时候，服务端在第二次握手产生一个 Cookie （已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 Cookie，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个 RTT 的时延；</li>
<li>在下次请求的时候，客户端在 SYN 包带上 Cookie 发给服务端，就提前可以跳过三次握手的过程，因为 Cookie 中维护了一些信息，服务端可以从 Cookie 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；</li>
</ul>
<p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断重复 TCP Fast Open 直至服务器认为 Cookie 无效（通常为过期）</p>
<h3 id="ⅢTCP连接断开"><a href="#ⅢTCP连接断开" class="headerlink" title="ⅢTCP连接断开"></a>ⅢTCP连接断开</h3><h4 id="①TCP-四次挥⼿过程和状态变迁"><a href="#①TCP-四次挥⼿过程和状态变迁" class="headerlink" title="①TCP 四次挥⼿过程和状态变迁"></a>①TCP 四次挥⼿过程和状态变迁</h4><p>记忆：标志位  xx报文 状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649900067215-bf5b240b-0b8f-478d-8ed2-6818ab626c15.png#averageHue=%23f3e6cd&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=405&amp;id=uc555fbfa&amp;originHeight=794&amp;originWidth=753&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u71d555d2-0b9d-4bde-89d4-61f4cfa9f2e&amp;title=&amp;width=384" alt=""></p>
<ul>
<li>客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客 </li>
</ul>
<p>户端进⼊ <strong>FIN_WAIT_1</strong> 状态。 </p>
<ul>
<li>服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ <strong>CLOSED_WAIT</strong> 状态。 </li>
<li><p>客户端收到服务端的 ACK 应答报⽂后，之后进⼊ <strong>FIN_WAIT_2</strong> 状态。 </p>
</li>
<li><p>等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊<strong> LAST_ACK </strong>状态。 </p>
</li>
<li><p>客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ <strong>TIME_WAIT</strong> 状态 </p>
</li>
<li><p>服务器收到了 ACK 应答报⽂后，就进⼊了 <strong>CLOSED </strong>状态，⾄此服务端已经完成连接的关闭。 </p>
</li>
<li>客户端在经过 2MSL ⼀段时间后，⾃动进⼊ <strong>CLOSED </strong>状态，⾄此客户端也完成连接的关闭。</li>
</ul>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h4 id="②为什么挥⼿需要四次？"><a href="#②为什么挥⼿需要四次？" class="headerlink" title="②为什么挥⼿需要四次？"></a>②为什么挥⼿需要四次？</h4><ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>所以服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送(三次握手syn和ack是一起发送的)，从而比三次握手导致多了一次。</p>
<h4 id="③握手丢失的情况"><a href="#③握手丢失的情况" class="headerlink" title="③握手丢失的情况"></a>③握手丢失的情况</h4><h5 id="a-第一次挥手丢失了，会发生什么？"><a href="#a-第一次挥手丢失了，会发生什么？" class="headerlink" title="a.第一次挥手丢失了，会发生什么？"></a>a.第一次挥手丢失了，会发生什么？</h5><ul>
<li>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。</li>
<li>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN_WAIT2状态。</li>
<li>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会<strong>触发超时重传</strong>机制，重传 FIN 报文，重发次数由<strong> tcp_orphan_retries </strong>参数控制。</li>
<li><p>当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p>
<h5 id="b-第二次挥手丢失了，会发生什么？"><a href="#b-第二次挥手丢失了，会发生什么？" class="headerlink" title="b.第二次挥手丢失了，会发生什么？"></a>b.第二次挥手丢失了，会发生什么？</h5></li>
<li><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。</p>
</li>
<li>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</li>
</ul>
<p>下述讲解重点看：<br>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。<br>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN_WAIT2 状态不可以持续太久，而 <strong>tcp_fin_timeout</strong> 控制了这个状态下连接的持续时长，默认值是 60 秒。<br>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。<br>但是注意，如果主动关闭方使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（tcp_fin_timeout 无法控制 shutdown 关闭的连接）。</p>
<h5 id="c-第三次挥手丢失了，会发生什么？"><a href="#c-第三次挥手丢失了，会发生什么？" class="headerlink" title="c.第三次挥手丢失了，会发生什么？"></a>c.第三次挥手丢失了，会发生什么？</h5><blockquote>
<ul>
<li>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</li>
<li>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</li>
<li>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</li>
</ul>
</blockquote>
<ul>
<li><p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由<strong> tcp_orphan_retries</strong> 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<h5 id="d-第四次挥手丢失了，会发生什么？"><a href="#d-第四次挥手丢失了，会发生什么？" class="headerlink" title="d.第四次挥手丢失了，会发生什么？"></a>d.第四次挥手丢失了，会发生什么？</h5></li>
<li><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。</p>
</li>
<li>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</li>
<li>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</li>
</ul>
<p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p>
<h4 id="✊④timewait相关面试题"><a href="#✊④timewait相关面试题" class="headerlink" title="✊④timewait相关面试题"></a>✊④timewait相关面试题</h4><h5 id="a-为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#a-为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="a:为什么 TIME_WAIT 等待的时间是 2MSL？"></a>a:为什么 TIME_WAIT 等待的时间是 2MSL？</h5><ul>
<li><p>MSL 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<blockquote>
<ul>
<li>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</li>
<li><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<ul>
<li>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</li>
</ul>
</li>
</ul>
<p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<hr>
<p>2MSL 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。<br>在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。<br>其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT </span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure><br>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<h5 id="b-为什么需要-TIME-WAIT-状态？（结合5-gt-5-2tcp优化-gt-timewait）"><a href="#b-为什么需要-TIME-WAIT-状态？（结合5-gt-5-2tcp优化-gt-timewait）" class="headerlink" title="b:为什么需要 TIME_WAIT 状态？（结合5-&gt;5.2tcp优化-&gt;timewait）"></a>b:为什么需要 TIME_WAIT 状态？（结合5-&gt;5.2tcp优化-&gt;timewait）</h5><p>主动发起关闭连接的一方，才会有 TIME-WAIT 状态。<br><em><strong>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></em><br>补充&gt; 为了能更好的理解这个原因，我们先来了解序列号（SEQ）和初始序列号（ISN）。</p>
<blockquote>
<ul>
<li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li>
<li><strong>初始序列号</strong>，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</li>
</ul>
<p>给大家抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659077930847-6cc6f94e-459a-493d-b6d8-6ec1a9c28c45.png#clientId=ub3ce7cf8-e5f6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=k352L&amp;name=image.png&amp;originHeight=545&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=888038&amp;status=done&amp;style=none&amp;taskId=u7b46737c-58e0-493e-92be-598740a6701&amp;title=" alt="image.png"><br>通过前面我们知道，<strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p>
</blockquote>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659077930704-f1051c58-1585-4bd9-b84f-d1eeba24c536.png#clientId=ub3ce7cf8-e5f6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=GKray&amp;name=image.png&amp;originHeight=1295&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=731276&amp;status=done&amp;style=none&amp;taskId=uc58e57f4-0d83-4ea7-9f21-e1a2bc6d966&amp;title=" alt="image.png"><br>如上图：</p>
<ul>
<li>服务端在关闭连接之前发送的 SEQ = 301 报文，被网络延迟了。</li>
<li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 SEQ = 301 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li>
</ul>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME<em>WAIT 状态，状态会持续 2MSL 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong>
</em><strong>原因二：保证「被动关闭连接」的一方，能被正确的关闭</strong>_</p>
<blockquote>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：<br><em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</em></p>
</blockquote>
<p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<ul>
<li>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</li>
<li>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSED 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</li>
<li>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</li>
<li>为了防止这种情况出现，客户端必须等待足够长的时间确保对端收到 ACK，如果对端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659077930486-5b9d15ae-7acd-44f1-9cf9-655caafab328.png#averageHue=%23f4e2c6&amp;clientId=ub3ce7cf8-e5f6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=437&amp;id=u6008fd20&amp;name=image.png&amp;originHeight=903&amp;originWidth=903&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=449588&amp;status=done&amp;style=none&amp;taskId=ue1de13d9-2e54-4311-8016-06441e80967&amp;title=&amp;width=437.00006103515625" alt="image.png"><br>但是你可能会说重新发送的 ACK 还是有可能丢失啊，没错，但 TCP 已经等待了那么长的时间了，已经算仁至义尽了。</p>
<h5 id="c-👌TIME-WAIT-过多有什么危害？"><a href="#c-👌TIME-WAIT-过多有什么危害？" class="headerlink" title="c:👌TIME_WAIT 过多有什么危害？"></a>c:👌TIME_WAIT 过多有什么危害？</h5><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是内存资源占用；</li>
<li>第二是对端口资源的占用，一个 TCP 连接至少消耗「发起连接方」的一个本地端口；</li>
</ul>
<p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的。<br><strong>如果「发起连接方」的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p>
<blockquote>
<p>客户端（发起连接方）受端口资源限制：</p>
<ul>
<li>客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就 65536 个，被占满就会导致无法创建新的连接。</li>
</ul>
<p>服务端（被动连接方）受系统资源限制：</p>
<ul>
<li>由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，因为服务端只监听一个端口，不会因为 TCP 连接过多而导致端口资源受限。但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</li>
</ul>
</blockquote>
<h5 id="d-👌如何优化-TIME-WAIT？-了解"><a href="#d-👌如何优化-TIME-WAIT？-了解" class="headerlink" title="d:👌如何优化 TIME_WAIT？(了解)"></a>d:👌如何优化 TIME_WAIT？(了解)</h5><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li><p>程序中使用 SO<em>LINGER ，应用强制使用 RST 关闭。<br>补充</em>方式一：net.ipv4.tcp<em>tw_reuse 和 tcp_timestamps</em><br>如下的 Linux 内核参数开启后，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。<br>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong><br>net.ipv4.tcp<em>tw_reuse = 1<br>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即<br>net.ipv4.tcp_timestamps=1（默认即为 1）<br>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。<br>由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。
</em>方式二：net.ipv4.tcp<em>max_tw_buckets</em><br>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。<br><em>方式三：程序中使用 SO_LINGER</em><br>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651542236229-b0dd3e0e-c54e-4c20-8095-19bf017560d2.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=141&amp;id=rt9oV&amp;name=image.png&amp;originHeight=176&amp;originWidth=946&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11475&amp;status=done&amp;style=none&amp;taskId=u4ad53f5d-e6a5-41df-b8ee-9699a475687&amp;title=&amp;width=756.8" alt="image.png"><br>如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。<br>但这为跨越TIME_WAIT状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。<br>前面介绍的方法都是试图越过 TIME_WAIT状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。<br>《UNIX网络编程》一书中却说道：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它</strong>。<br><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
<h5 id="e-tcp-tw-reuse-为什么默认是关闭的？"><a href="#e-tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="e:tcp_tw_reuse 为什么默认是关闭的？"></a>e:tcp_tw_reuse 为什么默认是关闭的？</h5><h6 id="tcp-tw-reuse-是什么？"><a href="#tcp-tw-reuse-是什么？" class="headerlink" title="tcp_tw_reuse 是什么？"></a>tcp_tw_reuse 是什么？</h6><p>在 Linux 操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：<br>net.ipv4.ip_local_port_range<br>那么，如果如果主动关闭连接方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。<br>不过，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：</p>
</li>
<li><p>net.ipv4.<strong>tcp_tw_reuse</strong>，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，<strong>内核会随机找一个 TIME_WAIT 状态超过 1 秒的连接给新的连接复用</strong>，所以该选项只适用于连接发起方。</p>
</li>
<li>net.ipv4.<strong>tcp_tw_recycle</strong>，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收，该参数在 <strong>NAT 的网络下是不安全的！</strong>详细见这篇文章介绍：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247502230&amp;idx=1&amp;sn=5fb86772de17ab650088944d4d0adf62&amp;scene=21#wechat_redirect">字节面试：SYN 报文什么时候情况下会被丢弃？(opens new window)</a></li>
</ul>
<p>要使得上面这两个参数生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1）。<br>开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>，我们先来介绍这个功能。<br>序列号是一个 32 位的无符号整型，上限值是 4GB，超过 4GB 后就需要将序列号回绕进行重用。这在以前网速慢的年代不会造成什么问题，但在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。<br>为了解决这个问题，就需要有 TCP 时间戳。<br>试看下面的示例，假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650783691056-bcef470a-d971-4738-9636-4004eba765e4.png#averageHue=%23e7e7e7&amp;clientId=u83577f3d-fd36-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=xYBBr&amp;name=image.png&amp;originHeight=298&amp;originWidth=956&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=99998&amp;status=done&amp;style=none&amp;taskId=u11ab82d1-91cd-4317-826b-ed56efa7806&amp;title=" alt="image.png"><br>32 位的序列号在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。<br>使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法（PAWS）会将其丢弃。<br>防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
<h6 id="为什么-tcp-tw-reuse-默认是关闭的？"><a href="#为什么-tcp-tw-reuse-默认是关闭的？" class="headerlink" title="为什么 tcp_tw_reuse 默认是关闭的？"></a>为什么 tcp_tw_reuse 默认是关闭的？</h6><p>通过前面这么多铺垫，终于可以说这个问题了。<br>开启 tcp_tw_reuse 会有什么风险呢？我觉得会有 2 个问题。<br><strong>第一个问题</strong><br>我们知道开启 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，意味着可以用时间戳的方式有效的判断回绕序列号的历史报文。<br>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。<br>下面 tcp_validate_incoming 函数就是验证接收到的 TCP 报文是否合格的函数，其中第一步就会进行 PAWS 检查，由 tcp_paws_discard 函数负责。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_validate_incoming</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th, <span class="type">int</span> syn_inerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RFC1323: H1. Apply PAWS check first. */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_fast_parse_options(sock_net(sk), skb, th, tp) &amp;&amp;</span><br><span class="line">        tp-&gt;rx_opt.saw_tstamp &amp;&amp;</span><br><span class="line">        tcp_paws_discard(sk, skb)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Reset is accepted even if it did not pass PAWS. */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>当 tcp_paws_discard 返回 true，就代表报文是一个历史报文，于是就要丢弃这个报文。但是在丢掉这个报文的时候，会先判断是不是 RST 报文，如果不是 RST 报文，才会将报文丢掉。也就是说，即使 RST 报文是一个历史报文，并不会被丢弃。<br>假设有这样的场景，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650783691851-f8d5417e-49a8-457e-820f-ff99b27781cb.png#averageHue=%23e8d280&amp;clientId=u83577f3d-fd36-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=715&amp;id=tPcu9&amp;name=image.png&amp;originHeight=1268&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=695117&amp;status=done&amp;style=none&amp;taskId=u15d819ad-8abe-493f-9024-abc15ea4bf4&amp;title=&amp;width=609" alt="image.png"></p>
<ul>
<li>客户端向一个还没有被服务端监听的端口发起了 HTTP 请求，接着服务端就会回 RST 报文给对方，很可惜的是 <strong>RST 报文被网络阻塞了</strong>。</li>
<li>由于客户端迟迟没有收到 TCP 第二次握手，于是重发了 SYN 包，与此同时服务端已经开启了服务，监听了对应的端口。于是接下来，客户端和服务端就进行了 TCP 三次握手、数据传输（HTTP应答-响应）、四次挥手。</li>
<li>因为<strong>客户端开启了 tcp_tw_reuse，于是快速复用 TIME_WAIT 状态的端口，又与服务端建立了一个与刚才相同的四元组的连接</strong>。</li>
<li>接着，<strong>前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开了</strong>。</li>
</ul>
<p>上面这个场景就是开启 tcp<em>tw_reuse 风险，<strong>因为快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序列号的 RST 报文断开了，而如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现下一个新的连接</strong>。<br>可能大家会有这样的疑问，为什么 PAWS 检查要放过过期的 RST 报文。我翻了 RFC 1323 ，里面有一句提到：<br>_It is recommended that RST segments NOT carry timestamps, and that RST segments be acceptable regardless of their timestamp. Old duplicate RST segments should be exceedingly unlikely, and their cleanup function should take precedence over timestamps.</em><br>大概的意思：<em>建议 RST 段不携带时间戳，并且无论其时间戳如何，RST 段都是可接受的。老的重复的 RST 段应该是极不可能的，并且它们的清除功能应优先于时间戳。</em><br>RFC 1323 提到说收历史的 RST 报文是极不可能，之所以有这样的想法是因为 TIME_WAIT 状态持续的 2MSL 时间，足以让连接中的报文在网络中自然消失，所以认为按正常操作来说是不会发生的，因此认为清除连接优先于时间戳。<br>而我前面提到的案例，是因为开启了 tcp_tw_reuse 状态，跳过了 TIME_WAIT 状态，才发生的事情。<br>有同学会说，都经过一个 HTTP 请求了，延迟的 RST 报文竟然还会存活？<br>一个 HTTP 请求其实很快的，比如我下面这个抓包，只需要 0.2 秒就完成了，远小于 MSL，所以延迟的 RST 报文存活是有可能的。</p>
<p><strong>第二个问题</strong><br>开启 tcp_tw_reuse 来快速复用 TIME_WAIT 状态的连接，如果第四次挥手的 ACK 报文丢失了，有可能会导致被动关闭连接的一方不能被正常的关闭，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650783693946-a7e4db2b-4a58-4010-91e0-fbc487b0498c.png#averageHue=%23f5e9d3&amp;clientId=u83577f3d-fd36-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=458&amp;id=gb3Bx&amp;name=image.png&amp;originHeight=865&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=478765&amp;status=done&amp;style=none&amp;taskId=u9fdf4fed-b596-4611-923d-57c1d1faa47&amp;title=&amp;width=572.0000610351562" alt="image.png"></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：</p>
<ul>
<li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li>
<li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li>
</ul>
<p>虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p>
<h4 id="⑤如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#⑤如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="⑤如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>⑤如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：<br>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。<br>补充在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651542221536-2e5fb538-0c41-4cf4-a2dd-242a1d9bf034.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=111&amp;id=qgKhC&amp;name=image.png&amp;originHeight=139&amp;originWidth=931&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7730&amp;status=done&amp;style=none&amp;taskId=uddd4a79a-e471-473f-b4fb-92ae301f7ff&amp;title=&amp;width=744.8" alt="image.png"></p>
<ul>
<li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651542101709-cf167e94-e637-4f7a-a1bb-18f4119cd38c.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=E4QIn&amp;originHeight=303&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8a57abe0-690b-4bf2-9128-7fbeb09b999&amp;title=&amp;width=575" alt=""><br>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。<br>TCP 保活的这个机制检测的时间是有点长，我们可以自己在应用层实现一个心跳机制。<br>比如，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1651542101839-0479cbae-cac5-4621-a483-7201b7098db6.png#clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=362&amp;id=xzKk6&amp;name=image.png&amp;originHeight=947&amp;originWidth=708&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77981&amp;status=done&amp;style=none&amp;taskId=ub4ba988b-c399-4030-86b2-9952e650f25&amp;title=&amp;width=271" alt="image.png"><br>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<ul>
<li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li>
<li><p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
<h4 id="⑥如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#⑥如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="⑥如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>⑥如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</p>
<h3 id="ⅣSocket通信"><a href="#ⅣSocket通信" class="headerlink" title="ⅣSocket通信"></a>ⅣSocket通信</h3><p>实现跨主机的通信</p>
<h4 id="①针对-TCP-应该如何-Socket-编程？"><a href="#①针对-TCP-应该如何-Socket-编程？" class="headerlink" title="①针对 TCP 应该如何 Socket 编程？"></a>①针对 TCP 应该如何 Socket 编程？</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649900600934-cc696bcb-d2f9-4eb3-87b8-eb635bca2f90.png#averageHue=%23fbfaf1&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=490&amp;id=ub71f3599&amp;originHeight=1007&amp;originWidth=1188&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufbd13c0d-6b73-4cfc-91e3-cc27cd55405&amp;title=&amp;width=578" alt=""></p>
</li>
<li><p>服务端和客户端初始化 socket，得到文件描述符；</p>
</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li><p>服务端调用 accept，等待客户端连接；</p>
</li>
<li><p>客户端调用 connect，向服务器端的地址和端口发起连接请求；</p>
</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。<br>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。<br>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h4 id="👌②listen-时候参数-backlog-的意义？"><a href="#👌②listen-时候参数-backlog-的意义？" class="headerlink" title="👌②listen 时候参数 backlog 的意义？"></a>👌②listen 时候参数 backlog 的意义？</h4><p>Linux内核中会维护两个队列：</p>
<ul>
<li>半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li>
<li>全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649900600908-26eeca5d-cd55-4680-971c-3b17182080b0.png#averageHue=%23f2f0ea&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=518&amp;id=u1b0a2c17&amp;originHeight=842&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u30b55719-d2fe-451b-b725-e9b94ed2fbc&amp;title=&amp;width=555" alt=""><br>补充int listen (int socketfd, int backlog) </p>
<ul>
<li>参数一 socketfd 为 socketfd 文件描述符</li>
<li>参数二 backlog，这参数在历史版本有一定的变化</li>
</ul>
<p>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。<br>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong><br><strong>但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 = min(backlog, somaxconn)。</strong><br>想详细了解 TCP 半连接队列和全连接队列，可以看这篇：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2qN0ulyBtO2I67NB_RnJbg">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？(opens new window)</a></p>
<h4 id="③accept-发生在三次握手的哪一步？"><a href="#③accept-发生在三次握手的哪一步？" class="headerlink" title="③accept 发生在三次握手的哪一步？"></a>③accept 发生在三次握手的哪一步？</h4><p>我们先看看客户端连接服务端时，发送了什么？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649900608877-b38c1723-ef5b-4a10-9a70-3349ed78dd35.png#averageHue=%23f5eccb&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=406&amp;id=u96a06730&amp;name=image.png&amp;originHeight=722&amp;originWidth=944&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=438841&amp;status=done&amp;style=none&amp;taskId=u21444a69-198e-4b1f-81d6-6a2f9de0216&amp;title=&amp;width=531" alt="image.png"></p>
<blockquote>
<ul>
<li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；</li>
<li>服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端进入 SYN_RCVD 状态；</li>
<li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 server_isn+1；</li>
<li>应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li>
</ul>
</blockquote>
<p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p>
<h4 id="④客户端调用-close-了，连接是断开的流程是什么？"><a href="#④客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="④客户端调用 close 了，连接是断开的流程是什么？"></a>④客户端调用 close 了，连接是断开的流程是什么？</h4><p>我们看看客户端主动调用了 close，会发生什么？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649900600837-ab98ec6a-dc20-4b9e-8b4e-69034efe56d5.png#averageHue=%23f2e6cd&amp;clientId=u25e7156c-5b63-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=446&amp;id=uec0d9f2b&amp;originHeight=794&amp;originWidth=753&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8a41964b-f1ad-489e-8398-8bc29a17d0b&amp;title=&amp;width=423" alt=""></p>
<ul>
<li>客户端调用 close，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li>
<li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包。这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li>
<li>接着，当处理完数据后，自然就会读到 EOF，于是也调用 close 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；</li>
<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li>
<li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li>
<li>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；<h2 id="二、TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#二、TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="二、TCP 重传、滑动窗口、流量控制、拥塞控制"></a>二、TCP 重传、滑动窗口、流量控制、拥塞控制</h2></li>
</ul>
<p>相信大家都知道 TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？<br>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。<br>那么，TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。<br>今天，将重点介绍 TCP 的<strong>重传机制、滑动窗口、流量控制、拥塞控制。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958505784-76dcb14b-6583-498a-bc7f-3ae414103110.png#averageHue=%23f3f4f6&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=346&amp;id=ub3594d82&amp;name=image.png&amp;originHeight=741&amp;originWidth=1029&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=238018&amp;status=done&amp;style=none&amp;taskId=u51a181af-280d-465a-932b-680fc14cab2&amp;title=&amp;width=480" alt="image.png"></p>
<hr>
<h3 id="Ⅰ重传机制"><a href="#Ⅰ重传机制" class="headerlink" title="Ⅰ重传机制"></a>Ⅰ重传机制</h3><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。<br>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958505183-860ca435-e98e-46a7-a2b2-7bfbf5cd543c.png#averageHue=%23f7f7ed&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=456&amp;id=u090cadd7&amp;name=image.png&amp;originHeight=677&amp;originWidth=422&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=165059&amp;status=done&amp;style=none&amp;taskId=u4805b706-6f26-4919-a2ab-0b0e028fe3d&amp;title=&amp;width=284" alt="image.png"><br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？<br>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。<br>接下来说说常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li><p>D-SACK</p>
<h4 id="①超时重传"><a href="#①超时重传" class="headerlink" title="①超时重传"></a>①超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。<br>TCP 会在以下两种情况发生超时重传：</p>
</li>
<li><p>数据包丢失</p>
</li>
<li>确认应答丢失</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958505710-2f1cb2cc-d0e9-4892-81a6-19e9b90e764c.png#averageHue=%23fbf9f7&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=414&amp;id=u7440e3a5&amp;name=image.png&amp;originHeight=846&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=317537&amp;status=done&amp;style=none&amp;taskId=u7fae3301-1586-4761-9064-a44e5a99b11&amp;title=&amp;width=534" alt="image.png"><br>超时时间应该设置为多少呢？<br>我们先来了解一下什么是 RTT（Round-Trip Time 往返时延），从下图我们就可以知道：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958505202-3d26ab91-3941-46e5-927c-828dd9bb4690.png#averageHue=%23f9f7f3&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=362&amp;id=u645fd671&amp;name=image.png&amp;originHeight=662&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183750&amp;status=done&amp;style=none&amp;taskId=u375d16e4-b31c-409e-924f-5fe44b76592&amp;title=&amp;width=428" alt="image.png"><br>RTT 指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。<br>超时重传时间是以 <strong>RTO </strong>（Retransmission Timeout 超时重传时间）表示。<br>假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958505825-e184a20c-1d15-4460-a374-f08951167249.png#averageHue=%23faf4f2&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5e8dc257&amp;name=image.png&amp;originHeight=846&amp;originWidth=1412&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=360122&amp;status=done&amp;style=none&amp;taskId=u6fef6d01-1ff1-43ca-b007-e921c80f746&amp;title=" alt="image.png"><br>上图中有两种超时时间不同的情况：</p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。<br>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958508594-bcc15069-8e97-40aa-b8e1-160583c744ee.png#averageHue=%23faf9f5&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=362&amp;id=u51b221b2&amp;name=image.png&amp;originHeight=482&amp;originWidth=617&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104854&amp;status=done&amp;style=none&amp;taskId=u7909bb0c-4ef8-44a1-a6c0-fc8e582aa98&amp;title=&amp;width=464" alt="image.png"><br>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？<br>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p>
<h4 id="②-快速重传"><a href="#②-快速重传" class="headerlink" title="② 快速重传"></a>② 快速重传</h4><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<blockquote>
<p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958508994-c7ca1595-a06a-407e-8e56-8cec624ad20a.png#averageHue=%23f8f6f3&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=408&amp;id=uf44dbbb5&amp;name=image.png&amp;originHeight=602&amp;originWidth=647&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=132601&amp;status=done&amp;style=none&amp;taskId=ued72dd2c-6f67-4c0f-9a2d-08190b3690c&amp;title=&amp;width=439" alt="image.png"><br>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
</blockquote>
<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。<br>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。<br>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。<br>根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。<br>为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。</p>
<h4 id="③-SACK-方法"><a href="#③-SACK-方法" class="headerlink" title="③ SACK 方法"></a>③ SACK 方法</h4><p>还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。<br>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958509375-6c601a7e-c94c-48dc-97ee-f75d494b4fc1.png#averageHue=%23fbfafa&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=365&amp;id=udf11bef6&amp;name=image.png&amp;originHeight=827&amp;originWidth=1413&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=376244&amp;status=done&amp;style=none&amp;taskId=u17d42399-1a2c-430f-acf3-88ad5de99a2&amp;title=&amp;width=623" alt="image.png"><br>如果要支持 SACK，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="④-Duplicate-SACK"><a href="#④-Duplicate-SACK" class="headerlink" title="④ Duplicate SACK"></a>④ Duplicate SACK</h4><p>Duplicate SACK 又称 D-SACK，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<blockquote>
<p>下面举例两个栗子，来说明 D-SACK 的作用。<br><em>栗子一号：ACK 丢包</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659096945517-922a447c-3abb-43c2-83c4-26d3de3171d0.png#averageHue=%23fbf7f6&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1a0f4d96&amp;name=image.png&amp;originHeight=602&amp;originWidth=887&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=210448&amp;status=done&amp;style=none&amp;taskId=u2feecbc2-4152-4e33-802a-d297cf3cdc2&amp;title=" alt="image.png"></p>
<ul>
<li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li>
<li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。</li>
<li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li>
</ul>
<p><em>栗子二号：网络延时</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659096945722-daa81022-d0c6-4cce-88b1-96375a8237c0.png#averageHue=%23faf7f4&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u8d947282&amp;name=image.png&amp;originHeight=1082&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=443449&amp;status=done&amp;style=none&amp;taskId=u791fa3ac-bdc7-4cf1-be72-6c9674176ff&amp;title=" alt="image.png"></p>
<ul>
<li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li>
<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li>
<li><strong>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li>
</ul>
</blockquote>
<p>可见，D-SACK 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>
<hr>
<h3 id="Ⅱ滑动窗口"><a href="#Ⅱ滑动窗口" class="headerlink" title="Ⅱ滑动窗口"></a>Ⅱ滑动窗口</h3><p>滑动窗口解决了什么问题</p>
<p>大小是从哪里获取的</p>
<ul>
<li><p>TCP 利用滑动窗口实现<strong>流量控制</strong>。<strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收</strong>。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于接收窗口。接收方发送的<strong>确认报文</strong>中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p>
</li>
<li><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p>
</li>
</ul>
<p>接收窗口和发送窗口的大小是相等的吗？<br>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。<br>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。<br>引入窗口概念的原因<br>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。<br>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。<br>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。<br>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。<br>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。<br>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668142095187-9fe68662-8e62-4954-854b-056ca63c2a59.png#averageHue=%23f9f5f4&amp;clientId=u5c8b8f72-f3c7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=uffe6e793&amp;name=image.png&amp;originHeight=602&amp;originWidth=857&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=227815&amp;status=done&amp;style=none&amp;taskId=udf358f0c-38c2-4714-9edf-76ade68aa66&amp;title=&amp;width=317.2857360839844" alt="image.png"><br>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。<br>窗口大小由哪一方决定？<br>TCP 头里有一个字段叫 Window，也就是窗口大小。<br><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong><br>所以，通常窗口的大小是由接收方的窗口大小来决定的。<br>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。<br>发送方的滑动窗口<br>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668142095249-3be72842-7b8a-4dae-aded-98d252891fe9.png#averageHue=%23c8dcc6&amp;clientId=u5c8b8f72-f3c7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1859f6ac&amp;name=image.png&amp;originHeight=483&amp;originWidth=1428&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=313054&amp;status=done&amp;style=none&amp;taskId=u59587a86-2638-4fae-bca1-bd025c8e02f&amp;title=" alt="image.png"></p>
<ul>
<li><h1 id="1-是已发送并收到-ACK确认的数据：1-31-字节"><a href="#1-是已发送并收到-ACK确认的数据：1-31-字节" class="headerlink" title="1 是已发送并收到 ACK确认的数据：1~31 字节"></a>1 是已发送并收到 ACK确认的数据：1~31 字节</h1></li>
<li><h1 id="2-是已发送但未收到-ACK确认的数据：32-45-字节"><a href="#2-是已发送但未收到-ACK确认的数据：32-45-字节" class="headerlink" title="2 是已发送但未收到 ACK确认的数据：32~45 字节"></a>2 是已发送但未收到 ACK确认的数据：32~45 字节</h1></li>
<li><h1 id="3-是未发送但总大小在接收方处理范围内（接收方还有空间）：46-51字节"><a href="#3-是未发送但总大小在接收方处理范围内（接收方还有空间）：46-51字节" class="headerlink" title="3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节"></a>3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</h1></li>
<li><h1 id="4-是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后"><a href="#4-是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后" class="headerlink" title="4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后"></a>4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</h1></li>
</ul>
<p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668142095197-48a53cb7-033b-47c3-83b8-a3d5ee479c0d.png#averageHue=%23c8dbc5&amp;clientId=u5c8b8f72-f3c7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=163&amp;id=u30393f59&amp;name=image.png&amp;originHeight=393&amp;originWidth=1428&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=231266&amp;status=done&amp;style=none&amp;taskId=u7dcaed62-d90e-4bb7-902e-a9468eaab9a&amp;title=&amp;width=593.2857666015625" alt="image.png"><br>在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668142095271-d6216631-c9d6-46ae-af3d-fc6daba00e74.png#averageHue=%23cbdec8&amp;clientId=u5c8b8f72-f3c7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=140&amp;id=u887fffae&amp;name=image.png&amp;originHeight=408&amp;originWidth=1608&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=348505&amp;status=done&amp;style=none&amp;taskId=u3fa259ee-0594-4d4e-9b7d-64119776507&amp;title=&amp;width=553.2857666015625" alt="image.png"><br>程序是如何表示发送方的四个部分的呢？<br>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668142097278-16ef5855-4d51-46e6-ae85-db9f70084ad1.png#averageHue=%23ccdeca&amp;clientId=u5c8b8f72-f3c7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=184&amp;id=u01f18b16&amp;name=image.png&amp;originHeight=513&amp;originWidth=1428&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=371816&amp;status=done&amp;style=none&amp;taskId=u27aab378-ae75-4a3e-b9a0-2afb34dfd3d&amp;title=&amp;width=512.2857666015625" alt="image.png"></p>
<ul>
<li>SND.WND：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li>SND.UNA（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li>SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<p>那么可用窗口大小的计算就可以是：<br><strong>可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</strong><br>接收方的滑动窗口<br>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p>
<ul>
<li><h1 id="1-2-是已成功接收并确认的数据（等待应用进程读取）；"><a href="#1-2-是已成功接收并确认的数据（等待应用进程读取）；" class="headerlink" title="1 + #2 是已成功接收并确认的数据（等待应用进程读取）；"></a>1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</h1></li>
<li><h1 id="3-是未收到数据但可以接收的数据；"><a href="#3-是未收到数据但可以接收的数据；" class="headerlink" title="3 是未收到数据但可以接收的数据；"></a>3 是未收到数据但可以接收的数据；</h1></li>
<li><h1 id="4-未收到数据并不可以接收的数据；"><a href="#4-未收到数据并不可以接收的数据；" class="headerlink" title="4 未收到数据并不可以接收的数据；"></a>4 未收到数据并不可以接收的数据；</h1></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1668142096958-2033e646-8359-4e3d-8736-60ca00b48216.png#averageHue=%23d1e1ce&amp;clientId=u5c8b8f72-f3c7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2975fadb&amp;name=image.png&amp;originHeight=498&amp;originWidth=1429&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=312942&amp;status=done&amp;style=none&amp;taskId=u2670f4eb-2050-44b5-8f91-6204be83c5b&amp;title=" alt="image.png"><br>其中三个接收部分，使用两个指针进行划分:</p>
<ul>
<li>RCV.WND：表示接收窗口的大小，它会通告给发送方。</li>
<li>RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<p>接收窗口和发送窗口的大小是相等的吗？<br>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。<br>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<hr>
<h3 id="Ⅲ流量控制"><a href="#Ⅲ流量控制" class="headerlink" title="Ⅲ流量控制"></a>Ⅲ流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。<br>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。<br>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong><br>下面举个栗子，为了简单起见，假设以下场景：</p>
<ul>
<li>客户端是接收方，服务端是发送方</li>
<li>假设接收窗口和发送窗口相同，都为 200</li>
<li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659097970274-af4266ac-7783-4ad9-8dca-5b553522b3b0.png#averageHue=%23f5f2f2&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=950&amp;id=uf47cf8e7&amp;name=image.png&amp;originHeight=2417&amp;originWidth=1499&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=947215&amp;status=done&amp;style=none&amp;taskId=u3a213985-d6d9-4b73-9ecb-32350a56636&amp;title=&amp;width=589.2857666015625" alt="image.png"><br>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。</li>
<li>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 Usable 减少为 120 字节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，<strong>这意味着下次发送数据的时候，序列号是 321。</strong></li>
<li>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，RCV.NXT 也就指向 321，<strong>这意味着客户端期望的下一个报文的序列号是 321</strong>，接着发送确认报文给服务端。</li>
<li>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法再继续发送数据。</li>
<li>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，RCV.NXT 也就指向 441，接着发送确认报文给服务端。</li>
<li>服务端收到对 80 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 321，于是可用窗口 Usable 增大到 80。</li>
<li>服务端收到对 120 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 441，于是可用窗口 Usable 增大到 200。</li>
<li>服务端可以继续发送了，于是发送了 160 字节的数据后，SND.NXT 指向 601，于是可用窗口 Usable 减少到 40。</li>
<li>客户端收到 160 字节后，接收窗口往右移动了 160 字节，RCV.NXT 也就是指向了 601，接着发送确认报文给服务端。</li>
<li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 SND.UNA 指针偏移了 160 后指向 601，可用窗口 Usable 也就增大至了 200。<h4 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h4>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。<br>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。<br>那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？<blockquote>
<p><em>我们先来看看第一个例子。</em><br>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化。<br>考虑以下场景：</p>
<ul>
<li>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为 360；</li>
<li>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659097970237-0a353490-f2f9-423c-a62e-961ff6f11ee9.png#averageHue=%23f3f2f2&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u437bc6d3&amp;name=image.png&amp;originHeight=2507&amp;originWidth=1614&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=957116&amp;status=done&amp;style=none&amp;taskId=u040f5eab-cb04-45b2-83ff-e2e16b9b60e&amp;title=" alt="image.png"><br>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</li>
<li>服务端收到 140 字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）</strong>，最后发送确认信息时，将窗口大小通告给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 260。</li>
<li>客户端发送 180 字节数据，此时可用窗口减少到 80。</li>
<li>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</li>
<li>客户端发送 80 字节数据后，可用窗口耗尽。</li>
<li>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0</strong>，并在发送确认信息时，通过窗口大小给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 0。</li>
</ol>
<p>可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变，这个内容后面会说，这里先简单提一下。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><em>我们先来看看第二个例子。</em><br>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659097970239-9b9f03d1-77fb-4216-9632-f0b94ec57de1.png#averageHue=%23f5f3f3&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4f8ac4a6&amp;name=image.png&amp;originHeight=1772&amp;originWidth=1757&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=773903&amp;status=done&amp;style=none&amp;taskId=u117053ba-e99b-4022-83fe-a7ea15d5b99&amp;title=" alt="image.png"><br>说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节的数据，于是可用窗口减少到了 220。</li>
<li><strong>服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100</strong>，最后发送确认信息时，通告窗口大小给对方。</li>
<li>此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。</li>
<li>服务端收到了 180 字节数据时，<strong>发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。</strong></li>
<li>客户端收到第 2 步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。</li>
</ol>
<p>所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。<br><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p>
</blockquote>
<h4 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h4><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。<br><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong><br>窗口关闭潜在的危险</p>
<ul>
<li>接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。</li>
<li>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</li>
<li>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659097969697-00f422a9-ad04-47a2-a27b-8992f05fc9d6.png#averageHue=%23f6ead1&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=388&amp;id=u9277062c&amp;name=image.png&amp;originHeight=827&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=359182&amp;status=done&amp;style=none&amp;taskId=u67f4dd43-cfc7-4e58-9cd8-88ec53875bf&amp;title=&amp;width=518.0000610351562" alt="image.png"></p>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？<br>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong><br>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659097969750-e5ae800d-3960-4d9b-ad0b-8cfca96a6bf6.png#averageHue=%23faf7f6&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=457&amp;id=u367b1000&amp;name=image.png&amp;originHeight=887&amp;originWidth=1184&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=349072&amp;status=done&amp;style=none&amp;taskId=ud8cfeaa3-5775-4560-88de-678e439e05b&amp;title=&amp;width=610.0000610351562" alt="image.png"></p>
<h4 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h4><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。<br>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。<br>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p>
<blockquote>
<p>就好像一个可以承载 50 人的大巴车，每次来了一两个人，就直接发车。除非家里有矿的大巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，大巴司机等乘客数量超过了 25 个，才认定可以发车。</p>
</blockquote>
<p>现举个糊涂窗口综合症的栗子，考虑以下场景：<br>接收方的窗口大小是 360 字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p>
<ul>
<li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</li>
<li>在下一个发送方的 TCP 段到达之前，应用程序还从缓冲区中读取了 40 个额外的字节；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659097972722-5ca980c6-7890-4d04-b487-b69fd78519ca.png#averageHue=%23f6f5f5&amp;clientId=u28900f28-0a01-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=601&amp;id=u0594cf8c&amp;name=image.png&amp;originHeight=1607&amp;originWidth=1653&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=773227&amp;status=done&amp;style=none&amp;taskId=u9f388cc9-521d-4ec3-b612-e323f8bf2b6&amp;title=&amp;width=618.0000610351562" alt="image.png"><br>每个过程的窗口大小的变化，在图中都描述的很清楚了，可以发现窗口不断减少了，并且发送的数据都是比较小的了。<br>所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>而发送方可以发送小数据</li>
</ul>
<p>于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了</p>
<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
<p>怎么让接收方不通告小窗口呢？<br>接收方通常的策略如下:<br>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。<br>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。<br>怎么让发送方避免发送小数据呢？<br>发送方通常的策略:<br>使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：</p>
<ul>
<li>要等到窗口大小 &gt;= MSS 或是 数据大小 &gt;= MSS</li>
<li>收到之前发送数据的 ack 回包</li>
</ul>
<p>只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。<br>另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。<br>可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="type">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><br>TCP 延迟确认与 Nagle 算法<br>当我们 TCP 报文的承载的数据非常小的时候，例如几个字节，那么整个网络的效率是很低的，因为每个 TCP 报文中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，而数据只有几个字节，所以在整个报文中有效数据占有的比重就会非常低。<br>这就好像快递员开着大货车送一个小包裹一样浪费。<br>那么就出现了常见的两种策略，来减少小报文的传输，分别是：</p>
<ul>
<li>Nagle 算法</li>
<li>延迟确认</li>
</ul>
<p>Nagle 算法是如何避免大量 TCP 小数据报文的传输？<br>Nagle 算法做了一些策略来避免过多的小数据报文发送，这可提高传输效率。<br>Nagle 算法的策略：</p>
<ul>
<li>没有已发送未确认报文时，立刻发送数据。</li>
<li>存在未确认报文时，直到「没有已发送未确认报文」或「数据长度达到 MSS 大小」时，再发送数据。</li>
</ul>
<p>只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651544552208-a179133d-7f18-407e-914b-66233dff1676.jpeg#averageHue=%23fbfaf9&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=491&amp;id=hpuOs&amp;originHeight=678&amp;originWidth=836&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u298bae31-c424-491d-bc1c-45a4ca05333&amp;title=&amp;width=606" alt=""><br>上图右侧启用了 Nagle 算法，它的发送数据的过程：</p>
<ul>
<li>一开始由于没有已发送未确认的报文，所以就立刻发了 H 字符；</li>
<li>接着，在还没收到对 H 字符的确认报文时，发送方就一直在囤积数据，直到收到了确认报文后，此时没有已发送未确认的报文，于是就把囤积后的 ELL 字符一起发给了接收方；</li>
<li>待收到对 ELL 字符的确认报文后，于是把最后一个 O 字符发送了出去</li>
</ul>
<p>可以看出，<strong>Nagle 算法一定会有一个小报文，也就是在最开始的时候。</strong><br>另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>那延迟确认又是什么？<br>事实上当没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。<br>为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。<br>TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651544552235-88844107-1c33-4135-8391-7471ed4e8ea3.jpeg#averageHue=%23f5f2e9&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=473&amp;id=NzNK9&amp;originHeight=789&amp;originWidth=747&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u02000ade-0e5f-408e-8867-3becfea825f&amp;title=&amp;width=448" alt=""></p>
<p>延迟确认 和 Nagle 算法混合使用时，会产生新的问题<br>当 TCP 延迟确认 和 Nagle 算法混合使用时，会导致时耗增长，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/21371548/1651544553236-252baf91-3f01-4cb4-b57a-284f2af302ae.jpeg#averageHue=%23f8f7f3&amp;clientId=uc8ddbc34-260f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=jClnc&amp;originHeight=617&amp;originWidth=483&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc25e615f-4af3-49d1-971c-2998c983fae&amp;title=" alt=""><br>发送方使用了 Nagle 算法，接收方使用了 TCP 延迟确认会发生如下的过程：</p>
<ul>
<li>发送方先发出一个小报文，接收方收到后，由于延迟确认机制，自己又没有要发送的数据，只能干等着发送方的下一个报文到达；</li>
<li>而发送方由于 Nagle 算法机制，在未收到第一个报文的确认前，是不会发送后续的数据；</li>
<li>所以接收方只能等待最大时间 200 ms 后，才回 ACK 报文，发送方收到第一个报文的确认报文后，也才可以发送后续的数据。</li>
</ul>
<p>很明显，这两个同时使用会造成额外的时延，这就会使得网络”很慢”的感觉。<br>要解决这个问题，只有两个办法：</p>
<ul>
<li>要不发送方关闭 Nagle 算法</li>
<li>要不接收方关闭 TCP 延迟确认</li>
</ul>
<hr>
<h3 id="Ⅳ拥塞控制"><a href="#Ⅳ拥塞控制" class="headerlink" title="Ⅳ拥塞控制"></a>Ⅳ拥塞控制</h3><p><strong>为什么要有拥塞控制呀，不是有流量控制了吗？</strong><br>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。<br>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<br><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong><br>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong><br>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。<br><strong>什么是拥塞窗口？和发送窗口有什么关系呢？</strong><br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<blockquote>
<p>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。<br>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少；</li>
</ul>
</blockquote>
<p><strong>那么怎么知道当前网络是否出现了拥塞呢？</strong><br>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong><br><strong>拥塞控制有哪些控制算法？</strong><br>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？<br>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><blockquote>
<p>这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958540138-6d49e386-0731-43cb-ab49-3faf2ebf0627.png#averageHue=%23fafaf9&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=368&amp;id=udd23a832&amp;name=image.png&amp;originHeight=632&amp;originWidth=1016&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=196358&amp;status=done&amp;style=none&amp;taskId=u5c0aaf77-ffe0-4bc0-86e0-f0235eab345&amp;title=&amp;width=592.0000610351562" alt="image.png"><br>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
</blockquote>
</li>
</ul>
<p>那慢启动涨到什么时候是个头呢？<br>有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li>
<li>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。<br>一般来说 ssthresh 的大小是 65535 字节。<br>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong><blockquote>
<p>接上前面的慢启动的栗子，现假定 ssthresh 为 8：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958540138-16ea3232-5c2e-482f-92b6-1626aaf18c93.png#averageHue=%23faf7f5&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u38eacc3b&amp;name=image.png&amp;originHeight=731&amp;originWidth=872&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155543&amp;status=done&amp;style=none&amp;taskId=udc6dd46e-62b6-40b2-8ed6-528d68a7295&amp;title=" alt="image.png"><br>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。<br>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。<br>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
</blockquote>
</li>
</ul>
<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。<br>发生超时重传的拥塞发生算法<br>当发生了「超时重传」，则就会使用拥塞发生算法。<br>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li>ssthresh 设为 cwnd/2，</li>
<li>cwnd 重置为 1</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958540605-a981dafe-8f02-4b78-a070-f03a8d88899f.png#averageHue=%23f8f4f2&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0a98e41e&amp;name=image.png&amp;originHeight=873&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=300269&amp;status=done&amp;style=none&amp;taskId=u2f938585-10b9-4e0d-9ae1-9e4dc47626e&amp;title=" alt="image.png"><br>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。<br>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。<br>发生快速重传的拥塞发生算法<br>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。<br>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li>
<li>ssthresh = cwnd;</li>
<li><p>进入快速恢复算法</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。<br>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p>
</li>
<li><p>cwnd = cwnd/2 ，也就是设置为原来的一半;</p>
</li>
<li>ssthresh = cwnd;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958540855-065f61d5-415d-454e-8989-43d9d8afb68a.png#averageHue=%23f7f3ef&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u193042c6&amp;name=image.png&amp;originHeight=873&amp;originWidth=1352&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=402224&amp;status=done&amp;style=none&amp;taskId=ue9a0f455-ce3e-4fbd-849f-e298d1f96ef&amp;title=" alt="image.png"><br>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p>
<h4 id="拥塞算法示意图"><a href="#拥塞算法示意图" class="headerlink" title="拥塞算法示意图"></a>拥塞算法示意图</h4><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下面这张图片，每个过程我相信你都能明白：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652958555844-b622614b-6770-4192-badb-2759ecd736bb.png#averageHue=%23eef2f4&amp;clientId=uec7e2579-b299-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ude0e0a12&amp;name=image.png&amp;originHeight=407&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=221070&amp;status=done&amp;style=none&amp;taskId=u5f0d00fd-33d6-41ab-8e7a-a193068812b&amp;title=" alt="image.png"></p>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</strong></p>
<h2 id="👌三、-如何优化-TCP"><a href="#👌三、-如何优化-TCP" class="headerlink" title="👌三、 如何优化 TCP?"></a>👌三、 如何优化 TCP?</h2><p>接下来，将以三个角度来阐述提升 TCP 的策略，分别是：</p>
<ul>
<li>TCP 三次握手的性能提升；</li>
<li>TCP 四次挥手的性能提升；</li>
<li>TCP 数据传输的性能提升；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440631557-87acfd52-9012-474a-8272-beec928afc44.png#averageHue=%23f0f0f4&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u64ad6a5c&amp;name=image.png&amp;originHeight=918&amp;originWidth=1252&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=181348&amp;status=done&amp;style=none&amp;taskId=u33e03978-ec21-4a55-b56f-4b10b2b6099&amp;title=" alt="image.png"></p>
<hr>
<h3 id="ⅠTCP-三次握手的性能提升"><a href="#ⅠTCP-三次握手的性能提升" class="headerlink" title="ⅠTCP 三次握手的性能提升"></a>ⅠTCP 三次握手的性能提升</h3><p>详细内容TCP 是面向连接的、可靠的、双向传输的传输层通信协议，所以在传输数据之前需要经过三次握手才能建立连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440649297-4905ebf5-a8f4-4b6e-892d-3d5e2d81e83d.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=FoWWF&amp;name=image.png&amp;originHeight=549&amp;originWidth=437&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=47577&amp;status=done&amp;style=none&amp;taskId=ua6f33fcb-95eb-4af1-8d7a-bb1e01f6a82&amp;title=" alt="image.png"><br>那么，三次握手的过程在一个 HTTP 请求的平均时间占比 10% 以上，在网络状态不佳、高并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握手中的参数，就会对性能产生很多的影响。<br>如何正确有效的使用这些参数，来提高 TCP 三次握手的性能，这就需要理解「三次握手的状态变迁」，这样当出现问题时，先用 netstat 命令查看是哪个握手阶段出现了问题，再来对症下药，而不是病急乱投医。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440649756-0f40d287-6c93-42b5-9991-e4cbf59dc559.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=385&amp;id=uBi04&amp;name=image.png&amp;originHeight=678&amp;originWidth=813&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80594&amp;status=done&amp;style=none&amp;taskId=ua51783bd-55f9-43a6-b5c1-bae2421f608&amp;title=&amp;width=462" alt="image.png"><br>客户端和服务端都可以针对三次握手优化性能。主动发起连接的客户端优化相对简单些，而服务端需要监听端口，属于被动连接方，其间保持许多的中间状态，优化方法相对复杂一些。<br>所以，客户端（主动发起连接方）和服务端（被动连接方）优化的方式是不同的，接下来分别针对客户端和服务端优化。</p>
<h4 id="①-客户端优化"><a href="#①-客户端优化" class="headerlink" title="① 客户端优化"></a>① 客户端优化</h4><p>三次握手建立连接的首要目的是「同步序列号」。<br>只有同步了序列号才有可靠传输，TCP 许多特性都依赖于序列号实现，比如流量控制、丢包重传等，这也是三次握手中的报文称为 SYN 的原因，SYN 的全称就叫 <em>Synchronize Sequence Numbers</em>（同步序列号）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440650111-2132b1f1-ea62-4347-8d21-2ec14ca7b062.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=309&amp;id=unPkY&amp;name=image.png&amp;originHeight=618&amp;originWidth=1053&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82874&amp;status=done&amp;style=none&amp;taskId=u14ec8c77-f7ef-40e8-ae8c-22de1107e10&amp;title=&amp;width=526" alt="image.png">注意有个窗口大小字段<br>SYN_SENT 状态的优化<br>客户端作为主动发起连接方，首先它将发送 SYN 包，于是客户端的连接就会处于 SYN_SENT 状态。<br>客户端在等待服务端回复的 ACK 报文，正常情况下，服务器会在几毫秒内返回 SYN+ACK ，但如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，默认是 5 次：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440653170-77a01e65-3324-4847-90ad-a2988e3e87f1.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=N6FIk&amp;name=image.png&amp;originHeight=220&amp;originWidth=906&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33104&amp;status=done&amp;style=none&amp;taskId=u705b6013-e9fd-461c-85ec-4f07618fb23&amp;title=" alt="image.png"></p>
<blockquote>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。<br>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手。<br>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。<br>你可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</p>
</blockquote>
<h4 id="②服务端优化"><a href="#②服务端优化" class="headerlink" title="②服务端优化"></a>②服务端优化</h4><p>当服务端收到 SYN 包后，服务端会立马回复 SYN+ACK 包，表明确认收到了客户端的序列号，同时也把自己的序列号发给对方。<br>此时，服务端出现了新连接，状态是 SYN_RCV。在这个状态下，Linux 内核就会建立一个「半连接队列」来维护「未完成」的握手信息，当半连接队列溢出后，服务端就无法再建立新的连接。</p>
<p>SYN 攻击，攻击的是就是这个半连接队列。<br>SYN_RCV 状态的优化<br>当客户端接收到服务器发来的 SYN+ACK 报文后，就会回复 ACK 给服务器，同时客户端连接状态从 SYN_SENT 转换为 ESTABLISHED，表示连接建立成功。<br>服务器端连接成功建立的时间还要再往后，等到服务端收到客户端的 ACK 后，服务端的连接状态才变为 ESTABLISHED。<br>如果服务器没有收到 ACK，就会重发 SYN+ACK 报文，同时一直处于 SYN_RCV 状态。<br>当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。<strong>修改重发次数的方法是，调整 tcp_synack_retries 参数</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440657280-95c61acb-7d1d-4b7f-8fe4-44b104f9e245.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Cem3R&amp;name=image.png&amp;originHeight=220&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36005&amp;status=done&amp;style=none&amp;taskId=u2a8eb744-77aa-4e5d-a73a-ee8ff15cb3a&amp;title=" alt="image.png"><br>tcp_synack_retries 的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、16 秒，最后一次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。<br>服务器收到 ACK 后连接建立成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。<br>如果进程不能及时地调用 accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建立好的 TCP 连接被丢弃。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440659605-b772ea71-bb37-4b94-ae59-26ad27cd6919.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=jB77J&amp;name=image.png&amp;originHeight=347&amp;originWidth=839&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41009&amp;status=done&amp;style=none&amp;taskId=uc804d5b2-1c32-4159-80e5-459c411234b&amp;title=&amp;width=606" alt="image.png"></p>
<h4 id="③如何绕过三次握手？"><a href="#③如何绕过三次握手？" class="headerlink" title="③如何绕过三次握手？"></a>③如何绕过三次握手？</h4><p>以上我们只是在对三次握手的过程进行优化，接下来我们看看如何绕过三次握手发送数据。<br>三次握手建立连接造成的后果就是，HTTP 请求必须在一个 RTT（从客户端到服务器一个往返的时间）后才能发送。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440663552-3c4b67f2-ec7e-45ce-bb55-6574f3799d78.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=458&amp;id=KMMQk&amp;name=image.png&amp;originHeight=647&amp;originWidth=518&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=47874&amp;status=done&amp;style=none&amp;taskId=ufb8d9a25-5e56-4ece-9204-de8d56fcc2a&amp;title=&amp;width=367" alt="image.png"><br>在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。<br>接下来说说，TCP Fast Open 功能的工作方式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440664659-e0a1c15d-8c37-4278-93d2-a4b03e33abe0.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=805&amp;id=WuPGy&amp;name=image.png&amp;originHeight=1037&amp;originWidth=626&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=78372&amp;status=done&amp;style=none&amp;taskId=u18afab56-85d7-4d5d-91b0-ff47645b6c9&amp;title=&amp;width=486" alt="image.png"><br>在客户端首次建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>所以，第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。<br>之后，如果客户端再次向服务器建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含「数据」以及此前记录的 Cookie；</li>
<li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li>
<li>如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，<strong>这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li>
<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；</li>
</ol>
<p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握手，这就减少了握手带来的 1 个 RTT 的时间消耗。</p>
<p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断重复 TCP Fast Open 直至服务器认为 Cookie 无效（通常为过期）。<br>Linux 下怎么打开 TCP Fast Open 功能呢？<br>在 Linux 系统中，可以通过<strong>设置 tcp_fastopn 内核参数，来打开 Fast Open 功能</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440665977-ae3f15bf-6e70-4ee1-85d7-043af9836c87.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=l7aP6&amp;name=image.png&amp;originHeight=220&amp;originWidth=854&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32216&amp;status=done&amp;style=none&amp;taskId=u617311f9-0626-41ee-8ba5-7e301807d4f&amp;title=" alt="image.png"><br>tcp_fastopn 各个值的意义:</p>
<ul>
<li>0 关闭</li>
<li>1 作为客户端使用 Fast Open 功能</li>
<li>2 作为服务端使用 Fast Open 功能</li>
<li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能</li>
</ul>
<p><strong>TCP Fast Open 功能需要客户端和服务端同时支持，才有效果。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440667875-7bdf3353-dbf0-4ea4-a2c4-081d57c50981.png#averageHue=%2373736e&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7c87dab0&amp;name=image.png&amp;originHeight=632&amp;originWidth=1037&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=102346&amp;status=done&amp;style=none&amp;taskId=u4e6954f9-c5dc-434b-b8ca-e30c04ffa76&amp;title=" alt="image.png"></p>
<h4 id="客户端的优化"><a href="#客户端的优化" class="headerlink" title="客户端的优化"></a>客户端的优化</h4><p>当客户端发起 SYN 包时，可以通过 tcp_syn_retries 控制其重传的次数。</p>
<h4 id="服务端的优化"><a href="#服务端的优化" class="headerlink" title="服务端的优化"></a>服务端的优化</h4><ul>
<li><p>如果 SYN 半连接队列溢出情况比较严重,可以调整 SYN 半连接队列的大小。</p>
<blockquote>
<p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况比较严重，可以通过 tcp_max_syn_backlog、somaxconn、backlog 参数来调整 SYN 半连接队列的大小</p>
</blockquote>
</li>
<li><p>服务端回复 SYN+ACK 的重传次数由 tcp_synack_retries 参数控制。如果遭受 SYN 攻击，应把 tcp_syncookies 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</p>
</li>
<li>服务端收到客户端返回的 ACK，会把连接移入 accpet 队列，等待进行调用 accpet() 函数取出连接。可以通过 ss -lnt 查看服务端进程的 accept 队列长度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 tcp_abort_on_overflow 设置为 1 ，表示用 RST 通知客户端连接建立失败。</li>
<li>如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)。<h4 id="绕过三次握手"><a href="#绕过三次握手" class="headerlink" title="绕过三次握手"></a>绕过三次握手</h4>TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 tcp_fastopen 开启该功能，同时必须保证服务端和客户端同时支持。</li>
</ul>
<hr>
<h3 id="ⅡTCP-四次挥手的性能提升"><a href="#ⅡTCP-四次挥手的性能提升" class="headerlink" title="ⅡTCP 四次挥手的性能提升"></a>ⅡTCP 四次挥手的性能提升</h3><p>详细内容#### ①主动方的优化<br>关闭连接的方式通常有两种，分别是 RST 报文关闭和 FIN 报文关闭。<br>如果进程异常退出了，内核就会发送 RST 报文来关闭，它可以不走四次挥手流程，是一个暴力关闭连接的方式。<br>安全关闭连接的方式必须通过四次挥手，它由进程调用 close 和 shutdown 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。<br>调用 close 函数和 shutdown 函数有什么区别？<br>调用了 close 函数意味着完全断开连接，<strong>完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。</strong><br>使用 close 函数关闭连接是不优雅的。于是，就出现了一种优雅关闭连接的 shutdown 函数，<strong>它可以控制只关闭一个方向的连接</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440669015-2dabc965-06b1-4528-9106-08084be3fc8d.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=141&amp;id=UAJBy&amp;name=image.png&amp;originHeight=184&amp;originWidth=650&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13898&amp;status=done&amp;style=none&amp;taskId=u8075ff1d-1841-4531-8f78-fd2414d3805&amp;title=&amp;width=497" alt="image.png"></p>
<blockquote>
<p>第二个参数决定断开连接的方式，主要有以下三种方式：</p>
<ul>
<li>SHUT_RD(0)：<strong>关闭连接的「读」这个方向（还能发送数据）</strong>，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数。</li>
<li>SHUT_WR(1)：<strong>关闭连接的「写」这个方向（还能接收数据）</strong>，这就是常被称为<strong>「半关闭」的连接</strong>。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端。断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机。</li>
<li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，<strong>关闭套接字的读和写两个方向</strong>。同时断开 I/O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数。</li>
</ul>
<p>close 和 shutdown 函数都可以关闭连接，但这两种方式关闭的连接，不只功能上有差异，控制它们的 Linux 参数也不相同。</p>
</blockquote>
<h5 id="FIN-WAIT1-状态的优化"><a href="#FIN-WAIT1-状态的优化" class="headerlink" title="FIN_WAIT1 状态的优化"></a>FIN_WAIT1 状态的优化</h5><p>主动方发送 FIN 报文后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动方的 ACK，则会很快变为 FIN_WAIT2 状态。<br>但是当迟迟收不到对方返回的 ACK 时，连接就会一直处于 FIN_WAIT1 状态。此时，<strong>内核会定时重发 FIN 报文，其中重发次数由 tcp_orphan_retries 参数控制</strong>（注意，orphan 虽然是孤儿的意思，该参数却不只对孤儿连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0。</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440670517-22d31415-7230-4924-b9da-a7d5bfd6f37e.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=mNnHj&amp;name=image.png&amp;originHeight=220&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33122&amp;status=done&amp;style=none&amp;taskId=u83aeb9e2-ea74-4336-98de-f4c4cdb954f&amp;title=" alt="image.png"><br>你可能会好奇，这 0 表示几次？<strong>实际上当为 0 时，特指 8 次</strong>，从下面的内核源码可知：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440672762-09a29499-ed3a-4a3f-ba7d-a0401044f7ee.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=360&amp;id=r4h03&amp;name=image.png&amp;originHeight=724&amp;originWidth=1306&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=124629&amp;status=done&amp;style=none&amp;taskId=u41b2228a-e6d0-489c-9346-34f615c1c45&amp;title=&amp;width=650" alt="image.png"><br>如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当重传次数超过 tcp_orphan_retries 时，连接就会直接关闭掉。<br>对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报文根本无法发送出去，这由 TCP 两个特性导致的：</p>
<ul>
<li>首先，TCP 必须保证报文是有序发送的，FIN 报文也不例外，当发送缓冲区还有数据没有发送时，FIN 报文也不能提前发送。</li>
<li>其次，TCP 有流量控制功能，当接收方接收窗口为 0 时，发送方就不能再发送数据。所以，当攻击者下载大文件时，就可以通过接收窗口设为 0 ，这就会使得 FIN 报文都无法发送出去，那么连接会一直处于 FIN_WAIT1 状态。</li>
</ul>
<p>解决这种问题的方法，是<strong>调整 tcp_max_orphans 参数，它定义了「孤儿连接」的最大数量</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440673347-03f098a7-7582-41b5-b16c-1514dfa18bdd.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=tMsBr&amp;name=image.png&amp;originHeight=220&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28433&amp;status=done&amp;style=none&amp;taskId=u8a8a8fc8-6f64-4256-8c48-8c95532a6a9&amp;title=" alt="image.png"><br>当进程调用了 close 函数关闭连接，此时连接就会是「孤儿连接」，因为它无法再发送和接收数据。Linux 系统为了防止孤儿连接过多，导致系统资源长时间被占用，就提供了 tcp_max_orphans 参数。如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。</p>
</blockquote>
<h5 id="FIN-WAIT2-状态的优化"><a href="#FIN-WAIT2-状态的优化" class="headerlink" title="FIN_WAIT2 状态的优化"></a>FIN_WAIT2 状态的优化</h5><p>当主动方收到 ACK 报文后，会处于 FIN_WAIT2 状态，就表示主动方的发送通道已经关闭，接下来将等待对方发送 FIN 报文，关闭对方的发送通道。<br>这时，<strong>如果连接是用 shutdown 函数关闭的，连接可以一直处于 FIN_WAIT2 状态，因为它可能还可以发送或接收数据。但对于 close 函数关闭的孤儿连接，由于无法再发送和接收数据，所以这个状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长</strong>，默认值是 60 秒：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440674038-c12e9703-f389-40f8-bc8a-fd2c1987f308.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=hB7Qn&amp;name=image.png&amp;originHeight=220&amp;originWidth=852&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33472&amp;status=done&amp;style=none&amp;taskId=u9435aae6-172f-4b21-8edb-af188384906&amp;title=" alt="image.png"><br>它意味着对于孤儿连接（调用 close 关闭的连接），如果在 60 秒后还没有收到 FIN 报文，连接就会直接关闭。<br>这个 60 秒不是随便决定的，它与 TIME_WAIT 状态持续的时间是相同的，后面我们再来说说为什么是 60 秒。</p>
<h5 id="TIME-WAIT-状态的优化"><a href="#TIME-WAIT-状态的优化" class="headerlink" title="TIME_WAIT 状态的优化"></a>TIME_WAIT 状态的优化</h5><p>TIME_WAIT 是主动方四次挥手的最后一个状态，也是最常遇见的状态。<br>当收到被动方发来的 FIN 报文后，主动方会立刻回复 ACK，表示确认对方的发送通道已经关闭，接着就处于 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进入关闭状态。<br>TIME_WAIT 状态的连接，在主动方看来确实快已经关闭了。然后，被动方没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果这个 ACK 报文没有到达被动方，被动方就会重发 FIN 报文。重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p>
<p>但是你可能会说重新发送的 ACK 还是有可能丢失啊，没错，但 TCP 已经等待了那么长的时间了，已经算仁至义尽了。<br><strong>我们再回过头来看看，为什么 TIME_WAIT 状态要保持 60 秒呢？</strong><br>这与孤儿连接 FIN_WAIT2 状态默认保留 60 秒的原理是一样的，<strong>因为这两个状态都需要保持 2MSL 时长。MSL 全称是 Maximum Segment Lifetime，它定义了一个报文在网络中的最长生存时间</strong>（报文每经过一次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报文就被丢弃，这就限制了报文的最长存活时间）。<br><strong>为什么是 2 MSL 的时长呢？</strong><br>这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。<br><strong>因此，TIME_WAIT 和 FIN_WAIT2 状态的最大时长都是 2 MSL，由于在 Linux 系统中，MSL 的值固定为 30 秒，所以它们都是 60 秒。</strong></p>
<h4 id="②-被动方的优化"><a href="#②-被动方的优化" class="headerlink" title="② 被动方的优化"></a>② 被动方的优化</h4><p>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。<br>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报文。</p>
<h5 id="如果连接双方同时关闭连接，会怎么样？"><a href="#如果连接双方同时关闭连接，会怎么样？" class="headerlink" title="如果连接双方同时关闭连接，会怎么样？"></a>如果连接双方同时关闭连接，会怎么样？</h5><p>由于 TCP 是双全工的协议，所以是会出现两方同时关闭连接的现象，也就是同时发送了 FIN 报文。<br>此时，上面介绍的优化策略仍然适用。两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态，FIN 报文的重发次数仍由 tcp_orphan_retries 参数控制。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440677633-c5353360-1a7d-474b-b871-96bf210b9f1d.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=571&amp;id=dqm1i&amp;name=image.png&amp;originHeight=783&amp;originWidth=768&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=97819&amp;status=done&amp;style=none&amp;taskId=u81029070-8d78-4f10-88ed-0536124aef0&amp;title=&amp;width=560" alt="image.png"><br>接下来，<strong>双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态</strong>。接着，双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。<br>针对 TCP 四次挥手的优化，我们需要根据主动方和被动方四次挥手状态变化来调整系统 TCP 内核参数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440677679-593cd333-6af5-4be9-8070-b71aa0ba0697.png#averageHue=%23f6e6d1&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=365&amp;id=u2442377d&amp;name=image.png&amp;originHeight=632&amp;originWidth=1037&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=124922&amp;status=done&amp;style=none&amp;taskId=u58e86060-9f19-40ba-9af1-ffce17e5bda&amp;title=&amp;width=599" alt="image.png"></p>
<h4 id="主动方的优化"><a href="#主动方的优化" class="headerlink" title="主动方的优化"></a>主动方的优化</h4><ul>
<li>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 tcp_orphan_retries 参数决定。</li>
<li>当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同：<ul>
<li>如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 tcp_fin_timeout 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，tcp_max_orphans 定义了最大孤儿连接的数量，超过时连接就会直接释放。</li>
<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li>
</ul>
</li>
<li>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，tcp_max_tw_buckets 定义了最大数量，超过时连接也会直接释放。</li>
<li>当 TIME_WAIT 状态过多时，还可以通过设置 tcp_tw_reuse 和 tcp_timestamps 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。<h4 id="被动方的优化"><a href="#被动方的优化" class="headerlink" title="被动方的优化"></a>被动方的优化</h4>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。<br>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报文。</li>
</ul>
<hr>
<h3 id="ⅢTCP-传输数据的性能提升（了解即可）"><a href="#ⅢTCP-传输数据的性能提升（了解即可）" class="headerlink" title="ⅢTCP 传输数据的性能提升（了解即可）"></a>ⅢTCP 传输数据的性能提升（了解即可）</h3><p>了解在前面介绍的是三次握手和四次挥手的优化策略，接下来主要介绍的是 TCP 传输数据时的优化策略。<br>TCP 连接是由内核维护的，内核会为每个连接建立内存缓冲区：</p>
<ul>
<li>如果连接的内存配置过小，就无法充分使用网络带宽，TCP 传输效率就会降低；</li>
<li>如果连接的内存配置过大，很容易把服务器资源耗尽，这样就会导致新连接无法建立；</li>
</ul>
<p>因此，我们必须理解 Linux 下 TCP 内存的用途，才能正确地配置内存大小。</p>
<h4 id="滑动窗口是如何影响传输速度的？"><a href="#滑动窗口是如何影响传输速度的？" class="headerlink" title="滑动窗口是如何影响传输速度的？"></a>滑动窗口是如何影响传输速度的？</h4><p>TCP 会保证每一个报文都能够抵达对方，它的机制是这样：报文发出去后，必须接收到对方返回的确认报文 ACK，如果迟迟未收到，就会超时重发该报文，直到收到对方的 ACK 为止。<br><strong>所以，TCP 报文发出去后，并不会立马从内存中删除，因为重传时还需要用到它。</strong><br>由于 TCP 是内核维护的，所以报文存放在内核缓冲区。如果连接非常多，我们可以通过 free 命令观察到 buff/cache 内存是会增大。<br>如果 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这个模式就有点像我和你面对面聊天，你一句我一句，但这种方式的缺点是效率比较低的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440679360-cff4d50e-f0c7-4cfb-9cab-1d609ec18153.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=445&amp;id=JRpXs&amp;name=image.png&amp;originHeight=617&amp;originWidth=498&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48380&amp;status=done&amp;style=none&amp;taskId=ua426eced-8268-4ec2-bcd5-8ee5adae903&amp;title=&amp;width=359" alt="image.png"><br>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。<br><strong>要解决这一问题不难，并行批量发送报文，再批量确认报文即可。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440679910-75fbcc47-0e32-4099-95da-3d24b42b7a4e.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=404&amp;id=Cwo0Q&amp;name=image.png&amp;originHeight=602&amp;originWidth=857&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=78580&amp;status=done&amp;style=none&amp;taskId=u5d1b7e84-c242-4d21-b77b-607f3a0a173&amp;title=&amp;width=575" alt="image.png"><br>然而，这引出了另一个问题，发送方可以随心所欲的发送报文吗？<strong>当然这不现实，我们还得考虑接收方的处理能力。</strong><br>当接收方硬件不如发送方，或者系统繁忙、资源紧张时，是无法瞬间处理这么多报文的。于是，这些报文只能被丢掉，使得网络效率非常低。<br><strong>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是滑动窗口的由来。</strong><br>接收方根据它的缓冲区，可以计算出后续能够接收多少字节的报文，这个数字叫做接收窗口。当内核接收到报文时，必须用缓冲区存放它们，这样剩余缓冲区空间变小，接收窗口也就变小了；当进程调用 read 函数后，数据被读入了用户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报文，接收窗口就会变大。<br>因此，接收窗口并不是恒定不变的，接收方会把当前可接收的大小放在 TCP 报文头部中的<strong>窗口字段</strong>，这样就可以起到窗口大小通知的作用。<br>发送方的窗口等价于接收方的窗口吗？如果不考虑拥塞控制，发送方的窗口大小「约等于」接收方的窗口大小，因为窗口通知报文在网络传输是存在时延的，所以是约等于的关系。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440679801-6e4d20c1-1d9d-466b-ae19-c64247a696a3.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=347&amp;id=WEqYn&amp;name=image.png&amp;originHeight=618&amp;originWidth=1053&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80899&amp;status=done&amp;style=none&amp;taskId=u3e40ecbf-f614-46d6-8a60-32fdb5d75a8&amp;title=&amp;width=592" alt="image.png"><br>从上图中可以看到，窗口字段只有 2 个字节，因此它最多能表达 65535 字节大小的窗口，也就是 64KB 大小。</p>
<blockquote>
<p>这个窗口大小最大值，在当今高速网络下，很明显是不够用的。所以后续有了扩充窗口的方法：<strong>在 TCP 选项字段定义了窗口扩大因子，用于扩大 TCP 通告窗口，其值大小是 2^14，这样就使 TCP 的窗口大小从 16 位扩大为 30 位（2^16 * 2^ 14 = 2^30），所以此时窗口的最大值可以达到 1GB。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440679963-0fd93f73-b9a7-4d75-99ee-764d0d682397.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=453&amp;id=foRpn&amp;name=image.png&amp;originHeight=933&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=205106&amp;status=done&amp;style=none&amp;taskId=u405f0134-1e0b-40a6-bb4f-031a87b3f44&amp;title=&amp;width=613" alt="image.png"><br>Linux 中打开这一功能，需要把 tcp_window_scaling 配置设为 1（默认打开）：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440679850-efdb89fd-14e0-4a39-a482-7a9935f21049.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=EFKez&amp;name=image.png&amp;originHeight=220&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28335&amp;status=done&amp;style=none&amp;taskId=u6d8e99ce-4972-4a54-88cf-7eea8ac2912&amp;title=" alt="image.png"><br>要使用窗口扩大选项，通讯双方必须在各自的 SYN 报文中发送这个选项：</p>
<ul>
<li>主动建立连接的一方在 SYN 报文中发送这个选项；</li>
<li>而被动建立连接的一方只有在收到带窗口扩大选项的 SYN 报文之后才能发送这个选项。</li>
</ul>
<p>这样看来，只要进程能及时地调用 read 函数读取数据，并且接收缓冲区配置得足够大，那么接收窗口就可以无限地放大，发送方也就无限地提升发送速度。<br><strong>这是不可能的，因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。</strong></p>
</blockquote>
<h4 id="如何确定最大传输速度？"><a href="#如何确定最大传输速度？" class="headerlink" title="如何确定最大传输速度？"></a>如何确定最大传输速度？</h4><p>在前面我们知道了 TCP 的传输速度，受制于发送窗口与接收窗口，以及网络设备传输能力。其中，窗口大小由内核缓冲区大小决定。如果缓冲区与网络传输能力匹配，那么缓冲区的利用率就达到了最大化。<br><strong>问题来了，如何计算网络的传输能力呢？</strong><br>相信大家都知道网络是有「带宽」限制的，带宽描述的是网络传输能力，它与内核缓冲区的计量单位不同:</p>
<ul>
<li>带宽是单位时间内的流量，表达是「速度」，比如常见的带宽 100 MB/s；</li>
<li>缓冲区单位是字节，当网络速度乘以时间才能得到字节数；</li>
</ul>
<p>这里需要说一个概念，就是带宽时延积，它决定网络中飞行报文的大小，它的计算方式：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440681659-1a6dcf93-f2aa-4db0-93ca-9cbe14155307.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=lkKFl&amp;name=image.png&amp;originHeight=93&amp;originWidth=498&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7949&amp;status=done&amp;style=none&amp;taskId=u04239cba-d058-46c6-a361-fc28d3c5d87&amp;title=" alt="image.png"><br>比如最大带宽是 100 MB/s，网络时延（RTT）是 10ms 时，意味着客户端到服务端的网络一共可以存放 100MB/s <em> 0.01s = 1MB 的字节。<br>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「飞行中」的 TCP 报文大小，它们就在网络线路、路由器等网络设备上。如果飞行报文超过了 1 MB，就会导致网络过载，容易丢包。<br><em>*由于发送缓冲区大小决定了发送窗口的上限，而发送窗口又决定了「已发送未确认」的飞行报文的上限。因此，发送缓冲区不能超过「带宽时延积」。</em></em><br>发送缓冲区与带宽时延积的关系：</p>
<ul>
<li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；</li>
<li>如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率。</li>
</ul>
<p>所以，发送缓冲区的大小最好是往带宽时延积靠近。</p>
<h4 id="怎样调整缓冲区大小？"><a href="#怎样调整缓冲区大小？" class="headerlink" title="怎样调整缓冲区大小？"></a>怎样调整缓冲区大小？</h4><p>在 Linux 中发送缓冲区和接收缓冲都是可以用参数调节的。设置完后，Linux 会根据你设置的缓冲区进行<strong>动态调节</strong>。<br>调节发送缓冲区范围<br>先来看看发送缓冲区，它的范围通过 tcp_wmem 参数配置；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440681844-5af2aaee-01f4-4aaa-8718-fd8373d5fc0d.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Zf9Nm&amp;name=image.png&amp;originHeight=220&amp;originWidth=1054&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32288&amp;status=done&amp;style=none&amp;taskId=udcf984eb-635b-42cf-abb2-435c6637bb8&amp;title=" alt="image.png"><br>上面三个数字单位都是字节，它们分别表示：</p>
<ul>
<li>第一个数值是动态范围的最小值，4096 byte = 4K；</li>
<li>第二个数值是初始默认值，87380 byte ≈ 86K；</li>
<li>第三个数值是动态范围的最大值，4194304 byte = 4096K（4M）；</li>
</ul>
<p><strong>发送缓冲区是自行调节的</strong>，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。<br>调节接收缓冲区范围<br>而接收缓冲区的调整就比较复杂一些，先来看看设置接收缓冲区范围的 tcp_rmem 参数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440681867-a0130191-df9a-483b-bfea-8fa1fbe48125.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=Mr2wy&amp;name=image.png&amp;originHeight=220&amp;originWidth=1054&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32644&amp;status=done&amp;style=none&amp;taskId=u8abe2d20-d45d-40df-a55a-7a77e768649&amp;title=" alt="image.png"><br>上面三个数字单位都是字节，它们分别表示：</p>
<ul>
<li>第一个数值是动态范围的最小值，表示即使在内存压力下也可以保证的最小接收缓冲区大小，4096 byte = 4K；</li>
<li>第二个数值是初始默认值，87380 byte ≈ 86K；</li>
<li>第三个数值是动态范围的最大值，6291456 byte = 6144K（6M）；</li>
</ul>
<p><strong>接收缓冲区可以根据系统空闲内存的大小来调节接收窗口：</strong></p>
<ul>
<li>如果系统的空闲内存很多，就可以自动把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而提升发送方发送的传输数据数量；</li>
<li>反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连接正常工作；</li>
</ul>
<p>发送缓冲区的调节功能是自动开启的，<strong>而接收缓冲区则需要配置 tcp_moderate_rcvbuf 为 1 来开启调节功能</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440681880-60d0f4de-c3f9-47e8-ad30-8f9cbef278c0.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=UhnAC&amp;name=image.png&amp;originHeight=220&amp;originWidth=918&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29278&amp;status=done&amp;style=none&amp;taskId=ue6e3707a-9d7d-49ca-81aa-6e77a2149c7&amp;title=" alt="image.png"><br>调节 TCP 内存范围<br>接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 tcp_mem 配置完成的：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440682029-5fea369c-543d-4ec0-94b7-9a603c4e579c.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=WcWW0&amp;name=image.png&amp;originHeight=220&amp;originWidth=1054&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28161&amp;status=done&amp;style=none&amp;taskId=u8badf4ab-1196-410e-a3b2-d18e097606d&amp;title=" alt="image.png"><br>上面三个数字单位不是字节，而是「页面大小」，1 页表示 4KB，它们分别表示：</p>
<ul>
<li>当 TCP 内存小于第 1 个值时，不需要进行自动调节；</li>
<li>在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的大小；</li>
<li>大于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是无法建立的；</li>
</ul>
<p>一般情况下这些值是在系统启动时根据系统内存数量计算得到的。根据当前 tcp_mem 最大内存页面数是 177120，当内存为 (177120 <em> 4) / 1024K ≈ 692M 时，系统将无法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。<br>根据实际场景调节的策略<br>在高并发服务器中，为了兼顾网速与大量的并发连接，<strong>我们应当保证缓冲区的动态调整的最大值达到带宽时延积，而最小值保持默认的 4K 不变即可。而对于内存紧张的服务而言，调低默认值是提高并发的有效手段。</strong><br>同时，如果这是网络 IO 型服务器，那么，<strong>调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力</strong>。需要注意的是，tcp_wmem 和 tcp_rmem 的单位是字节，而 tcp_mem 的单位是页面大小。而且，<em>*千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能。</em></em></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%B0%8F%E7%BB%93-3"></a>小结</h3><p>本节针对 TCP 优化数据传输的方式，做了一些介绍。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650440683345-8ffc2ef0-26d6-4c28-a800-1f0e2e78302d.png#clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=KXVCh&amp;name=image.png&amp;originHeight=632&amp;originWidth=1037&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94340&amp;status=done&amp;style=none&amp;taskId=u44fe419b-bc5f-4160-8507-04e94ef1a75&amp;title=" alt="image.png"><br>TCP 可靠性是通过 ACK 确认报文实现的，又依赖滑动窗口提升了发送速度也兼顾了接收方的处理能力。<br>可是，默认的滑动窗口最大值只有 64 KB，不满足当今的高速网络的要求，要想提升发送速度必须提升滑动窗口的上限，在 Linux 下是通过设置 tcp_window_scaling 为 1 做到的，此时最大值可高达 1GB。<br>滑动窗口定义了网络中飞行报文的最大字节数，当它超过带宽时延积时，网络过载，就会发生丢包。而当它小于带宽时延积时，就无法充分利用网络带宽。因此，滑动窗口的设置，必须参考带宽时延积。<br>内核缓冲区决定了滑动窗口的上限，缓冲区可分为：发送缓冲区 tcp_wmem 和接收缓冲区 tcp_rmem。<br>Linux 会对缓冲区动态调节，我们应该把缓冲区的上限设置为带宽时延积。发送缓冲区的调节功能是自动打开的，而接收缓冲区需要把 tcp_moderate_rcvbuf 设置为 1 来开启。其中，调节的依据是 TCP 内存范围 tcp_mem。<br>但需要注意的是，如果程序中的 socket 设置 SO_SNDBUF 和 SO_RCVBUF，则会关闭缓冲区的动态整功能，所以不建议在程序设置它俩，而是交给内核自动调整比较好。<br>有效配置这些参数后，既能够最大程度地保持并发性，也能让资源充裕时连接传输速度达到最大值。</p>
<h2 id="四、如何理解是-TCP-面向字节流协议？"><a href="#四、如何理解是-TCP-面向字节流协议？" class="headerlink" title="四、如何理解是 TCP 面向字节流协议？"></a>四、如何理解是 TCP 面向字节流协议？</h2><p>TCP 是面向字节流的协议，UDP 是面向报文的协议？这里的「面向字节流」和「面向报文」该如何理解。</p>
<hr>
<h3 id="①如何理解字节流？"><a href="#①如何理解字节流？" class="headerlink" title="①如何理解字节流？"></a>①如何理解字节流？</h3><p>之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的<strong>发送方的机制不同</strong>，也就是问题原因在发送方。<br>先来说说为什么 UDP 是面向报文的协议？<br>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。<br>你可能会问，如果收到了两个 UDP 报文，操作系统是怎么区分开的？<br>操作系统在收到 UDP 报文后，会将其插入到<strong>队列</strong>里，<strong>队列里的每一个元素就是一个 UDP 报文</strong>，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650442588335-4b187682-f339-4ce3-a51f-bfa0a7d5b331.png#averageHue=%23f4f4f4&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=u1f673a1e&amp;name=image.png&amp;originHeight=302&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35439&amp;status=done&amp;style=none&amp;taskId=u71daa150-07dc-4474-8982-ced7e22fc6c&amp;title=&amp;width=646" alt="image.png"><br>再来说说为什么 TCP 是面向字节流的协议？<br>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。<br>这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。<br><strong>举个实际的例子来说明。</strong><br>发送方准备发送 「Hi.」和「I am Xiaolin」这两个消息。<br>在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。<br>至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。</p>
<blockquote>
<p>如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送 「Hi.」和「I am Xiaolin」 报文，那么实际的发送很有可能是这几种情况。<br>第一种情况，这两个消息被分到同一个 TCP 报文，像这样：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650442588321-3d60f8cb-df8c-45a6-99ea-25994cabf5f8.png#averageHue=%23f3efe7&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u15fc8c4d&amp;name=image.png&amp;originHeight=189&amp;originWidth=356&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8808&amp;status=done&amp;style=none&amp;taskId=u9d7c346b-599e-4cff-adda-4a83455693d&amp;title=" alt="image.png"><br>第二种情况，「I am Xiaolin」的部分随 「Hi」 在一个 TCP 报文中发送出去，像这样：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650442588349-8ec989e5-e066-4ccb-b6c5-ee3529ac5416.png#averageHue=%23faedc5&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6cf97aac&amp;name=image.png&amp;originHeight=152&amp;originWidth=407&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10710&amp;status=done&amp;style=none&amp;taskId=u31e39d32-3764-4eb2-a9d2-1f33446245a&amp;title=" alt="image.png"><br>第三种情况，「Hi.」 的一部分随 TCP 报文被发送出去，另一部分和 「I am Xiaolin」 一起随另一个 TCP 报文发送出去，像这样。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650442588260-963d71b8-4d13-4f98-be2f-ff1c23e31320.png#averageHue=%23fceec7&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ufc2e71e8&amp;name=image.png&amp;originHeight=152&amp;originWidth=437&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10747&amp;status=done&amp;style=none&amp;taskId=ua50f524e-0933-4c21-926c-45c43821625&amp;title=" alt="image.png"><br>类似的情况还能举例很多种，这里主要是想说明，我们不知道 「Hi.」和 「I am Xiaolin」 这两个用户消息是如何进行 TCP 分组传输的。</p>
</blockquote>
<p>因此，<strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。<br>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。<br>要解决这个问题，要交给<strong>应用程序</strong>。<br>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。</p>
<h3 id="②如何解决粘包？"><a href="#②如何解决粘包？" class="headerlink" title="②如何解决粘包？"></a>②如何解决粘包？</h3><p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。<br>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。<h4 id="固定长度的消息"><a href="#固定长度的消息" class="headerlink" title="固定长度的消息"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%B6%88%E6%81%AF"></a>固定长度的消息</h4>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。<br>但是这种方式灵活性不高，实际中很少用。<h4 id="特殊字符作为边界"><a href="#特殊字符作为边界" class="headerlink" title="特殊字符作为边界"></a>特殊字符作为边界</h4>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。<blockquote>
<p>HTTP 是一个非常好的例子。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650442588354-acfc11f2-a671-43ae-b209-7561244ed8bf.png#averageHue=%23e3e2e2&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u48e7327e&amp;name=image.png&amp;originHeight=324&amp;originWidth=942&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50889&amp;status=done&amp;style=none&amp;taskId=u19ab7612-2454-4965-aa30-fb054274588&amp;title=" alt="image.png"><br>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。<br>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
</blockquote>
</li>
</ul>
<h4 id="自定义消息结构"><a href="#自定义消息结构" class="headerlink" title="自定义消息结构"></a>自定义消息结构</h4><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<blockquote>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650442666065-a81a450a-2d6f-4658-9a53-df9b5a15efe4.png#averageHue=%23282c35&amp;clientId=u8538f3f6-82e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=120&amp;id=u010f26c1&amp;name=image.png&amp;originHeight=150&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6501&amp;status=done&amp;style=none&amp;taskId=u5a739f0a-04a7-40c2-ab71-973cab08195&amp;title=&amp;width=732.8" alt="image.png"><br>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
</blockquote>
<h2 id="五、SYN-报文什么时候情况下会被丢弃？"><a href="#五、SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="五、SYN 报文什么时候情况下会被丢弃？"></a>五、SYN 报文什么时候情况下会被丢弃？</h2><p>接下来，我就给出我遇到过 SYN 报文被丢弃的两种场景：</p>
<ul>
<li>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</li>
<li>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃<h3 id="坑爹的-tcp-tw-recycle"><a href="#坑爹的-tcp-tw-recycle" class="headerlink" title="坑爹的 tcp_tw_recycle"></a>坑爹的 tcp_tw_recycle</h3><blockquote>
<p>TCP 四次挥手过程中，主动断开连接方会有一个 TIME_WAIT 的状态，这个状态会持续 2 MSL 后才会转变为 CLOSED 状态。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650590508966-890d77e1-bddc-44f1-b227-13757d819e39.png#averageHue=%23f4e6cd&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=489&amp;id=ufa38debb&amp;name=image.png&amp;originHeight=794&amp;originWidth=753&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=89528&amp;status=done&amp;style=none&amp;taskId=u3bb9a1e8-7557-4d8e-a5e6-a423947d253&amp;title=&amp;width=464" alt="image.png"></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在 Linux 操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 。<br>那么，如果如果主动断开连接方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</p>
</blockquote>
<p>Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：</p>
<ul>
<li>net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，<strong>内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用</strong>，所以该选项只适用于连接发起方。</li>
<li>net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；</li>
</ul>
<p>要使得这两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1)）。<br><strong>tcp_tw_recycle 在使用了 NAT 的网络下是不安全的！</strong><br>对于服务器来说，如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」。<br>首先给大家说说什么是 PAWS 机制？<br>tcp_timestamps 选项开启之后， PAWS 机制会自动开启，它的作用是防止 TCP 包中的序列号发生绕回。<br>正常来说每个 TCP 包都会有自己唯一的 SEQ，出现 TCP 数据包重传的时候会复用 SEQ 号，这样接收方能通过 SEQ 号来判断数据包的唯一性，也能在重复收到某个数据包的时候判断数据是不是重传的。<strong>但是 TCP 这个 SEQ 号是有限的，一共 32 bit，SEQ 开始是递增，溢出之后从 0 开始再次依次递增</strong>。<br>所以当 SEQ 号出现溢出后单纯通过 SEQ 号无法标识数据包的唯一性，某个数据包延迟或因重发而延迟时可能导致连接传递的数据被破坏，比如：</p>
<blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650590509080-f6dd77c3-2c38-4f1e-807e-4876c7a9de4e.png#averageHue=%23f6f6f4&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=u999af05d&amp;name=image.png&amp;originHeight=659&amp;originWidth=649&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=123619&amp;status=done&amp;style=none&amp;taskId=u72abcfa0-fed3-4039-b34b-e8179c3f07c&amp;title=&amp;width=368.0000305175781" alt="image.png"><br>上图 A 数据包出现了重传，并在 SEQ 号耗尽再次从 A 递增时，第一次发的 A 数据包延迟到达了 Server，这种情况下如果没有别的机制来保证，Server 会认为延迟到达的 A 数据包是正确的而接收，反而是将正常的第三次发的 SEQ 为 A 的数据包丢弃，造成数据传输错误。<br>PAWS 就是为了避免这个问题而产生的，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。<br>对于上面图中的例子有了 PAWS 机制就能做到在收到 Delay 到达的 A 号数据包时，识别出它是个过期的数据包而将其丢掉。</p>
</blockquote>
<p>那什么是 per-host 的 PAWS 机制呢？</p>
<ul>
<li>前面我提到，开启了 recycle 和 timestamps 选项，就会开启一种叫 per-host 的 PAWS 机制。<strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>，而非对「IP + 端口」四元组做 PAWS 检查。</li>
<li>但是如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。</li>
<li>Per-host PAWS 机制利用TCP option里的 timestamp 字段的增长来判断串扰数据，而 timestamp 是根据客户端各自的 CPU tick 得出的值。</li>
<li>当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，<strong>客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包</strong>。</li>
</ul>
<p>因此，tcp_tw_recycle 在使用了 NAT 的网络下是存在问题的，如果它是对 TCP 四元组做 PAWS 检查，而不是对「相同的 IP 做 PAWS 检查」，那么就不会存在这个问题了。<br>网上很多博客都说开启 tcp_tw_recycle 参数来优化 TCP，我信你个鬼，糟老头坏的很！<br>tcp_tw_recycle 在 Linux 4.12 版本后，直接取消了这一参数。</p>
<h3 id="accpet-队列满了"><a href="#accpet-队列满了" class="headerlink" title="accpet 队列满了"></a>accpet 队列满了</h3><blockquote>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accepet 队列；</li>
</ul>
<p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p>
</blockquote>
<h4 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h4><p>当服务器造成syn攻击，就有可能导致 <strong>TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃</strong>。<br>但是，<strong>如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包</strong>。<br>syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，<br>开启 syncookies 功能<br>syncookies 参数主要有以下三个值：</p>
<ul>
<li>0 值，表示关闭该功能；</li>
<li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li>
<li>2 值，表示无条件开启功能；</li>
</ul>
<p>那么在应对 SYN 攻击时，只需要设置为 1 即可：</p>
<h4 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h4><p><strong>在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了 ，这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650590512348-fe0c7307-9e54-4e7e-b172-5925ae8e7a2b.png#averageHue=%23faf4e7&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ub4127f10&amp;name=image.png&amp;originHeight=347&amp;originWidth=839&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41446&amp;status=done&amp;style=none&amp;taskId=u8f692144-1f4f-4bae-a66a-0f788016c61&amp;title=" alt="image.png"><br>如果 Recv-Q 的大小超过 Send-Q，就说明发生了 accpet 队列满的情况。<br>要解决这个问题，我们可以：</p>
<ul>
<li>调大 accpet 队列的最大长度，调大的方式是通过<strong>调大 backlog 以及 somaxconn 参数。</strong></li>
<li>检查系统或者代码为什么调用 accept() 不及时；<h2 id="六、已建立连接的TCP，收到SYN会发生什么？"><a href="#六、已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="六、已建立连接的TCP，收到SYN会发生什么？"></a>六、已建立连接的TCP，收到SYN会发生什么？</h2></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650591094751-7b86406e-ec16-4e99-bff6-34d2e19a1393.png#averageHue=%23e5e5e5&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue3ddb71c&amp;name=image.png&amp;originHeight=348&amp;originWidth=550&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=92287&amp;status=done&amp;style=none&amp;taskId=u17a33188-774d-476a-a60f-a11ad1c3f3f&amp;title=" alt="image.png"><br>大概意思是，一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p>
<hr>
<p>TCP 连接是由「四元组」唯一确认的。<br>然后这个场景中，客户端的IP、服务端IP、目的端口并没有变化，所以这个问题关键要看客户端发送的 SYN 报文中的源端口是否和上一次连接的源端口相同。<br><strong>1. 客户端的 SYN 报文里的端口号与历史连接不相同</strong><br>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。<br><strong>那旧连接里处于 establish 状态的服务端最后会怎么样呢？</strong><br>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。<br>如果服务端一直没有发送数据包给客户端，在超过一段时间后， TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。<br><strong>2. 客户端的 SYN 报文里的端口号与历史连接相同</strong></p>
<ul>
<li>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样，也就是处于 establish 状态的服务端收到了这个 SYN 报文。</li>
<li>处于 establish 状态的服务端如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</li>
<li>接着，客户端收到这个 Challenge ACK，发现序列号并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650591094839-bb3fa8a4-dd08-41c4-850a-476be1b5425c.png#averageHue=%23f9f8f8&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=545&amp;id=u04da54ac&amp;name=image.png&amp;originHeight=959&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=100026&amp;status=done&amp;style=none&amp;taskId=ud3ad0c61-b385-48f6-aa77-693422cda7d&amp;title=&amp;width=540" alt="image.png"></p>
<h3 id="如何关闭一个-TCP-连接？"><a href="#如何关闭一个-TCP-连接？" class="headerlink" title="如何关闭一个 TCP 连接？"></a>如何关闭一个 TCP 连接？</h3><p>可能大家第一反应是「杀掉进程」不就行了吗？<br>是的，这个是最粗暴的方式，杀掉客户端进程和服务端进程影响的范围会有所不同：</p>
<ul>
<li>在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接，这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。</li>
<li>而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。</li>
</ul>
<p>所以，关闭进程的方式并不可取，最好的方式要精细到关闭某一条 TCP 连接。</p>
<blockquote>
<p>有的小伙伴可能会说，伪造一个四元组相同的 RST 报文不就行了？<br>这个思路很好，但是不要忘了还有个序列号的问题，你伪造的 RST 报文的序列号一定能被对方接受吗？<br>如果 RST 报文的序列号不能落在对方的滑动窗口内，这个 RST 报文会被对方丢弃的，就达不到关闭的连接的效果。<br>所以，<strong>要伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号正好落在对方的滑动窗口内」这两个条件。</strong><br>直接伪造符合预期的序列号是比较困难，因为如果一个正在传输数据的 TCP 连接，滑动窗口时刻都在变化，因此很难刚好伪造一个刚好落在对方滑动窗口内的序列号的 RST 报文。<br>办法还是有的，</p>
</blockquote>
<ul>
<li><strong>我们可以伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号！</strong></li>
<li>如果处于 establish 状态的服务端，收到四元组相同的 SYN 报文后，<strong>会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号，说白了，就是可以通过这一步拿到服务端下一次预期接收的序列号。</strong></li>
<li><strong>然后用这个确认号作为 RST 报文的序列号，发送给服务端，此时服务端会认为这个 RST 报文里的序列号是合法的，于是就会释放连接！</strong></li>
</ul>
<h2 id="七、四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#七、四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="七、四次挥手中收到乱序的 FIN 包会如何处理？"></a>七、四次挥手中收到乱序的 FIN 包会如何处理？</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650591807398-b20fcc7f-cc54-412c-b457-354ba3534af2.png#averageHue=%23dddddd&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=524&amp;id=u55eaa44b&amp;name=image.png&amp;originHeight=648&amp;originWidth=565&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=263851&amp;status=done&amp;style=none&amp;taskId=u8f0baf51-56f9-430b-afc8-3e15275282f&amp;title=&amp;width=457" alt="image.png"><br>不得不说，鹅厂真的很喜欢问网络问题，而且爱问异常情况下的网络问题，之前也有篇另外一个读者面试鹅厂的网络问题：「<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34827674/article/details/117922761">被鹅厂面怕了！(opens new window)</a>」。<br><strong>shutdown函数讲解：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650683980305-c565e298-4173-40cb-91a5-586eb2415369.png#averageHue=%23c7d292&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=132&amp;id=u1309c5c8&amp;name=image.png&amp;originHeight=165&amp;originWidth=220&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27723&amp;status=done&amp;style=none&amp;taskId=u228e5755-6a3c-4d1e-8f37-3ec4ead80c7&amp;title=&amp;width=176" alt="image.png">关闭写端，还能接收数据，还能读<br>不过这道鹅厂的网络题可能是提问的读者表述有问题，<strong>因为如果 FIN 报文比数据包先抵达客户端，此时 FIN 报文其实是一个乱序的报文，此时客户端的 TCP 连接并不会从 FIN_WAIT_2 状态转换到 TIME_WAIT 状态</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650591807064-617365e4-bfcc-46a4-b6ad-8105a3067df3.png#averageHue=%23f0d966&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=538&amp;id=u38465454&amp;name=image.png&amp;originHeight=744&amp;originWidth=722&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=174388&amp;status=done&amp;style=none&amp;taskId=uc2b92a90-c7e7-4aa1-a493-8fd0c01aba2&amp;title=&amp;width=522" alt="image.png"><br>因此，我们要关注到点是看「<strong>在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP 连接又是什么时候才进入到 TIME_WAIT 状态?</strong>」。<br>我这里先直接说结论：<br><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong><br><strong>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong><br>我也画了一张图，大家可以结合着图来理解。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650591807569-5368f413-9398-4874-93ab-8cd1fb4010aa.png#averageHue=%23dfcf6b&amp;clientId=ua42bb3c8-7eb4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=620&amp;id=u4709fc20&amp;name=image.png&amp;originHeight=992&amp;originWidth=722&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=229545&amp;status=done&amp;style=none&amp;taskId=ue763deb2-3d2e-4c86-b48a-18a7fa7d768&amp;title=&amp;width=451" alt="image.png"></p>
<h2 id="八、在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#八、在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="八、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>八、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><p>所以，今天就来讨论下这个问题，「<strong>在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？</strong>」<br>问题现象如下图，左边是服务端，右边是客户端：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684585510-6251c19d-f24b-4624-af3b-7a741294e2e8.png#averageHue=%23f2dec0&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=523&amp;id=u8aea217c&amp;name=image.png&amp;originHeight=782&amp;originWidth=635&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=153672&amp;status=done&amp;style=none&amp;taskId=u0e0c2bf4-b316-4f43-9973-88030ec62db&amp;title=&amp;width=425" alt="image.png"></p>
<h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><p>针对这个问题，<strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong>，因为处于 TIME_WAIT 状态的连接收到 SYN 后，会判断 SYN 的「序列号和时间戳」是否合法，然后根据判断结果的不同做不同的处理。<br>先跟大家说明下， 什么是「合法」的 SYN？</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li>
</ul>
<p>上面 SYN 合法判断是基于双方都开启了 TCP 时间戳机制的场景，如果双方都没有开启 TCP 时间戳机制，则 SYN 合法判断如下：</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>。<h4 id="收到合法-SYN"><a href="#收到合法-SYN" class="headerlink" title="收到合法 SYN"></a>收到合法 SYN</h4>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。<blockquote>
<p>用下图作为例子，双方都启用了 TCP 时间戳机制，<strong>TSval </strong>是发送报文时的时间戳：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684585741-42322cbd-dba4-4ccd-9c48-f25ca920c163.png#averageHue=%23ecca71&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=624&amp;id=uf62766a8&amp;name=image.png&amp;originHeight=1221&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=588433&amp;status=done&amp;style=none&amp;taskId=u1d551341-6ad7-445e-a737-d942f9c5c47&amp;title=&amp;width=552" alt="image.png"><br>上图中，在收到第三次挥手的 FIN 报文时，会记录该报文的 TSval （21），用 ts_recent 变量保存。然后会计算下一次期望收到的序列号，本次例子下一次期望收到的序列号就是 301，用 rcv_nxt 变量保存。<br>处于 TIME_WAIT 状态的连接收到 SYN 后，<strong>因为 SYN 的 seq（400） 大于 rcv_nxt（301），并且 SYN 的 TSval（30） 大于 ts_recent（21），所以是一个「合法的 SYN」，于是就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。</strong></p>
</blockquote>
</li>
</ul>
<h4 id="收到非法的-SYN"><a href="#收到非法的-SYN" class="headerlink" title="收到非法的 SYN"></a>收到非法的 SYN</h4><p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。<br>用下图作为例子，双方都启用了 TCP 时间戳机制，TSval 是发送报文时的时间戳：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684585781-af652337-3900-4ef1-a4aa-29dd77842fd6.png#averageHue=%23f6e6c9&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=606&amp;id=ud5839fe4&amp;name=image.png&amp;originHeight=1106&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=527992&amp;status=done&amp;style=none&amp;taskId=u3158984f-82f6-4398-8459-a9de3b2da8c&amp;title=&amp;width=592" alt="image.png"><br>上图中，在收到第三次挥手的 FIN 报文时，会记录该报文的 TSval （21），用 ts_recent 变量保存。然后会计算下一次期望收到的序列号，本次例子下一次期望收到的序列号就是 301，用 rcv_nxt 变量保存。<br>处于 TIME_WAIT 状态的连接收到 SYN 后，<strong>因为 SYN 的 seq（200） 小于 rcv_nxt（301），所以是一个「非法的 SYN」，就会再回复一个与第四次挥手一样的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端</strong>。<br>客户端等待一段时间还是没收到 SYN + ACK 后，就会超时重传 SYN 报文，重传次数达到最大值后，就会断开连接。</p>
<h3 id="在-TIME-WAIT-状态，收到-RST-会断开连接吗？"><a href="#在-TIME-WAIT-状态，收到-RST-会断开连接吗？" class="headerlink" title="在 TIME_WAIT 状态，收到 RST 会断开连接吗？"></a>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</h3><p>在前面我留了一个疑问，处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？<br>会不会断开，关键看 net.ipv4.tcp_rfc1337 这个内核参数（默认情况是为 0）：</p>
<ul>
<li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li>
</ul>
<p>源码处理如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684933690-82148dd1-7b3c-4b24-a2fd-350ad398297e.png#averageHue=%23282c35&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=659&amp;id=u4ced7991&amp;name=image.png&amp;originHeight=824&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48759&amp;status=done&amp;style=none&amp;taskId=ua09f9a2b-9eec-48dd-9aca-3a30882eb6d&amp;title=&amp;width=732.8" alt="image.png"><br>TIME_WAIT 状态收到 RST 报文而释放连接，这样等于跳过 2MSL 时间，这么做还是有风险。<br>sysctl_tcp_rfc1337 这个参数是在 rfc 1337 文档提出来的，目的是避免因为 TIME_WAIT 状态收到 RST 报文而跳过 2MSL 的时间，文档里也给出跳过 2MSL 时间会有什么潜在问题。<br>TIME_WAIT 状态之所以要持续 2MSL 时间，主要有两个目的：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
<p>详细的为什么要设计 TIME_WAIT 状态，我在这篇有详细说明：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247502380&amp;idx=1&amp;sn=7b82818a5fb6f1127d17f0ded550c4bd&amp;scene=21#wechat_redirect">如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？(opens new window)</a><br>所以，我个人觉得将 net.ipv4.tcp_rfc1337 设置为 1 会比较安全。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？<br>如果双方开启了时间戳机制：</p>
<ul>
<li>如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong>SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。那么就会重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。</li>
<li>如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong>SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。那么就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端</strong>。</li>
</ul>
<p>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</p>
<ul>
<li>如果 net.ipv4.tcp_rfc1337 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果 net.ipv4.tcp_rfc1337 参数为 1，则会丢掉该 RST 报文。</li>
</ul>
<p>完！</p>
<h2 id="十、TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#十、TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="十、TCP 连接，一端断电和进程崩溃有什么区别？"></a>十、TCP 连接，一端断电和进程崩溃有什么区别？</h2><p>这个属于 <strong>TCP 异常断开连接</strong>的场景。</p>
<p>这个问题有几个关键词：</p>
<ul>
<li>没有开启 keepalive；</li>
<li>一直没有数据交互；</li>
<li>进程崩溃；</li>
<li>主机崩溃；</li>
</ul>
<p>我们先来认识认识什么是 TCP keepalive 呢？<br>这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684992472-ebff6f4e-f3a0-4cf2-9c0e-a19082bff2ab.png#averageHue=%23f2f1eb&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1110&amp;id=uf1cce5ff&amp;name=image.png&amp;originHeight=1905&amp;originWidth=750&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=772822&amp;status=done&amp;style=none&amp;taskId=u5ba89bd5-2863-4edb-a2e0-77fcb3158a4&amp;title=&amp;width=437" alt="image.png"><br>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
<p>知道了 TCP keepalive 作用，我们再回过头看题目中的「主机崩溃」这种情况。<br>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么。<br>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。<br>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。<br>那题目中的「进程崩溃」的情况呢？<br>我自己做了实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。<br>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
<hr>
<p>以上就是对这个面试题的回答，接下来我们看看在「<strong>有数据传输</strong>」的场景下的一些异常情况：</p>
<ul>
<li>第一种，客户端主机宕机，又迅速重启，会发生什么？</li>
<li>第二种，客户端主机宕机，一直没有重启，会发生什么？</li>
</ul>
<p>客户端主机宕机，又迅速重启<br>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。<br>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p>
<ul>
<li>如果客户端主机上<strong>没有</strong>进程监听该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；</li>
<li>如果客户端主机上<strong>有</strong>进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
</ul>
<p>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。<br>客户端主机宕机，一直没有重启<br>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，一般就是 ETIMEOUT 状态码。<br>那具体重传几次呢？<br>在 Linux 系统中，提供一个叫 <strong>tcp_retries2 </strong>配置项，默认值是 15，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684992847-44192332-0097-4812-a164-8a389c391cbc.png#averageHue=%23f1f1f1&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uac770b39&amp;name=image.png&amp;originHeight=73&amp;originWidth=493&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8787&amp;status=done&amp;style=none&amp;taskId=u83dcce6e-9b9c-4d82-89d0-1b23434aa80&amp;title=" alt="image.png"><br>这个内核参数是控制，在 TCP 连接建立的情况下，超时重传的最大次数。<br>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「最大超时时间」来判定。<br>每一轮的超时时间都是<strong>倍数增长</strong>的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650684994943-6fb912ab-cd0a-4a45-bdce-03bcd03a976f.png#averageHue=%23f6f4f0&amp;clientId=ub5ecb47a-aa60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=465&amp;id=ue69f1220&amp;name=image.png&amp;originHeight=720&amp;originWidth=848&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=286958&amp;status=done&amp;style=none&amp;taskId=u5549d503-ba3f-408d-9476-6255c4be885&amp;title=&amp;width=548" alt="image.png"><br>内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。</p>
<p><strong>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传</strong>。</p>
<h2 id="十一、拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#十一、拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="十一、拔掉网线后， 原本的 TCP 连接还存在吗？"></a>十一、拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>今天，聊一个有趣的问题：<strong>拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？</strong><br>可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的传输层理应也会断开，所以原本的 TCP 连接就不会存在的了。就好像， 我们拨打有线电话的时候，如果某一方的电话线被拔了，那么本次通话就彻底断了。<br>真的是这样吗？<br>上面这个逻辑就有问题。问题在于，错误的认为拔掉网线这个动作会影响传输层，事实上并不会影响。<br>实际上，TCP 连接在 Linux 内核中是一个名为 struct socket 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。<br>我在我的电脑上做了个小实验，我用 ssh 终端连接了我的云服务器，然后我通过断开 wifi 的方式来模拟拔掉网线的场景，此时查看 TCP 连接的状态没有发生变化，还是处于 ESTABLISHED 状态。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653013676992-ab4a44ad-6ab7-4249-88fa-e647e003c5ff.png#averageHue=%23131f2c&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7dbfb58e&amp;name=image.png&amp;originHeight=381&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=201375&amp;status=done&amp;style=none&amp;taskId=u1c299f94-94fb-4d76-9851-f2e9bc684a7&amp;title=" alt="image.png"><br>通过上面这个实验结果，我们知道了，拔掉网线这个动作并不会影响 TCP 连接的状态。<br>接下来，要看拔掉网线后，双方做了什么动作。<br>所以， 针对这个问题，要分场景来讨论：</p>
<ul>
<li>拔掉网线后，有数据传输；</li>
<li><p>拔掉网线后，没有数据传输；</p>
<h3 id="拔掉网线后，有数据传输"><a href="#拔掉网线后，有数据传输" class="headerlink" title="拔掉网线后，有数据传输"></a>拔掉网线后，有数据传输</h3><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。<br><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。<br>此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生。<br>但是，<strong>如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。<br>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。<br>此时，客户端和服务端的 TCP 连接都已经断开了。<br>那 TCP 的数据报文具体重传几次呢？<br>在 Linux 系统中，提供了一个叫 <strong>tcp_retries2</strong> 配置项，默认值是 15，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653013676548-d09bc9d2-85bb-445b-a4e9-e70655f78164.png#averageHue=%23f1f1f1&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue57b1fd9&amp;name=image.png&amp;originHeight=73&amp;originWidth=493&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8787&amp;status=done&amp;style=none&amp;taskId=ue0416a6f-ff81-4713-a1bb-a77b7930ee4&amp;title=" alt="image.png"><br>这个内核参数是控制，在 TCP 连接建立的情况下，超时重传的最大次数。<br>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「最大超时时间」来判定。<br>每一轮的超时时间都是倍数增长的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653013677016-eb6d943a-c17d-44f2-9969-68071f681a05.png#averageHue=%23f6f4ef&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc577bb1d&amp;name=image.png&amp;originHeight=720&amp;originWidth=848&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=283008&amp;status=done&amp;style=none&amp;taskId=ue079909a-36e8-4169-ba70-bfc1e7eeaa3&amp;title=" alt="image.png"><br>内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。<br>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传，然后就会断开 TCP 连接。</p>
<h3 id="拔掉网线后，没有数据传输"><a href="#拔掉网线后，没有数据传输" class="headerlink" title="拔掉网线后，没有数据传输"></a>拔掉网线后，没有数据传输</h3><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。<br>如果<strong>没有开启</strong> TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。<br>而如果<strong>开启</strong>了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p>
</li>
<li><p>如果<strong>对端是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li>如果<strong>对端主机崩溃，或对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。<br>TCP keepalive 机制具体是怎么样的？<br>这个机制的原理是这样的：<br>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<blockquote>
<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：<br>net.ipv4.tcp_keepalive_time=7200 net.ipv4.tcp_keepalive_intvl=75   net.ipv4.tcp_keepalive_probes=9 </p>
<ul>
<li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653013676745-35e0bafd-4517-460e-8f61-4126268d65c7.png#averageHue=%23f7f7b4&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u55b130fa&amp;name=image.png&amp;originHeight=303&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25186&amp;status=done&amp;style=none&amp;taskId=u7ec09d3d-e21a-420d-9091-43312f38025&amp;title=" alt="image.png">图片<br>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。<br>TCP keepalive 机制探测的时间也太长了吧？<br>对的，是有点长。<br>TCP keepalive 是 <strong>TCP 层（内核态）</strong> 实现的，它是给所有基于 TCP 传输协议的程序一个兜底的方案。<br>实际上，我们应用层可以自己实现一套探测机制，可以在较短的时间内，探测到对方是否存活。<br>比如，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653013676805-597be1e1-b2a6-4d7f-9a20-a16f33036030.png#averageHue=%23faf6f4&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=754&amp;id=u0cf2157f&amp;name=image.png&amp;originHeight=947&amp;originWidth=708&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77981&amp;status=done&amp;style=none&amp;taskId=u52a8a481-6567-4c12-a835-890f1008adf&amp;title=&amp;width=564" alt="image.png"></p>
</blockquote>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。<br>有数据传输的情况：</p>
<ul>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。</li>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</li>
</ul>
<p>没有数据传输的情况：</p>
<ul>
<li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li>
<li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li>
</ul>
<p>除了客户端拔掉网线的场景，还有客户端「宕机和进程崩解」的两种场景。<br>第一个场景，客户端宕机这件事跟拔掉网线是一样无法被服务端的感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。<br>所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。<br>第二个场景，客户端的进程崩解后，客户端的内核就会向服务端发送 FIN 报文，<strong>与服务端进行四次挥手</strong>。<br>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。<br>完！</p>
<h2 id="十二、HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#十二、HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="十二、HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>十二、HTTPS 中 TLS 和 TCP 能同时握手吗？</h2><blockquote>
<p>前置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014980942-073036f7-4324-4a12-82db-0bcb0b7c48a4.png#averageHue=%23e5e5e5&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=824&amp;id=u1be7069b&amp;name=image.png&amp;originHeight=1112&amp;originWidth=644&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=481646&amp;status=done&amp;style=none&amp;taskId=ub77ec13e-53cd-4c1e-8571-50cdc24b5db&amp;title=&amp;width=477" alt="image.png"><br>如果是我面试遇到这样的面试官，我直接当场给他抓 HTTPS 建立过程的网络包，然后给他看，啪啪啪啪啪的打他脸。<br>比如，下面这个 TLSv1.2 的 基于 RSA 算法的四次握手过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014980808-b0fc965a-101d-4d30-b14b-1c675d328491.png#averageHue=%23275689&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u688a8961&amp;name=image.png&amp;originHeight=406&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=261683&amp;status=done&amp;style=none&amp;taskId=ubd4c105a-9d81-47f6-9cac-0c2517adada&amp;title=" alt="image.png"><br>难道不是先三次握手，再进行 TLS 四次握手吗？面试官你脸疼吗？<br>不过 TLS 握手过程的次数还得看版本。<br>TLSv1.2 握手过程基本都是需要四次，也就是需要经过 2-RTT 才能完成握手，然后才能发送请求，而 TLSv1.3 只需要 1-RTT 就能完成 TLS 握手，如下图。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014980791-96a59568-9dfd-47f4-b23f-24045f31e61b.png#averageHue=%23f7f9f4&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=393&amp;id=u7f824343&amp;name=image.png&amp;originHeight=685&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=262149&amp;status=done&amp;style=none&amp;taskId=u86e0b4f5-5ad8-41ba-be27-5fb62fa5516&amp;title=&amp;width=619" alt="image.png"><br><strong>一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行</strong>，因为 HTTPS 都是基于 TCP 传输协议实现的，得先建立完可靠的 TCP 连接才能做 TLS 握手的事情。</p>
</blockquote>
<p>那面试官说的这句「HTTPS 中的 TLS 握手过程可以同时进行三次握手」对不对呢？<br>这个场景是可能发生的，但是需要在特定的条件下才可能发生，<strong>如果没有说任何前提条件，说这句话就是在耍流氓。</strong><br>那到底什么条件下，这个场景才能发生呢？需要下面这两个条件同时满足才可以：</p>
<ul>
<li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li>
<li><strong>客户端和服务端已经完成过一次通信。</strong></li>
</ul>
<p>那具体怎么做到的呢？我们先了解些 TCP Fast Open 功能和 TLSv1.3 的特性。</p>
<h3 id="TCP-Fast-Open"><a href="#TCP-Fast-Open" class="headerlink" title="TCP Fast Open"></a>TCP Fast Open</h3><p>我们先来了解下什么是 TCP Fast Open？<br>常规的情况下，如果要使用 TCP 传输协议进行通信，则客户端和服务端通信之前，先要经过 TCP 三次握手后，建立完可靠的 TCP 连接后，客户端才能将数据发送给服务端。<br>其中，TCP 的第一次和第二次握手是不能够携带数据的，而 TCP 的第三次握手是可以携带数据的，因为这时候客户端的 TCP 连接状态已经是 ESTABLISHED，表明客户端这一方已经完成了 TCP 连接建立。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014980145-d50cc0f8-baf4-4e82-ad80-7981c191dd94.png#averageHue=%23f9f9f9&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u437a157d&amp;name=image.png&amp;originHeight=330&amp;originWidth=600&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43840&amp;status=done&amp;style=none&amp;taskId=ub247a94f-4c73-47a8-be9a-a53808714b8&amp;title=" alt="image.png"><br>就算客户端携带数据的第三次握手在网络中丢失了，客户端在一定时间内没有收到服务端对该数据的应答报文，就会触发超时重传机制，然后客户端重传该携带数据的第三次握手的报文，直到重传次数达到系统的阈值，客户端就会销毁该 TCP 连接。<br>说完常规的 TCP 连接后，我们再来看看 TCP Fast Open。<br>TCP Fast Open 是为了绕过 TCP 三次握手发送数据，在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。<br>要使用 TCP Fast Open 功能，客户端和服务端都要同时支持才会生效。<br>不过，开启了 TCP Fast Open 功能，<strong>想要绕过 TCP 三次握手发送数据，得建立第二次以后的通信过程。</strong><br>在客户端首次建立连接时的过程，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014980350-03e77a47-4df7-475b-b8d2-b25499626459.png#averageHue=%23f7f7f7&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u221004a3&amp;name=image.png&amp;originHeight=310&amp;originWidth=600&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=47615&amp;status=done&amp;style=none&amp;taskId=ubf741a19-6161-4d9c-8a9d-4b7cb695431&amp;title=" alt="image.png"><br>具体介绍：</p>
<ul>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 报文中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ul>
<p>所以，第一次客户端和服务端通信的时候，还是需要正常的三次握手流程。随后，客户端就有了 Cookie 这个东西，它可以用来向服务器 TCP 证明先前与客户端 IP 地址的三向握手已成功完成。<br>对于客户端与服务端的后续通信，客户端可以在第一次握手的时候携带应用数据，从而达到绕过三次握手发送数据的效果，整个过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014981118-1c1dc246-ecd5-472c-a85e-60cc1d89d7b7.png#averageHue=%23f8f8f8&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u364e1f39&amp;name=image.png&amp;originHeight=365&amp;originWidth=600&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53621&amp;status=done&amp;style=none&amp;taskId=u2922afa3-ec18-46df-a3c0-d78ab9f34c2&amp;title=" alt="image.png"><br>我详细介绍下这个过程：</p>
<ul>
<li>客户端发送 SYN 报文，该报文可以携带「应用数据」以及此前记录的 Cookie；</li>
<li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「应用数据」递送给对应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「应用数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li>
<li><strong>如果服务器接受了 SYN 报文中的「应用数据」，服务器可在握手完成之前发送「响应数据」，这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li>
<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「应用数据」，但如果客户端在初始的 SYN 报文中发送的「应用数据」没有被确认，则客户端将重新发送「应用数据」；</li>
<li>此后的 TCP 连接的数据传输过程和非 TCP Fast Open 的正常情况一致。</li>
</ul>
<p>所以，如果客户端和服务端同时支持 TCP Fast Open 功能，那么在完成首次通信过程后，后续客户端与服务端 的通信则可以绕过三次握手发送数据，这就减少了握手带来的 1 个 RTT 的时间消耗。</p>
<h3 id="TLSv1-3"><a href="#TLSv1-3" class="headerlink" title="TLSv1.3"></a>TLSv1.3</h3><p>说完 TCP Fast Open，再来看看 TLSv1.3。<br>在最开始的时候，我也提到 TLSv1.3 握手过程只需 1-RTT 的时间，它到整个握手过程，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014988375-5bd169da-3aaa-4430-8b16-1143df3274a2.png#averageHue=%23041a34&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue91eec5f&amp;name=image.png&amp;originHeight=570&amp;originWidth=585&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57350&amp;status=done&amp;style=none&amp;taskId=u8f8f052d-5d3a-42a6-a9ee-0a3338a9671&amp;title=" alt="image.png"><br>TCP 连接的第三次握手是可以携带数据的，如果客户端在第三次握手发送了 TLSv1.3 第一次握手数据，是不是就表示「<em>HTTPS 中的 TLS 握手过程可以同时进行三次握手</em>」？。<br>不是的，因为服务端只有在收到客户端的 TCP 的第三次握手后，才能和客户端进行后续 TLSv1.3 握手。<br>TLSv1.3 还有个更厉害到地方在于<strong>会话恢复</strong>机制，在<strong>重连 TLvS1.3 只需要 0-RTT</strong>，用“pre_shared_key”和“early_data”扩展，在 TCP 连接后立即就建立安全连接发送加密消息，过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653014988645-d698ec43-f723-443c-b2b8-4485c35bbcc2.png#averageHue=%23f7f7f7&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=346&amp;id=u6ee1d823&amp;name=image.png&amp;originHeight=557&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=85510&amp;status=done&amp;style=none&amp;taskId=u7d16ec43-4ea5-44b4-b05b-5e947ea9607&amp;title=&amp;width=671" alt="image.png"></p>
<h3 id="TCP-Fast-Open-TLSv1-3"><a href="#TCP-Fast-Open-TLSv1-3" class="headerlink" title="TCP Fast Open + TLSv1.3"></a>TCP Fast Open + TLSv1.3</h3><p>在前面我们知道，客户端和服务端同时支持 TCP Fast Open 功能的情况下，<strong>在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据。</strong><br>如果 HTTPS 的 TLS 版本是 1.3，那么 TLS 过程只需要 1-RTT。<br><strong>因此如果「TCP Fast Open + TLSv1.3」情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的。</strong><br><strong>如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握手过程是可以同时进行的，而且 HTTP 请求也可以在这期间内一同完成。</strong></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>最后做个总结。<br>「HTTPS 是先进行 TCP 三次握手，再进行 TLSv1.2 四次握手」，这句话一点问题都没有，怀疑这句话是错的人，才有问题。<br>「HTTPS 中的 TLS 握手过程可以同时进行三次握手」，这个场景是可能存在到，但是在没有说任何前提条件，而说这句话就等于耍流氓。需要下面这两个条件同时满足才可以：</p>
<ul>
<li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li>
<li><p><strong>客户端和服务端已经完成过一次通信；</strong></p>
<h2 id="十三、TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#十三、TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="十三、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>十三、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015223369-68f66620-b9c2-4dfa-8fa1-c499efd1b750.png#averageHue=%23e8e8e7&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0795fabf&amp;name=image.png&amp;originHeight=382&amp;originWidth=607&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=146986&amp;status=done&amp;style=none&amp;taskId=u0fdb582a-059b-4a6b-8506-9a0026a5b13&amp;title=" alt="image.png"><br>大致问题是，<strong>TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</strong><br>这是个好问题，应该有不少人都会搞混，因为这两个东西看上去太像了，很容易误以为是同一个东西。<br>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p>
</li>
<li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p>
</li>
<li>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</li>
</ul>
<p>接下来，分别说说它们。</p>
<h3 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h3><ul>
<li>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</li>
<li>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015223235-b136c390-1619-4a09-a6c7-1f2c32e1a132.png#averageHue=%23f9f2ec&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=473&amp;id=u49883dfa&amp;name=image.png&amp;originHeight=722&amp;originWidth=386&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=47822&amp;status=done&amp;style=none&amp;taskId=u0ee89f92-37c2-4575-88b3-49aa1cb3abe&amp;title=&amp;width=253" alt="image.png"><br>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>。</p>
<p>这样实在太累人了，一次连接只能请求一次资源。<br>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？<br>当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015223280-dff21a88-1938-437f-b067-9efdfa4b48c9.png#averageHue=%23faf6f1&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3b7b8813&amp;name=image.png&amp;originHeight=1067&amp;originWidth=386&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61840&amp;status=done&amp;style=none&amp;taskId=uc56e599a-ae80-40a2-8741-2daf69f872a&amp;title=" alt="image.png"><br>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。<br>怎么才能使用 HTTP 的 Keep-Alive 功能？<br>在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：<br>Connection: Keep-Alive<br>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：<br>Connection: Keep-Alive<br>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。<br><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive</strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：<br>Connection:close<br>现在大多数浏览器都默认是使用 HTTP/1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。<br>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong>技术提供了可实现的基础。<br>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。<br>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015229197-47d912a8-a9ce-46c3-916c-8357182449a5.png#averageHue=%23fbf7f3&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=593&amp;id=u7bc6687e&amp;name=image.png&amp;originHeight=1025&amp;originWidth=926&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=121263&amp;status=done&amp;style=none&amp;taskId=u946479b5-9be4-4a62-be76-ed93f676bcc&amp;title=&amp;width=536" alt="image.png"><br>但是<strong>服务器还是按照顺序响应</strong>，先回应 A 请求，完成后再回应 B 请求。<br>而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。<br>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？<br>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供<strong> keepalive_timeout</strong> 参数，用来指定 HTTP 长连接的超时时间。<br>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015238130-5fc11c9d-bda4-406d-bb3c-079441f5efab.png#averageHue=%23f9f6f4&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=781&amp;id=u0b25fe8d&amp;name=image.png&amp;originHeight=947&amp;originWidth=708&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=76882&amp;status=done&amp;style=none&amp;taskId=u48cad40e-be43-453d-a2c9-58293065759&amp;title=&amp;width=584" alt="image.png"></p>
<h3 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h3><p>TCP 的 Keepalive 这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。<br>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015238186-2da88f6d-79ca-473c-be03-d25e406f3113.png#averageHue=%23fbfaf8&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=582&amp;id=uded7d232&amp;name=image.png&amp;originHeight=810&amp;originWidth=833&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=67650&amp;status=done&amp;style=none&amp;taskId=u55573612-28e4-45c1-852b-e1e25b8bd96&amp;title=&amp;width=599.0000610351562" alt="image.png"><br>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。<br>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p>
<h2 id="十四、TCP-协议有什么缺陷？"><a href="#十四、TCP-协议有什么缺陷？" class="headerlink" title="十四、TCP 协议有什么缺陷？"></a>十四、TCP 协议有什么缺陷？</h2><p>写的多了后，忽然思考一个问题，TCP 通过序列号、确认应答、超时重传、流量控制、拥塞控制等方式实现了可靠传输，看起来它很完美，事实真的是这样吗？TCP 就没什么缺陷吗？<br>所以，今天就跟大家聊聊，TCP 协议有哪些缺陷？主要有四个方面：</p>
<ul>
<li>升级 TCP 的工作很困难；</li>
<li>TCP 建立连接的延迟；</li>
<li>TCP 存在队头阻塞问题；</li>
<li>网络迁移需要重新建立 TCP 连接；</li>
</ul>
<p>接下来，针对这四个方面详细说一下。</p>
<h3 id="升级-TCP-的工作很困难"><a href="#升级-TCP-的工作很困难" class="headerlink" title="升级 TCP 的工作很困难"></a>升级 TCP 的工作很困难</h3><ul>
<li>TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核。而升级内核这个工作是很麻烦的事情，麻烦的事情不是说升级内核这个操作很麻烦，而是由于内核升级涉及到底层软件和运行库的更新，我们的服务程序就需要回归测试是否兼容新的内核版本，所以服务器的内核升级也比较保守和缓慢。</li>
<li>很多 TCP 协议的新特性，都是需要客户端和服务端同时支持才能生效的，比如 TCP Fast Open 这个特性，虽然在2013 年就被提出了，但是 Windows 很多系统版本依然不支持它，这是因为 PC 端的系统升级滞后很严重，W indows Xp 现在还有大量用户在使用，尽管它已经存在快 20 年。所以，即使 TCP 有比较好的特性更新，也很难快速推广，用户往往要几年或者十年才能体验到。<h3 id="TCP-建立连接的延迟"><a href="#TCP-建立连接的延迟" class="headerlink" title="TCP 建立连接的延迟"></a>TCP 建立连接的延迟</h3>基于 TCP 实现的应用协议，都是需要先建立三次握手才能进行数据传输，比如 HTTP 1.0/1.1、HTTP/2、HTTPS。</li>
</ul>
<p>现在大多数网站都是使用 HTTPS 的，这意味着在 TCP 三次握手之后，还需要经过 TLS 四次握手后，才能进行 HTTP 数据的传输，这在一定程序上增加了数据传输的延迟。<br>TCP 三次握手和 TLS 握手延迟，如图：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1653015396604-ae4639bd-493e-4a03-91e5-e4f318368f95.gif#averageHue=%23f6f2ed&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=516&amp;id=u42f7e022&amp;originHeight=693&amp;originWidth=777&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u302e127b-8b9d-4ad0-9180-87ac842b171&amp;title=&amp;width=579" alt=""><br>TCP 三次握手的延迟被 TCP Fast Open （快速打开）这个特性解决了，这个特性可以在「第二次建立连接」时减少 TCP 连接建立的时延。</p>
<p>还有一点，针对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。<br>也正是 TCP 是在内核实现的，所以 TLS 是无法对 TCP 头部加密的，这意味着 TCP 的序列号都是明文传输，所以就存安全的问题。</p>
<h3 id="TCP-存在队头阻塞问题"><a href="#TCP-存在队头阻塞问题" class="headerlink" title="TCP 存在队头阻塞问题"></a>TCP 存在队头阻塞问题</h3><p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。</p>
<blockquote>
<p>如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/21371548/1653015396605-c74b64a3-debc-4f43-84d5-f9d54febc96d.gif#averageHue=%23f6f4f3&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u11d4f2e9&amp;originHeight=502&amp;originWidth=521&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucfbc39dd-357a-4bc8-83a9-2dab4af7f5f&amp;title=" alt=""><br>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据。<br>这就是 TCP 队头阻塞问题，但这也不能怪 TCP ，因为只有这样做才能保证数据的有序性。</p>
</blockquote>
<p>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求，所以 HTTP/2 队头阻塞问题就是因为 TCP 协议导致的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015398784-2436db41-72f9-4afa-b65f-4451c52da937.png#averageHue=%23f8f7f4&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3d6226f7&amp;name=image.png&amp;originHeight=377&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=191678&amp;status=done&amp;style=none&amp;taskId=u077fd1f6-b308-4a9b-85b2-c524c423058&amp;title=" alt="image.png"></p>
<h3 id="网络迁移需要重新建立-TCP-连接"><a href="#网络迁移需要重新建立-TCP-连接" class="headerlink" title="网络迁移需要重新建立 TCP 连接"></a>网络迁移需要重新建立 TCP 连接</h3><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653015396597-46bb7bcd-11fd-4327-aff0-692571cdf222.png#averageHue=%23f1d6b8&amp;clientId=u4c6ab8ca-2b4c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1809f45f&amp;originHeight=228&amp;originWidth=821&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d33483c-b5e3-491d-82ce-edda7748aec&amp;title=" alt=""><br>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。<br>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>我记得之前在群里看到，有位读者字节一面的时候被问到：「<strong>如何基于 UDP 协议实现可靠传输？</strong>」<br>很多同学第一反应就会说把 TCP 可靠传输的特性（序列号、确认应答、超时重传、流量控制、拥塞控制）在应用层实现一遍。<br>实现的思路确实这样没错，但是有没有想过，<strong>既然 TCP 天然支持可靠传输，为什么还需要基于 UDP 实现可靠传输呢？这不是重复造轮子吗？</strong><br>所以，我们要先弄清楚 TCP 协议有哪些痛点？而这些痛点是否可以在基于 UDP 协议实现的可靠传输协议中得到改进？<br>现在市面上已经有基于 UDP 协议实现的可靠传输协议的成熟方案了，那就是 QUIC 协议，<strong>QUIC 协议把我本文说的 TCP 的缺点都给解决了</strong>，而且已经应用在了 HTTP/3。</p>
<h2 id="十五、TCP-和-UDP-可以使用同一个端口吗？"><a href="#十五、TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="十五、TCP 和 UDP 可以使用同一个端口吗？"></a>十五、TCP 和 UDP 可以使用同一个端口吗？</h2><p>大家好，我是小林。<br>之前有读者在字节面试的时候，被问到：<strong>TCP 和 UDP 可以同时监听相同的端口吗？</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507775428-34acef40-df65-4dc1-a43c-dedb20d76b75.png#averageHue=%23f5f5f5&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u008e047c&amp;name=image.png&amp;originHeight=198&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61520&amp;status=done&amp;style=none&amp;taskId=u6ef64458-90b7-4ce9-9127-0265712cbe3&amp;title=" alt="image.png"><br>关于端口的知识点，还是挺多可以讲的，比如还可以牵扯到这几个问题：</p>
<ul>
<li>多个 TCP 服务进程可以同时绑定同一个端口吗？</li>
<li>重启 TCP 服务进程时，为什么会出现“Address in use”的报错信息？又该怎么避免？</li>
<li>客户端的端口可以重复使用吗？</li>
<li>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</li>
</ul>
<p>所以，这次就跟大家盘一盘这些问题。</p>
<h3 id="TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗？"></a>TCP 和 UDP 可以同时绑定相同的端口吗？</h3><p>其实我感觉这个问题「TCP 和 UDP 可以同时监听相同的端口吗？」表述有问题，这个问题应该表述成「<strong>TCP 和 UDP 可以同时绑定相同的端口吗？</strong>」<br>因为「监听」这个动作是在 TCP 服务端网络编程中才具有的，而 UDP 服务端网络编程中是没有「监听」这个动作的。<br>TCP 和 UDP 服务端网络相似的一个地方，就是会调用 bind 绑定端口。<br>给大家贴一下 TCP 和 UDP 网络编程的区别就知道了。<br>TCP 网络编程如下，服务端执行 listen() 系统调用就是监听端口的动作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507776266-fb931d68-c04a-40f5-ae07-37ba6979ee81.png#averageHue=%23f4e9c1&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uecfcc0fe&amp;name=image.png&amp;originHeight=722&amp;originWidth=407&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84384&amp;status=done&amp;style=none&amp;taskId=u2e0f1917-1894-4649-aede-d460ac6d325&amp;title=" alt="image.png"><br>UDP 网络编程如下，服务端是没有监听这个动作的，只有执行 bind() 系统调用来绑定端口的动作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507775560-5621ad7c-2eaa-4417-9b4b-65f7f78abf9d.png#averageHue=%2323241a&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uf65a9690&amp;name=image.png&amp;originHeight=396&amp;originWidth=464&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65984&amp;status=done&amp;style=none&amp;taskId=ucdaf3cc7-4df0-4fc1-900a-5c13af57767&amp;title=" alt="image.png"><br>TCP 和 UDP 可以同时绑定相同的端口吗？<br>答案：<strong>可以的</strong>。<br>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。<br>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。<br>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。<br>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507776249-330e2330-975e-4da9-9cf2-f49bec2d52e8.png#averageHue=%23dddbc8&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=665&amp;id=uc9463f65&amp;name=image.png&amp;originHeight=1197&amp;originWidth=952&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=381631&amp;status=done&amp;style=none&amp;taskId=u6067bfe3-caaf-4559-80cc-c178b782ac6&amp;title=&amp;width=529.0000610351562" alt="image.png"><br>因此， TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。<br>验证结果<br>我简单写了 TCP 和 UDP 服务端的程序，它们都绑定同一个端口号 8888。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507775886-ec123d56-9114-4438-bdc5-9df152e8d1ba.png#averageHue=%23f1f0f0&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc51d58c5&amp;name=image.png&amp;originHeight=878&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=427085&amp;status=done&amp;style=none&amp;taskId=uae7564e9-060f-497a-91dc-dc25db64554&amp;title=" alt="image.png"><br>运行这两个程序后，通过 netstat 命令可以看到，TCP 和 UDP 是可以同时绑定同一个端口号的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507776898-2c827c7f-4840-4ff0-b6b5-ab4b964d04b2.png#averageHue=%2313161d&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0e426289&amp;name=image.png&amp;originHeight=85&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79337&amp;status=done&amp;style=none&amp;taskId=ucc06f113-dee9-4f47-a96c-a27fc304b85&amp;title=" alt="image.png"></p>
<h3 id="多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗？"></a>多个 TCP 服务进程可以绑定同一个端口吗？</h3><p>还是以前面的 TCP 服务端程序作为例子，启动两个同时绑定同一个端口的 TCP 服务进程。<br>运行第一个 TCP 服务进程之后，netstat 命令可以查看，8888 端口已经被一个 TCP 服务进程绑定并监听了，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507777012-f8b12067-7132-496b-8fba-79139bfd6ed3.png#averageHue=%2314171e&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u401a0351&amp;name=image.png&amp;originHeight=50&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49643&amp;status=done&amp;style=none&amp;taskId=u4b1e9c81-bde1-48eb-a484-3986fe07ffd&amp;title=" alt="image.png"><br>接着，运行第二个 TCP 服务进程的时候，就报错了“Address already in use”，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507777365-24f2d7a3-093f-4125-bf37-9d582d56bb5e.png#averageHue=%230f121a&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uece1ab47&amp;name=image.png&amp;originHeight=84&amp;originWidth=760&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62714&amp;status=done&amp;style=none&amp;taskId=u02c237b7-ed41-4898-9e61-6f85f2a372a&amp;title=" alt="image.png"><br>我上面的测试案例是两个 TCP 服务进程同时绑定地址和端口是：0.0.0.0 地址和8888端口，所以才出现的错误。<br>如果两个 TCP 服务进程绑定的 IP 地址不同，而端口相同的话，也是可以绑定成功的，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507778013-24b34fe6-8d3c-4fa8-af95-fc25f07e1e05.png#averageHue=%2313161d&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udb308949&amp;name=image.png&amp;originHeight=71&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=73343&amp;status=done&amp;style=none&amp;taskId=u6f3cd450-84cf-43a5-b343-0f6646e719c&amp;title=" alt="image.png"><br>所以，默认情况下，针对「多个 TCP 服务进程可以绑定同一个端口吗？」这个问题的答案是：<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。<br>注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。<br>这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。<br><strong>TIP</strong><br>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性），本文不对 SO_REUSEPORT 做具体介绍，感兴趣的同学自行去学习。<br>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？<br>TCP 服务进程需要绑定一个 IP 地址和一个端口，然后就监听在这个地址和端口上，等待客户端连接的到来。<br>然后在实践中，我们可能会经常碰到一个问题，当 TCP 服务进程重启之后，总是碰到“Address in use”的报错信息，TCP 服务进程不能很快地重启，而是要过一会才能重启成功。<br>这是为什么呢？<br>当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507779325-0b28ca1e-7207-4976-ba66-66a5eabed18a.png#averageHue=%23f5e7cc&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=589&amp;id=u57336329&amp;name=image.png&amp;originHeight=1031&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=366239&amp;status=done&amp;style=none&amp;taskId=uf2b189cc-a0b3-439a-888d-63739eb8ad5&amp;title=&amp;width=617.0000610351562" alt="image.png"><br><strong>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误</strong>。<br>而等 TIME_WAIT 状态的连接结束后，重启 TCP 服务进程就能成功。<br>重启 TCP 服务进程时，如何避免“Address in use”的报错信息？<br>我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure><br>因为 SO_REUSEADDR 作用是<strong>：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功。</strong><br>举个例子，服务端有个监听 0.0.0.0 地址和 8888 端口的 TCP 服务进程。‍<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507780631-05874cf3-82fb-41c4-bd9b-58344f1f3da7.png#averageHue=%2314171e&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u16fb8cde&amp;name=image.png&amp;originHeight=50&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49643&amp;status=done&amp;style=none&amp;taskId=u4f341515-4a53-4768-8590-9b0f8f4312b&amp;title=" alt="image.png"><br>有个客户端（IP地址：192.168.1.100）已经和服务端（IP 地址：172.19.11.200）建立了 TCP 连接，那么在 TCP 服务进程重启时，服务端会与客户端经历四次挥手，服务端的 TCP 连接会短暂处于 TIME_WAIT 状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端地址:端口           服务端地址:端口        TCP 连接状态</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>:<span class="number">37272</span>     <span class="number">172.19</span><span class="number">.11</span><span class="number">.200</span>:<span class="number">8888</span>    TIME_WAI</span><br></pre></td></tr></table></figure><br>如果 TCP 服务进程没有对 socket 设置 SO_REUSEADDR 属性，那么在重启时，由于存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，那么在执行 bind() 函数的时候，就会返回了 Address already in use 的错误。<br>如果 TCP 服务进程对 socket 设置 SO_REUSEADDR 属性了，那么在重启时，即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。<br>因此，在所有 TCP 服务器程序中，调用 bind 之前最好对 socket 设置 SO_REUSEADDR 属性，这不会产生危害，相反，它会帮助我们在很快时间内重启服务端程序。‍<br><strong>前面我提到过这个问题：</strong>如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。<br>这个问题也可以由 SO_REUSEADDR 解决，因为它的<strong>另外一个作用是：**</strong>绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。**<br>比如，0.0.0.0:8888 和192.168.1.100:8888，虽然逻辑意义上前者包含了后者，但是 0.0.0.0 泛指所有本地 IP，而 192.168.1.100 特指某一IP，两者并不是完全相同，所以在对 socket 设置 SO_REUSEADDR 属性后，那么执行 bind() 时候就会绑定成功。</p>
<h3 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h3><p>客户端在执行 connect 函数的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507781329-2ec6b2b6-6aa2-4987-9357-b280551173e8.png#averageHue=%23fcfbf0&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubd1db415&amp;name=image.png&amp;originHeight=915&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=229314&amp;status=done&amp;style=none&amp;taskId=ua040c1e0-944b-4094-b99c-fa68f8a14ab&amp;title=" alt="image.png"><br>所以，客户端的端口选择的发生在 connect 函数，内核在选择端口的时候，会从 net.ipv4.ip_local_port_range 这个内核参数指定的范围来选取一个端口作为客户端端口。<br>该参数的默认值是 32768 61000，意味着端口总可用的数量是 61000 - 32768 = 28232 个。<br>当客户端与服务端完成 TCP 连接建立后，我们可以通过 netstat 命令查看 TCP 连接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -napt</span><br><span class="line">协议  源ip地址:端口            目的ip地址：端口         状态</span><br><span class="line">tcp  <span class="number">192.168</span><span class="number">.110</span><span class="number">.182</span><span class="number">.64992</span>   <span class="number">117.147</span><span class="number">.199</span><span class="number">.51</span><span class="number">.443</span>     ESTABLISHED</span><br></pre></td></tr></table></figure><br>那问题来了，上面客户端已经用了 64992 端口，那么还可以继续使用该端口发起连接吗？<br>这个问题，很多同学都会说不可以继续使用该端口了，如果按这个理解的话， 默认情况下客户端可以选择的端口是 28232 个，那么意味着客户端只能最多建立 28232 个 TCP 连接，如果真是这样的话，那么这个客户端并发连接也太少了吧，所以这是错误理解。<br>正确的理解是，<strong>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</strong><br>比如下面这张图，有 2 个 TCP 连接，左边是客户端，右边是服务端，客户端使用了相同的端口 50004 与两个服务端建立了 TCP 连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507781475-2532ca35-e276-4f83-833a-e574b7c1553f.png#averageHue=%23282828&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5881bd3b&amp;name=image.png&amp;originHeight=125&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=83518&amp;status=done&amp;style=none&amp;taskId=u64b17c69-9050-4de4-acc3-e1cd06c5b4c&amp;title=" alt="image.png"><br>仔细看，上面这两条 TCP 连接的四元组信息中的「目的 IP 地址」是不同的，一个是 180.101.49.12 ，另外一个是 180.101.49.11。<br>多个客户端可以 bind 同一个端口吗？<br>bind 函数虽然常用于服务端网络编程中，但是它也是用于客户端的。<br>前面我们知道，客户端是在调用 connect 函数的时候，由内核随机选取一个端口作为连接的端口。<br>而如果我们想自己指定连接的端口，就可以用 bind 函数来实现：客户端先通过 bind 函数绑定一个端口，然后调用 connect 函数就会跳过端口选择的过程了，转而使用 bind 时确定的端口。<br>针对这个问题：多个客户端可以 bind 同一个端口吗？<br>要看多个客户端绑定的 IP + PORT 是否都相同，如果都是相同的，那么在执行 bind() 时候就会出错，错误是“Address already in use”。<br>如果一个绑定在 192.168.1.100:6666，一个绑定在 192.168.1.200:6666，因为 IP 不相同，所以执行 bind() 的时候，能正常绑定。<br>所以， 如果多个客户端同时绑定的 IP 地址和端口都是相同的，那么执行 bind() 时候就会出错，错误是“Address already in use”。<br>一般而言，客户端不建议使用 bind 函数，应该交由 connect 函数来选择端口会比较好，因为客户端的端口通常都没什么意义。<br>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？<br>针对这个问题要看，客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。<br>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。<br>但是，<strong>因为只要客户端连接的服务器不同，端口资源可以重复使用的</strong>。<br>所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的（当然这个过程还会受限于其他资源，比如文件描述符、内存、CPU 等）。<br>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？<br>前面我们提到，如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。<br>针对这个问题，也是有解决办法的，那就是打开 net.ipv4.tcp_tw_reuse 这个内核参数。<br><strong>因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</strong><br>举个例子，假设客户端已经与服务器建立了一个 TCP 连接，并且这个状态处于 TIME_WAIT 状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端地址:端口           服务端地址:端口         TCP 连接状态</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>:<span class="number">2222</span>      <span class="number">172.19</span><span class="number">.11</span><span class="number">.21</span>:<span class="number">8888</span>     TIME_WAIT</span><br></pre></td></tr></table></figure><br>然后客户端又与该服务器（172.19.11.21:8888）发起了连接，<strong>在调用 connect 函数时，内核刚好选择了 2222 端口，接着发现已经被相同四元组的连接占用了：</strong></p>
<ul>
<li>如果<strong>没有开启</strong> net.ipv4.tcp_tw_reuse 内核参数，那么内核就会选择下一个端口，然后继续判断，直到找到一个没有被相同四元组的连接使用的端口， 如果端口资源耗尽还是没找到，那么 connect 函数就会返回错误。</li>
<li>如果<strong>开启</strong>了 net.ipv4.tcp_tw_reuse 内核参数，就会判断该四元组的连接状态是否处于 TIME_WAIT 状态，<strong>如果连接处于 TIME_WAIT 状态并且该状态持续的时间超过了 1 秒，那么就会重用该连接</strong>，于是就可以使用 2222 端口了，这时 connect 就会返回成功。</li>
</ul>
<p>再次提醒一次，开启了 net.ipv4.tcp_tw_reuse 内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用，所以在服务端开启这个参数是没有效果的。<br>客户端端口选择的流程总结<br>至此，我们已经把客户端在执行 connect 函数时，内核选择端口的情况大致说了一遍，为了让大家更明白客户端端口的选择过程，我画了一流程图。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1659507782182-5ae43043-bce1-4f92-9368-c845b61f5427.png#averageHue=%23fbf8f8&amp;clientId=u45feb1e7-5ce6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1183&amp;id=u7670d086&amp;name=image.png&amp;originHeight=3400&amp;originWidth=1549&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=823549&amp;status=done&amp;style=none&amp;taskId=ua60241d0-c953-4a70-b781-d1406483418&amp;title=&amp;width=539.0000610351562" alt="image.png"></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>TCP 和 UDP 可以同时绑定相同的端口吗？<br>可以的。<br>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。<br>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。<br>因此， TCP/UDP 各自的端口号也相互独立，互不影响。<br>多个 TCP 服务进程可以同时绑定同一个端口吗？<br>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。<br>如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。<br>如何解决服务端重启时，报错“Address already in use”的问题？<br>当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。<br>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。<br>要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。<br>这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。<br>客户端的端口可以重复使用吗？<br>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。<br>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。<br>所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。<br>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？<br>要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。<br>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。<br>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？<br>打开 net.ipv4.tcp_tw_reuse 这个内核参数。<br>因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。<br>如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</p>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="1-DNS-的解析过程？"><a href="#1-DNS-的解析过程？" class="headerlink" title="1.DNS 的解析过程？"></a>1.DNS 的解析过程？</h3><ol>
<li>浏览器搜索<strong>自己的DNS缓存</strong></li>
<li>若没有，则搜索<strong>操作系统中的DNS缓存和hosts文件</strong></li>
<li>若没有，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向<strong>根域名服务器、顶级域名服务器、权限域名服务器</strong>发起查询请求，最终返回IP地址给本地域名服务器</li>
<li>本地域名服务器将得到的IP地址返回给<strong>操作系统</strong>，同时自己也<strong>将IP地址缓存起来</strong></li>
<li>操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来</li>
<li>浏览器得到域名对应的IP地址<h3 id="如何解决udp不丢包问题"><a href="#如何解决udp不丢包问题" class="headerlink" title="如何解决udp不丢包问题"></a>如何解决udp不丢包问题</h3><a target="_blank" rel="noopener" href="https://blog.csdn.net/GoodLinGL/article/details/116780880">https://blog.csdn.net/GoodLinGL/article/details/116780880</a><h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><a target="_blank" rel="noopener" href="https://github.com/Zeb-D/my-review/blob/master/network/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90--TCP%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85.md">https://github.com/Zeb-D/my-review/blob/master/network/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90—TCP%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85.md</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">FettersLove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/09/%E8%AE%A1%E7%BD%91/TCP_IP%E7%AF%87/">http://example.com/2022/08/09/%E8%AE%A1%E7%BD%91/TCP_IP%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FettersLoveの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110180115.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FettersLove</div><div class="author-info__description">从来没憎恨过谁，只是想成为最强的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FettersLove"><i></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fetterslove-blog" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fetterslove2y@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">一、TCP 三次握手与四次挥手面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0TCP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">ⅠTCP基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">TCP头部格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TCP-%E5%8D%8F%E8%AE%AE%EF%BC%9F-TCP-%E2%BC%AF%E4%BD%9C%E5%9C%A8%E5%93%AA%E2%BC%80%E5%B1%82%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">什么是 TCP ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">什么是 TCP 连接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">如何唯一确定一个 TCP 连接呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA-IP-%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E5%90%AC%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%AE%83%E7%9A%84-TCP-%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%8AUDP-%E5%92%8C-TCP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%E6%98%AF%EF%BC%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">✊UDP 和 TCP 有什么区别呢？分别的应⽤场景是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-UDP-%E5%A4%B4%E9%83%A8%E6%B2%A1%E6%9C%89%E3%80%8C%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6%E3%80%8D%E5%AD%97%E6%AE%B5%EF%BC%8C%E8%80%8C-TCP-%E5%A4%B4%E9%83%A8%E6%9C%89%E3%80%8C%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6%E3%80%8D%E5%AD%97%E6%AE%B5%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1-TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">Ⅱ TCP连接建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">①TCP三次握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%8A%E2%91%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E2%BC%BF%EF%BC%9F%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">✊②为什么是三次握⼿？不是两次、四次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">③为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%91%8C%E2%91%A3%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7-ISN-%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%8F%E6%9C%BA%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">👌④初始序列号 ISN 是如何随机产生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%8A%E2%91%A4%E6%97%A2%E7%84%B6-IP-%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81-MSS-%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">✊⑤既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">⑥握手丢失的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">a.第一次握手丢失了，会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">b.第二次握手丢失了，会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">c.第三次握手丢失了，会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6-%E4%BB%80%E4%B9%88%E6%98%AF-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.2.7.</span> <span class="toc-text">⑦ 什么是 SYN 攻击？如何避免 SYN 攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%A2%9E%E5%A4%A7%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">方式一：增大半连接队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%BC%80%E5%90%AF-tcp-syncookies-%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">方式二：开启 tcp_syncookies 功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%87%8F%E5%B0%91-SYN-ACK-%E9%87%8D%E4%BC%A0%E6%AC%A1%E6%95%B0"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">方式三：减少 SYN+ACK 重传次数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7-TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.2.8.</span> <span class="toc-text">⑧ TCP半连接队列与全连接队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">a: 什么是 TCP 半连接队列和全连接队列？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%AE%9E%E6%88%98-TCP-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">b: 实战 - TCP 全连接队列溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E5%AE%9E%E6%88%98-TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">c: 实战 - TCP 半连接队列溢出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8TCP-%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.9.</span> <span class="toc-text">⑨TCP 快速建立连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2TCP%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80"><span class="toc-number">1.3.</span> <span class="toc-text">ⅢTCP连接断开</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E2%BC%BF%E8%BF%87%E7%A8%8B%E5%92%8C%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">①TCP 四次挥⼿过程和状态变迁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E2%BC%BF%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">②为什么挥⼿需要四次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.3.3.</span> <span class="toc-text">③握手丢失的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">a.第一次挥手丢失了，会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">b.第二次挥手丢失了，会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">c.第三次挥手丢失了，会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">d.第四次挥手丢失了，会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%8A%E2%91%A3timewait%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">✊④timewait相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2MSL%EF%BC%9F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">a:为什么 TIME_WAIT 等待的时间是 2MSL？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F%EF%BC%88%E7%BB%93%E5%90%885-gt-5-2tcp%E4%BC%98%E5%8C%96-gt-timewait%EF%BC%89"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">b:为什么需要 TIME_WAIT 状态？（结合5-&gt;5.2tcp优化-&gt;timewait）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%F0%9F%91%8CTIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">c:👌TIME_WAIT 过多有什么危害？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%F0%9F%91%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-TIME-WAIT%EF%BC%9F-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">d:👌如何优化 TIME_WAIT？(了解)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-tcp-tw-reuse-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">e:tcp_tw_reuse 为什么默认是关闭的？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tcp-tw-reuse-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.4.5.1.</span> <span class="toc-text">tcp_tw_reuse 是什么？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-tcp-tw-reuse-%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.4.5.2.</span> <span class="toc-text">为什么 tcp_tw_reuse 默认是关闭的？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">⑤如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">⑥如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A3Socket%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.</span> <span class="toc-text">ⅣSocket通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E9%92%88%E5%AF%B9-TCP-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95-Socket-%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">①针对 TCP 应该如何 Socket 编程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%91%8C%E2%91%A1listen-%E6%97%B6%E5%80%99%E5%8F%82%E6%95%B0-backlog-%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">👌②listen 时候参数 backlog 的意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2accept-%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%93%AA%E4%B8%80%E6%AD%A5%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">③accept 发生在三次握手的哪一步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8-close-%E4%BA%86%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%96%AD%E5%BC%80%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">④客户端调用 close 了，连接是断开的流程是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TCP-%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">二、TCP 重传、滑动窗口、流量控制、拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Ⅰ重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">①超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">② 快速重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-SACK-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">③ SACK 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-Duplicate-SACK"><span class="toc-number">2.1.4.</span> <span class="toc-text">④ Duplicate SACK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">Ⅱ滑动窗口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%98%AF%E5%B7%B2%E5%8F%91%E9%80%81%E5%B9%B6%E6%94%B6%E5%88%B0-ACK%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A1-31-%E5%AD%97%E8%8A%82"><span class="toc-number"></span> <span class="toc-text">1 是已发送并收到 ACK确认的数据：1~31 字节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%98%AF%E5%B7%B2%E5%8F%91%E9%80%81%E4%BD%86%E6%9C%AA%E6%94%B6%E5%88%B0-ACK%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A32-45-%E5%AD%97%E8%8A%82"><span class="toc-number"></span> <span class="toc-text">2 是已发送但未收到 ACK确认的数据：32~45 字节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%98%AF%E6%9C%AA%E5%8F%91%E9%80%81%E4%BD%86%E6%80%BB%E5%A4%A7%E5%B0%8F%E5%9C%A8%E6%8E%A5%E6%94%B6%E6%96%B9%E5%A4%84%E7%90%86%E8%8C%83%E5%9B%B4%E5%86%85%EF%BC%88%E6%8E%A5%E6%94%B6%E6%96%B9%E8%BF%98%E6%9C%89%E7%A9%BA%E9%97%B4%EF%BC%89%EF%BC%9A46-51%E5%AD%97%E8%8A%82"><span class="toc-number"></span> <span class="toc-text">3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%98%AF%E6%9C%AA%E5%8F%91%E9%80%81%E4%BD%86%E6%80%BB%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E6%8E%A5%E6%94%B6%E6%96%B9%E5%A4%84%E7%90%86%E8%8C%83%E5%9B%B4%EF%BC%88%E6%8E%A5%E6%94%B6%E6%96%B9%E6%B2%A1%E6%9C%89%E7%A9%BA%E9%97%B4%EF%BC%89%EF%BC%9A52%E5%AD%97%E8%8A%82%E4%BB%A5%E5%90%8E"><span class="toc-number"></span> <span class="toc-text">4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-2-%E6%98%AF%E5%B7%B2%E6%88%90%E5%8A%9F%E6%8E%A5%E6%94%B6%E5%B9%B6%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E7%AD%89%E5%BE%85%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%8F%96%EF%BC%89%EF%BC%9B"><span class="toc-number"></span> <span class="toc-text">1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%98%AF%E6%9C%AA%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BD%86%E5%8F%AF%E4%BB%A5%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9B"><span class="toc-number"></span> <span class="toc-text">3 是未收到数据但可以接收的数据；</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%AA%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9B"><span class="toc-number"></span> <span class="toc-text">4 未收到数据并不可以接收的数据；</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">0.1.</span> <span class="toc-text">Ⅲ流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">0.1.1.</span> <span class="toc-text">操作系统缓冲区与滑动窗口的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="toc-number">0.1.2.</span> <span class="toc-text">窗口关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="toc-number">0.1.3.</span> <span class="toc-text">糊涂窗口综合症</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A3%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">0.2.</span> <span class="toc-text">Ⅳ拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">0.2.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">0.2.2.</span> <span class="toc-text">拥塞避免算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="toc-number">0.2.3.</span> <span class="toc-text">拥塞发生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">0.2.4.</span> <span class="toc-text">快速恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">0.2.5.</span> <span class="toc-text">拥塞算法示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">0.2.6.</span> <span class="toc-text">重点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%91%8C%E4%B8%89%E3%80%81-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-TCP"><span class="toc-number">1.</span> <span class="toc-text">👌三、 如何优化 TCP?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">1.1.</span> <span class="toc-text">ⅠTCP 三次握手的性能提升</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">① 客户端优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">②服务端优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">③如何绕过三次握手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">客户端的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.5.</span> <span class="toc-text">服务端的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">绕过三次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">1.2.</span> <span class="toc-text">ⅡTCP 四次挥手的性能提升</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FIN-WAIT1-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">FIN_WAIT1 状态的优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FIN-WAIT2-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">FIN_WAIT2 状态的优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">TIME_WAIT 状态的优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E8%A2%AB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">② 被动方的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%BF%9E%E6%8E%A5%E5%8F%8C%E6%96%B9%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">如果连接双方同时关闭连接，会怎么样？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">主动方的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">被动方的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2TCP-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">ⅢTCP 传输数据的性能提升（了解即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">滑动窗口是如何影响传输速度的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">如何确定最大传输速度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E8%B0%83%E6%95%B4%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">怎样调整缓冲区大小？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%98%AF-TCP-%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">四、如何理解是 TCP 面向字节流协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">①如何理解字节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">②如何解决粘包？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">固定长度的消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E8%BE%B9%E7%95%8C"><span class="toc-number">2.2.2.</span> <span class="toc-text">特殊字符作为边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">自定义消息结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81SYN-%E6%8A%A5%E6%96%87%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A2%AB%E4%B8%A2%E5%BC%83%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">五、SYN 报文什么时候情况下会被丢弃？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%91%E7%88%B9%E7%9A%84-tcp-tw-recycle"><span class="toc-number">3.1.</span> <span class="toc-text">坑爹的 tcp_tw_recycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accpet-%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86"><span class="toc-number">3.2.</span> <span class="toc-text">accpet 队列满了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">半连接队列满了</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">全连接队列满了</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B7%B2%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84TCP%EF%BC%8C%E6%94%B6%E5%88%B0SYN%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">六、已建立连接的TCP，收到SYN会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">如何关闭一个 TCP 连接？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E6%94%B6%E5%88%B0%E4%B9%B1%E5%BA%8F%E7%9A%84-FIN-%E5%8C%85%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">七、四次挥手中收到乱序的 FIN 包会如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9C%A8-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%94%B6%E5%88%B0-SYN-%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">八、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA"><span class="toc-number">6.1.</span> <span class="toc-text">先说结论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%88%B0%E5%90%88%E6%B3%95-SYN"><span class="toc-number">6.1.1.</span> <span class="toc-text">收到合法 SYN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%88%B0%E9%9D%9E%E6%B3%95%E7%9A%84-SYN"><span class="toc-number">6.1.2.</span> <span class="toc-text">收到非法的 SYN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%8C%E6%94%B6%E5%88%B0-RST-%E4%BC%9A%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">在 TIME_WAIT 状态，收到 RST 会断开连接吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81TCP-%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%80%E7%AB%AF%E6%96%AD%E7%94%B5%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">十、TCP 连接，一端断电和进程崩溃有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C-%E5%8E%9F%E6%9C%AC%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">十一、拔掉网线后， 原本的 TCP 连接还存在吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">8.1.</span> <span class="toc-text">拔掉网线后，有数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">8.2.</span> <span class="toc-text">拔掉网线后，没有数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81HTTPS-%E4%B8%AD-TLS-%E5%92%8C-TCP-%E8%83%BD%E5%90%8C%E6%97%B6%E6%8F%A1%E6%89%8B%E5%90%97%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">十二、HTTPS 中 TLS 和 TCP 能同时握手吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-Fast-Open"><span class="toc-number">9.1.</span> <span class="toc-text">TCP Fast Open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLSv1-3"><span class="toc-number">9.2.</span> <span class="toc-text">TLSv1.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-Fast-Open-TLSv1-3"><span class="toc-number">9.3.</span> <span class="toc-text">TCP Fast Open + TLSv1.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81TCP-Keepalive-%E5%92%8C-HTTP-Keep-Alive-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">十三、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%9A%84-Keep-Alive"><span class="toc-number">10.1.</span> <span class="toc-text">HTTP 的 Keep-Alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84-Keepalive"><span class="toc-number">10.2.</span> <span class="toc-text">TCP 的 Keepalive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">10.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81TCP-%E5%8D%8F%E8%AE%AE%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">十四、TCP 协议有什么缺陷？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7-TCP-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%BE%88%E5%9B%B0%E9%9A%BE"><span class="toc-number">11.1.</span> <span class="toc-text">升级 TCP 的工作很困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E8%BF%9F"><span class="toc-number">11.2.</span> <span class="toc-text">TCP 建立连接的延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%AD%98%E5%9C%A8%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">TCP 存在队头阻塞问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.4.</span> <span class="toc-text">网络迁移需要重新建立 TCP 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE"><span class="toc-number">11.5.</span> <span class="toc-text">结尾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">十五、TCP 和 UDP 可以使用同一个端口吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">TCP 和 UDP 可以同时绑定相同的端口吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA-TCP-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">多个 TCP 服务进程可以绑定同一个端口吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">客户端的端口可以重复使用吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">12.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other"><span class="toc-number">13.</span> <span class="toc-text">other</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DNS-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">1.DNS 的解析过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3udp%E4%B8%8D%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">13.2.</span> <span class="toc-text">如何解决udp不丢包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">13.3.</span> <span class="toc-text">粘包</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/cover/cover/" title="翻唱"><img src="/1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻唱"/></a><div class="content"><a class="title" href="/2022/08/09/cover/cover/" title="翻唱">翻唱</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180052.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/08/09/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="存储引擎篇"/></a><div class="content"><a class="title" href="/2022/08/09/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AF%87/" title="存储引擎篇">存储引擎篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">基础篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇"><img src="https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程模型篇"/></a><div class="content"><a class="title" href="/2022/08/09/redis/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="线程模型篇">线程模型篇</a><time datetime="2022-08-08T16:00:00.000Z" title="发表于 2022-08-09 00:00:00">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/cover/QQ%E5%9B%BE%E7%89%8720221113180059.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By FettersLove</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1976848374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script defer src="/js/light.js"></script><script async src="//at.alicdn.com/t/c/xxx.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 MySQL (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 redis (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://example.com/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 计算机网络 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720221110175517.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223040.jpg);"> <a class="categoryBar-list-link" href="categories/MySQL/">MySQL</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223046.jpg);"> <a class="categoryBar-list-link" href="categories/redis/">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">计算机网络</span></li><li class="categoryBar-list-item" style="background:url(https://edu-fly.oss-cn-beijing.aliyuncs.com/hexo-blog/categories/QQ%E5%9B%BE%E7%89%8720221113223049.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">redis</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>