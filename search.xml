<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈哈</title>
      <link href="/2022/08/09/E-M/"/>
      <url>/2022/08/09/E-M/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>多练的代码也就是不容易写出来的：✊<br>困难的代码：😡<br>了解：👌</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>PriorityQueue**&lt;**Node**&gt; **heap &#x3D; **new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) **-&gt; a.**value **- b.<strong>value)</strong>;<br>要练熟的代码：</p><p>排序：Arrays.sort()<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650254542022-b29c6afb-07da-458f-aad0-d9195e2cbb60.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=37&id=BvypH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=46&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29461&status=done&style=none&taskId=ue1e9cf3b-75fb-4abc-a0d2-566f55d0aec&title=&width=466.4" alt="image.png"></p><p>子串子数组想到以i结尾往左推 class3例子</p><h2 id="·-返回离非负整数num最近的2的某次方"><a href="#·-返回离非负整数num最近的2的某次方" class="headerlink" title="· 返回离非负整数num最近的2的某次方"></a>· 返回离非负整数num最近的2的某次方</h2><p><strong>题意</strong><br>num&#x3D;7, 返回8   num&#x3D;8，返回8   num&#x3D;13，返回6<br><strong>题解</strong><br>二进制第一个1后面全部填充完1后加1返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606374038-5dc3bdff-f8db-4cea-b539-13bc0f241519.png#clientId=u24411928-8d24-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=348&id=u6f518ae8&margin=%5Bobject%20Object%5D&name=DEF082573F9BE5D1BD2D58935BF11CDD.png&originHeight=1166&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=328379&status=done&style=none&taskId=uc329201a-a346-4a48-9408-2ab96b91a62&title=&width=448.2857666015625" alt="DEF082573F9BE5D1BD2D58935BF11CDD.png"></p><p>| &#x2F;&#x2F; 已知n是正数<br>&#x2F;&#x2F; 返回大于等于，且最接近n的，2的某次方的值<br>public static final int tableSizeFor(int n) {<br>   &#x2F;&#x2F;这个是为了如果正好是2的某次方，打散！！<br>   n–;<br>   &#x2F;&#x2F;&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补0。<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 1;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 2;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 4;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 8;<br>   &#x2F;&#x2F;整型最多32位<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 16;<br>   return (n &lt; 0) ? 1 : n + 1;&#x2F;&#x2F;负数最高位是1，填满32个1，返回1</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-相邻字符的交换次数"><a href="#·-相邻字符的交换次数" class="headerlink" title="· 相邻字符的交换次数"></a>· 相邻字符的交换次数</h2><p><strong>题意</strong><br>刻意的说两个标准, 搞你一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704873615-836bf286-fab2-47cb-8817-a817f740da5d.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=70&id=u73201307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=88&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19948&status=done&style=none&taskId=ub30207ba-f24d-4b60-884e-75662524657&title=&width=660.8" alt="image.png"><br><strong>题解</strong><br>贪心:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704850684-0c6b231e-483f-4ad1-99fb-9b7d76b6ffc9.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u5d3653f9&margin=%5Bobject%20Object%5D&originHeight=398&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u976907e3-3bde-438a-891c-5605344be3c&title=&width=556"><br><strong>两个指针</strong><br>index: 往右扫, 不是G就往右飘<br>L: 如果发现了放到哪儿的位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606588940-7b194664-6549-49a7-bec8-3209b6c93f08.png#clientId=u24411928-8d24-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=249&id=uab987630&margin=%5Bobject%20Object%5D&name=39A8E84629C793605662823ED198A9D4.png&originHeight=718&originWidth=1126&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126502&status=done&style=none&taskId=uc016d720-79cd-42d8-8978-bf6dafda160&title=&width=390.2857666015625" alt="39A8E84629C793605662823ED198A9D4.png"><br>如何确定这是最优解?<br>这个过程, L, index都不回退, 复杂度O(N)<br>原题: 你可以选择让 G 在左边B 在右边或者你可以选择让 B 在左边G在右边哪种更省。<br>哪种更剩你用哪种, 问你最小的用代价</p><p>| _&#x2F;&#x2F; 可以让G在左，或者在右<br>_**public static int **minSteps2(String s) {<br>   **if **(s &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; s.equals(</strong>“”</strong>)) {<br>      **return **0;<br>   }<br>   <strong>char</strong>[] str &#x3D; s.toCharArray();<br>   **int **step1 &#x3D; 0;<br>   **int **step2 &#x3D; 0;<br>   **int **gi &#x3D; 0;<br>   **int **bi &#x3D; 0;<br>   **for **(**int **i &#x3D; 0; i &lt; str.<strong>length</strong>; i++) {<br>      **if **(str[i] &#x3D;&#x3D; <strong>‘G’</strong>) { _&#x2F;&#x2F; 当前的G，去左边   方案1<br>         <em>step1 +&#x3D; i - (gi++);<br>      } **else **{</em>&#x2F;&#x2F; 当前的B，去左边   方案2<br>         _step2 +&#x3D; i - (bi++);<br>      }<br>   }<br>   **return **Math.<em>min</em>(step1, step2);</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-无序数组需要排序的最短子数组长度"><a href="#·-无序数组需要排序的最短子数组长度" class="headerlink" title="· 无序数组需要排序的最短子数组长度"></a>· 无序数组需要排序的最短子数组长度</h2><p><strong>题意</strong><br>想让整体有序<br>时间复杂度 O(N)额外空间复杂度O(1)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710897296-aa25c260-3795-403f-a63d-abcb51e33ff8.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u907fe5bc&margin=%5Bobject%20Object%5D&originHeight=593&originWidth=1216&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e7d06d1-a6cb-4207-a123-ea9ca887b8c&title=&width=477"><br><strong>题解</strong><br>最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654696304737-51815bbc-5fb1-4258-8122-5b4218ecc06f.png#clientId=uaf1c0b48-9cd0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=2891&id=u37b19965&margin=%5Bobject%20Object%5D&name=63E3A64272C54C218FDD9192B70053CB.png&originHeight=5059&originWidth=1612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=673473&status=done&style=none&taskId=u1c723737-203b-4864-b838-1417ede3aeb&title=&width=921.1428571428571" alt="63E3A64272C54C218FDD9192B70053CB.png"><br>需要排序范围2~5<br>你第一回从左往右遍历最右的违规，然后从右往左遍历最左的违规这之间需要排序。</p><p>左面max&lt;&#x3D;当前数, 比如左max&#x3D;6, 最后8,9是对号, 说明如果真要排序的话, 8不必给前面的最大值让位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898543-234a31d2-30e8-43f4-8676-33e52a7b9d25.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u2443991c&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90eff19c-58f3-47d7-a63a-a785a4fd9f9&title=&width=572"><br>9不必给前面的最大值让位置<br>10也不必给前面的最大值让位置<br>你后面连续的对号说明如果真的排序的话，它们动都不需要动<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898593-d8fbbadb-d557-419e-867b-23549142645e.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=u9fabbcb7&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1258&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6eca0a4-35e4-44ff-9ecc-aeb906a1b14&title=&width=631"><br>从右往左滑同理, 最左的对号说明在往左一直到开头全是对号,<br>说明如果真的排序的话，这些数据也不用给右边部分的最小值让位置。<br>你确定了一个右边不需要排的部分, 确定了一个左边不需要排的部分，那中间就是需要排序的部分, 搞定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898762-58901f0c-bbed-431c-a9f4-1bbd7fea4661.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u670e797a&margin=%5Bobject%20Object%5D&originHeight=609&originWidth=1212&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4471b33b-6b3d-4372-8a6b-4a2b4749e8c&title=&width=484"><br>第一个X到最后一个X中间直接排序不行吗?<br>不行, 因为你只关注了最大值, 例子中8没有人处理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710899406-b03a72c2-596b-40b2-b0a1-9d726f5d16a4.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u033c7053&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=1204&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u59606f10-dbf2-4450-924e-ed0813e7169&title="></p><p>| **public static int **findUnsortedSubarray2(<strong>int</strong>[] nums) {</p><p>   **if **(nums &#x3D;&#x3D; **null **&amp;#124;&amp;#124; nums.**length **&lt; 2) {<br>      **return **0;<br>   }<br>   **int **N &#x3D; nums.<strong>length</strong>;<br>   **int **right &#x3D; -1;<br>   <strong>int <strong>max &#x3D; Integer.</strong><em>MIN_VALUE</em></strong>;</p><p>   **for **(**int **i &#x3D; 0; i &lt; nums.**length**; i++) {<br>      **if **(nums[i] &gt;&#x3D; max) {<br>         max &#x3D; nums[i];<br>      } **else **{<br>         right &#x3D; i;<br>      }</p><p>   }<br>   **int **left &#x3D; N;<br>   <strong>int <strong>min &#x3D; Integer.</strong><em>MAX_VALUE</em></strong>;</p><p>   **for **(**int **i &#x3D; N - 1; i &gt;&#x3D; 0; i–) {<br>      **if **(nums[i] &lt; min) {<br>         min &#x3D; nums[i];<br>      } **else **{<br>         left &#x3D; i;<br>      }<br>   }<br>   **return **Math.<em>max</em>(0,right-left+1);</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-字符串种类"><a href="#·-字符串种类" class="headerlink" title="· 字符串种类"></a>· 字符串种类</h2><p>你只有26种字符，一个整数是不是有32位了，<br>你就拿这个整数的第0位表示a从没出现过，它是1是出现过，它是0就没出现过，<br>你拿这个整数第1位表示b拿这个整数，第2位表示c拿一个整数，第25位表示z，<br>你还结余了这么多倍不用了，那你的摘要是不是就不用是str类型了，变成一个<br>整数就可以表示一个摘要了<br>最后看这个set中留下了多少不同的整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351350-dc64aa66-e5f5-44a0-a5d7-96736ca8680d.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=207&id=u5fa830fc&margin=%5Bobject%20Object%5D&originHeight=582&originWidth=1183&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue6d9144b-3a7b-4eca-8c40-f73d1b2aa6d&title=&width=420"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351667-30911ef7-b885-449e-ab70-5c2e626b1445.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u6191cdd4&margin=%5Bobject%20Object%5D&originHeight=257&originWidth=422&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uece8ee91-b5ee-4851-a947-dd631519c75&title=&width=358"></p><h2 id="·-最大的以-1-为边界的正方形-M"><a href="#·-最大的以-1-为边界的正方形-M" class="headerlink" title="· 最大的以 1 为边界的正方形 [M]"></a>· 最大的以 1 为边界的正方形 [M]</h2><p><strong>题意</strong><br>边框全是1就达标，它不要求内部也有1, 内部有1, 也可以没有1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-9c36b203-d37d-46a9-9483-0348e3180719.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=ub37f09bb&margin=%5Bobject%20Object%5D&originHeight=578&originWidth=1082&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a91b9c9-d45e-406e-9103-c6290e2fc15&title=&width=427"><br><strong>题解</strong><br>预处理数组技巧</p><p><strong>前置</strong><br>N<em>N区域中长方形正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399168-04bf1552-399a-4c84-9e06-1ba7badf959e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=151&id=ud0e60c23&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=1167&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1bf94e4e-6018-42e3-bfac-44286cc6e9a&title=&width=311.0000305175781"><br>N</em>N区域中正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399176-f2349f13-30c8-4f6b-8779-a086f36cb16e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=163&id=u2f2a5857&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1160&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a4e536e-ea47-4b8f-acd2-17bb7283331&title=&width=359"><br><strong>代码</strong><br>所以边长的枚举一定是哪个少，就到那个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-09736a59-aa8a-4393-b496-335dd697275c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u3d7bd96a&margin=%5Bobject%20Object%5D&originHeight=501&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u924c016e-b4a5-492d-890b-d66b64c878a&title=&width=403"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399153-31e8e2ec-e0f7-4ab7-a328-8b2e74742a8f.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u6d60a1cb&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1011&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0b2a46c-d586-4bff-99d6-7555284bbb0&title=&width=414"><br>当我们点一个点的时候，我们只要那个长方形，它往右下方向拉, 然后看你能拉多远<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401624-62771dcc-0e46-4e02-95be-f03c4a11dd8d.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u20bd98fa&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=741&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9ee39ed7-94fc-449b-ba80-16d2550e136&title=&width=487"><br>验证过程能不能快一点 O(1)内<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401970-88428577-d5a9-4b70-8787-83d3001063ea.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uada68211&margin=%5Bobject%20Object%5D&originHeight=304&originWidth=692&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua0608d42-bb77-46f4-b982-6c6e649dd36&title="><br>假设我知道任何一个(i,j)位置右边有多少个连续的1, 下方有多少个连续的1(包括自己在内)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402673-739ba559-43f0-4cfc-9907-3a8c7357f9aa.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=359&id=uda259ca9&margin=%5Bobject%20Object%5D&originHeight=603&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uef3ee539-2f80-47f9-813c-47d085e71b8&title=&width=399"><br>17,29的左上顶点, 边长是7的这么一个正方形。<br>怎么验证?<br>你先看看(7,29)右方连续的1够不够 7 个，你再看看(7,29)这个点下方连续的1够不够 7个<br>…<br>只需要调出这 3 个点的信息, O(1)的过程<br>接下来就是求任何一个(i,j)点，让它右方和下方有这个信息</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402900-dc768550-cd1a-4853-a5d8-f871f5fcabfc.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=uc6970c91&margin=%5Bobject%20Object%5D&originHeight=547&originWidth=995&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08ef4750-7959-4b40-969e-e9a6bda8fc0&title=&width=572"><br>怎么求这个信息呢?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781186419-16a3698d-6e4e-4407-9643-68dfc9156b32.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=810&id=u0773d943&margin=%5Bobject%20Object%5D&name=8594CD1133E89D6E5D0DE8C781C7E60E.png&originHeight=1418&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=457290&status=done&style=none&taskId=ub2bac3a4-0128-47f0-b5ea-c0907f659e3&title=&width=590.8571428571429" alt="8594CD1133E89D6E5D0DE8C781C7E60E.png"><br>咋知道这个O(N^3)的解需不需要继续优化?<br>矩阵规模告诉你, 最多100*100, 你拿N^3一套没到10^8这个级别,<br>你知道O(N^3)的这个解不需要再优化了, 这个题目必过.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403570-4bf72a85-3dce-4515-959c-f1866430fbbd.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8da21f2c&margin=%5Bobject%20Object%5D&originHeight=63&originWidth=246&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc724a96e-b8cd-4797-97b5-7198d88597b&title="></p><p>怎么想到是预处理数组呢?<br>当写完3个for循环之后, 底层一个正方形再验的时候不想再遍历了,<br>势必会设计一种查询的结构来支持它, 不让它遍历来保证O(1)<br>这就是思想的开端,<br>预处理数组怎么用?<br>就是当你最后卡在最后一步，一个小的元件需要遍历搞定，这样的时候特别的多，<br>你就想着我怎么样做出一个能够提前查询的结构，到这一步的时候把遍历省掉, 比如前缀数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403652-75a89599-d8f8-43a3-a1e1-5d2643008a8c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=ub5033baf&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=884&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1f7af3b0-f56a-4be7-b7cc-baeebc9e05a&title=&width=492"></p><p>| **public static int <strong>largest1BorderedSquare</strong>(int[][] <strong>m</strong>) {<br>   int[][] **right &#x3D; **new int[**m.<strong>length][<strong>m</strong>[<strong>0</strong>]</strong>.<strong>length]</strong>;<br>   **int[][] <strong>down &#x3D; <strong>new int[<strong>m.<strong>length][<strong>m</strong>[<strong>0</strong>]</strong>.<strong>length]</strong>;<br>   &#x2F;&#x2F;&#x3D;&#x3D;生成右信息 下信息<br>   setBorderMap</strong>(<strong>m, right, down</strong>)</strong>;<br>   <strong>for (int <strong>size &#x3D; Math.min</strong>(<strong>m.<strong>length</strong>, m</strong>[<strong>0</strong>]</strong>.<strong>length)</strong>; size !&#x3D; 0; size–</strong>) {<br>      if (<strong>hasSizeOfBorder</strong>(<strong>size, right, down</strong>)) {<br>         return **size * size;<br>      **}<br>   }<br>   return **0;<br>**}<br>**<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781251250-6c80220e-fc56-430a-b4c9-377e6c3fa002.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=455&id=uadd39646&margin=%5Bobject%20Object%5D&name=image.png&originHeight=797&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&size=221761&status=done&style=none&taskId=udef49ab0-cccf-4360-9f48-ec0dcec606e&title=&width=568.5714285714286" alt="image.png">****public static void <strong>setBorderMap</strong>(int[][] **m, **int[][] **right, **int[][] <strong>down</strong>) {<br>   int **r &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>c &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   &#x2F;&#x2F;右下角<br>   **if (<strong>m</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>      <strong>right</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] <strong>&#x3D; 1;<br>      down</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] **&#x3D; 1;<br>   **}<br>   **&#x2F;&#x2F;最右侧的数据<br>   **for (int <strong>i &#x3D; r - 2; i !&#x3D; -1; i–</strong>) {<br>      if (<strong>m</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>         <strong>right</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D; 1;<br>         &#x2F;&#x2F;等于1的话九四下一行加1<br>         down</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D; down</strong>[<strong>i + 1</strong>][<strong>c - 1</strong>] **+ 1;<br>      **}<br>   }<br>   **&#x2F;&#x2F;最后一行的数据<br>   **for (int <strong>i &#x3D; c - 2; i !&#x3D; -1; i–</strong>) {<br>      if (<strong>m</strong>[<strong>r - 1</strong>][<strong>i</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>         <strong>right</strong>[<strong>r - 1</strong>][<strong>i</strong>] <strong>&#x3D; right</strong>[<strong>r - 1</strong>][<strong>i + 1</strong>] <strong>+ 1;<br>         down</strong>[<strong>r - 1</strong>][<strong>i</strong>] **&#x3D; 1;<br>      **}<br>   }<br>   **&#x2F;&#x2F;然后从倒数第二行开始，从倒数第二列往前一行一行的推 &lt;–  ^<br>   **for (int <strong>i &#x3D; r - 2; i !&#x3D; -1; i–</strong>) {<br>      for (int <strong>j &#x3D; c - 2; j !&#x3D; -1; j–</strong>) {<br>         if (<strong>m</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>            <strong>right</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D; right</strong>[<strong>i</strong>][<strong>j + 1</strong>] <strong>+ 1;<br>            down</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D; down</strong>[<strong>i + 1</strong>][<strong>j</strong>] **+ 1;<br>         **}<br>      }<br>   }<br>}</p><table><thead><tr><th>**</th></tr></thead></table><p>| **public static boolean <strong>hasSizeOfBorder</strong>(int **size, **int[][] **right, **int[][] <strong>down</strong>) {<br>   for (int **i &#x3D; 0; i !&#x3D; right.<strong>length <strong>- size + 1; i++</strong>) {<br>      for (int <strong>j &#x3D; 0; j !&#x3D; right</strong>[<strong>0</strong>]</strong>.**length <strong>- size + 1; j++</strong>) {<br>         **&#x2F;&#x2F;找那三个点！！  左上的那个点              下方的那个点<br>         <strong>if (<strong>right</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size &amp;&amp; down</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size &amp;&amp; right</strong>[<strong>i + size - 1</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size<br>               &#x2F;&#x2F;右边的那个点<br>               &amp;&amp; down</strong>[<strong>i</strong>][<strong>j + size - 1</strong>] <strong>&gt;&#x3D; size</strong>) {<br>            return true</strong>;<br>         <strong>}<br>      }<br>   }<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-乘客坐船使用的最少船数"><a href="#·-乘客坐船使用的最少船数" class="headerlink" title="· 乘客坐船使用的最少船数"></a>· 乘客坐船使用的最少船数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266540654-bc52c017-346b-4c9c-ba85-2f8363a2f43d.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=123&id=u90d68d8f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20339&status=done&style=none&taskId=ua7a2c8fd-24f1-479b-b9e4-4bb22b8c84a&title=&width=412.8" alt="image.png"><br><strong>题意</strong><br>每艘船最多坐两人，且不能超过载重。问你让所有人同时过河，并且用最好的分配方法，<br>使船尽量少返回最少的船数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754920033-d23a14f3-997f-4f13-a9f0-7b561f79d2f2.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u96abc735&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1151&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25fc0b67-d916-4e77-8078-1029b98c178&title=&width=428"><br><strong>题解</strong><br>你先遍历一遍数组，如果有单独一个人的体重已经超过了limit返回无穷大。<br>多少条船都搞不定的<br><strong>流程</strong><br>先排序<br>从中间分界点开始往左右两边滑</p><p>找&lt;&#x3D;limit&#x2F;2最右的位置, 做为L指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919993-2fc7575c-c414-4b7e-a832-5bf0bcb40ff6.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=ufb0881ef&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75a44641-53ce-4de8-8f74-8ac55b102d0&title=&width=446"><br>R指针: 第一个超过limit&#x2F;2的位置<br>看L位置和R位置能否凑一个船, 不能, 超了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919953-4a90aa2e-3033-4477-8930-018ff980a464.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u95912d5e&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1102&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue7bf048f-aaa8-4400-803d-9d57b976d24&title=&width=538"><br>L往左飘, L来到3, 可以<br>先不忙分配船, R往右滑, 一直划到R再往下进一个就没有办法跟 3凑一船为止<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919952-f9d1b099-1792-43c3-931a-0e97bdbaec96.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u65f47ec7&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1076&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u854235fa-c1f2-44a8-9746-bc7d404a688&title=&width=522"><br>贪心的核心点:<br>从3出发往左数6个的这6个，去消化这6个，一定是最省的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919986-6ed6fbd8-2c1a-41ba-9150-e1e3bb4a60e3.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u93e568a4&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1162&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u91791187-7421-4fec-b6c7-edf0f6db13c&title=&width=445"><br><strong>例子1: 右侧先耗尽</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921589-39ec9db9-b791-4250-84a0-959f28c10384.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u89cdb406&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5babd024-fc3f-4e18-897a-c9982047463&title=&width=475"><br>俩对号装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921991-8f261b8f-5962-4c73-85b3-f6a17ed90471.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u2d0e63b4&margin=%5Bobject%20Object%5D&originHeight=558&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08d96e78-dff0-43b7-a5d1-52d57f628ed&title=&width=503"><br>X号两两可以装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922406-6a35f17e-24ef-4b59-92c8-c94d60e2eeaa.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u608ae23c&margin=%5Bobject%20Object%5D&originHeight=548&originWidth=1040&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud57e21a5-c48a-4d3e-a609-646cb20f153&title=&width=439"><br><strong>例子2: 左侧先耗尽</strong><br>最后对号的数量除2，加上×号的数量除2(向上取整)，加上右侧剩几个数它们一定单独一艘船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922475-c578911c-83dd-4b73-a887-e8c5088bf359.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=u2c8f3183&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=1191&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua593a755-3782-413c-ab6c-595e375b6c0&title=&width=456"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654782938733-ff5ae0ad-f593-4836-8ee2-b595c618751a.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=867&id=u98f15db6&margin=%5Bobject%20Object%5D&name=2B163C063CD4521C4323347FAFB38F50.png&originHeight=1518&originWidth=1036&originalType=binary&ratio=1&rotation=0&showTitle=false&size=511608&status=done&style=none&taskId=uee0c2454-79c7-4464-a51a-0459a5ae855&title=&width=592" alt="2B163C063CD4521C4323347FAFB38F50.png"></p><p>| public static int numRescueBoats(int[] arr, int limit) {<br>   if (arr &#x3D;&#x3D; null &amp;#124;&amp;#124; arr.length &#x3D;&#x3D; 0) {<br>      return 0;<br>   }<br>   int N &#x3D; arr.length;<br>   Arrays.sort(arr);<br>   if (arr[N - 1] &gt; limit) {<br>      return -1;<br>   }<br>   int lessR &#x3D; -1;<br>   &#x2F;&#x2F;找到 最左侧里 limit&#x2F;2最接近的数<br>   for (int i &#x3D; N - 1; i &gt;&#x3D; 0; i–) {<br>      if (arr[i] &lt;&#x3D; (limit &#x2F; 2)) {<br>         lessR &#x3D; i;<br>         break;<br>      }<br>   }<br>   if (lessR &#x3D;&#x3D; -1) {<br>      return N;<br>   }<br>   int L &#x3D; lessR;<br>   int R &#x3D; lessR + 1;<br>   int noUsed &#x3D; 0;<br>   while (L &gt;&#x3D; 0) {<br>      int solved &#x3D; 0;&#x2F;&#x2F;用来更新L下标的<br>      while (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;&#x3D; limit) {<br>         R++;<br>         solved++;<br>      }<br>      &#x2F;&#x2F;表示上述结束了右边没有一个能和当前的L乘坐<br>      if (solved &#x3D;&#x3D; 0) {<br>         noUsed++;&#x2F;&#x2F;左侧未使用的<br>         L–;<br>      } else {<br>         L &#x3D; Math.max(-1, L - solved);<br>      }<br>   }<br>  &#x2F;&#x2F;下面的要用具体的例子来换算下标<br>   int leftAll &#x3D; lessR + 1;&#x2F;&#x2F;理解的好方法：因为数组是下标0开始的 +1就表示左侧的全部数量<br>   int leftUsed &#x3D; leftAll - noUsed;&#x2F;&#x2F;左侧的全部数量-未使用的就是使用的<br>   &#x2F;&#x2F;右侧还剩下未使用的<br>   int rightUnsolved &#x3D; (N - all) - used;<br>   return used + ((noUsed + 1) &gt;&gt; 1) + moreUnsolved;</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-子数组最大累加和"><a href="#·-子数组最大累加和" class="headerlink" title="· 子数组最大累加和"></a>· 子数组最大累加和</h2><p><strong>题解</strong><br>看到子数组子串想想每个位置结尾是答案是什么<br>如果子数组必须以0结尾, 它往左扩到什么程度，能让累加和最大<br>如果子数组必须以1位置结尾, 它往左扩到什么程度，能让累加和最大</p><p><strong>大流程</strong><br><strong>可能性划分</strong><br>必须以i位置结尾答案可能来自什么?</p><ol><li>完全不向左扩, 只有自己<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677717-e5aafff1-1b52-4e5e-80db-0a14e490e373.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=194&id=uea3b3eb0&margin=%5Bobject%20Object%5D&originHeight=389&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u498816dd-5c0d-429b-81ef-e611245e7c0&title=&width=489"></li><li>要向左扩， i-1结尾的时候扩出来的最好决定了当前能扩出来的最好<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677743-cc8cf0a5-a0c2-459a-abbe-6d083b658117.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=315&id=ue16cd42f&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=863&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89741c3c-0ea1-41a0-8082-0ac2dd610c1&title=&width=559"><br><strong>例子</strong><br>dp[i]: 必须以i位置的数结尾的时候最好累加和多少<br>dp中的max就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677733-ba8e98b6-b4cd-4ab5-8570-929835020c5b.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u3525b401&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1029&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udbb81fdc-2585-4a4b-9adb-f55a90e2193&title=&width=470"><br><strong>代码</strong><br>没有必要准备一整个 BP 有几个变量滚动更新下去就完了<br>因为它只依赖左边的一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756678781-859e8520-7df4-4d2f-887d-9be3467f97b0.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubf36503d&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=788&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u515da530-1d5b-46cd-8343-4404bd2aed8&title="></li></ol><h2 id="·-😡子矩阵最大累加和-H"><a href="#·-😡子矩阵最大累加和-H" class="headerlink" title="· 😡子矩阵最大累加和 [H]"></a>· 😡子矩阵最大累加和 [H]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655000610147-a7d3a92b-d3ae-4465-94ce-a8a8d694215c.png#clientId=u7bc39c19-43ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=313&id=u0e2403c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92137&status=done&style=none&taskId=u927eb0d4-d5e2-468d-8556-18104e0bc5a&title=&width=668.5714285714286" alt="image.png"><br><strong>题解</strong><br>大流程<br>矩形必须包含第0行数据, 且只包含第0行的情况下, 最大累加和是多少?<br>矩形必须包含0,1两行数据, 且只包含0,1两行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2三行数据, 且只包含0,1,2三行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2,3四行数据, 且只包含0,1,2,3四行的情况下, 最大累加和是多少?<br>….<br>然后<br>1行<del>1行<br>1行</del>2行<br>1行<del>3行<br>1行</del>4行<br>…<br>然后<br>2行<del>2行<br>2行</del>3行<br>2行<del>4行<br>…<br>然后<br>3行</del>3行<br>…<br>然后<br>4行~4行<br>如果我们能够每一个都求出来，答案一定在其中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884708-799a0b20-7c1c-47b3-977e-90592414790a.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u0156074e&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7b53efdb-4fdf-4833-8ad0-bd3bc9bb71d&title=&width=432"><br>如果我们能够每一个都求出来答案一定在其中</p><p>压缩数组技巧<br>0行<br>必须包含第0行数据，且只有第0行情况下画框, 最大累加和多少?<br>就是子数组的最大累加和问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884722-2be04454-65aa-4ab1-bf9a-f9b97da2206c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4164a828&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1f9b8e9-8a11-4a1f-9e61-14d37d138b3&title=&width=554"><br>下面<br>矩形必须包含0, 1两行数据, 且只包含0, 1两行的情况下, 最大累加和是多少?<br>两行上下数据压在一起,形成一个新数组<br>对这个数组求最大累加和就代表必须包含0, 1两行数据，且只包含01两行数据画框的最好答案是啥。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884649-aa42ef84-bb7a-4136-98bb-9fd3691bc443.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ude7883e6&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2740ec61-35a4-4813-9a55-36c15b2fcb8&title=&width=526"><br>复杂度O(行^2*列)<br>在行上玩了一个O(行^2)的事<br>0<del>0<br>0</del>1<br>…<br>1<del>1<br>1</del>2<br>…<br>但你每次解决一个子任务它就是过一遍数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884664-75b98c0a-3eaa-493f-bfb2-184b1e00835a.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=ue4e4a946&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u95e57951-deb2-47df-983f-7072b817740&title=&width=506"><br>进一步优化: 让行列小的当平方项<br>如果是5行, 100列, 选择让行做平方项<br>如果是100行, 5列, 选择让列做平方项</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884772-ba08c36e-d98b-45f2-8291-2432422e914c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=uf99229ea&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=1061&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a44cb24-c550-46f5-888f-c474dd72d23&title=&width=559"><br><strong>代码</strong></p><p>| **public static int <strong>maxSum</strong>(int[][] <strong>m</strong>) {<br>   if (**m &#x3D;&#x3D; **null **&amp;#124;&amp;#124; m.<strong>length <strong>&#x3D;&#x3D; 0 &amp;#124;&amp;#124; m</strong>[<strong>0</strong>]</strong>.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   **&#x2F;&#x2F; O(N^2 * M)<br>   **int **N &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      **&#x2F;&#x2F; i行~j行<br>      **int[] **s &#x3D; <strong>new int[<strong>M</strong>]</strong>;<br>      <strong>for (int <strong>j &#x3D; i; j &lt; N; j++</strong>) {<br>         for (int <strong>k &#x3D; 0; k &lt; M; k++</strong>) {<br>            <strong>s</strong>[<strong>k</strong>] <strong>+&#x3D; m</strong>[<strong>j</strong>][<strong>k</strong>]</strong>;<br>         <strong>}<br>         <strong>max &#x3D; Math.max</strong>(<strong>max, maxSubArray</strong>(<strong>s</strong>))</strong>;<br>      **}<br>   }<br>   return **max;<br>**}</p><p>public static int <strong>maxSubArray</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   <strong>int <strong>cur &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>cur +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      max &#x3D; Math.max</strong>(<strong>max, cur</strong>)</strong>;<br>      cur &#x3D; cur &lt; 0 ? 0 : cur;<br>   **}<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>LeetCode原题<br>需要返回最大累加和矩形的左上角跟右下角点<br>当你发现了更大的答案， 你把它左上角点跟右下角点抓一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655001837943-7e030c8e-9549-42e0-a28a-31e013cd2d7b.png#clientId=ub6405de6-621a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=530&id=u0049c974&margin=%5Bobject%20Object%5D&name=A19EA1E0AF7663EFCF77985E2517F6F4.png&originHeight=1296&originWidth=1216&originalType=binary&ratio=1&rotation=0&showTitle=false&size=510166&status=done&style=none&taskId=u1f0706bf-c56b-4e69-9411-9025019afa5&title=&width=497.2857360839844" alt="A19EA1E0AF7663EFCF77985E2517F6F4.png"></p><p>| &#x2F;&#x2F;返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。<br>&#x2F;&#x2F; 本题测试链接 : <a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">https://leetcode-cn.com/problems/max-submatrix-lcci/</a><br>**public static int[] <strong>getMaxMatrix</strong>(int[][] <strong>m</strong>) {<br>   int **N &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **int **cur &#x3D; 0;<br>   **int **a &#x3D; 0;<br>   **int **b &#x3D; 0;<br>   **int **c &#x3D; 0;<br>   **int **d &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      int[] **s &#x3D; <strong>new int[<strong>M</strong>]</strong>;<br>      **for (int <strong>j &#x3D; i; j &lt; N; j++</strong>) {<br>         **cur &#x3D; 0;<br>         &#x2F;&#x2F;记录左上角的列<br>         <em>*int <strong>begin &#x3D; 0;<br>         &#x2F;</strong><br>          * [1 1 1 1]<br>          * [0 1 1 2]<br>          * [2 1 0 1]<br>          *&#x2F;<br>         <strong>for (int <strong>k &#x3D; 0; k &lt; M; k++</strong>) {<br>            <strong>s</strong>[<strong>k</strong>] <strong>+&#x3D; m</strong>[<strong>j</strong>][<strong>k</strong>]</strong>;<br>            cur +&#x3D; s**[<strong>k</strong>]</em>*;<br>            **if (<strong>max &lt; cur</strong>) {<br>               **max &#x3D; cur;<br>               a &#x3D; i;<br>               &#x2F;&#x2F;主要这一句<br>               b &#x3D; begin;<br>               &#x2F;&#x2F;<br>               c &#x3D; j;<br>               d &#x3D; k;<br>            **}<br>            **&#x2F;&#x2F;只有一开始就为负数的情况下，0列<br>            **if (<strong>cur &lt; 0</strong>) {<br>               **cur &#x3D; 0;<br>               begin &#x3D; k + 1;<br>            **}<br>         }<br>      }<br>   }<br>   return new int[] { **a, b, c, d <strong>}</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-135-分糖果问题-H"><a href="#·-135-分糖果问题-H" class="headerlink" title="· 135.分糖果问题 [H]"></a>· 135.分糖果问题 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757640476-f9879a7a-09ff-4b7e-9894-dcc5fb7a88f1.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=294&id=uefc12a68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26786&status=done&style=none&taskId=u1a5c1fb5-6fbe-4e76-9b2f-86a45e8de44&title=&width=573.6" alt="image.png"><br><strong>原问题</strong><br>一个数组是所有孩子的得分, 规则是，每个孩子至少一颗糖。相等不管, 只管严格大小关系<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486177-e5f2c5b1-bff0-4a8a-b27f-80ba3eac2b1c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=u249a86d3&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8840862e-eeb8-4455-87ff-fdf3aa4e161&title=&width=504"><br><strong>题解</strong><br><strong>预处理数组+贪心</strong><br>左边没东西1块糖, 比左边大, 数字就++, 不再大了就返回1, left代表每一个点左边的坡度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486316-27402c6e-a9dd-4a3a-b72e-c09cae8103ee.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u59a65f06&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=1093&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u999c1aa3-b272-4cb8-9003-279e9af6e87&title=&width=499"><br>右边没东西1块糖, 比右边打了就++, 不再大了就回1<br>每个位置的max就是分糖数量，因为左坡跟右坡以较大坡为准<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486225-aba65e85-23b1-4233-a76e-2e967ed35bc0.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ud59977cd&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf3423d64-9cb4-4a2c-9e49-352f333674a&title=&width=652"><br><strong>复杂度</strong><br>时间复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757488676-248c8add-ee09-4fe4-9157-ff396f83324e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ued7c1b61&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=913&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u552fabd9-cd94-48a3-bc14-1d1ab0ac4fe&title=&width=479"><br><strong>最优解</strong><br>我遍历的过程中，我先认为进入到上坡阶段和下坡阶段，我如果能找出一个坡来<br>就是上坡跟下坡共同构成这么一个坡度的话，该怎么分糖我就知道了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489305-1d4f8a25-b3af-43b7-9067-6174a5c50d95.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=180&id=ucfc19315&margin=%5Bobject%20Object%5D&originHeight=329&originWidth=1101&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8812c98d-eef3-4d11-8bbc-cbd7af31d8c&title=&width=603"><br>对coding要求比较高<br>Coding技巧可以让我找到一组上坡下坡, 等找到的时候, 再回过去给糖</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489355-8a08973f-476c-46d2-8817-37ea96dc2203.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ua20e6791&margin=%5Bobject%20Object%5D&originHeight=412&originWidth=942&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9aab8328-aca0-4baa-acf8-3a67fc6e1b5&title=&width=646"><br>没有重复值的例子<br>先遍历一遍找到坡, 然后再回去给糖, 两个坡度较大的那个+1<br>然后处理下个坡<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489655-913e2252-71e6-43df-9f0f-e11e4963f752.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u9023b751&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u293717ff-dce2-472f-a9bc-18f6b77868d&title=&width=525"><br>要保证两个坡中间同样的那个1不要重复给<br>相当于遍历两遍这个事儿就出来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489683-68970db3-f71e-47f9-a62e-43d3352f2041.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ud4227d7e&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u373ac26e-6280-4b9b-9741-d0f405fca4a&title=&width=567"><br>有相等值就更考验coding<br>相等是无非就是你认为上坡停止下会停止, 更考研Coding技巧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490765-ec269bd1-cd03-4caf-a292-1556e258aaed.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=uf2363b7e&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=751&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1aa1af8b-180e-44d1-adbd-6f02d306b85&title=&width=498"><br>补充问题<br>相邻孩子分数一样, 糖的数量必须一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490609-1e02392c-0c28-4911-aabe-a0e441adc3b2.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u9114b783&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1041&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u74edf940-9fec-4510-bf50-509068979ff&title=&width=441"><br><strong>例子</strong><br>生成辅助数组<br>三个原则，第一比左边大就++，<br>第二，跟左边相等就继承, 就是不变，<br>第三比左边小就归1<br>同样方法生成right<br>还是每个位置的值求max</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490724-1661c665-c1f5-4df8-8d39-1a84b646d746.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ubc071e71&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubd737b23-0203-49bd-9d92-6f6dddc3625&title=&width=492"><br>可以Coding省掉辅助数组, 更难（idea上有代码）<br>相等认为坡没变<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757491157-d5860f2a-c415-4dba-a996-a2ef506de57f.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=u5b8b35db&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=971&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8911ce37-03e3-4967-8e7d-037c74c385c&title=&width=426"></p><p>| &#x2F;&#x2F; 这是原问题的优良解<br>&#x2F;&#x2F; 时间复杂度O(N)，额外空间复杂度O(N)<br>**public static int <strong>candy1</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   **int[] **left &#x3D; <strong>new int[<strong>N</strong>]</strong>;<br>   **for (int <strong>i &#x3D; 1; i &lt; N; i++**) {<br>      if (**arr**[**i - 1**] **&lt; arr**[**i**]) {<br>         **left**[**i**] **&#x3D; left**[**i - 1**] **+ 1;<br>      **}<br>   }<br>   int[] **right &#x3D; **new int[**N**]**;<br>   **for (int **i &#x3D; N - 2; i &gt;&#x3D; 0; i–</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; arr</strong>[<strong>i + 1</strong>]) {<br>         <strong>right</strong>[<strong>i</strong>] <strong>&#x3D; right</strong>[<strong>i + 1</strong>] **+ 1;<br>      <strong>}<br>   }<br>   int <strong>ans &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      <strong>ans +&#x3D; Math.max</strong>(<strong>left</strong>[<strong>i</strong>]</strong>, right</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   return **ans + N;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-小人过有鳄鱼的河-博弈论"><a href="#·-小人过有鳄鱼的河-博弈论" class="headerlink" title="· 小人过有鳄鱼的河(博弈论)"></a>· 小人过有鳄鱼的河(博弈论)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757912442-ad573f17-7f4a-489a-ad67-3e78f85412e8.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=76&id=uacedcc1b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17519&status=done&style=none&taskId=u60591a67-ac3f-4cdc-b743-12dc5bc1e43&title=&width=669.6" alt="image.png"><br><strong>题解</strong><br>思路: 从小推到大<br>这个人在一只鳄鱼的时候就过不了河了，<br>两只鳄鱼的时候就可以过河<br>三只鳄鱼等同于一个人两条鳄鱼的时候, 也不能过河, 因为任何一个鳄鱼吃掉人是没风险的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885276-012e6b97-e501-4f4e-be4b-fa012f482633.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u9ca7460a&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=937&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1dff254-e3ae-49c7-94e2-2f88822fd1d&title=&width=530"><br>奇数能过河, 偶数不能过河<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885221-16ccb180-9d2a-48a8-bd80-9148fde82953.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u2548e3b4&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u299d4d20-2cf8-471b-8a64-0863faf084d&title=&width=457"></p><h2 id="·-Nim博弈问题"><a href="#·-Nim博弈问题" class="headerlink" title="· Nim博弈问题"></a>· Nim博弈问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800477496-814bb547-f09d-498f-abe5-e2c0e47bb5df.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=79&id=u4fd49066&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22068&status=done&style=none&taskId=uc93319c5-ad21-4523-9ae1-dc89387a500&title=&width=674.4" alt="image.png"><br><strong>题意</strong><br>所有的数&gt;&#x3D;0, 每一轮不管谁都不能拿0<br>谁最先把最后一点数拿完谁赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457877-281d0894-d81e-47d0-987e-47ebb159a8b0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u3d1eed1b&margin=%5Bobject%20Object%5D&originHeight=607&originWidth=1273&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7304e460-0286-465e-aee9-75c63e9b7ec&title=&width=478"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457894-773ef509-f81a-4726-b0ee-d9cf10ef31bd.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=uf044b29a&margin=%5Bobject%20Object%5D&originHeight=468&originWidth=672&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue799c9d7-94cb-4cac-8596-1d6808cdfa8&title=&width=342"><br>先手跟后手，绝顶聪明，每一个人都充分为所有为自己打算，<br>而且绝对理智，问你，给你一个数组状况返回谁会赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800467223-97b4ba95-223a-4115-827b-edf542fc7b0c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=ud3a77b39&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=734&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue582679d-eb0a-4430-ac2a-50f530a132f&title=&width=410"><br>先手第一回拿把它拿成两个数都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458021-1b935de2-12bb-47d3-8f26-530ef46b89a0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=udc3de2b1&margin=%5Bobject%20Object%5D&originHeight=515&originWidth=693&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u18bf42a8-f831-4160-8833-13cff2b33f1&title=&width=378"><br>后手接下来不管拿多少, 先手都让它两个数一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457964-b74ab48f-bb7e-453a-beb0-160600a24846.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=u85f511af&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u107afaec-9b34-4b96-8fe4-32cb147b4a3&title=&width=418"><br>这样先手一定会赢<br>这是两个数的规律<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458667-6220c51c-3dd2-47e9-bde9-b5b33c5a54a4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=u163724fc&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=862&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufbf57780-7d21-4ca3-8ca3-77502419af6&title=&width=391"><br><strong>题解</strong><br>由1900年数学家尼姆搞出来一个非常牛逼的解，<br>结论:<br>所有的数异或起来，如果异或和不等于零先手赢，如果异或和等于0后手赢</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458782-28023103-8346-46b2-a8dc-de62f52c13ac.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=u8660b253&margin=%5Bobject%20Object%5D&originHeight=563&originWidth=987&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua5dfad24-d8cf-4843-9bf3-a66fb04062c&title=&width=442"><br>先手的大目标:<br>让后手最先面对所有数组中都是 0 的状态。<br>大目标不知道怎么实现, 转换一下目标</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458900-733597fd-a958-4f2d-bd91-7dee949c8ffa.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u50188994&margin=%5Bobject%20Object%5D&originHeight=459&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud4ecb940-750d-4418-b3c3-e54b7d7592a&title=&width=446"></p><p>所有数都异或起来的异或和, 我如果先手能够做到我面对这坨数的异或和它不等于零，<br>但是我拿完之后每一次都让后手面对的异或和等于0，那么最后胜利是先手<br>我们知道最后全 0 的时候异或和是0。所以就这么玩下去，它总有一个时刻全 0 的时候，<br>而我是遇不到的，只会让后手遇到，所以我必胜的大目标被我们变成一个看似更难的目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458936-68a35d98-dbb4-4fbc-8eb7-a1dd85180307.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=uda72b545&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u505fe591-a3c8-41b2-ab41-bd6884a1f14&title=&width=500"><br><strong>例子</strong><br>把二进制写出来, 数组7,5,3 整体异或和001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459312-eddefebf-42c9-45db-9b8e-ddbd313e4e16.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=ua7fccb0e&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud2f98016-c6b9-4d1d-a11e-a52172c1446&title=&width=560"><br>先手在1这拿一个, 变成6, 更后面的5,3异或和为6的合起来异或和为0<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459424-4f4051be-b558-49e1-90b9-860f4b9f0660.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u72048edf&margin=%5Bobject%20Object%5D&originHeight=617&originWidth=1318&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e0608f9-d441-45c1-80f0-19fbc6e06d1&title=&width=491"><br>后手再拿的时候，他不管在哪个位置上拿哪个数都一定会让异或和从 0 变成不是零，<br>因为他必然会改变某一个位置上一的数量, 改变了它的异或和就不是0，然后先手继续让<br>它异或和变0, 先手必胜.<br>但是这样做的前提是什么?初始的时候异或和得是非零的先手才能这么干，如果先手面<br>对一个一上来就是异或和等于0的状态，后手赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459439-1138e3cb-d17b-4fe9-810b-e54a6fc1742f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u2905cd61&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1307&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf2bff4b1-484e-4ee0-9b03-d077dffc405&title=&width=510"><br>先手不一定在最大值上拿</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459509-11aaa21d-d569-4be6-9afa-9d6e11b76fa1.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u5f1b26a9&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1179&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3841b959-e751-45bc-9027-7d4efd1ad33&title=&width=507"><br>就是先手一定能做到一个不是0 异或和的东西变成全零，但不一定是在最大值上拿的，但是他一定能做到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800460027-d4c6583e-9e89-43ce-92f4-10ed5c3be356.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=uc64a46f9&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1331&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8bef9a58-5ca7-415c-85d2-26b3416a918&title=&width=566"></p><p>| &#x2F;&#x2F; 保证arr是正数数组<br>**public static void <strong>printWinner</strong>(int[] <strong>arr</strong>) {<br>   int **eor &#x3D; 0;<br>   **for (int <strong>num : arr</strong>) {<br>      **eor ^&#x3D; num;<br>   <strong>}<br>   if (<strong>eor &#x3D;&#x3D; 0</strong>) {<br>      <strong>System.<strong>out</strong>.println</strong>(“后手赢”)</strong>;<br>   <strong>} else {<br>      <strong>System.<strong>out</strong>.println</strong>(“先手赢”)</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><h2 id="·-非负数组中两个数相与的最大结果"><a href="#·-非负数组中两个数相与的最大结果" class="headerlink" title="· 非负数组中两个数相与的最大结果"></a>· 非负数组中两个数相与的最大结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650113590488-8110c2b9-7a47-41d5-a42b-f0a7399ead91.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=u485e8bbb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15539&status=done&style=none&taskId=u122a7d6b-ae77-4da4-8b41-ac244820e50&title=&width=315.2" alt="image.png"><br><strong>题解</strong><br>可以用前缀树, 额外空间比较大, 存在更好的解法<br>思路: 高位尽量变1<br>因为我如果选一些数让30位变成0，它就不如30位变成1的值大</p><p>先遍历一遍所有的数字, 只考察30位是1的有几个, 分情况</p><ol><li>小于两个<br>这说明最终的结果30位上肯定不是1，因为你小于两个就不存在任何两个数，两个两个数与玩之后第30位是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800811891-1b46d42a-fe12-4196-af17-9775c90ea3a4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u164ba3a7&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf326dddf-1871-4357-abfd-fc5d79a368e&title=&width=518"></li><li>正好有两个数， 就是这两个数与完的结果最大， 直接返回就行<br>3） 大于两个数<br>那我就把这100个数淘汰掉，剩下的我只留这23个数，我再去看第29位</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812084-94f090b2-a658-437e-8dc0-a7931e7bc517.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u2d559d95&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub142840c-3848-4aa9-ae7d-5317a77cf57&title=&width=549"><br>假设目前这一批数还剩20个， 来到第i位<br>第i位上有1的数：<br>1） &lt;2个<br>2） &#x3D;2个<br>3） &gt; 2个</p><p>我们遍历一遍整个数组，如果有第i位上有1的数，<br>第1种情况小于两个，那么这20个数一个也不淘汰，你接下来去看a减，<br>第2种情况如果这20个数中第i位上1的只有两个数，你不用再看，就这两个是结果<br>第3种情况如果大约在在地在第i位上有1的数是大于两个的，比如说他有7个，那么删掉剩余的13个，只留这7个数去搞安检一位不就玩儿去了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812139-21391412-9c69-4642-866d-d3f960d20bc7.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=ucefcac7f&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=1083&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54468d3d-1d2f-4ae3-b207-9d23095f3ba&title=&width=504"><br><strong>时间复杂度</strong><br>30位遍历一遍数组， 29位遍历一遍数组…<br>一共遍历32遍数组, O(32N)</p><p><strong>空间复杂度怎么计算</strong><br>如果删到只剩下6个数, 17位的时候<br>保留数字这件事情, 在原数组上操作, 原数组末尾做垃圾区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812121-214352ae-98c3-4159-91d0-39878e511b6c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u73578c17&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=833&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue4361ff8-1204-42b3-9953-9cab2cc1866&title="><br><strong>代码</strong><br>垃圾区<br>&lt;2个, 一个数也不淘汰, 让M跳回去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812117-fb4a8866-f4ce-4796-9d6f-e723dcabb358.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u3dfa6e88&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=895&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud964a6ce-61a5-49cc-bd8b-f81d3549e57&title=&width=483"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812536-2890f02a-970d-48af-90d3-2e5b41d3edb8.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0869c0ec&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=575&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u146e66a2-ea4d-4abe-92ce-6d990b399e2&title="></p><p>| **public static int <strong>maxAndValue2</strong>(int[] <strong>arr</strong>) {<br>   **&#x2F;&#x2F; arr[0…M-1]  arr[M….]<br>   **int **M &#x3D; arr.<strong>length</strong>;<br>   **int **ans &#x3D; 0;<br>   **for (int <strong>bit &#x3D; 30; bit &gt;&#x3D; 0; bit–</strong>) {<br>      **&#x2F;&#x2F; arr[0…M-1] arr[M…]<br>      **int **i &#x3D; 0;<br>      **int **tmp &#x3D; M;&#x2F;&#x2F;有可能跳回去<br>      **while (**i &lt; M**) { **&#x2F;&#x2F; arr[0…M-1]<br>         **if ((**arr**[**i**] **&amp; **(**1 &lt;&lt; bit**)) **&#x3D;&#x3D; 0**) {<br>            **swap**(**arr, i, –M**)**;<br>         **} else {<br>            **i++;<br>         **}<br>      }<br>      if (**M &#x3D;&#x3D; 2**) { **&#x2F;&#x2F; arr[0,1]<br>         **return **arr**[**0**] **&amp; arr**[**1**]**;<br>      **}<br>      **&#x2F;&#x2F;&#x3D;&#x3D;<br>      **if (**M &lt; 2**) {**&#x2F;&#x2F;当前bit为无法得到1，M跳回原来位置，一个数也不删****         **M &#x3D; tmp;<br>      **} else { **&#x2F;&#x2F; &gt; 2个数  bit位上有1<br>         ans &amp;#124;&#x3D; <strong>(<strong>1 &lt;&lt; bit</strong>)</strong>;<br>      **}<br>   }<br>   return **ans;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊括号嵌套系列问题"><a href="#·-✊括号嵌套系列问题" class="headerlink" title="· ✊括号嵌套系列问题"></a>· ✊括号嵌套系列问题</h2><h3 id="①计算str表达式结果"><a href="#①计算str表达式结果" class="headerlink" title="①计算str表达式结果"></a>①计算str表达式结果</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650098950782-2396606a-0bbb-4b55-9cb6-f263b9578ad9.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=uaeee7735&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49751&status=done&style=none&taskId=u4b5b7ea1-393b-431b-8ac2-e4790d56699&title=&width=679.2" alt="image.png"><br><strong>题意</strong><br>负数作为公式的开头 或括号部分的开头，可以没有括号<br><strong>题解</strong><br>先处理没有小括号的情况</p><p>指针从零开始就有两种情况:</p><ol><li>当前压中的是数字</li><li>当前压中的是符号<br>准备一个栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569314-732407d5-15f9-4a7e-955b-af2e37ff100f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u1a923818&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=1096&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc508edf6-c054-45e5-b769-4791d54b022&title=&width=505"><br>压中运算符号, 当初过数字阶段结束了, 找到了34<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569315-adc8cd07-34b4-4302-9e41-3b97c55765fb.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=uce5b21e3&margin=%5Bobject%20Object%5D&originHeight=493&originWidth=1115&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua15fcfcf-0634-4317-b4a3-83765138bda&title=&width=536"><br>**1, * **入栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569327-d3093cd3-afae-4027-a13c-21a795ed98e4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u8b5cb035&margin=%5Bobject%20Object%5D&originHeight=477&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0f70762-e91b-40e6-ad16-29f364c33ce&title=&width=567"><br>栈顶乘除, 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569326-10c63ce7-1bb7-4088-b202-5669ddcfa1ce.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0ca380b&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=1116&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u19d8bda1-3868-4505-8ef6-06decfae122&title="><br>栈顶 &#x2F; 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569330-71ccfd20-9804-4216-a208-53f5b5d350c1.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=uaea7846f&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69bde130-2897-4078-9dfd-67844659fef&title=&width=570"><br>最后位置， 7 入栈， 栈里只有+-符号了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802570274-71211b4b-b360-454e-af84-04dd0cae9fc3.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=ub7bce47c&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1112&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8191caa6-71ac-442a-8cc3-02e1fd3d0ff&title=&width=558"><br>定义递归函数f<br>int[] f(int i)<br>从i位置出发, 遇到右括号或者整个字符串终止位置停止， 返回两个值</li></ol><ul><li><ol><li>answer</li></ol></li><li><ol start="2"><li>F函数算到哪个位置了</li></ol></li></ul><p>条件情况：<br>①遇到数字</p><ul><li>设置cur</li></ul><p>②遇到运算符，结合cur加入到队列中<br>③遇到左括号就交给递归去搞，递归返回两个值</p><ul><li><ol><li>answer</li></ol></li><li><ol start="2"><li>F函数算到哪个位置了</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127597996-d7be7b6e-c490-4bea-bd31-166716737d7e.png#clientId=u7251bedd-719d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=504&id=u8c22e28e&margin=%5Bobject%20Object%5D&name=B03D96AEEDFC16F1164F383A3C4FA837.png&originHeight=1081&originWidth=1739&originalType=binary&ratio=1&rotation=0&showTitle=false&size=456166&status=done&style=none&taskId=u8a1e2898-b1b8-4344-a8d0-08c331b7bf2&title=&width=811.0000610351562" alt="B03D96AEEDFC16F1164F383A3C4FA837.png"></p><p><strong>例子2</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802571970-a1640f24-2c37-483d-b77a-efbb1b989559.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=ua50d068b&margin=%5Bobject%20Object%5D&originHeight=445&originWidth=1107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u99525ff6-64ba-48bf-b068-cce57175db3&title=&width=506"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572172-4a4912ea-4cde-4445-8205-a79369f2c4ca.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=187&id=u81b31c60&margin=%5Bobject%20Object%5D&originHeight=416&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf9fcaa9a-38b5-4adf-97e8-c0b34eab9cd&title=&width=498"><br>遇到左括号了就调递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572369-f6d4f508-2cf3-4096-944a-dd73f55c5d87.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u0ecc431b&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1103&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub543cc02-862d-4386-ac2e-09562639620&title=&width=546"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572690-1f71ba4c-d5a1-4bca-b4b9-84e14c4ec028.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u1ef6c4e6&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=1112&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u81b410fe-4bce-4b03-ae45-37ae4dc0511&title=&width=543"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572941-2ab03421-1f4d-4d27-89e2-904c73ddb9d8.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u5a645239&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1105&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u43dfc911-4281-454a-8e5d-0e49de897e6&title=&width=515"><br>压缩数组例子<br>只要是括号嵌套的都这玩意儿。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573019-d4ab5767-707d-4c9e-b387-12602d4bcdc0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=206&id=u794d34bb&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=940&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u011e5f47-e7bf-4aeb-9bb3-746df83d1bb&title=&width=498"><br>开头为负怎么计算<br>一上来碰到-号, 0, -, 压栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573351-066ab599-0ef9-4c1a-9f56-c63f6a74181f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u36ef568b&margin=%5Bobject%20Object%5D&originHeight=464&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud82d0514-6263-41c7-b9d5-faaef151f10&title=&width=485"><br><strong>代码</strong><br>最后一个数字还没入栈， 放进去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573451-a23baef1-630a-43f3-89a6-cd2766a53edd.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=312&id=u878bd00f&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0b6eb0c-a03c-4a1a-8d42-f425afa6344&title=&width=582"><br>这种方法一定要牢牢掌握，因为任何括号嵌套的题都可以这么改</p><p>| **public static int[] <strong>f</strong>(char[] **str, **int <strong>i</strong>) {<br>   <strong>LinkedList</strong>&lt;**String**&gt; **que &#x3D; <strong>new <strong>LinkedList</strong>&lt;**String**&gt;()</strong>;<br>   **int **cur &#x3D; 0;<br>   **int[] **bra &#x3D; <strong>null</strong>;<br>   &#x2F;&#x2F; 从i出发，开始撸串<br>   **while (**i &lt; str.**length **&amp;&amp; str**[**i**] **!&#x3D; **’)’) {<br>      if (**str**[**i**] **&gt;&#x3D; **’0’ <strong>&amp;&amp; str</strong>[<strong>i</strong>] <strong>&lt;&#x3D; <strong>‘9’) {<br>         <strong>cur &#x3D; cur * 10 + str</strong>[<strong>i++</strong>] <strong>- <strong>‘0’</strong>;<br>      <strong>} else if (<strong>str</strong>[<strong>i</strong>] <strong>!&#x3D; <strong>‘(‘) { <strong>&#x2F;&#x2F; 遇到的是运算符号<br>         addNum</strong>(<strong>que, cur</strong>)</strong>;&#x2F;&#x2F;比如队列中此时有 1 +   cur &#x3D; 2  来到+ 放入 2 +<br>         que.addLast</strong>(<strong>String.valueOf</strong>(<strong>str</strong>[<strong>i++</strong>]))</strong>;<br>         cur &#x3D; 0;<br>      <strong>} else { <strong>&#x2F;&#x2F; 遇到左括号了<br>         bra &#x3D; f</strong>(<strong>str, i + 1</strong>)</strong>;<br>         cur &#x3D; bra</strong>[<strong>0</strong>]</strong>;<br>         i &#x3D; bra</strong>[<strong>1</strong>] **+ 1;<br>      <strong>}<br>   }<br>   <strong>&#x2F;&#x2F;注意！要结束了，把最后一个数字放进去<br>   addNum</strong>(<strong>que, cur</strong>)</strong>;<br>   <strong>return new int[] { <strong>getNum</strong>(<strong>que</strong>)</strong>, i <strong>}</strong>;<br>**}</p><p>public static void <strong>addNum</strong>(<strong>LinkedList</strong>&lt;<strong>String**&gt; <strong>que, <strong>int <strong>num</strong>) {<br>   if (</strong>!que.isEmpty</strong>()) {<br>      int <strong>cur &#x3D; 0;<br>      String top &#x3D; que.pollLast</strong>()</strong>;<br>      <strong>if (<strong>top.equals</strong>(“+”) <strong>&amp;#124;&amp;#124; top.equals</strong>(“-“)) {<br>         <strong>que.addLast</strong>(<strong>top</strong>)</strong>;<br>      <strong>} else {<br>         <strong>cur &#x3D; Integer.valueOf</strong>(<strong>que.pollLast</strong>())</strong>;<br>         num &#x3D; top.equals**(“*”) **? **(<strong>cur * num</strong>) **: <strong>(<strong>cur &#x2F; num</strong>)</strong>;<br>      <strong>}<br>   }<br>   <strong>que.addLast</strong>(<strong>String.valueOf</strong>(<strong>num</strong>))</strong>;<br><strong>}</strong><br>**public static int <strong>getNum</strong>(<strong>LinkedList</strong>&lt;**String**&gt; <strong>que</strong>) {<br>   int **res &#x3D; 0;<br>   **boolean **add &#x3D; <strong>true</strong>;<br>   String cur &#x3D; <strong>null</strong>;<br>   <strong>int <strong>num &#x3D; 0;<br>   <strong>while (</strong>!que.isEmpty</strong>()) {<br>      <strong>cur &#x3D; que.pollFirst</strong>()</strong>;<br>      **if (<strong>cur.equals</strong>(“+”)) {<br>         **add &#x3D; <strong>true</strong>;<br>      <strong>} else if (<strong>cur.equals</strong>(“-“)) {<br>         <strong>add &#x3D; <strong>false</strong>;<br>      <strong>} else {<br>         <strong>num &#x3D; Integer.valueOf</strong>(<strong>cur</strong>)</strong>;<br>         res +&#x3D; add ? num : <strong>(</strong>-num</strong>)</strong>;<br>      **}<br>   }<br>   return **res;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h3 id="②字符串解码"><a href="#②字符串解码" class="headerlink" title="②字符串解码"></a>②字符串解码</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127913238-063d6a0a-b032-4ca8-89e2-5dc17f30d0be.png#clientId=u7251bedd-719d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u2e367064&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22499&status=done&style=none&taskId=u6402f452-c01d-4576-b24d-7d027b199f9&title=&width=440.57142857142856" alt="image.png"></p><p>| **public static **String calculate(String str) {<br>        **return **f(str.toCharArray(), 0)[0];<br>    }</p><pre><code>**public static **String[] f(**char**[] str, **int **i) &#123;    String ans = **&quot;&quot;**;    **int **cur = 0;    // 从i出发，开始撸串    **while **(i &lt; str.**length **&amp;&amp; str[i] != **&#39;]&#39;**) &#123;        //遇到数字        **if **(str[i] &gt;= **&#39;0&#39; **&amp;&amp; str[i] &lt;= **&#39;9&#39;**) &#123;            cur = cur * 10 + str[i++] - **&#39;0&#39;**;        &#125; **else if **(str[i] &gt;= **&#39;a&#39; **&amp;&amp; str[i] &lt;= **&#39;z&#39;**) &#123; //            ans += str[i++];        &#125; **else **&#123; // 遇到左括号了            String[] f = f(str, i + 1);            **for **(**int **j = 0; j &lt; cur; j++) &#123;                ans += f[0];            &#125;            cur = 0;            i = Integer.valueOf(f[1]);            i++;        &#125;    &#125;    **return new **String[] &#123; ans, String.valueOf(i) &#125;;&#125; |</code></pre><p>| — |</p><h3 id="③❓原子的数量"><a href="#③❓原子的数量" class="headerlink" title="③❓原子的数量"></a>③❓原子的数量</h3><p><strong>扩展：计算括号字符串的分数</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650109458205-b1b14786-40bd-4f1c-bfa1-9a055b24847d.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=uabd6313c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=711&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36399&status=done&style=none&taskId=u2890ec75-3800-40a2-aabe-f170319bf19&title=&width=568.8" alt="image.png"><br>记住代码，比较难理解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650110035627-385b43a8-6afc-437b-bb16-74508df9d7f8.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u52f0ac7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111603&status=done&style=none&taskId=uc24e086b-659c-49f0-b945-4a1fb06b24d&title=&width=304" alt="image.png"></p><h2 id="·-盛最多水的容器"><a href="#·-盛最多水的容器" class="headerlink" title="· 盛最多水的容器"></a>· 盛最多水的容器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652803229358-74a054ba-5506-4cb4-888f-08fb6bd8faed.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=uab3100b9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=609&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40053&status=done&style=none&taskId=u5e22d377-cb6c-42c5-a11e-f25dd5bf093&title=&width=514.7999877929688" alt="image.png"><br><strong>题解</strong><br>先假设无重复值, 左右两个指针<br>左边跟右边比大小， 谁小结算谁的水量<br>两个左右两个指针依次划的过程中算出所有水量的最大值就是答案</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603322-564cdac1-d9b0-46b5-ae4f-e90597069858.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=ue0abe2ca&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u56957f64-7d7b-4946-9167-ea72d58d406&title=&width=462"><br>而事实上3可以继续往右扩大，那我为什么不求出唯一的正确答案，<br>只求3~8这一段的答案呢，这是因为a的答案包含这一段，所以我只关注会不会有把答案推高的可能性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603354-4d6989ad-b2b5-4a05-8c69-6f7008972fd5.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=uf256ec8f&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uba4cb029-1101-4abf-a81a-be756f71cbe&title=&width=496"><br>它不是严格要求每一个数都能够准确的算出来它的答案, 它只关心有没有推高答案的可能性<br>为啥你不知道这道题怎么做?<br>但是你看数据量，你就知道自己一定会憋出一个O(N)的解，<br>那势必可能会想到双指针，谁大移动谁跟谁小移动谁都试一遍这题就出来了，不用知道为什么有可能都能猜出来<br>复杂度O(N)<br>我不去严格纠结到底这个值他真实的最优解是什么，我只纠结会不会让答案变大<br>ref： 数组三连第三连<br><strong>例子</strong><br>只关注它推高答案的可能性，但是我们不去严格纠结每一个位置的值，它具体答案是多少<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603343-312db809-99e8-414c-a228-7fc6ae108e0c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=200&id=u90840346&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=928&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u82dc8d2e-0c79-4da0-9b9b-729957c3535&title=&width=419"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603345-91268f80-07fa-46fd-9be0-2ac568756483.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u9a46939d&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=1092&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2229fb65-1462-44d2-a2f2-ad111e6093d&title=&width=475"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603340-dff504be-50d9-4110-bde8-60d0eaa86e2f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u5153fc20&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1094&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54178eed-544a-423b-9a03-b4e0b59ea95&title=&width=488"></p><p>| **public static int <strong>maxArea1</strong>(int[] <strong>h</strong>) {<br>   int **max &#x3D; 0;<br>   **int **N &#x3D; h.<strong>length</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) { <strong>&#x2F;&#x2F; h[i]<br>      <strong>for (int <strong>j &#x3D; i + 1; j &lt; N; j++</strong>) { <strong>&#x2F;&#x2F; h[j]<br>         max &#x3D; Math.max</strong>(<strong>max, Math.min</strong>(<strong>h</strong>[<strong>i</strong>]</strong>, h</strong>[<strong>j</strong>]) *** <strong>(<strong>j - i</strong>))</strong>;<br>      **}<br>   }<br>   return **max;<br>**}</p><p>public static int <strong>maxArea2</strong>(int[] <strong>h</strong>) {<br>   int **max &#x3D; 0;<br>   **int **l &#x3D; 0;<br>   **int **r &#x3D; h.**length **- 1;<br>   **while (<strong>l &lt; r**) {<br>      **max &#x3D; Math.max**(**max, Math.min**(**h**[**l**]**, h**[**r**]) *** **(**r - l**))**;<br>      **if (**h**[**l**] **&gt; h</strong>[<strong>r</strong>]) {<br>         **r–;<br>      **} else {<br>         **l++;<br>      **}<br>   }<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-多个有序list中的top-100-大"><a href="#·-多个有序list中的top-100-大" class="headerlink" title="· 多个有序list中的top 100 大"></a>· 多个有序list中的top 100 大</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882236750-67c0af3e-05fa-4bed-98b7-fcf80e36b74c.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=30&id=ufd509bb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=38&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7392&status=done&style=none&taskId=uef743611-362e-49ac-b624-c0c7dc58095&title=&width=509.6" alt="image.png"><br>大根堆<br>先把链表逆序<br>所有头部拿出来组成一个大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882248310-fbb2aa87-caa0-422c-a083-a8713a7d4694.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u5395c82a&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1291&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u437d1bae-2ae6-40d8-a1af-96d46908e56&title=&width=624"></p><h2 id="·-跳跃游戏Ⅱ"><a href="#·-跳跃游戏Ⅱ" class="headerlink" title="· 跳跃游戏Ⅱ"></a>· 跳跃游戏Ⅱ</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650029478423-12a50e13-5642-45ad-9e9e-04f762f5b727.png#clientId=u98aeb21b-e583-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u7efc409b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37693&status=done&style=none&taskId=u765ebde4-b464-4164-bf78-e8a292676f9&title=&width=532.8" alt="image.png"><br><strong>题意</strong><br>存在一个选择<br>如果尽着最大步数跳他可能得不到最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305648-957d0562-d157-4d3d-ae6c-fc146f1a4502.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u7daad865&margin=%5Bobject%20Object%5D&originHeight=510&originWidth=1237&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3f318203-80a6-4650-85bf-4d1f226ff95&title=&width=609"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305602-7f9f8032-223f-476c-b74f-d76bef9d32ac.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=210&id=u21788ad8&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1216&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufb841da7-04af-4c5b-907e-0212ae690a1&title=&width=524"><br>用贪心, 老紧着最大步数跳是不对的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305681-d01ab949-c241-4243-bac5-4c66c124efae.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=uc2a1cfe5&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1252&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u926d9fc0-6e2a-4122-a843-128c9c2436c&title=&width=521"><br><strong>题解</strong><br>流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655211162287-fd0710b0-b985-4a90-bfed-0abe223715f1.png#clientId=u83bd60c9-5fa5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=812&id=u6a026509&margin=%5Bobject%20Object%5D&name=41D4CCD93F04922A9F2D17AA467437A5.png&originHeight=1421&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&size=417915&status=done&style=none&taskId=u26adf01b-d2c7-4f51-8d3d-1813a4c2bf8&title=&width=704" alt="41D4CCD93F04922A9F2D17AA467437A5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882306957-1850e9b7-de8b-4a4a-adea-eb2cfffcc9eb.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ufbe8fdc9&margin=%5Bobject%20Object%5D&originHeight=579&originWidth=1043&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc564cc66-4380-40a6-a766-66d63c6b832&title=&width=509"><br>反例<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307533-6f1f96c5-ad80-4f9e-9ab2-54da1412c258.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=uc54b612f&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=1132&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3debd364-ff69-4b03-b637-3746408f53d&title=&width=507"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307672-7a9a40e1-5757-4e56-8392-55c6b983411e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u9fe696a3&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=797&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u381a4f25-cc9a-4da0-94f2-80b9ae28f16&title=&width=428"><br><strong>代码</strong></p><p>| **public static int <strong>jump</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **step &#x3D; 0;&#x2F;&#x2F;目前位置跳了几步<br>   **int **cur &#x3D; 0;&#x2F;&#x2F;如果你不增加步数，step以内，你最远能到哪儿<br>   <strong>int <strong>next &#x3D; 0;&#x2F;&#x2F;如果允许我多跳一步，请问我最远的到哪儿<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882687455-34de4ef7-d45e-4515-8847-2cdd7261f16a.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=141&id=u998e7fdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=219&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15857&status=done&style=none&taskId=uf377eb45-a694-43de-80a6-f4277e28737&title=&width=292.8000183105469" alt="image.png"></strong></strong>      if (<strong>cur &lt; i</strong>) {<br>         **step++;<br>         cur &#x3D; next;<br>      <strong>}<br>      <strong>next &#x3D; Math.max</strong>(<strong>next, i + arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   return **step;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·✊在两个都有序的数组找整体第k小的数"><a href="#·✊在两个都有序的数组找整体第k小的数" class="headerlink" title="·✊在两个都有序的数组找整体第k小的数"></a><strong>·✊在两个都有序的数组找整体第k小的数</strong></h2><h3 id="①算法模型：在两个都有序的数组中找上中位数"><a href="#①算法模型：在两个都有序的数组中找上中位数" class="headerlink" title="①算法模型：在两个都有序的数组中找上中位数"></a>①算法模型：在两个都有序的数组中找上中位数</h3><p><strong>题意</strong><br>O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884443226-1de0ecb3-1471-4e81-899c-0e32b5ca4a66.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ub50901c6&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua642aa49-06f2-439b-a489-64f4f71a01d&title=&width=426"><br><strong>题解</strong><br>分情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655299291411-6ecd16bb-340f-4d93-9539-e4bb4a986a8a.png#clientId=u02685321-15d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1841&id=uf949730e&margin=%5Bobject%20Object%5D&name=7A99CC63E8320AA8102F6ACA846A0A14.png&originHeight=3222&originWidth=1849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1850552&status=done&style=none&taskId=ucde9adac-f3e4-459e-a56d-0b19154fa4c&title=&width=1056.5714285714287" alt="7A99CC63E8320AA8102F6ACA846A0A14.png"><br><strong>代码</strong></p><p>| **public static int <strong>getUpMedian</strong>(int[] **A, **int **s1, **int **e1, **int[] **B, **int **s2, **int <strong>e2</strong>) {<br>   int **mid1 &#x3D; 0;<br>   **int **mid2 &#x3D; 0;<br>   **while (**s1 &lt; e1**) {<br>      **&#x2F;&#x2F; mid1 &#x3D; s1 + (e1 - s1) &gt;&gt; 1<br>      mid1 &#x3D; **(<strong>s1 + e1</strong>) **&#x2F; 2;<br>      mid2 &#x3D; **(<strong>s2 + e2</strong>) **&#x2F; 2;<br>      <strong>if (<strong>A</strong>[<strong>mid1</strong>] <strong>&#x3D;&#x3D; B</strong>[<strong>mid2</strong>]) {<br>         return <strong>A</strong>[<strong>mid1</strong>]</strong>;<br>      **}<br>      **&#x2F;&#x2F; 两个中点一定不等！<br>      &#x2F;&#x2F;e1 - s1 + 1就是个数 奇数&amp;1 &#x3D;&#x3D; 1<br>      **if (((<strong>e1 - s1 + 1</strong>) <strong>&amp; 1</strong>) <strong>&#x3D;&#x3D; 1</strong>) { **&#x2F;&#x2F; 奇数长度<br>         &#x2F;&#x2F;一定要对着例子<br>         <strong>if (<strong>A</strong>[<strong>mid1</strong>] <strong>&gt; B</strong>[<strong>mid2</strong>]) {<br>            if (<strong>B</strong>[<strong>mid2</strong>] <strong>&gt;&#x3D; A</strong>[<strong>mid1 - 1</strong>]) {<br>               return <strong>B</strong>[<strong>mid2</strong>]</strong>;<br>            **}<br>            **e1 &#x3D; mid1 - 1;<br>            s2 &#x3D; mid2 + 1;<br>         <strong>} else { <strong>&#x2F;&#x2F; A[mid1] &lt; B[mid2]<br>            **if (**A**[**mid1**] **&gt;&#x3D; B</strong>[<strong>mid2 - 1</strong>]) {<br>               return <strong>A</strong>[<strong>mid1</strong>]</strong>;<br>            **}<br>            **e2 &#x3D; mid2 - 1;<br>            s1 &#x3D; mid1 + 1;<br>         **}<br>      } else { **&#x2F;&#x2F; 偶数长度<br>         **if (<strong>A</strong>[<strong>mid1</strong>] <strong>&gt; B</strong>[<strong>mid2</strong>]) {<br>            **e1 &#x3D; mid1;<br>            s2 &#x3D; mid2 + 1;<br>         <strong>} else {<br>            <strong>e2 &#x3D; mid2;<br>            s1 &#x3D; mid1 + 1;<br>         <strong>}<br>      }<br>   }<br>   return <strong>Math.min</strong>(<strong>A</strong>[<strong>s1</strong>]</strong>, B</strong>[<strong>s2</strong>])</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>复杂度</strong><br>每一次比价砍一半, 二分, O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884449524-c998a42f-d576-4006-9cf1-9c30739af9d7.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=342&id=Dep6S&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=945&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25c8aeb9-2c09-4667-9058-e9474a70a88&title=&width=517"></p><h3 id="②进阶：在两个都有序的数组找整体第k小的数"><a href="#②进阶：在两个都有序的数组找整体第k小的数" class="headerlink" title="②进阶：在两个都有序的数组找整体第k小的数"></a><strong>②进阶：在两个都有序的数组找整体第k小的数</strong></h3><p><strong>例子：arr1 17个 arr2 10个</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655300515983-61e193b4-7e6a-4b2e-8067-4cd547c49684.png#clientId=u02685321-15d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1109&id=uc06c0ab8&margin=%5Bobject%20Object%5D&name=ACE1391B1036C5CD896CD36C7A4E1AF8.png&originHeight=1941&originWidth=2212&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1248551&status=done&style=none&taskId=u7e89ae7d-1de4-45b4-a7ae-d3b2e6a1f95&title=&width=1264" alt="ACE1391B1036C5CD896CD36C7A4E1AF8.png"></p><p>| &#x2F;&#x2F; 进阶问题 : 在两个都有序的数组中，找整体第K小的数<br>&#x2F;&#x2F; 可以做到O(log(Min(M,N)))<br>**public static int <strong>findKthNum</strong>(int[] **arr1, **int[] **arr2, **int <strong>kth</strong>) {<br>   int[] **longs &#x3D; arr1.**length **&gt;&#x3D; arr2.**length **? arr1 : arr2;<br>   **int[] **shorts &#x3D; arr1.**length <strong>&lt; arr2.**length **? arr1 : arr2;<br>   **int **l &#x3D; longs.**length**;<br>   **int **s &#x3D; shorts.**length**;<br>   **if (**kth &lt;&#x3D; s**) { **&#x2F;&#x2F; 1)<br>      **return **getUpMedian**(**shorts, 0, kth - 1, longs, 0, kth - 1**)**;<br>   **}<br>   if (**kth &gt; l</strong>) { <strong>&#x2F;&#x2F; 3)  对着例子【例子太重要了，具象化的代码改为抽象化就可以了】看代码就懂了  贴图过来非常简单！<br>      <strong>if (<strong>shorts</strong>[<strong>kth - l - 1</strong>] <strong>&gt;&#x3D; longs</strong>[<strong>l - 1</strong>]) {<br>         return <strong>shorts</strong>[<strong>kth - l - 1</strong>]</strong>;<br>      <strong>}<br>      if (<strong>longs</strong>[<strong>kth - s - 1</strong>] <strong>&gt;&#x3D; shorts</strong>[<strong>s - 1</strong>]) {<br>         return <strong>longs</strong>[<strong>kth - s - 1</strong>]</strong>;<br>      <strong>}<br>      return <strong>getUpMedian</strong>(<strong>shorts, kth - l, s - 1, longs, kth - s, l - 1</strong>)</strong>;<br>   <strong>}</strong><br>****   <strong>&#x2F;&#x2F; 2)  s &lt; k &lt;&#x3D; l<br>   **if (**longs**[**kth - s - 1**] **&gt;&#x3D; shorts</strong>[<strong>s - 1</strong>]) {<br>      return <strong>longs</strong>[<strong>kth - s - 1</strong>]</strong>;<br>   <strong>}<br>   return <strong>getUpMedian</strong>(<strong>shorts, 0, s - 1, longs, kth - s, kth - 1</strong>)</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h3 id="·-394-字符串解码-M"><a href="#·-394-字符串解码-M" class="headerlink" title="· 394. 字符串解码 [M]"></a>· 394. 字符串解码 [M]</h3><p><strong>题意</strong><br>字符串还原成全是小写字母<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500821-75a18c69-29c4-4b24-b7e5-887be3cb6749.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=ucd62da43&margin=%5Bobject%20Object%5D&originHeight=596&originWidth=1175&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u468d9297-5ca7-472c-88dc-6d62e3ef096&title=&width=488"><br>原始串只有a~z<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500842-3195e513-118a-4630-af49-7b8ed4406f4d.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=uf17c79f4&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u987e1af2-77b6-46ca-b800-4512ab05154&title=&width=364"><br><strong>题解</strong><br>定义递归函数:</p><ol><li>返回结果字符串</li><li>处理到的位置</li></ol><p>从压缩串str i位置往后转换, 遇到]或者压缩串结尾停止, 停的时候, 从i…停这段返回, 并返回计算到的位置</p><p>所有的嵌套结构可以用这个递归结构求解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500729-ad1aeada-e94d-4f7f-9263-31b5031971c8.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=ua4899735&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1306&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a9acdf8-1639-498c-b25c-8532d5b9013&title=&width=451"><br>比如表达式计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500774-5f55cb4a-375e-4628-8a25-c5886f9b8ecf.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=ub4b51deb&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6130fe28-6f0f-4e73-8f26-03514873989&title=&width=505"><br>例子<br>一个字符串的总结果， ans<br>一个收集数字的 cur</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500812-577e8e62-310b-441d-b5fc-70f6264da78d.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ueb3f028b&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=1249&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e762acf-74d3-4f32-a96c-9b00be09246&title=&width=643"><br>2位置遇到左括号, 调子过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504551-ef54c717-a12c-4ef7-a8e6-1dea07860e9f.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u174ad8d4&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=1290&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb7240e5-7fd4-4f17-9d0c-dc13026baee&title=&width=530"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504525-6706a8a2-0c1d-4b36-941c-b9c59ded0d45.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u689b0aea&margin=%5Bobject%20Object%5D&originHeight=668&originWidth=1371&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7f4f3313-621b-4ad6-a317-6341b366355&title=&width=513"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504536-785698a9-0b58-4ea5-bb85-e5870cbed403.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u107f1f9b&margin=%5Bobject%20Object%5D&originHeight=665&originWidth=1262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8359b1d3-cd55-4872-a3b1-24b10aa2d4d&title=&width=468"><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504635-339d1550-5bd7-4f34-8eca-7de606f92831.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3a36b325&margin=%5Bobject%20Object%5D&originHeight=795&originWidth=747&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5993c173-de94-4eac-806d-e4d0ee9a8b5&title="></p><p>| <strong>public static <strong>String decodeString</strong>(<strong>String s</strong>) {<br>   char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>   <strong>return <strong>process</strong>(<strong>str, 0</strong>)</strong>.<strong>ans</strong>;<br>**}</p><p>public static class **Info **{<br>   public **String <strong>ans</strong>;<br>   <strong>public int stop</strong>;</p><p>   **public <strong>Info</strong>(**String a, **int <strong>e</strong>) {<br>      ans **&#x3D; a;<br>      **stop **&#x3D; e;<br>   **}<br>}</p><p>**&#x2F;&#x2F; s[i….]  何时停？遇到   ‘]’  或者遇到 s的终止位置，停止<br>&#x2F;&#x2F; 返回Info<br>&#x2F;&#x2F; 0) 串<br>&#x2F;&#x2F; 1) 算到了哪<br>**public static <strong>Info process</strong>(char[] **s, **int <strong>i</strong>) {<br>   **StringBuilder ans &#x3D; <strong>new <strong>StringBuilder</strong>()</strong>;<br>   **int **count &#x3D; 0;<br>   **while (**i &lt; s.**length **&amp;&amp; s**[**i**] **!&#x3D; **’]’) {<br>      if ((**s**[**i**] **&gt;&#x3D; **’a’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’z’) **&amp;#124;&amp;#124; **(**s**[**i**] **&gt;&#x3D; **’A’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’Z’)) {<br>         **ans.append**(**s**[**i++**])**;<br>      **} else if (**s**[**i**] **&gt;&#x3D; **’0’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’9’) {<br>         <strong>count &#x3D; count * 10 + s</strong>[<strong>i++</strong>] <strong>- <strong>‘0’</strong>;<br>      <strong>} else { <strong>&#x2F;&#x2F; str[index] &#x3D; ‘[‘<br>         Info next &#x3D; process</strong>(<strong>s, i + 1</strong>)</strong>;<br>         ans.append</strong>(<strong>timesString</strong>(**count, next.<strong>ans))</strong>;<br>         &#x2F;&#x2F;<br>         count &#x3D; 0;<br>         i &#x3D; next.<strong>stop <strong>+ 1;<br>      <strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>ans.toString</strong>()</strong>, i</strong>)</strong>;<br>**}</p><p>public static <strong>String timesString</strong>(int <strong>times, String str</strong>) {<br>   **StringBuilder ans &#x3D; <strong>new <strong>StringBuilder</strong>()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; times; i++</strong>) {<br>      <strong>ans.append</strong>(<strong>str</strong>)</strong>;<br>   <strong>}<br>   return <strong>ans.toString</strong>()</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-最长连续序列"><a href="#·-最长连续序列" class="headerlink" title="· 最长连续序列"></a>· 最长连续序列</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650027587467-9c71453c-132e-4e65-92ea-5e95c4838e80.png#clientId=u98aeb21b-e583-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=341&id=uc6150b29&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35602&status=done&style=none&taskId=u165c0c4b-a7e3-4fba-bdad-65d2fc46eed&title=&width=666.4" alt="image.png"><br><strong>题解</strong><br>连续区间头表+连续区间尾表<br>100来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450085-90058467-9331-4e7f-afc9-abfc89b72c9e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u25beeefc&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=1139&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e7bb74f-ea0e-4c9a-93a4-d29beffe1e0&title=&width=530"><br>3来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450084-3d961eca-d28d-4f43-b7fe-e707f3e47a19.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=uac2eb7d7&margin=%5Bobject%20Object%5D&originHeight=461&originWidth=1141&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u17d37d9c-915a-46fd-ab24-ef6eb833409&title=&width=498"><br>4来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450169-15fadec0-cbd9-4797-82c9-51f4aa1f8295.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u4eee0f77&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9de3535e-8e32-4ff8-bc47-4d00a37927c&title=&width=480"><br>合并<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450083-6829ff9b-d260-46f0-b4f6-170148bd867e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ud0fd55ea&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1511e11d-3175-4713-8409-9f9a8863080&title=&width=457"><br>6来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450067-4a7f66f8-a015-411b-a4cc-095f219446d4.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u00347243&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90b8fbaa-d0f1-43c4-8845-9a8afae0a7f&title=&width=480"><br>7来了<br>5<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450782-178be574-6064-458a-9275-a8f116757def.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u9c05a450&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u85da3f43-5abc-4192-bdfc-dccfad0d0ca&title=&width=472"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450958-39fc9099-3c15-44d8-bc54-5f2a4a86304a.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=uaca38d01&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udcfcab17-b0c7-49d5-b493-4931f6a3233&title=&width=448"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450977-0bb7308a-fa05-40a5-9dcf-9540516264b5.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=uedf3ad85&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=1091&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u863f4790-bc00-4d11-b7ac-4d41a2ecfc5&title=&width=428"><br>总结<br>每个数来的时候都自己建出自己的区间，看看跟之前都不能合，看看后面能不能合,<br>你每次都严严格格的合完之后，你问我最后有多长的连续区间，你随便找一张表，把value最大值拿出来<br>每一个数来到的时候, 对于哈希表的操作都是O(1)<br><strong>代码</strong><br>难点在于它怎么只用一张哈表搞出来。</p><p>| **public static int <strong>longestConsecutive</strong>(int[] <strong>nums</strong>) {<br>   <strong>HashMap</strong>&lt;**Integer, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>len &#x3D; 0;<br>   <strong>for (int <strong>num : nums</strong>) {<br>      if (</strong>!map.containsKey</strong>(<strong>num</strong>)) {<br>         <strong>map.put</strong>(<strong>num, 1</strong>)</strong>;<br>         <strong>int <strong>preLen &#x3D; map.containsKey</strong>(<strong>num - 1</strong>) <strong>? map.get</strong>(<strong>num - 1</strong>) <strong>: 0;<br>         <strong>int <strong>posLen &#x3D; map.containsKey</strong>(<strong>num + 1</strong>) <strong>? map.get</strong>(<strong>num + 1</strong>) <strong>: 0;<br>         <strong>int <strong>all &#x3D; preLen + posLen + 1;<br>         map.put</strong>(<strong>num - preLen, all</strong>)</strong>;<br>         map.put</strong>(<strong>num + posLen, all</strong>)</strong>;<br>         len &#x3D; Math.max</strong>(<strong>len, all</strong>)</strong>;<br>      **}<br>   }<br>   return **len;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-超级洗衣机（硬记）"><a href="#·-超级洗衣机（硬记）" class="headerlink" title="· 超级洗衣机（硬记）"></a><strong>· 超级洗衣机（硬记）</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932367995-bbe4de73-2904-4594-916c-9533bbc0f67e.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=uea6a2d41&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39680&status=done&style=none&taskId=u8f0f91ee-9a43-4785-a206-f20939def19&title=&width=668" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403145-b876e20d-8562-4eff-b4f8-d442cf06b0f4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=u3a840e1e&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0ffadcba-008c-4d96-b91e-d0ebf518fa5&title=&width=482"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403138-c0c32760-5291-473e-8c7b-ed2d0d17ab3d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=u2bc83435&margin=%5Bobject%20Object%5D&originHeight=569&originWidth=1275&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udf474620-5c39-4ccf-9947-d5377322ff9&title=&width=432"><br><strong>题解</strong><br>大过滤器<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403158-39eaeb21-beea-423a-9a81-ab1b3e4f0c8a.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u5dbce6c0&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=889&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b72d3a9-8d80-444f-a2a7-71510f9fd37&title=&width=381"><br>思想传统: 算单点的瓶颈, 最后看总答案跟单点瓶颈之间的关系</p><p>假设来到某一台(i号)洗衣机, 衣服数量?<br>假设每台机器该有的平均数我们知道<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403159-bc4570ef-622d-4f66-b7b2-806dd142a67c.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=uaf6e2a70&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1229&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc26ff0ff-3a4e-4e24-ae5a-aa0f7723c5f&title=&width=589"><br><strong>第一种情况</strong><br>左右两侧有一个为正数有一个为负数<br>左侧整体欠15件。而它右侧整体多10件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403191-6e7e37d7-0bf5-4987-a6ce-5be5b43a0741.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u95da6da5&margin=%5Bobject%20Object%5D&originHeight=622&originWidth=837&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u070d6067-1b7d-42c5-b8ff-3bc599784ca&title=&width=386"><br>左侧整体欠15件。而它右侧整体多20件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932412835-bcbf1abd-1049-4490-a288-38569f24b131.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u491fbc95&margin=%5Bobject%20Object%5D&originHeight=604&originWidth=899&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua656072e-d9c0-41e4-8e4c-954b2598c76&title=&width=402"><br><strong>总结</strong><br>左右两侧有一个为正数有一个为负数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932414115-732d2fca-785a-4f8e-a095-b8ca0fbe23b4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=ucc357489&margin=%5Bobject%20Object%5D&originHeight=546&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5290c3aa-c695-47a0-9411-e0238a73417&title=&width=394"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932417841-5e9e3984-a2c9-4e68-9694-6b85c58bafd0.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u6fe2d0e8&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=971&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ac861c9-058d-4e4e-8e96-d5996a3c43d&title=&width=365"><br><strong>第二种情况</strong><br>左右两侧都为正数<br>i如果衣服特别少就可能左右两侧都要给它衣服<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932420558-7c95096e-d93b-4f93-b6f3-4eb0b7ca8c5c.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=ud8e9e4fd&margin=%5Bobject%20Object%5D&originHeight=638&originWidth=857&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6165a81f-c605-4f9c-a6aa-8fe99ad651f&title=&width=296"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421080-d8bf23ca-28a5-4431-aa0e-425b360ae4bd.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u2fc15dd2&margin=%5Bobject%20Object%5D&originHeight=561&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u720e32f9-1f9c-4cd3-bec7-e5cff31ee20&title=&width=394"><br><strong>最后一种情况</strong><br>左右两侧都为负数<br>如果左侧欠15件。右侧欠7件，我问你是要搬多少轮, 两侧都指望着i出力, 它一次只能扔一件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421484-2e38c5da-e2b5-44fc-b02a-0f6932eb9510.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=udc41672d&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=745&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6afbd492-5e3d-4243-ae8d-d15ddd0797d&title=&width=408"><br>先算一个总衣服的数量，你再算一个左侧部分的累加和, i位置自己有值。<br>左侧部分欠几件还多几件, 右侧部分欠几件还是多几件。都能算出来<br>有一个衣服的总数量，有一个i左侧的累加和, 接下来你到任何一个i位置。<br>你左侧, 右侧到底是多还是少？你都能算出来</p><p>根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,<br>2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。<br>因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了<br>因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421558-5fddfdda-a71d-4671-aece-dc0b34e07408.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u75e1afcf&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1024&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u550aae88-3e80-416e-bdc1-1f855da6fc1&title=&width=445"><br><strong>单点思维传统</strong><br>接雨水的问题, 左侧最大值最小值问题，这些东西都是以单点算出来一个答案，然后去决策等。<br>洗衣机问题它属于我把整个问题，我不去想它整体我就想它单点的答案是啥，你给我整出一个答案，<br>然后我去决策出来什么东西，以后单点去求然后再得到整体答案的办法，将会成为我们的一个思想传统。<br>类似子串子数组问题, 每个位置结尾时候啥答案。其实这也是<strong>单点思维。</strong><br><strong>代码</strong></p><p>| **public static int <strong>findMinMoves</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **size &#x3D; arr.<strong>length</strong>;<br>   **int **sum &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; size; i++</strong>) {<br>      <strong>sum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   **}<br>   if (<strong>sum % size !&#x3D; 0</strong>) {<br>      return **-1;<br>   **}<br>   int **avg &#x3D; sum &#x2F; size;<br>   &#x2F;&#x2F;左侧部分累加和<br>   **int **leftSum &#x3D; 0;<br>   **int **ans &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      **&#x2F;&#x2F;左侧部分剩余<br>      **int **leftRest &#x3D; leftSum - i * avg;<br>      &#x2F;&#x2F;右侧部分剩余<br>      **int **rightRest &#x3D; **(<strong>sum - leftSum - arr</strong>[<strong>i</strong>]) <strong>- <strong>(<strong>size - i - 1</strong>) *** avg;<br>      <strong>if (<strong>leftRest &lt; 0 &amp;&amp; rightRest &lt; 0</strong>) {<br>         <strong>ans &#x3D; Math.max</strong>(<strong>ans, Math.abs</strong>(<strong>leftRest</strong>) <strong>+ Math.abs</strong>(<strong>rightRest</strong>))</strong>;<br>      <strong>} else {<br>         <strong>ans &#x3D; Math.max</strong>(<strong>ans, Math.max</strong>(<strong>Math.abs</strong>(<strong>leftRest</strong>)</strong>, Math.abs</strong>(<strong>rightRest</strong>)))</strong>;<br>      <strong>}<br>      <strong>leftSum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   **}<br>   return **ans;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-缺失的第一个正数"><a href="#·-缺失的第一个正数" class="headerlink" title="· 缺失的第一个正数"></a><strong>· 缺失的第一个正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922711623-5f275d70-6ad9-4a85-b908-b754c4c08188.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=377&id=u10e943fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31833&status=done&style=none&taskId=u01469d94-35f3-4ad3-8669-3edd28f7319&title=&width=536.8" alt="image.png"><br>核心就是<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922917933-411751da-967b-4a5a-bba8-08ca6afba789.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u1d4d9e20&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81409&status=done&style=none&taskId=uea4d21e0-d3fc-4dc9-be76-12aa8351e2e&title=&width=503.2" alt="image.png"><br>分为有效区和垃圾区<br>核心</p><ul><li>如果L位置上的数 &lt;&#x3D;L跟垃圾区交换</li><li><blockquote><p>R位置的数 跟垃圾区交换</p></blockquote></li><li>等于 arr[arr[L]-1]的数也交换<br>| **public static int <strong>firstMissingPositive</strong>(int[] <strong>arr</strong>) {<br> **&#x2F;&#x2F; l是盯着的位置<br> &#x2F;&#x2F; 0 ~ L-1有效区<br> **int **L &#x3D; 0;<br> **int **R &#x3D; arr.<strong>length</strong>;<br> **while (<strong>L !&#x3D; R</strong>) {<br>**&#x2F;&#x2F;有效区向右扩<br>**if (<strong>arr</strong>[<strong>L</strong>] <strong>&#x3D;&#x3D; L + 1</strong>) {<br>   **L++;<br><strong>} else if (<strong>arr</strong>[<strong>L</strong>] <strong>&lt;&#x3D; L &amp;#124;&amp;#124; arr**[**L**] **&gt; R &amp;#124;&amp;#124; arr</strong>[<strong>arr</strong>[<strong>L</strong>] <strong>- 1</strong>] <strong>&#x3D;&#x3D; arr</strong>[<strong>L</strong>]) { <strong>&#x2F;&#x2F; 垃圾的情况<br>   swap</strong>(<strong>arr, L, –R</strong>)</strong>;<br><strong>} else {<br>   <strong>swap</strong>(<strong>arr, L, arr</strong>[<strong>L</strong>] <strong>- 1</strong>)</strong>;<br>**}<br> }<br> return **L + 1;<br>**}</li></ul><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-数组的自己不能累加和出的最小正数"><a href="#·-数组的自己不能累加和出的最小正数" class="headerlink" title="· 数组的自己不能累加和出的最小正数"></a><strong>· 数组的自己不能累加和出的最小正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649908121718-8953c38b-c4f7-47ac-ae29-35e9ffd72e37.png#clientId=u66160ce2-b06d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=99&id=u1ea6fc03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=366&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12897&status=done&style=none&taskId=u8559eaa1-8292-41bd-a5cc-ca091503438&title=&width=292.8" alt="image.png"><br><strong>第一问</strong><br>同上问<br>arr所有值的累加和从一个负数到一个整数做出一张表, 然后看最后一行<br>arr 0~N-1宿友的值能不能搞定1, 2, 3…, 哪一个最早不行的, 返回就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274512-42b3c5d7-4c34-41d1-90af-b01987c4bcf7.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=ub0253dce&margin=%5Bobject%20Object%5D&originHeight=664&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4c3059f8-c8ca-4e0e-8def-f24e2bb3715&title=&width=434"></p><p>| **public static int <strong>unformedSum2</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **1;<br>   **}<br>   int **sum &#x3D; 0;<br>   <strong>int <strong>min &#x3D; Integer.<strong>MAX_VALUE</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>sum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      min &#x3D; Math.min</strong>(<strong>min, arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   **&#x2F;&#x2F; boolean[][] dp …<br>   **int **N &#x3D; arr.<strong>length</strong>;<br>   **boolean[][] **dp &#x3D; <strong>new boolean[<strong>N</strong>][<strong>sum + 1</strong>]</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++**) {**&#x2F;&#x2F; arr[0..i] 0<br>      dp**[**i**][**0**] **&#x3D; **true**;<br>   **}<br>   **dp**[**0**][**arr**[**0**]] **&#x3D; **true**;<br>   **for (int **i &#x3D; 1; i &lt; N; i++**) {<br>      for (int **j &#x3D; 1; j &lt;&#x3D; sum; j++**) {<br>         **dp**[**i**][**j**] **&#x3D; dp**[**i - 1**][**j**] **&amp;#124;&amp;#124; **((**j - arr**[**i**] **&gt;&#x3D; 0</strong>) <strong>? dp</strong>[<strong>i - 1</strong>][<strong>j - arr</strong>[<strong>i</strong>]] <strong>: <strong>false)</strong>;<br>      <strong>}<br>   }<br>   for (int <strong>j &#x3D; min; j &lt;&#x3D; sum; j++</strong>) {<br>      if (</strong>!dp</strong>[<strong>N - 1</strong>][<strong>j</strong>]) {<br>         return **j;<br>      **}<br>   }<br>   return **sum + 1;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>第二问</strong><br>先把array排序, 正数数组排完序, 左边0位置肯定是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274407-d5bb7112-75b6-4c1a-8c5a-636c29d2da74.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=u7c7998e0&margin=%5Bobject%20Object%5D&originHeight=598&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6d443944-221f-4578-af40-df6b9538517&title=&width=428"><br>定义变量range &#x3D;1, 表示从1<del>1范围上的正数都能累加出来<br>range&#x3D;k, 代表1</del>k上的所有正数都能搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-064d2ceb-c903-444a-8b3b-def179bd1054.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=udb091615&margin=%5Bobject%20Object%5D&originHeight=627&originWidth=1208&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87640a35-779d-455c-92d7-3d66170c5b2&title=&width=451"><br>当arr 0位置是1的情况下, range&#x3D;1, 代表1<del>1范围的正数都可以搞出来<br>如果1位置也是1, range变成2, 代表1</del>2范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-3a9c1b06-df19-4cbf-a1a0-8890c1df2d33.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u4a638e7d&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uacb8b2ee-8e40-476b-b0e6-d3dd0902597&title=&width=546"><br>如果2位置也是2, range变成4, 代表1<del>4范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274433-c44f8de2-ab64-4735-a4ae-0d303eaeb2be.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=u36d33f1c&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=1218&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75c49504-7235-4203-9e18-e0efd1c066a&title=&width=500"><br>如果0</del>i-1是0~100, range&#x3D;100<br>i位置17, 可以让range扩充到117</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276639-76ea18e4-1553-4416-b729-602f169e4256.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=ud24b4420&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf800b3ae-b828-40f4-9f35-e53b5b30e59&title=&width=540"><br>注意一点<br>如果0<del>i-1能搞定的数是1</del>100, 此时i位置是102, 那么101不可以搞定<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276627-25522d30-aa31-47f1-a2c0-70754b005b35.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=ub8d18f54&margin=%5Bobject%20Object%5D&originHeight=641&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c78c50f-b4c4-4174-aeb2-65532acedc1&title=&width=484"><br><strong>抽象化</strong><br>如果0<del>i-1搞定1</del>a, 如果i位置上是b:<br>1)如果b&lt;&#x3D; a+1, 能扩充, 范围到1~a+b<br>2)如果b&gt; a+1, a+1就是搞定不了的最小正整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276617-5b986e34-cf33-4d56-a953-8b54313b7cb9.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=309&id=u561892aa&margin=%5Bobject%20Object%5D&originHeight=661&originWidth=1101&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8618d200-7b25-4c41-89a5-14bb0c7e026&title=&width=515"><br><strong>代码</strong></p><p>| **&#x2F;&#x2F; 已知arr中肯定有1这个数<br>**public static int <strong>unformedSum3</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   <strong>}<br>   <strong>Arrays.sort</strong>(<strong>arr</strong>)</strong>; &#x2F;&#x2F; O (N * logN)<br>   **int **range &#x3D; 1;<br>   &#x2F;&#x2F; arr[0] &#x3D;&#x3D; 1<br>   **for (int <strong>i &#x3D; 1; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; range + 1</strong>) {<br>         return **range + 1;<br>      <strong>} else {<br>         <strong>range +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      **}<br>   }<br>   return **range + 1;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>原题<br>arr是正数, 要求子集不能是空集, 最小子集累加和到最大子集累加和的范围中哪个数是最小不可组成的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927277249-0071ad5e-e13b-4370-bfe9-c4e82ef62414.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=202&id=u10a4ace4&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1230&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6504140f-42f0-4cdd-ab09-4e8752f37b5&title=&width=385"></p><h2 id="·-按要求补齐数组"><a href="#·-按要求补齐数组" class="headerlink" title="· 按要求补齐数组"></a>· 按要求补齐数组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649917704725-47286ee2-4581-440e-87d2-40217bdc6892.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=401&id=uafa838b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=501&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36432&status=done&style=none&taskId=u650b2498-cf20-4fe1-bdde-0a59049f6aa&title=&width=656.8" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555620-061a554b-82b5-41e0-9e92-a690ce40510d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=ud98747b1&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=1248&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc3bcf646-19ce-4700-8f4a-bd401665f44&title=&width=389"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555641-e30d7e5e-1c75-4f52-a033-af5aee074d54.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u7ba03d88&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=1240&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a3bc28c-d3a2-4b58-ba9a-de9d7ca6744&title=&width=477"><br>到达数字+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555680-c1d3ccf6-3771-4e93-96b8-39c885a5a4bf.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=211&id=ub2e23613&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc2cbb657-a0c0-4d31-afee-d802e35c8fe&title=&width=417"><br><strong>题解</strong><br>先把数组排序<br>数组中每个数最经济的使用<br>只能是 1<del>3 范围，你先都搞定之后，你舒舒服服，使用这个4，就能扩到1</del>7了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555600-28054282-00a3-4ada-b588-8c83daa1343d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u36009711&margin=%5Bobject%20Object%5D&originHeight=414&originWidth=1355&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c1ace8f-dc3d-4e30-aa37-c80e0af525c&title=&width=540"><br>给自己提了小目标，这个小目标是搞定1<del>3 范围上，你缺几个数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555576-2c52f0c4-a3ee-4fe0-99fd-d5ad4194db98.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=u2bb70482&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1326&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u30cd7616-6530-4109-9843-187a632bcd8&title=&width=539"><br>对于5, 小目标1</del>4范围上都可以搞定, 已经满足了<br>可以直接使用这个5，让它变成12，不用添任何数字</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559417-d4b87abf-d387-42d2-8d80-4a0a8ec4f0c4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u32d93753&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=1317&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u127e139e-6b60-4227-ad19-1e323514d0d&title=&width=521"><br>想使用17, 要求目标1<del>16必须具备<br>目前有1</del>12, 缺13, 补13之后范围扩到1~25<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559808-215561a1-ff63-415f-bf78-fad7b73a64ba.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=uea5b1f49&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1322&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2cc09c61-ee32-4302-b314-4ba0be0fea5&title=&width=507"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927560402-d3d539ae-2061-402e-8409-47fe164264a2.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=227&id=u09c809c8&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1338&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7877baab-db60-4c74-96b5-33a014c76fd&title=&width=491"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561057-82a9fd44-9823-4f41-858c-acdcdc07147b.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u1757f08b&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1340&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucad0fd2b-6999-4754-89cb-2a2fdc5f0e0&title=&width=468"><br><strong>例子</strong><br>如果n特别大, 整个数组都使用完以后范围是1~3050, 先补3051<br>整个数组都使完之后，如果你还没到，接下来的过程就等同于给了你一个范围，你一个数也没有了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561285-f47b7093-d077-49ef-9d8a-40af2438e4b0.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u48355d80&margin=%5Bobject%20Object%5D&originHeight=587&originWidth=1165&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25fd03f5-cf32-4ea9-b5a2-10523fc59b6&title=&width=399"><br>注意点<br>只要范围扩充了，我就盯着总目标有没有实现，我不一定要使用完所有数字，我可能已经提前搞定考了，<br>我缺了多少数字，如果发现我range已经到它了，直接返回就可以了，不用看后面的数字<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927562331-6d5e0b3b-b786-468c-a940-7c5b9ed70aa2.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=u84594179&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1341&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d649c1a-e5d8-43f0-87e0-47de55d83b7&title=&width=510"></p><p>| &#x2F;&#x2F; arr请保证有序，且正数  1~aim<br>**public static int <strong>minPatches</strong>(int[] **arr, **int <strong>aim</strong>) {<br>   int **patches &#x3D; 0; &#x2F;&#x2F; 缺多少个数字<br>   <strong>long <strong>range &#x3D; 0; &#x2F;&#x2F; 已经完成了1 ~ range的目标<br>   Arrays.sort</strong>(<strong>arr</strong>)</strong>;<br>   **for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      **&#x2F;&#x2F; arr[i]<br>      &#x2F;&#x2F; 要求：1 ~ arr[i]-1 范围被搞定！<br>      **while (<strong>arr</strong>[<strong>i</strong>] <strong>- 1 &gt; range</strong>) { **&#x2F;&#x2F; arr[i] 1 ~ arr[i]-1<br>         range +&#x3D; (range + 1); &#x2F;&#x2F; range + 1 是缺的数字<br>         patches++;<br>         &#x2F;&#x2F;只要范围一变化就盯着目标<br>         **if (<strong>range &gt;&#x3D; aim</strong>) {<br>            return **patches;<br>         <strong>}<br>      }<br>      <strong>&#x2F;&#x2F; 要求被满足了！<br>      range +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      **if (<strong>range &gt;&#x3D; aim</strong>) {<br>         return **patches;<br>      **}<br>   }<br>   while (<strong>aim &gt;&#x3D; range + 1</strong>) {<br>      **range +&#x3D; range + 1;<br>      patches++;<br>   **}<br>   return **patches;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="x2F-x2F-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x2F-x2F-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><h2 id="·-240-行列递增矩阵的查找-搜索二维矩阵-II-M"><a href="#·-240-行列递增矩阵的查找-搜索二维矩阵-II-M" class="headerlink" title="· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]"></a>· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538431656-6b591c24-62b5-4f4d-a992-0e2ee6455b85.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=ucaa40dd5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11740&status=done&style=none&taskId=u76050ce0-5216-4663-83e4-b58fdd5ced0&title=&width=439.2" alt="image.png"><br><strong>题意</strong><br>让你找某一个数字在其中是否存在<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537626124-5e69971c-798a-4382-a6c0-56062f07a154.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u825d9625&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=642&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u938e2c19-6aff-4589-84b0-79641bb03ae&title=&width=348"><br><strong>题解</strong><br>经典解法:<br>从右上角开始找<br>复杂度O(N+M)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624515-057e50f5-c481-4b0a-8091-003f019142d4.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u86a3eab4&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1257&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufda2a2e9-c766-4bc5-9780-98846953c45&title=&width=553"><br>从左下角走</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624507-9f4bca2b-fa51-4bd1-ae0a-cc127e634a97.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=ubf5cba53&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0f5c24b9-5e75-475b-96da-fcd5f286991&title=&width=515"></p><p>| **public static boolean <strong>isContains</strong>(int[][] **matrix, **int <strong>K</strong>) {<br>   int **row &#x3D; 0;<br>   <strong>int <strong>col &#x3D; matrix</strong>[<strong>0</strong>]</strong>.**length **- 1;<br>   <strong>while (<strong>row &lt; matrix.**length **&amp;&amp; col &gt; -1</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&#x3D;&#x3D; K</strong>) {<br>         return true</strong>;<br>      **} else if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&gt; K</strong>) {<br>         **col–;<br>      **} else {<br>         **row++;<br>      <strong>}<br>   }<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊378-行列递增矩阵中的第K小-M"><a href="#·-✊378-行列递增矩阵中的第K小-M" class="headerlink" title="· ✊378.行列递增矩阵中的第K小 [M]"></a>· ✊378.行列递增矩阵中的第K小 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538447469-55d93518-20af-4ac9-bb0d-cc650b505a39.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=75&id=ue2220b92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=94&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12027&status=done&style=none&taskId=u7642227d-241c-4306-8adb-3d21d1474a6&title=&width=434.4" alt="image.png"><br><strong>最优解</strong><br>给定一个目标, 想知道&lt;&#x3D;100的数有几个, 怎么快能求出来?<br>往左走, 获得0个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464907-2dead8bf-8612-4941-8c80-3b22ba09131b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u2e5cfef4&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=1302&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua5722571-1037-41c0-a18e-d6fb6cb934b&title=&width=427"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464900-3f1bafb2-1bae-4cdb-8c53-cc846c69f134.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u4704966e&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1269&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4d022a33-b6ba-45b1-8229-acd68f70a81&title=&width=500"><br>就这样一直卡到结束，你正确的获得整个数组中有多少个数&lt;&#x3D;100<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464925-50973775-2761-4ed9-8cd5-5337041bf338.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=ua11d3edf&margin=%5Bobject%20Object%5D&originHeight=636&originWidth=1279&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueff346fb-ab57-4bd5-9a3e-3880b1e4b7b&title=&width=534"><br>**例子**<br>&lt;&#x3D;100的有几个, 同时也可以知道最接近100的是啥数?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464932-49c9b5d2-a01d-4a5c-8975-50303fa6a936.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u56983f42&margin=%5Bobject%20Object%5D&originHeight=588&originWidth=1296&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u67098799-26c6-4f3c-8175-19f94ecb673&title=&width=521"><br>120&gt;100获得0个</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464930-de301eda-d2b0-440b-b938-1bc52130534e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=u2cdb7407&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1311&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b4b31cf-26dc-496f-8390-87189a86c68&title=&width=411"><br>100&gt;90 假设90所在的列是col<br>获得的个数是rol+1<br>同时更新接近100的数字为90</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465650-44206736-0a80-4be1-b524-3e42d7c92086.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u653e1491&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=1304&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uefd5909b-1438-4e68-8c39-07bb5605a84&title=&width=549"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465710-67505b3a-0cc8-4c66-b908-40ff88ecab43.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u66d628df&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufefde839-ee65-4893-88e1-ff39a92a975&title=&width=431"><br>解决原问题<br><strong>二分</strong><br>整个数组中最小的是谁？左上角的数<br>那整个数组中，最大的数是谁？右下角的数<br>第一百小的数一定在一到1000之间, 看看&lt;&#x3D;500的数有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465810-e8be4f70-42f7-4fa5-b7a0-c81514b2ff5d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=256&id=u9bcf7146&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1219&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u479e614c-408d-4eb6-9c84-94373d1aa27&title=&width=521"><br>如果&lt;&#x3D;500有200个, 目标大了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465999-a6e86772-a3ac-4585-a06c-2081f5cdd43e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=284&id=uddbef8b1&margin=%5Bobject%20Object%5D&originHeight=650&originWidth=1265&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u361c54da-f6cb-48a8-9aaf-db96a0a03c1&title=&width=553"><br>有可能最后得到&lt;&#x3D;785的数有100个, 但是数组中没有这个数, 应该是&lt;&#x3D;785并离它最近<br>的数<br>我每次让你过的时候求俩信息，</p><ul><li>第一小于等于某一个值个数有几个</li><li>第二，最接近它的是谁？</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466133-869c69d6-fbbd-4e08-b85f-e7affbbdba50.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=u32fd171a&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1263&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf7b5a0ae-78a1-4110-90ef-898624a9d91&title=&width=560"><br><strong>复杂度</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466525-0b2fee08-0f44-4e91-b063-3992ab4853f0.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=268&id=ucbc9934f&margin=%5Bobject%20Object%5D&originHeight=659&originWidth=1263&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua58a75d8-03db-4569-b937-1af685bff8d&title=&width=513"><br><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466467-9e5f348e-c41d-4268-9b00-b0c0e20be6de.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u762a2f31&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1285&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8fa0287d-25c4-48b9-a7cf-aa1e3e128a1&title=&width=516"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466606-1c01a2b3-8288-4f63-a32f-5ef20107ec9d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=ua6082d71&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=912&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1827838a-ed61-4d55-b0e4-80808063065&title=&width=564"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466819-f599b5d1-bfaf-409d-9a8b-05f51b31ee1a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u7c9fce28&margin=%5Bobject%20Object%5D&originHeight=671&originWidth=1356&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u150b1272-8545-4d16-8622-d69dad22697&title=&width=544"><br><strong>代码</strong></p><p>| &#x2F;&#x2F; 二分的方法<br>**public static int <strong>kthSmallest2</strong>(int[][] **matrix, **int <strong>k</strong>) {<br>   int **N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   <strong>int <strong>left &#x3D; matrix</strong>[<strong>0</strong>][<strong>0</strong>]</strong>;<br>   <strong>int <strong>right &#x3D; matrix</strong>[<strong>N - 1</strong>][<strong>M - 1</strong>]</strong>;<br>   <strong>int <strong>ans &#x3D; 0;<br>   <strong>while (<strong>left &lt;&#x3D; right**) {<br>      int **mid &#x3D; left + **((**right - left**) **&gt;&gt; 1</strong>)</strong>;<br>      &#x2F;&#x2F; &lt;&#x3D;mid 有几个 &lt;&#x3D; mid 在矩阵中真实出现的数，谁最接近mid<br>      Info info &#x3D; noMoreNum</strong>(<strong>matrix, mid</strong>)</strong>;<br>      **if (**info.**num <strong>&lt; k</strong>) {<br>         **left &#x3D; mid + 1;<br>      **} else {<br>         **&#x2F;&#x2F;这里就是有可能&lt;&#x3D;785的数有100个，但是数组中没有这个数，所以要记录与他最接近的<br>         ans &#x3D; info.<strong>near</strong>;<br>         right &#x3D; mid - 1;<br>      **}<br>   }<br>   return **ans;<br>**}</p><p>public static class **Info <strong>{<br>   public int near</strong>;<br>   <strong>public int num</strong>;</p><p>   **public <strong>Info</strong>(int **n1, **int <strong>n2</strong>) {<br>      near **&#x3D; n1;<br>      **num **&#x3D; n2;<br>   **}<br>}</p><p>public static <strong>Info noMoreNum</strong>(int[][] **matrix, **int <strong>value</strong>) {<br>   int **near &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **int **num &#x3D; 0;<br>   **int **N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **row &#x3D; 0;<br>   **int **col &#x3D; M - 1;<br>   <strong>while (<strong>row &lt; N &amp;&amp; col &gt;&#x3D; 0</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&lt;&#x3D; value</strong>) {<br>         <strong>near &#x3D; Math.max</strong>(<strong>near, matrix</strong>[<strong>row</strong>][<strong>col</strong>])</strong>;<br>         num +&#x3D; col + 1;<br>         row++;<br>      **} else {<br>         **col–;<br>      <strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>near, num</strong>)</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>| &#x2F;&#x2F; 堆的方法<br><strong>public static int <strong>kthSmallest1</strong>(int[][] <strong>matrix, <strong>int <strong>k</strong>) {<br>   int <strong>N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   PriorityQueue</strong>&lt;**Node**&gt; <strong>heap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;(new <strong>NodeComparator</strong>())</strong>;<br>   <strong>boolean[][] <strong>set &#x3D; <strong>new boolean[<strong>N</strong>][<strong>M</strong>]</strong>;<br>   heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>0</strong>][<strong>0</strong>]</strong>, 0, 0</strong>))</strong>;<br>   set</strong>[<strong>0</strong>][<strong>0</strong>] <strong>&#x3D; <strong>true</strong>;<br>   <strong>int <strong>count &#x3D; 0;<br>   Node ans &#x3D; <strong>null</strong>;<br>   <strong>while (</strong>!heap.isEmpty</strong>()) {<br>      <strong>ans &#x3D; heap.poll</strong>()</strong>;<br>      <strong>if (</strong>++count &#x3D;&#x3D; k</strong>) {<br>         break</strong>;<br>      <strong>}<br>      int <strong>row &#x3D; ans.<strong>row</strong>;<br>      <strong>int <strong>col &#x3D; ans.<strong>col</strong>;<br>      <strong>if (<strong>row + 1 &lt; N &amp;&amp; !set</strong>[<strong>row + 1</strong>][<strong>col</strong>]) {<br>         <strong>heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>row + 1</strong>][<strong>col</strong>]</strong>, row + 1, col</strong>))</strong>;<br>         set</strong>[<strong>row + 1</strong>][<strong>col</strong>] <strong>&#x3D; <strong>true</strong>;<br>      <strong>}<br>      if (<strong>col + 1 &lt; M &amp;&amp; !set</strong>[<strong>row</strong>][<strong>col + 1</strong>]) {<br>         <strong>heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>row</strong>][<strong>col + 1</strong>]</strong>, row, col + 1</strong>))</strong>;<br>         set**[<strong>row</strong>][<strong>col + 1</strong>] **&#x3D; <strong>true</strong>;<br>      **}<br>   }<br>   return **ans.<strong>value</strong>;<br>**}</p><p>public static class **Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   **public <strong>Node</strong>(int **v, **int **r, **int <strong>c</strong>) {<br>      value **&#x3D; v;<br>      **row **&#x3D; r;<br>      **col **&#x3D; c;<br>   **}</p><p>}</p><p>public static class **NodeComparator **implements <strong>Comparator</strong>&lt;**Node**&gt; {</p><p>   **@Override<br>   **public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return **o1.**value **- o2.<strong>value</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><h2 id="·-940-不同的子序列-II-H"><a href="#·-940-不同的子序列-II-H" class="headerlink" title="· 940.不同的子序列 II [H]"></a>· 940.不同的子序列 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538612708-fda8d9fb-bb27-4677-8080-a6c88db86f79.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=u64377b4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=412&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24324&status=done&style=none&taskId=ub9741443-896e-42ce-8c56-8a848253493&title=&width=529.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-ffb30de6-f89e-4cc2-97f9-f689fa201501.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=u1fea0879&margin=%5Bobject%20Object%5D&originHeight=587&originWidth=1215&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u55df378d-a803-40de-a808-0dedf0ccfe0&title=&width=458"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-f0b61739-d00f-48b6-998c-26a3711ea3bf.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u1df3788a&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1042&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4f9cf5bd-ef8b-440e-8b26-ba037940ecf&title=&width=429"><br><strong>题解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655384932788-bf089bd0-c6f2-473c-a397-a313422b8837.png#clientId=u782dedcd-cafb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1810&id=ua0fa29c9&margin=%5Bobject%20Object%5D&name=779E39B64BA9EC69E5A1C515E4200530.png&originHeight=3168&originWidth=1424&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1164522&status=done&style=none&taskId=udfa184cd-8bbd-4169-93f5-29e4850f4c6&title=&width=813.7142857142857" alt="779E39B64BA9EC69E5A1C515E4200530.png"><br>模操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538826795-e3410ba0-a512-485d-951d-69bb5cb981a6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9b1dd3e0&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=755&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u811d823a-3961-4f75-b8f3-4b6d6da427b&title="></p><p>| **public static int <strong>zuo1</strong>(<strong>String s</strong>) {<br>      if (**s &#x3D;&#x3D; **null <strong>&amp;#124;&amp;#124; s.length</strong>() <strong>&#x3D;&#x3D; 0</strong>) {<br>         return **0;<br>      **}<br>      int <strong>m &#x3D; 1000000007;<br>      <strong>char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>      HashMap</strong>&lt;**Character, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>      **int **all &#x3D; 1; &#x2F;&#x2F; 一个字符也没遍历的时候，有空集<br>      **for (char <strong>x : str</strong>) {<br>         **&#x2F;&#x2F;新加出来的玩意儿就是以什么结尾的数量<br>         **int **newAdd &#x3D; all;<br>         <strong>int <strong>curAll &#x3D; all + newAdd - <strong>(<strong>map.containsKey</strong>(<strong>x</strong>) <strong>? map.get</strong>(<strong>x</strong>) <strong>: 0</strong>)</strong>;<br>         all &#x3D; curAll;<br>         map.put</strong>(<strong>x, newAdd</strong>)</strong>;<br>      **}<br>      return **all;<br>   **}<br>   public static int <strong>zuo</strong>(<strong>String s</strong>) {<br>      if (**s &#x3D;&#x3D; **null <strong>&amp;#124;&amp;#124; s.length</strong>() <strong>&#x3D;&#x3D; 0</strong>) {<br>         return **0;<br>      **}<br>      int <strong>m &#x3D; 1000000007;<br>      <strong>char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>      HashMap</strong>&lt;**Character, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>      **int **all &#x3D; 1; &#x2F;&#x2F; 一个字符也没遍历的时候，有空集<br>      **for (char <strong>x : str</strong>) {<br>         int **newAdd &#x3D; all;<br>&#x2F;&#x2F;       int curAll &#x3D; all + newAdd - (map.containsKey(x) ? map.get(x) : 0);<br>         **int **curAll &#x3D; all;<br>         curAll &#x3D; **(<strong>curAll + newAdd</strong>) **% m;<br>         &#x2F;&#x2F;减完可能为负数，所以要先加<br>         curAll &#x3D; **(**curAll - <strong>(<strong>map.containsKey</strong>(<strong>x</strong>) <strong>? map.get</strong>(<strong>x</strong>) <strong>: 0</strong>) <strong>+ m</strong>) <strong>% m;<br>         all &#x3D; curAll;<br>         map.put</strong>(<strong>x, newAdd</strong>)</strong>;<br>      **}<br>      return **all;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-汉诺塔游戏中的最优状态"><a href="#·-汉诺塔游戏中的最优状态" class="headerlink" title="· 汉诺塔游戏中的最优状态"></a>· 汉诺塔游戏中的最优状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539211568-a1dd0839-322f-4a09-8fbb-4427209b059d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=u5e9bcd3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40554&status=done&style=none&taskId=u75553f41-4211-4e03-b1c3-af09e2d344e&title=&width=489.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187846-f70f3d8f-0157-43bd-b853-e65f7208f8ce.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=ua14962a4&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1280&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u50a5c929-49c5-44bd-bc95-307b8dadc4c&title=&width=585"><br>7层汉诺塔问题的一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187621-d66d9436-5fa6-4b96-8665-50fa8b081a64.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=uc20ed9ff&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1260&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1831e6fb-2ea6-4897-b345-95c2d0e887b&title=&width=559"><br>最优解的第一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187608-84fce00e-ce50-476f-8097-9a88be815ab3.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=188&id=u606020c1&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=1323&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udc765580-8b82-4da7-9d75-d59459d93e9&title=&width=666"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187793-ebb720d3-d2df-44dd-b600-10e2915349d5.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=ue283094b&margin=%5Bobject%20Object%5D&originHeight=633&originWidth=1368&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub9dc08a9-ad4f-48c3-9036-b1723d5d890&title=&width=595"><br><strong>题解</strong><br>复杂度 O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187754-902ce282-eb4d-4ffa-b9f2-08d5bb24a1ca.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=ueee15b1a&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5fe3be44-3808-4c07-a651-80f9cb66498&title=&width=523"><br>先忘掉左中右, 目标是逐渐分解的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281818-8f55bc3d-600b-4fe1-9a28-194a2e14b313.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=uc72a3d6d&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1309&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9972a330-30f9-4bb4-b8c7-08fe6f74d00&title=&width=560"><br><strong>抽象</strong><br>i: 1<del>i的圆盘需要移动<br>F: 1</del>i的圆盘现在处在什么圆盘上, 可能是左, 中, 右<br>t: 需要去的位置, 可能是左, 中, 右<br>other: 除了from, to的另外一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281875-9d349353-6eed-4b5a-9c10-e6e7433d67c4.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=ua78ed761&margin=%5Bobject%20Object%5D&originHeight=633&originWidth=1251&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued654e3c-92fc-4ef3-a314-9c63cc17362&title=&width=574"><br><strong>代码</strong><br>i层的圆盘没有任何道理是在other上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358889-bf247fdd-e580-4abd-8d24-c40995fab0f6.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=316&id=u5e1ef882&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1171&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d288535-fb85-41b3-98d3-2cf5fb5d4b2&title=&width=591"><br>如果index还在From上, 说明第一大步没走完<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358848-516f2145-a3f9-46ba-81c9-e9ce28edee97.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=293&id=u07d3b69a&margin=%5Bobject%20Object%5D&originHeight=651&originWidth=1255&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u48e1996c-d742-490a-96d7-66c6462a3a3&title=&width=565"><br><strong>n层汉诺塔最优解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358910-0c4cbbd5-0292-44fe-b9d6-b53981389b71.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=ua0d8af67&margin=%5Bobject%20Object%5D&originHeight=654&originWidth=879&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d18edcc-fa98-42fc-8d83-170aa0206d6&title=&width=386"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028378401-1aa4cb61-81e0-4606-934e-dbf7cd028030.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u5785399a&margin=%5Bobject%20Object%5D&originHeight=612&originWidth=1203&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uea4922b0-8da4-4a95-abb3-8986b68ee4c&title=&width=491"><br>后续有任何一点点无效，你整体就无效</p><p>| **public static int <strong>kth</strong>(int[] <strong>arr</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>return <strong>step</strong>(<strong>arr, N - 1, 1, 3, 2</strong>)</strong>;<br>**}</p><p>**&#x2F;&#x2F; 0…index这些圆盘，arr[0..index] index+1层塔<br>&#x2F;&#x2F; 在哪？from 去哪？to 另一个是啥？other<br>&#x2F;&#x2F; arr[0..index]这些状态，是index+1层汉诺塔问题的，最优解第几步<br>**public static int <strong>step</strong>(int[] **arr, **int **index, **int **from, **int **to, **int <strong>other</strong>) {<br>   if (<strong>index &#x3D;&#x3D; -1</strong>) {<br>      return **0;<br>   **}<br>   if (<strong>arr</strong>[<strong>index</strong>] <strong>&#x3D;&#x3D; other</strong>) {<br>      return **-1;<br>   **}<br>   **&#x2F;**多想想就明白了<br>    * 比如 arr[3,2,1] 三层汉诺塔问题<br>    *<br>    * 第一个在to区<br>    * 第二个在<br>    *<br>    *&#x2F;<br>   &#x2F;&#x2F; arr[index] &#x3D;&#x3D; from arr[index] &#x3D;&#x3D; to;<br>   <strong>if (<strong>arr</strong>[<strong>index</strong>] <strong>&#x3D;&#x3D; from</strong>) {<br>      return <strong>step</strong>(<strong>arr, index - 1, from, other, to</strong>)</strong>;<br>   **} else {<br>      int **p1 &#x3D; **(<strong>1 &lt;&lt; index</strong>) **- 1;<br>      **int **p2 &#x3D; 1;<br>      <strong>int <strong>p3 &#x3D; step</strong>(<strong>arr, index - 1, other, to, from</strong>)</strong>;<br>      **if (<strong>p3 &#x3D;&#x3D; -1</strong>) {<br>         return **-1;<br>      **}<br>      return **p1 + p2 + p3;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><p><strong>复杂度</strong><br>单决策递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028426636-08060a50-74cc-4c62-8e62-424f512cf88c.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=338&id=u443ec777&margin=%5Bobject%20Object%5D&originHeight=634&originWidth=943&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u203f3cdf-b1ab-456b-b0c3-d0034313049&title=&width=502"></p><h2 id="·-两个有序数组间相加和的Topk问题"><a href="#·-两个有序数组间相加和的Topk问题" class="headerlink" title="· 两个有序数组间相加和的Topk问题"></a>· 两个有序数组间相加和的Topk问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539251891-3de0d850-c8d0-4239-a81d-fa1a2210426c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=ue5640a4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43271&status=done&style=none&taskId=u6feb9167-120c-415a-b74d-95ac0e48b98&title=&width=664" alt="image.png"><br>用大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031978240-dce8b855-e997-478e-933a-aab5c7268225.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=u92e50c4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82696&status=done&style=none&taskId=ue0cf5ae5-f712-4140-aac0-9aa695e0286&title=&width=456.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031989072-10c19f0a-4015-407a-8fb7-176cef820206.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u9583c67c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90083&status=done&style=none&taskId=ufffa987b-c980-44a0-89a3-38926c6b62d&title=&width=478.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032000117-c9d348c8-6b94-4a91-a50e-1a47217c9b57.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u80c59775&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119662&status=done&style=none&taskId=udb562210-be25-49bb-981b-b2ccf26efe2&title=&width=516.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032013255-95030714-b09e-4f25-a865-2758167fb7b1.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u49edc7c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=649&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146468&status=done&style=none&taskId=u5745c217-4dbe-4db4-b967-7cfbd0548ac&title=&width=519.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032038337-4b6eddac-52e2-40b0-ac4f-694be2af4927.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u7efe8179&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145293&status=done&style=none&taskId=uc4397788-c306-4e30-b954-1c34575127e&title=&width=510.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032058547-5ce5c648-4d2f-4c69-a0ca-51424b5f5c83.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=uec145c06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=317&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38852&status=done&style=none&taskId=uee16e7db-0793-4ade-bcf7-ae43094fe60&title=&width=420" alt="image.png"></p><p>| &#x2F;&#x2F; 放入大根堆中的结构<br>**public static class **Node <strong>{<br>   public int index1</strong>;&#x2F;&#x2F; arr1中的位置<br>   <strong>public int index2</strong>;&#x2F;&#x2F; arr2中的位置<br>   <strong>public int sum</strong>;&#x2F;&#x2F; arr1[index1] + arr2[index2]的值</p><p>   **public <strong>Node</strong>(int **i1, **int **i2, **int <strong>s</strong>) {<br>      index1 **&#x3D; i1;<br>      **index2 **&#x3D; i2;<br>      **sum **&#x3D; s;<br>   **}<br>}</p><p>**&#x2F;&#x2F; 生成大根堆的比较器<br>**public static class **MaxHeapComp **implements <strong>Comparator</strong>&lt;**Node**&gt; {<br>   **@Override<br>   **public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return **o2.**sum **- o1.<strong>sum</strong>;<br>   **}<br>}</p><p>public static int[] <strong>topKSum</strong>(int[] **arr1, **int[] **arr2, **int <strong>topK</strong>) {<br>   if (**arr1 &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr2 &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; topK &lt; 1</strong>) {<br>      return null</strong>;<br>   **}<br>   int **N &#x3D; arr1.<strong>length</strong>;<br>   **int **M &#x3D; arr2.<strong>length</strong>;</p><p>   topK &#x3D; Math.min**(<strong>topK, N * M</strong>)**;</p><p>   **int[] **res &#x3D; <strong>new int[<strong>topK</strong>]</strong>;<br>   **int **resIndex &#x3D; 0;</p><p>   PriorityQueue**&lt;<strong>Node**&gt; <strong>maxHeap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;(new <strong>MaxHeapComp</strong>())</strong>;<br>   HashSet</strong>&lt;**Long**&gt; <strong>set &#x3D; <strong>new <strong>HashSet</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>i1 &#x3D; N - 1;<br>   <strong>int <strong>i2 &#x3D; M - 1;<br>   maxHeap.add</strong>(new <strong>Node</strong>(<strong>i1, i2, arr1</strong>[<strong>i1</strong>] <strong>+ arr2</strong>[<strong>i2</strong>]))</strong>;<br>   set.add</strong>(<strong>x</strong>(<strong>i1, i2, M</strong>))</strong>;&#x2F;&#x2F;二维变一维<br>   <strong>while (<strong>resIndex !&#x3D; topK</strong>) {<br>      <strong>Node curNode &#x3D; maxHeap.poll</strong>()</strong>;<br>      res</strong>[<strong>resIndex++</strong>] <strong>&#x3D; curNode.<strong>sum</strong>;<br>      i1 &#x3D; curNode.<strong>index1</strong>;<br>      i2 &#x3D; curNode.<strong>index2</strong>;<br>      set.remove</strong>(<strong>x</strong>(<strong>i1, i2, M</strong>))</strong>;<br>      <strong>if (<strong>i1 - 1 &gt;&#x3D; 0 &amp;&amp; !set.contains</strong>(<strong>x</strong>(<strong>i1 - 1, i2, M</strong>))) {<br>         <strong>set.add</strong>(<strong>x</strong>(<strong>i1 - 1, i2, M</strong>))</strong>;<br>         maxHeap.add**(new <strong>Node</strong>(<strong>i1 - 1, i2, arr1</strong>[<strong>i1 - 1</strong>] <strong>+ arr2</strong>[<strong>i2</strong>]))<strong>;<br>      <strong>}<br>      if (<strong>i2 - 1 &gt;&#x3D; 0 &amp;&amp; !set.contains</strong>(<strong>x</strong>(<strong>i1, i2 - 1, M</strong>))) {<br>         <strong>set.add</strong>(<strong>x</strong>(<strong>i1, i2 - 1, M</strong>))</strong>;<br>         maxHeap.add</strong>(new <strong>Node</strong>(<strong>i1, i2 - 1, arr1</strong>[<strong>i1</strong>] <strong>+ arr2</strong>[<strong>i2 - 1</strong>]))**;<br>      **}<br>   }<br>   return **res;<br>**}</p><p>public static long <strong>x</strong>(int **i1, **int **i2, **int <strong>M</strong>) {<br>   return (long) **i1 * **(long) **M + **(long) **i2;<br>**}</p><table><thead><tr><th>**</th></tr></thead></table><h2 id="·-42-接雨水-H"><a href="#·-42-接雨水-H" class="headerlink" title="· 42. 接雨水 [H]"></a>· 42. 接雨水 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267273178-987b1982-ef81-4324-8306-8f79b8e3d6ff.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=353&id=u9a387aaa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33271&status=done&style=none&taskId=u7e5d0662-374f-45a2-926d-fe2e07cee61&title=&width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653183809624-bfe54faa-fc8e-4c66-a37c-99bf00c7ccb2.png#clientId=u9486b31d-676a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=uc43d2755&margin=%5Bobject%20Object%5D&name=image.png&originHeight=359&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17507&status=done&style=none&taskId=u90fb9776-20c1-498f-95f0-ab5a02da7b7&title=&width=724" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323108-3482efdf-9617-4893-953d-ccef84395862.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uf94fe60c&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=855&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue2587b40-59ad-4b39-8b70-6184ba23117&title=&width=490"><br><strong>题解</strong><br>跟踪坡峰坡谷的Coding解法不正确<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323100-9d08de8c-b1e3-4f1d-9d28-813b0490efef.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=u98c83e06&margin=%5Bobject%20Object%5D&originHeight=366&originWidth=986&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c3e4756-b5a8-4817-8a39-e247925cb50&title=&width=578"><br>i位置自己整个位置上方有几格水?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323023-37d28c90-8cf6-460d-96e9-9cf07801d95d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=298&id=u691728f9&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=984&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5e997542-0ba1-4e3b-9bf7-b430884218a&title=&width=614"><br>边界情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323022-bf49b7ca-7a22-499d-89e4-9ba96be952dc.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u185b9d89&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=681&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1a037bb2-07a4-406b-b36a-a860e287ed7&title=&width=545"><br>i位置的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268325675-aeb3f9d1-c2fd-4218-89f5-368d9ac0bf4f.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ua64db485&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4474289a-e974-4f64-822b-7bed7e7cc27&title=&width=506"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326254-52267b69-79ad-4bf9-9fa8-cd8d26a94a8d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=292&id=u4434b4f8&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=962&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5338f041-b732-47d3-b061-8a59c39d9b4&title=&width=587"><br><strong>辅助数组</strong><br>需要0<del>i范围上的最大值max<br>i</del>N-1范围上的最大值max<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326340-b8cc0df3-73c2-4d4e-a267-dbe509ac09a4.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=u3182ff51&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=710&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e3ff214-4949-458e-a458-e98f1d2275a&title=&width=540"><br><strong>最优解</strong><br>不需要辅助数组<br>0位置最左 20位置最右是不可能留下水的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326487-100d9b8f-7d1c-416f-9c3f-d57fed517bdc.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue35ef49f&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f3ada90-3915-4cab-ae55-b2018430e01&title="><br>19位置的最大高度假设6, 要结算算水量<br>需要求6的左边, 右边部分的max, 以13做瓶颈,<br>因为6它的左边这么多最大值还没看过，但它的最大值是17，恐怕它真实的左边最大值是大于17的。<br>而我右边的最大值，这可是个真实最大值, 所以6位置的水量就是13-6 &#x3D; 7 格子水<br>左边跟右边max谁小就先结算那边的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326627-e696ef0d-bcf9-4c31-b14d-f8340253c3b2.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=278&id=uac262f4d&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=1063&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uecb45efd-f557-48a5-b00f-d7bd73562f1&title=&width=635"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327142-fa9a9589-71a6-4d59-aa66-b7c33cee30c5.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4c693001&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2adf84f1-1a9b-4fe1-b0a8-886ae13e2cf&title=&width=564"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327723-c5a819e2-e219-4a73-a4fb-5d3e37bc01c7.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u59b410f0&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1074&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u401cfdd3-d2fd-4b7e-9f90-aa11bcb92b4&title=&width=568"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327914-13401c07-43a7-45f0-b9fb-be52bf672963.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u0fcb1059&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u33092d65-5421-468c-961f-251f018357f&title=&width=562"><br>相等怎么办<br>可以一起结算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328197-0ef67c95-b205-4b96-bb3b-4861e493c575.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=197&id=u58c81a8a&margin=%5Bobject%20Object%5D&originHeight=340&originWidth=1038&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d5765fc-e857-484a-bb9b-b63c2ef9a07&title=&width=602"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328220-048d534c-040c-4157-851b-81ffab6e636e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ub7259426&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=1024&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud895d562-3d89-4df9-973d-e6e4a3153f3&title=&width=557"><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328354-f6461e69-c9fc-464e-b55d-98e8f7a989f6.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2f50eac9&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=433&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufd62e68c-e8d6-4953-ae67-65811a0750c&title="></p><h2 id="·-✊407-接雨水-II-H"><a href="#·-✊407-接雨水-II-H" class="headerlink" title="· ✊407. 接雨水 II [H]"></a>· ✊407. 接雨水 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267310891-9ae51e62-eb36-4c3d-aecf-42757c8bc9da.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=424&id=u4348eeb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=921&originalType=binary&ratio=1&rotation=0&showTitle=false&size=167029&status=done&style=none&taskId=u12c089cc-f48c-4fe5-b32a-f49a6ad36f5&title=&width=616.7999877929688" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567058-f79a7202-de25-40fb-a9e7-36ee14452e6c.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uf198170f&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=835&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc30f9554-6db3-457f-b0f2-32d091524b1&title=&width=489"><br><strong>题解</strong><br>这一圈的值放到小根堆去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566883-18c6b4b4-30c6-4a82-a82a-59b43835a5db.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=u3d5807f8&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=806&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u427cc3c0-49d7-4081-aa59-7229fad2c68&title=&width=542"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566896-0282f120-5392-4308-9d6e-ecdfee83e80e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=u9d229db5&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=1004&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u218c752a-31e6-48f8-919c-307b08a911f&title=&width=595"><br>都会以max做为瓶颈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567083-2497db05-4afd-4681-82b4-112847d15636.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=316&id=u799526e3&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=957&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc83a1690-d0de-4210-95ad-eb1fbc9439e&title=&width=608"><br>只要max不更新, 都是max的内湖区域<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566876-7b3a2096-ce22-4ac5-90e4-10ffa818dc49.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u8728c50f&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=916&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae7d39ad-2aa8-4dd3-922b-4deb1c5a810&title=&width=608"><br><strong>例子</strong><br>一个数进去的时候结算水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568452-8d0329f2-01e6-457a-af5e-535b96a0aa9e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=324&id=u2d7d0a44&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=962&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2363d263-1b25-4389-b468-1c17f534e8d&title=&width=642"><br><strong>代码</strong><br>max不更新就说明出海口就没有变</p><p>| **public static class **Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   **public <strong>Node</strong>(int **v, **int **r, **int <strong>c</strong>) {<br>      value **&#x3D; v;<br>      **row **&#x3D; r;<br>      **col **&#x3D; c;<br>   **}</p><p>}</p><p>public static int <strong>trapRainWater</strong>(int[][] <strong>heightMap</strong>) {<br>   if (**heightMap &#x3D;&#x3D; **null **&amp;#124;&amp;#124; heightMap.**length <strong>&#x3D;&#x3D; 0 &amp;#124;&amp;#124; heightMap</strong>[<strong>0</strong>] **&#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; heightMap</strong>[<strong>0</strong>]</strong>.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **N &#x3D; heightMap.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; heightMap</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   <strong>boolean[][] <strong>isEnter &#x3D; <strong>new boolean[<strong>N</strong>][<strong>M</strong>]</strong>;<br>   PriorityQueue</strong>&lt;**Node**&gt; <strong>heap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) <strong>-&gt; a.<strong>value <strong>- b.<strong>value)</strong>;<br>   <strong>for (int <strong>col &#x3D; 0; col &lt; M - 1; col++**) {<br>      **isEnter**[**0**][**col**] **&#x3D; **true**;<br>      heap.add**(new **Node**(**heightMap**[**0**][**col**]**, 0, col**))**;<br>   **}<br>   for (int **row &#x3D; 0; row &lt; N - 1; row++**) {<br>      **isEnter**[**row**][**M - 1**] **&#x3D; **true**;<br>      heap.add**(new **Node**(**heightMap**[**row**][**M - 1**]**, row, M - 1**))**;<br>   **}<br>   for (int **col &#x3D; M - 1; col &gt; 0; col–</strong>) {<br>      <strong>isEnter</strong>[<strong>N - 1</strong>][<strong>col</strong>] <strong>&#x3D; <strong>true</strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>N - 1</strong>][<strong>col</strong>]</strong>, N - 1, col</strong>))</strong>;<br>   <strong>}<br>   for (int <strong>row &#x3D; N - 1; row &gt; 0; row–</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>0</strong>] <strong>&#x3D; <strong>true</strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>0</strong>]</strong>, row, 0</strong>))</strong>;<br>   <strong>}<br>   int <strong>water &#x3D; 0;<br>   <strong>int <strong>max &#x3D; 0;<br>   <strong>while (</strong>!heap.isEmpty</strong>()) {<br>      <strong>Node cur &#x3D; heap.poll</strong>()</strong>;<br>      max &#x3D; Math.max</strong>(<strong>max, cur.<strong>value)</strong>;<br>      <strong>int <strong>r &#x3D; cur.<strong>row</strong>;<br>      <strong>int <strong>c &#x3D; cur.<strong>col</strong>;<br>      &#x2F;&#x2F;上下左右去放<br>      &#x2F;&#x2F;有上面<br>      <strong>if (<strong>r &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>])</strong>;<br>         isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>]</strong>, r - 1, c</strong>))</strong>;<br>      <strong>}<br>      <strong>&#x2F;&#x2F;有下<br>      <strong>if (<strong>r &lt; N - 1 &amp;&amp; !isEnter**[**r + 1**][**c**]) {<br>         **water +&#x3D; Math.max**(**0, max - heightMap**[**r + 1**][**c**])**;<br>         isEnter**[**r + 1**][**c**] **&#x3D; **true**;<br>         heap.add**(new **Node**(**heightMap**[**r + 1**][**c**]**, r + 1, c**))**;<br>      **}<br>      **&#x2F;&#x2F;有左<br>      **if (**c &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>])</strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>]</strong>, r, c - 1</strong>))</strong>;<br>      <strong>}<br>      <strong>&#x2F;&#x2F;有右<br>      <strong>if (<strong>c &lt; M - 1 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>])</strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>]</strong>, r, c + 1</strong>))</strong>;<br>      **}<br>   }<br>   return **water;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568940-16d91986-3ce5-4170-995b-25e5eb327a2d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=ua197f36f&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=560&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5856214b-6641-45ba-838e-b397b8823c9&title=&width=378"></p><h2 id="·-找出最大的左部分最大值减去右部分最大值的绝对值"><a href="#·-找出最大的左部分最大值减去右部分最大值的绝对值" class="headerlink" title="· 找出最大的左部分最大值减去右部分最大值的绝对值"></a>· 找出最大的左部分最大值减去右部分最大值的绝对值</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652270318016-0e37cdc1-b8e3-47ba-bf01-6f42eb4e6247.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=ua69a96f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17778&status=done&style=none&taskId=u26260abf-215f-42d6-9e95-5f6eace034c&title=&width=652.8" alt="image.png"><br><strong>题意</strong><br>所以你每切一刀都会有一个左部分的最大值，减去右部分的最大值的绝对值<br>一共有N-1种切法。那么哪一种切法下，这个值能最大, 把这个最大的结果返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009637-2441118c-f8dd-47dd-afef-1bf81668b74a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=pClpf&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f94afae-e9f4-41ae-8f51-6fb3c2947e8&title=&width=485"><br><strong>题解</strong><br>暴力: 遍历<br>当我来到i位置的时候, 0<del>i是左部分, i+1</del>N-1是右部分, 枚举i, 遍历一下找左右部分的最大值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009601-259b07db-0b03-422c-aa80-7360e0e29474.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=zBUSt&margin=%5Bobject%20Object%5D&originHeight=525&originWidth=1171&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u68d556cd-13fd-4bfa-b226-e655edba474&title=&width=605"><br><strong>辅助数组</strong><br>left数组: 记录0~i范围上的最大值<br>当前数跟前一个位置的数, 谁大拷贝谁</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009616-8360c1b6-bd21-47cf-b05a-4894b6301470.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=w2PrR&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=1020&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3dd0bbc-0eb9-4eda-8708-0ac0d2dcf67&title=&width=656"><br>right数组:从右往左生成,i+1<del>N-1范围上的最大值<br>有了两个辅助数组, 再去枚举i的时候<br>0</del>i范围上的最大值直接从left数组里取, i+1~N-1范围上的最大值直接从right数组里拿<br>把O(N^2)的暴力解优化成O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009605-dbca0f91-6ad8-4748-9f10-8885d7311c83.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=337&id=qF9iP&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1035&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8518c4be-731f-43bd-910f-44af73685c7&title=&width=690"></p><p>| **public static int <strong>maxABS2</strong>(int[] <strong>arr</strong>) {<br>   int[] **lArr &#x3D; **new int[**arr.<strong>length]</strong>;<br>   **int[] <strong>rArr &#x3D; <strong>new int[<strong>arr.<strong>length]</strong>;<br>   lArr</strong>[<strong>0</strong>] <strong>&#x3D; arr</strong>[<strong>0</strong>]</strong>;<br>   rArr</strong>[**arr.<strong>length <strong>- 1</strong>] <strong>&#x3D; arr</strong>[<strong>arr.<strong>length <strong>- 1</strong>]</strong>;<br>   <strong>for (int <strong>i &#x3D; 1; i &lt; arr.**length**; i++**) {<br>      **lArr**[**i**] **&#x3D; Math.max**(**lArr**[**i - 1**]**, arr**[**i**])**;<br>   **}<br>   for (int **i &#x3D; arr.**length **- 2; i &gt; -1; i–</strong>) {<br>      <strong>rArr</strong>[<strong>i</strong>] <strong>&#x3D; Math.max</strong>(<strong>rArr</strong>[<strong>i + 1</strong>]</strong>, arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   int **max &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.<strong>length <strong>- 1; i++</strong>) {<br>      <strong>max &#x3D; Math.max</strong>(<strong>max, Math.abs</strong>(<strong>lArr</strong>[<strong>i</strong>] <strong>- rArr</strong>[<strong>i + 1</strong>]))</strong>;<br>   **}<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>最优解</strong><br>arr 遍历一遍找到全局最大值, 然后0位置数跟N-1位置数, 谁小减谁就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009794-49174c11-7c15-4f33-86e2-e55388ed91d5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=cLoHI&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=885&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c009e6b-c545-4de7-913a-67aee64f8ad&title=&width=519"><br>可能性罗列</p><ol><li><p>全局max被划分到了左边</p></li><li><p>全局max被划分到了右边</p></li><li><p>max - 右边的最大值就是答案<br>让右max尽量小<br>右部分一定要有数, 一定会包含N-1位置的数<br>右部分只包含最右边一个数是右边max最小的时候<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010132-31eed44f-ffcb-4639-bc25-e746726c22ef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=D4cKJ&margin=%5Bobject%20Object%5D&originHeight=453&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d6af354-eb1a-467a-8e6e-9faad6833e9&title="></p></li><li><p>左max尽量小, 左部分一定会包含0位置的数<br>就让左部分只包含0位置的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010235-2ac3a3a2-5e64-4573-90c1-1ce1513e4177.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=dhLOT&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1030&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue7dd0c92-9bcb-4ee3-ae1f-c25a9700fb7&title="><br><strong>代码</strong></p></li></ol><p>| &#x2F;&#x2F;amazing！<br><strong>public static int <strong>maxABS3</strong>(int[] <strong>arr</strong>) {<br>   int <strong>max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>max &#x3D; Math.max</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, max</strong>)</strong>;<br>   <strong>}<br>   return <strong>max - Math.min</strong>(<strong>arr</strong>[<strong>0</strong>]</strong>, arr**[**arr.<strong>length <strong>- 1</strong>])</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊最大可整合子数组的长度"><a href="#·-✊最大可整合子数组的长度" class="headerlink" title="· ✊最大可整合子数组的长度"></a>· ✊最大可整合子数组的长度</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532365836-3c8093cf-782d-4f0e-854a-8c3427e0a834.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=u867734bf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=305&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61875&status=done&style=none&taskId=u53f84319-b0b7-4cfb-9d4d-beafbf2b477&title=&width=669.6" alt="image.png"><br><strong>题意</strong><br>排完序之后依次加1得到就是可整合<br>只要有重复值，它就没办法做可整合数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386766-8b1f7bae-ec0c-4109-bd44-011cacc7d351.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=ua84eeb28&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=581&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u015f7cff-9f62-4bfc-954d-9440e8dd640&title=&width=396"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386782-0ba22845-7afc-4f9e-a81b-9283c470caba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u3850d3b2&margin=%5Bobject%20Object%5D&originHeight=438&originWidth=728&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb9990b4-f7ff-479c-94d4-943e8d57ac3&title=&width=449"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386975-f5f84998-bdcd-4f75-8fb4-702dc86cb261.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=udf385003&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=782&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d425bbc-9f7b-4f84-bf26-d91fcd501fa&title=&width=462"><br>哪一个子数组是可整合的而且最长, 返回最长长度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386935-72cadf66-19f6-4562-b619-f95e67f91c55.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=u6cceb4e0&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=694&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4089eb32-f3bb-4b90-9c15-e35b315eb17&title=&width=491"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386866-d20c76bd-4969-4bce-ad9b-c784eb6a76a2.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=224&id=u7df7ee5c&margin=%5Bobject%20Object%5D&originHeight=387&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua502ac2b-174e-47d6-b4d4-4187fa647f2&title=&width=521"><br>不能排序<br>因为他问的就是你原始arr的数据状况，最长可整合子数组是啥？<br>排完序0,1,2原数组没有这个子数组<br>原数据状况是不能够动的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387154-7c295c6a-1838-45a2-ae75-508ced86774f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=320&id=u735cfd92&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=882&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0882a71c-1ed1-4ec5-bce0-e4fbd3b9685&title=&width=625"><br><strong>题解</strong><br>不能用滑动窗口, 没有单调性<br>因为如果一个窗口是可整合的, 它扩大或缩小不一定可整合<br>子数组范围这件事和可整合这件事建立不起单调性。<br>能用滑动窗口的最重要的性质就是某种范围上的单调性<br>子数组范围扩大了，或者子数组范围缩小了，对于可整合的东西，<br>它是有一定的单调性的，我菜可以去利用，而本题是没有的。<br>所以滑动窗口也用不了。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387319-f3df4fef-b417-4636-bfc4-b098e97ad628.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=u07077d33&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6d45fb4c-a596-4283-a50a-b3b83d3dd28&title=&width=496"><br><strong>暴力解:</strong><br>枚举所有子数组<br>比如说我验证从L到R这一段是不是可整合的,<br>可以把它拷贝出来, 拍完序再验证是不是可整合的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387425-c3b5c57f-08b3-4119-a9d3-65813f51fc17.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=307&id=uf7a760b5&margin=%5Bobject%20Object%5D&originHeight=435&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u83b81b1d-d7d6-49c7-ac07-77c4d2696e1&title=&width=636"><br><strong>复杂度</strong><br>子数组数量O(N^2), 子数组平均长度N<br>把子数组拷贝一下O(N), 子数组排序O(N<em>logN), 排序后的验证O(N)<br>取最高阶O(N</em>logN), 最终复杂度O(N^3*logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387470-931d4e55-faee-4d65-aaf2-82ec28e91d09.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=u9026a328&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89e7ad6f-b03b-4734-b328-39d568514d8&title=&width=625"><br><strong>重新定义可整合数组标准！！！</strong></p><ol><li>没有重复值</li><li>数组最大值-最小值&#x3D;个数-1<br>满足这两个条件就是可整合数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387491-c2cc6771-68b6-4a63-a0ab-83e7c4f0ed43.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u4220dfc8&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=965&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23575989-4df0-4efb-a468-212b66ddbef&title=&width=532"><br>简化的过程</li></ol><p>| **public static int <strong>maxLen</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   <strong>}<br>   int <strong>N &#x3D; arr.<strong>length</strong>;<br>   HashSet</strong>&lt;**Integer**&gt; <strong>set &#x3D; <strong>new <strong>HashSet</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>ans &#x3D; 1;&#x2F;&#x2F;答案至少是1<br>   <strong>for (int <strong>L &#x3D; 0; L &lt; N; L++</strong>) {<br>      <strong>set.clear</strong>()</strong>;&#x2F;&#x2F;因为r要归为<br>      <strong>int <strong>min &#x3D; arr</strong>[<strong>L</strong>]</strong>;<br>      <strong>int <strong>max &#x3D; arr</strong>[<strong>L</strong>]</strong>;<br>      set.add</strong>(<strong>arr</strong>[<strong>L</strong>])</strong>;<br>      &#x2F;&#x2F; L..R<br>      <strong>for (int <strong>R &#x3D; L + 1; R &lt; N; R++</strong>) {<br>         <strong>&#x2F;&#x2F; L….R<br>         <strong>if(<strong>set.contains</strong>(<strong>arr</strong>[<strong>R</strong>])) {<br>            break</strong>;<br>         <strong>}<br>         <strong>set.add</strong>(<strong>arr</strong>[<strong>R</strong>])</strong>;<br>         min &#x3D; Math.min</strong>(<strong>min, arr</strong>[<strong>R</strong>])</strong>;&#x2F;&#x2F;可能r的值更小<br>         max &#x3D; Math.max</strong>(<strong>max, arr</strong>[<strong>R</strong>])</strong>;&#x2F;&#x2F;也可能r的值更大<br>         &#x2F;&#x2F;个数：R-L+1,再减个1<br>         <strong>if(<strong>max - min &#x3D;&#x3D; R - L</strong>) {<br>            <strong>ans &#x3D; Math.max</strong>(<strong>ans, R - L + 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   return **ans;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>总结: 改题目的设定让它变得更简洁</strong><br>就是当你发现，比如说面试场上给了你一道题，它的定义部分让你求解的部分是如此之复杂。<br>你不要硬着头皮，就按照他的说法就硬上了，你要改成你自己的定义。比如说我们把这个就<br>拆分成了系统最大值减两头这样一个问题，把可整合数组重新写了定义之后，能让我们验证<br>可整合这个过程变快，这种就属于在面试场上遇到了一类，它给你来一个设定，但是你要改<br>它的设定让它变得更简洁的。要有这个心眼，你发现这道题目设定的部分写得特别的绕。<br>那说明它可能不够简洁，这时要有一个心眼，就是要改设定。这样改设定的题型很多，<br>我们以后遇到再说。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532543649-53d3de55-8561-4ff0-add7-817357bd81ac.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=u7ad3e556&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ce4aaab-9297-47d3-9ce8-fbaa226b91f&title=&width=474"></p><h2 id="·-✊超级水王问题"><a href="#·-✊超级水王问题" class="headerlink" title="· ✊超级水王问题"></a>· ✊超级水王问题</h2><p><strong>题意</strong><br>我给你个数组，如果有水王数你打印出来，如果无水王数，你告诉用户没有<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564573-18f0aae5-4c48-4583-a5fc-908f05f918aa.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ub63ef09a&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb3f9d95-2385-4717-ab8a-502c4ce9c0f&title=&width=489"><br>要求时间复杂度O(N)<br>空间复杂度O(1)<br>把用hash表的路堵死了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564812-7f6017f2-4972-4dde-b65e-5065ad21c9b5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=ua3b9fe6a&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=963&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u345c305d-94e0-4908-a782-ea6311d8772&title=&width=533"><br><strong>题解</strong><br>一次删掉两个不同值的数, 如果arr中真的有水王的话, 这个水王数一定会剩下来<br>因为水王数是大于一半的次数的。哪怕其它所有的数字都跟水王数为敌<br>水王数也会活下来, 更不用说其它数字之间还会有内战的情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564621-4c4d07c4-1905-4d22-8161-ba7827127276.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=ud9c14c93&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uac5cb9f7-4ed2-4d56-99bd-234e14ca061&title=&width=470"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564724-40df89be-6e7c-479d-b755-0479f9168ce6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1df2e5b3&margin=%5Bobject%20Object%5D&originHeight=144&originWidth=382&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94cefb0a-39fc-4749-88dc-a340c7f447b&title="><br>arr一次删掉两个不同的数, 最后剩下的数一定是水王吗?<br>不一定是水王<br>如果有水王的话, 一定会剩下来<br>如果没有水王的话, 如果剩下来的数都不是水王，那就没有数是了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564674-454bc6b4-a8ff-479c-938b-e6e9a24a390d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua49eec8c&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=421&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1cb3b4b7-b9f8-4379-a900-ef09a62f703&title="><br><strong>思路</strong></p><ol><li>arr 一次删除两个不同值的数, 看最终谁会剩下来</li></ol><p>可能性<br>1: 没有数字剩下来: 无水王数<br>2: 有数剩下来<br>x剩下来, 再遍历看x真实出现的次数跟N&#x2F;2对比</p><p><strong>怎么一次删除两个不同的数?</strong><br>时间复杂度O(N)<br>空间复杂度O(1)<br>两个变量</p><ol><li>候选cand</li><li>血量hp<br>当血量&#x3D;0, 认为没有候选人<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565245-13d042e9-15ce-451f-9d00-22fb6b8c37eb.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u22eda463&margin=%5Bobject%20Object%5D&originHeight=431&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua04fdaf1-7f3e-4a6d-9286-dad2914a968&title=&width=542"><br><strong>流程</strong><br>一个一个数遍历, 三条规则:</li><li>如果没有候选, 当前数立为候选, 血量+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565228-0cb5c6f0-77d1-4a27-9618-82f95127135e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u3e918b1a&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=1021&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8d87f13b-7fc7-4e50-aa59-77782c0c05d&title=&width=585"></li><li>如果有候选<br> 1)当前数跟候选不一样,血量–<br> 2)当前数是候选,血量++<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565221-c7dde5a0-148c-4fc2-9ce8-9c33a38b526a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u9c9600a3&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=1032&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c27cf79-9f62-4684-95ac-0cb1bb50623&title=&width=571"><br>解释</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565427-1f53495a-7f90-4a2e-b08b-43af2f9f0147.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u1cb7e569&margin=%5Bobject%20Object%5D&originHeight=506&originWidth=1011&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf9fba9e6-c81e-4f75-a1bc-54ac7326b4d&title=&width=592"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565702-b20446ee-a34b-4303-85dc-18bfb790a1ab.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=u81618e25&margin=%5Bobject%20Object%5D&originHeight=497&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua102ae15-5ac8-4490-a8d4-6d41c0048d7&title=&width=623"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565738-f2a9bd97-215c-4362-9d4d-23af8dc985b1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u9538e7a3&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=1009&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72d5eca0-0819-455a-bb9a-c4de485e2ab&title=&width=634"><br>遍历完成后,如果血量&#x3D;0,表示什么数也没有剩下来,如果血量不等于零，候选就是剩下来的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565794-847db360-2964-4094-8ffe-a086883180e7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u676fec88&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e114edf-2d28-4477-a82d-92b2a494048&title=&width=634"><br><strong>代码</strong></p><p>| **public static void <strong>printHalfMajor</strong>(int[] <strong>arr</strong>) {<br>   int **cand &#x3D; 0;<br>   **int **HP &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.**length**; i++**) {<br>      if (**HP &#x3D;&#x3D; 0**) {<br>         **cand &#x3D; arr**[**i**]**;<br>         HP &#x3D; 1;<br>      **} else if (**arr**[**i**] **&#x3D;&#x3D; cand**) {<br>         **HP++;<br>      **} else {<br>         **HP–;<br>      **}<br>   }<br>   if(**HP &#x3D;&#x3D; 0**) {<br>      **System.**out**.println**(“no such number.”)**;<br>      **return**;<br>   **}<br>   **HP &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.**length**; i++**) {<br>      if (**arr**[**i**] **&#x3D;&#x3D; cand**) {<br>         **HP++;<br>      **}<br>   }<br>   if (**HP &gt; arr.<strong>length <strong>&#x2F; 2</strong>) {<br>      <strong>System.<strong>out</strong>.println</strong>(<strong>cand</strong>)</strong>;<br>   <strong>} else {<br>      <strong>System.<strong>out</strong>.println</strong>(“no such number.”)</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><p><strong>扩展</strong><br>给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N&#x2F;K，打印这些数，如果没有不打印</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692268-ec19fdb8-d919-4ff4-989b-a9441d09217c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u794e348d&margin=%5Bobject%20Object%5D&originHeight=467&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c744658-4ae3-453a-95bc-6b4354a53a7&title=&width=532"><br>至多K-1个出现N&#x2F;K次的数（假设k &#x3D; 2，至多只有一个数字）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692364-02aa48c0-9e3a-4054-aaa4-0a8176783fbc.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u7c355bf8&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=820&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u22b99e23-11f2-4517-ad75-24ab4f0e7ac&title=&width=477"><br><strong>例子</strong><br>K&#x3D;4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692393-908c6f08-2bfa-4465-812d-6007cce170df.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=udfebc94e&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=919&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c9dd817-5300-40b5-818b-31b809878ad&title=&width=563"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692292-a6252411-18f3-4e51-a21c-65ab7d2fe782.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=uc29f6c64&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=907&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udfc00b4d-da71-4486-92cc-4c1ec0d3bb6&title=&width=521"><br>4来了, 所有人-1点血量<br>血量是0不要, 删掉, 一次删掉了4个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692349-175242d0-ebac-4c64-8c62-f814f64470dd.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59831a71&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=603&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub7fa5c34-2c6b-4a84-8c3a-dac5f6647df&title="><br><strong>代码</strong><br>必须验证真实次数<br>候选有什么，也不代表它就代表唯一考虑的集合<br>但它是不是, 不收集真实次数没人知道</p><p>| **public static void <strong>printKMajor</strong>(int[] **arr, <strong>int <strong>K</strong>) {<br>   if (<strong>K &lt; 2**) {<br>      **System.**out**.println**(“the value of K is invalid.”)**;<br>      **return**;<br>   **}<br>   **&#x2F;&#x2F; 攒候选，cands，候选表，最多K-1条记录！ &gt; N &#x2F; K次的数字，最多有K-1个<br>   HashMap</strong>&lt;**Integer, Integer**&gt; <strong>cands &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      if (<strong>cands.containsKey</strong>(<strong>arr</strong>[<strong>i</strong>])) {<br>         <strong>cands.put</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, cands.get</strong>(<strong>arr</strong>[<strong>i</strong>]) <strong>+ 1</strong>)</strong>;<br>      <strong>} else { <strong>&#x2F;&#x2F; arr[i] 不是候选<br>         <strong>if (<strong>cands.size</strong>() <strong>&#x3D;&#x3D; K - 1</strong>) { <strong>&#x2F;&#x2F; 当前数肯定不要！，每一个候选付出1点血量，血量变成0的候选，要删掉！<br>            allCandsMinusOne</strong>(<strong>cands</strong>)</strong>;<br>         <strong>} else {<br>            <strong>cands.put</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   **&#x2F;&#x2F; 所有可能的候选，都在cands表中！遍历一遍arr，每个候选收集真实次数</p><p>   HashMap**&lt;<strong>Integer, Integer**&gt; <strong>reals &#x3D; getReals</strong>(<strong>arr, cands</strong>)</strong>;<br>   **boolean **hasPrint &#x3D; <strong>false</strong>;<br>   <strong>for (<strong>Entry</strong>&lt;**Integer, Integer**&gt; <strong>set : cands.entrySet</strong>()) {<br>      <strong>Integer key &#x3D; set.getKey</strong>()</strong>;<br>      **if (<strong>reals.get</strong>(<strong>key</strong>) **&gt; arr.**length <strong>&#x2F; K</strong>) {<br>         <strong>hasPrint &#x3D; <strong>true</strong>;<br>         System.<strong>out</strong>.print</strong>(**key + <strong>“ “)</strong>;<br>      **}<br>   }<br>   <strong>System.<strong>out</strong>.println</strong>(**hasPrint ? **”” **: <strong>“no such number.”)</strong>;<br>**}</p><p>public static void <strong>allCandsMinusOne</strong>(<strong>HashMap</strong>&lt;<strong>Integer, Integer**&gt; <strong>map</strong>) {<br>   <strong>List</strong>&lt;**Integer**&gt; <strong>removeList &#x3D; <strong>new <strong>LinkedList</strong>&lt;**Integer**&gt;()</strong>;<br>   <strong>for (<strong>Entry</strong>&lt;**Integer, Integer**&gt; <strong>set : map.entrySet</strong>()) {<br>      <strong>Integer key &#x3D; set.getKey</strong>()</strong>;<br>      Integer value &#x3D; set.getValue</strong>()</strong>;<br>      <strong>if (<strong>value &#x3D;&#x3D; 1</strong>) {<br>         <strong>removeList.add</strong>(<strong>key</strong>)</strong>;<br>      <strong>}<br>      <strong>map.put</strong>(<strong>key, value - 1</strong>)</strong>;<br>   <strong>}<br>   for (<strong>Integer removeKey : removeList</strong>) {<br>      <strong>map.remove</strong>(<strong>removeKey</strong>)</strong>;<br>   **}<br>}</p><p>public static <strong>HashMap</strong>&lt;**Integer, Integer**&gt; <strong>getReals</strong>(int[] <strong>arr,<br>      HashMap</strong>&lt;**Integer, Integer**&gt; <strong>cands</strong>) {<br>   <strong>HashMap</strong>&lt;**Integer, Integer**&gt; **reals &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      int <strong>curNum &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      <strong>if (<strong>cands.containsKey</strong>(<strong>curNum</strong>)) {<br>         if (<strong>reals.containsKey</strong>(<strong>curNum</strong>)) {<br>            <strong>reals.put</strong>(<strong>curNum, reals.get</strong>(<strong>curNum</strong>) <strong>+ 1</strong>)</strong>;<br>         <strong>} else {<br>            <strong>reals.put</strong>(<strong>curNum, 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   return **reals;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊第k小的数值对"><a href="#·-✊第k小的数值对" class="headerlink" title="· ✊第k小的数值对"></a>· ✊第k小的数值对</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533451839-1dcc4f86-8175-4b98-bb2d-33fab076095b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ucc6bd1e8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43310&status=done&style=none&taskId=udbf48c7b-c5c2-41b0-807a-c792b021443&title=&width=669.6" alt="image.png"><br><strong>题解</strong><br><strong>暴力解</strong><br>两个for循环生成所有数值对, 放到数组里用比较器排序, 取出第K位的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574288-932f369b-6665-4975-870e-8d798fe5b12a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ue3aaa206&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1081&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1fb1f388-552d-4f2a-a109-a817c3ba4b9&title=&width=604"><br>复杂度 O(N^2*logN^2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574337-82315d0f-95c8-492b-9c77-3fc02ea2091e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=u7073562e&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1147&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6c9f817e-0dab-474c-857c-d4fef6c040a&title=&width=655"><br><strong>最优解</strong><br>最优解复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574399-0f80a80f-e29a-446a-91ed-6eb65d947887.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ud6983707&margin=%5Bobject%20Object%5D&originHeight=323&originWidth=806&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u84b6d280-143f-4d10-abd7-57f845288b9&title=&width=626"><br><strong>过程</strong><br>根据第一维数据进行分组<br>第一维的数字是1的叫第1组里的数值对<br>第一维的数字是2的叫第2组里的数值对<br>第一维的数字是3的叫第3组里的数值对<br>第一维的数字是5的叫第4组里的数值对<br>大体上分块就这么多块<br>想知道第70个数是哪个数值对里的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574353-1821c432-0685-4133-b7b9-be12b0b00a2f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaf4e4a03&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=1148&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ded78e1-5092-4773-9c69-8dd1d9d867c&title="><br>假设第70个数是(a,b)这两维数据, 先定位a是谁, 数组长度是11<br>必须以0位置的1做为第一维数据的一共有11个<br>必须以1位置的1做为第一维数据的一共有11个<br>必须以2位置的1做为第一维数据的一共有11个<br>必须以3位置的2做为第一维数据的一共有11个<br>所以你想求第 70 个怎么定位这个a？你就看看它是哪一组里的, 说明它第一维就是那个位置的数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574305-dac448dc-7170-485a-a101-f723d251e819.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueab68af7&margin=%5Bobject%20Object%5D&originHeight=407&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u052e5313-afe0-43a7-8a72-428388a3bf1&title="><br>定位70是哪一组里的,<br>第70个数来自于3的组, 第一维数据是3<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575227-31b8ed61-55a5-4dfe-9627-7c7149d896d6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1a4f9244&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=1133&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucf6b52e7-70e5-4015-a29f-6c52f65ea6e&title="><br>怎么得到b<br>b肯定是3组里的数值对,<br>3之前一共搞定了55个, 所以你要第 70 个，它应该是三大组中的第 15 个。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575288-74bcd08a-9b14-434a-8bff-c504f8dabde3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=ufa15bced&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2db97466-6de6-4213-9d9d-840e2b29949&title=&width=635"><br>3大组中再细分,<br>必须以0位置的1做二维数据的有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575449-630237a5-8e4c-44e5-8adf-02ebd9c41cf7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u2e30a4fd&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1129&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uca568bff-376a-4bb3-812f-4b3fa039d94&title=&width=527"><br>相求3大组中的第15个, 一共有4个3, 所以<br>必须0位置的1做第二维数据的, 4个<br>必须1位置的1做第二维数据的,4个<br>必须2位置的1做第二维数据的,4个<br>必须3位置的2做第二维数据的,4个<br>看看这第15个来自那一组, 就可以定位第二维的数字来自哪儿了</p><p><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575700-2e9c1dc6-1c5a-434e-8f4a-34e244c6162e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=ue603987f&margin=%5Bobject%20Object%5D&originHeight=390&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u494d13cd-e862-4e22-a402-187828b9bf6&title=&width=689"><br>第一维的数字是4<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575882-6c7e9e5d-1b94-4951-841f-d623a6840864.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udeef2653&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u06579f25-1baa-49c4-81f0-bda6a471bfc&title=&width=667"><br>1,2,3开头的一共有70个<br>第一维是4的情况下,<br>4里的12<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576014-43be7fca-337b-4cbf-9dd6-ac93d054933f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6ae98023&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1126&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufe456ad6-a016-4ec4-9226-9d0d844b402&title="><br>4的组细分<br>第二维数字是1,2,3,4的那些<br>第一维数字是 4 的情况下再往下细分组是啥?<br>第二维数据是 1 的那些<br>第二维数据是 2 的那些<br>第二维数据是 3 的那些<br>第二维数据是 4 的那些</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576961-4018a1d4-8795-402b-ad61-9094ebaf856f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=uc4ab67a7&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=1135&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub026b4b3-619a-4a77-a4a5-ae1fc99b04f&title=&width=629"><br>第一维的数字已经确实是4了<br>第二维数据是 1 的那些分为<br>0位置的1做第二维的数据, 3个, 7,8,9位置的4都是<br>1位置的1做第二维的数据, 3个, 7,8,9位置的4都是</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577008-8175b831-2b92-4719-bc9c-ea5b8bf3434e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=372&id=u8e3187a1&margin=%5Bobject%20Object%5D&originHeight=547&originWidth=873&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf2f6ca15-0d35-46b9-be0d-6928f79b21f&title=&width=594"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576966-c18e528a-b6b0-4d36-b9ad-54ce913287a5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=u2b5ae72a&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1121&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uee646ef9-bab2-4946-9ef3-cdd53fb4f48&title=&width=627"><br><strong>抽象化</strong><br>假设一共有N个数,求第K小数值对<br>怎么定位第一维数据?<br>K&#x2F;N的下标对应的值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577141-db303288-f81d-47eb-a691-3490f7349eeb.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u855fa134&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8076f660-ae44-4486-a8c9-004532ef1a2&title=&width=563"><br>边界考虑<br>第一维数字的下标<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577309-cb5440cc-ec6c-42d0-a207-c3f531c35f16.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u3731a3d1&margin=%5Bobject%20Object%5D&originHeight=530&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue81e3ddb-626b-4ef0-b035-e2b5239cb4e&title=&width=508"><br>无序数组中找到第k小, bfprt<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577557-ad44f93d-e7d0-4003-ba23-3ae7897ccd42.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ud35ec140&margin=%5Bobject%20Object%5D&originHeight=557&originWidth=1120&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u38e4bc18-5977-4562-9d02-123c3e64abe&title=&width=545"><br><strong>怎么定义第二维数字</strong><br>你必须数一下小于 7 的数字有几个你才能知道前面做的一位数字的组帮你搞定了几个，<br>然后拿k减去它才是属于7的组，在第一位数字是 7 的情况下，在这个内部组里面我是第几个呢？<br>这事怎么求?<br>你必须数一下前面小于 7 的数字有几个</p><p>**代码 **<br>必须搞清楚的第一维数字小于 5 的，之前的数字有几个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577715-e66d1dd1-8985-476f-a263-11335040c1ba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u9c8a0bcd&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uedae6774-6831-4395-9c5d-11ba2520332&title=&width=551"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577892-e34c0223-de0d-4c47-88cc-c15cd07653ef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=uc48d9a27&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1134&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u939b5448-34f1-459a-a8cb-f98e841f015&title=&width=631"></p><p>| **public static class **Pair <strong>{<br>   public int x</strong>;<br>   <strong>public int y</strong>;</p><p>   Pair**(int **a, **int <strong>b</strong>) {<br>      x **&#x3D; a;<br>      **y **&#x3D; b;<br>   **}<br>}</p><p>public static class **PairComparator **implements <strong>Comparator</strong>&lt;**Pair**&gt; {</p><p>   **@Override<br>   **public int <strong>compare</strong>(<strong>Pair arg0, Pair arg1</strong>) {<br>      return **arg0.**x **!&#x3D; arg1.**x **? arg0.**x **- arg1.**x **: arg0.**y **- arg1.<strong>y</strong>;<br>   **}</p><p>}</p><p>**&#x2F;&#x2F; O(N^2 * log (N^2))的复杂度，你肯定过不了<br>&#x2F;&#x2F; 返回的int[] 长度是2，{3,1} int[2] &#x3D; [3,1]<br>**public static int[] <strong>kthMinPair1</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   **}<br>   <strong>Pair</strong>[] **pairs &#x3D; <strong>new <strong>Pair</strong>[<strong>N * N</strong>]</strong>;<br>   **int **index &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      for (int <strong>j &#x3D; 0; j &lt; N; j++</strong>) {<br>         <strong>pairs</strong>[<strong>index++</strong>] <strong>&#x3D; <strong>new <strong>Pair</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, arr</strong>[<strong>j</strong>])</strong>;<br>      <strong>}<br>   }<br>   <strong>Arrays.sort</strong>(<strong>pairs, <strong>new <strong>PairComparator</strong>())</strong>;<br>   <strong>return new int[] { <strong>pairs</strong>[<strong>k - 1</strong>]</strong>.<strong>x</strong>, pairs</strong>[<strong>k - 1</strong>]</strong>.<strong>y }</strong>;<br>**}</p><table><thead><tr><th>**</th></tr></thead></table><p>| &#x2F;&#x2F; O(N*logN)的复杂度，你肯定过了<br>**public static int[] <strong>kthMinPair2</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   <strong>}<br>   <strong>&#x2F;&#x2F; O(N*logN)<br>   Arrays.sort</strong>(<strong>arr</strong>)</strong>;<br>   &#x2F;&#x2F; 第K小的数值对，第一维数字，是什么 是arr中<br>   <strong>int <strong>fristNum &#x3D; arr</strong>[(<strong>k - 1</strong>) <strong>&#x2F; N</strong>]</strong>;<br>   **int **lessFristNumSize &#x3D; 0;&#x2F;&#x2F; 数出比fristNum小的数有几个<br>   **int **fristNumSize &#x3D; 0; &#x2F;&#x2F; 数出&#x3D;&#x3D;fristNum的数有几个<br>   &#x2F;&#x2F; &lt;&#x3D; fristNum<br>   **for (int <strong>i &#x3D; 0; i &lt; N &amp;&amp; arr</strong>[<strong>i</strong>] <strong>&lt;&#x3D; fristNum; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&lt; fristNum</strong>) {<br>         **lessFristNumSize++;<br>      **} else {<br>         **fristNumSize++;<br>      **}<br>   }<br>   int **rest &#x3D; k - <strong>(<strong>lessFristNumSize * N</strong>)</strong>;<br>   <strong>return new int[] { <strong>fristNum, arr</strong>[(<strong>rest - 1</strong>) <strong>&#x2F; fristNumSize</strong>] }</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>| &#x2F;&#x2F; O(N)的复杂度，你肯定蒙了<br>**public static int[] <strong>kthMinPair3</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   **}<br>   **&#x2F;&#x2F; 在无序数组中，找到第K小的数（k表示下标），返回值<br>   &#x2F;&#x2F; 第K小，以1作为开始<br>   **int <strong>fristNum &#x3D; getMinKth</strong>(**arr, <strong>(<strong>k - 1</strong>) <strong>&#x2F; N</strong>)</strong>;<br>   &#x2F;&#x2F; 第1维数字<br>   **int **lessFristNumSize &#x3D; 0;<br>   **int **fristNumSize &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&lt; fristNum</strong>) {<br>         **lessFristNumSize++;<br>      **}<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&#x3D;&#x3D; fristNum</strong>) {<br>         **fristNumSize++;<br>      **}<br>   }<br>   <strong>&#x2F;&#x2F;切记不能死记硬背<br>   &#x2F;</strong><br>    *  2 1 5 3 6 5 4 7 2 长度为9 求K &#x3D; 58<br>    *  1 2 2 3 4 5 5 6 7   firstNum &#x3D; 5(第6小的数)<br>    *  rest &#x3D; 58 - 45 &#x3D; 13<br>    *&#x2F;<br>   <strong>int <strong>rest &#x3D; k - <strong>(<strong>lessFristNumSize * N</strong>)</strong>;<br>   System.<strong>out</strong>.println</strong>(“rest &#x3D; “ <strong>+ rest</strong>)</strong>;<br>   **return new int[] { <strong>fristNum, getMinKth</strong>(**arr, <strong>(<strong>rest - 1</strong>) <strong>&#x2F; fristNumSize</strong>) }</strong>;<br>**}</p><p>**&#x2F;&#x2F; 改写快排，时间复杂度O(N)<br>&#x2F;&#x2F; 在无序数组arr中，找到，如果排序的话，arr[index]的数是什么？<br>**public static int <strong>getMinKth</strong>(int[] **arr, **int <strong>index</strong>) {<br>   int **L &#x3D; 0;<br>   **int **R &#x3D; arr.**length **- 1;<br>   **int **pivot &#x3D; 0;<br>   **int[] **range &#x3D; <strong>null</strong>;<br>   **while (<strong>L &lt; R**) {<br>      **pivot &#x3D; arr**[**L + **(int) (**Math.random**() *** **(**R - L + 1**))]**;<br>      range &#x3D; partition**(**arr, L, R, pivot**)**;<br>      **if (**index &lt; range**[**0**]) {<br>         **R &#x3D; range**[**0**] **- 1;<br>      **} else if (**index &gt; range</strong>[<strong>1</strong>]) {<br>         <strong>L &#x3D; range</strong>[<strong>1</strong>] **+ 1;<br>      **} else {<br>         return **pivot;<br>      <strong>}<br>   }<br>   return <strong>arr</strong>[<strong>L</strong>]</strong>;<br>**}</p><p>public static int[] <strong>partition</strong>(int[] **arr, **int **L, **int **R, **int <strong>pivot</strong>) {<br>   int **less &#x3D; L - 1;<br>   **int **more &#x3D; R + 1;<br>   **int **cur &#x3D; L;<br>   <strong>while (<strong>cur &lt; more**) {<br>      if (**arr**[**cur**] **&lt; pivot**) {<br>         **swap**(**arr, ++less, cur++**)**;<br>      **} else if (**arr**[**cur**] **&gt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, cur, –more</strong>)</strong>;<br>      **} else {<br>         **cur++;<br>      **}<br>   }<br>   return new int[] { **less + 1, more - 1 <strong>}</strong>;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-数组能不能分成4个相等的部分"><a href="#·-数组能不能分成4个相等的部分" class="headerlink" title="· 数组能不能分成4个相等的部分"></a>· 数组能不能分成4个相等的部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533468062-870ee3db-9ba1-438d-bfba-f1f0eaca5b6e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=139&id=u21da3700&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31102&status=done&style=none&taskId=u552b24ea-96ee-414d-8b28-0f5ce24cea0&title=&width=456.8" alt="image.png"><br><strong>题意</strong><br>N&gt;&#x3D;7, 正数数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471540-fc6df3a7-1744-4cd5-abf5-c52f0a31e14f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u3c662ee6&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u91f5bb87-ba17-433f-954d-94343906014&title=&width=508"><br>你能不能切出四个部分，让四个部分累加和一样。但是切掉的数字是不算的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471734-ee7c3286-54dc-49c0-9841-5a6297def955.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=ucc6800d7&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u02fc3a3e-8ed3-4c74-9bd3-99e837f2411&title=&width=578"><br><strong>题解</strong><br>做出前缀和数组, 假设来到i位置, 想问<br>i位置做第一刀的情况下有没有可能切出4个部分累加和一样<br><strong>例子</strong><br>找209的前缀和<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471524-5d3a4faa-2313-4e57-b4a0-f8c9f5f4cd8b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=u24736741&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=651&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b0e8c1c-ddc2-4fac-829c-3118343a3af&title=&width=483"><br>14位置是第二刀<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471485-660cacba-56bd-4b13-a478-cf66a91eec8a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=uf0101aab&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae1dd84f-46f8-46f8-af79-6a3c3d93766&title=&width=541"><br>验证7位置能不能第一刀, O(1), 然后验证每一个位置做为第一刀, 就可以了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471488-436b2399-5728-40d0-8da9-e1a64ed33a89.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u97f20565&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f84d7de-0496-43f3-a6c5-e1cb29a148d&title="></p><p><strong>代码</strong></p><p>| **public static boolean <strong>canSplits2</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length **&lt; 7**) {<br>      return false**;<br>   **}<br>   **&#x2F;&#x2F; key 某一个累加和， value出现的位置<br>   HashMap**&lt;**Integer, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>int <strong>sum &#x3D; arr</strong>[<strong>0</strong>]</strong>;<br>   <strong>for (int <strong>i &#x3D; 1; i &lt; arr.**length**; i++**) {<br>      **map.put**(**sum, i**)**;<br>      sum +&#x3D; arr**[**i**]**;<br>   **}<br>   int **lsum &#x3D; arr**[**0**]**; &#x2F;&#x2F; 第一刀左侧的累加和<br>   **for (int **s1 &#x3D; 1; s1 &lt; arr.**length **- 5; s1++**) { **&#x2F;&#x2F; s1是第一刀的位置<br>      **int **checkSum &#x3D; lsum * 2 + arr**[**s1**]**; &#x2F;&#x2F; 100 x 100   100*2 + x<br>      **if (**map.containsKey**(**checkSum**)) {<br>         int **s2 &#x3D; map.get**(**checkSum**)**; &#x2F;&#x2F; j -&gt; y<br>         checkSum +&#x3D; (lsum + arr</strong>[<strong>s2</strong>])</strong>;<br>         **if (<strong>map.containsKey</strong>(<strong>checkSum</strong>)) { **&#x2F;&#x2F; 100 * 3 + x + y<br>            <strong>int <strong>s3 &#x3D; map.get</strong>(<strong>checkSum</strong>)</strong>; &#x2F;&#x2F; k -&gt; z<br>            <strong>if (<strong>checkSum + (arr</strong>[<strong>s3</strong>] <strong>+ lsum) &#x3D;&#x3D; sum</strong>) {<br>               return true</strong>;<br>            <strong>}<br>         }<br>      }<br>      <strong>lsum +&#x3D; arr</strong>[<strong>s1</strong>]</strong>;<br>   <strong>}<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊316-去除重复字母-M"><a href="#·-✊316-去除重复字母-M" class="headerlink" title="· ✊316. 去除重复字母  [M]"></a>· ✊316. 去除重复字母  [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533504865-a0411f35-f468-4fe7-ba62-98a6ffb066a1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udc341fe0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32042&status=done&style=none&taskId=u83a362da-6605-45be-b799-61f01d3e0bb&title=&width=662.4" alt="image.png"><br><strong>题意</strong><br>每种字符只保留一个, 请你返回字典序最小的结果<br>相对次序不能乱<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940519-92d4b450-75f4-4738-b2fc-d448dabee78d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=uc3a5dde1&margin=%5Bobject%20Object%5D&originHeight=393&originWidth=973&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7ea7df2e-ecc2-4679-8640-20a95c7d97c&title=&width=502"><br><strong>题解</strong><br>先建立词频统计表, 从左往右划线, 划线的词从词频表里删除</p><p>我如果在这线里面，这条线代表啥意思，我如果要选保留的第一个字符的话，我只能在这条线里选，<br>不能够再把右侧的字符考虑进来了。<br>当我决定保留一个字符的时候，我保留这个字符的同时，左侧字符全不要, 右侧字符可以继续选，<br>我在后面的字符里再选一个字符Y，那么 Y 左边的字符就不能再选了，在后面继续选，这是我的主流程。<br>选ascii码最小的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940426-5bd3de48-60bb-4186-b3f0-dafc220489fd.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=uec914f16&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=931&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d28ade0-97a0-4e57-8028-5f5f382ea6d&title=&width=598"><br>因为如果我这个 C 作为我保留第一个字符的话，后面就没 A 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940449-8ead876f-9228-42c5-9a3a-9e1da7419ba8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u7b220aee&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=918&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb18526a-30cb-44be-9a19-beabfa28a43&title=&width=586"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940483-a32ca227-5889-422a-a8a6-b692068da001.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u476f8fde&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=861&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua441ad0d-c491-4083-8559-fa70fc38f5b&title=&width=550"><br><strong>代码</strong></p><p>| &#x2F;&#x2F;递归版本： 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回<br>**public static <strong>String removeDuplicateLetters1</strong>(<strong>String str</strong>) {<br>   if (**str &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; str.length</strong>() <strong>&lt; 2**) {<br>      return **str;<br>   **}<br>   int[] **map &#x3D; **new int[**256**]**;<br>   **for (int **i &#x3D; 0; i &lt; str.length**()**; i++**) {<br>      **map**[**str.charAt**(**i**)]**++;<br>   **}<br>   int **minACSIndex &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; str.length**()**; i++**) {<br>      **minACSIndex &#x3D; str.charAt**(**minACSIndex**) **&gt; str.charAt</strong>(<strong>i</strong>) <strong>? i : minACSIndex;<br>      <strong>if (</strong>–map</strong>[<strong>str.charAt</strong>(<strong>i</strong>)] <strong>&#x3D;&#x3D; 0</strong>) {<br>         break</strong>;<br>      <strong>}<br>   }<br>   <strong>&#x2F;&#x2F; 0…break(之前) minACSIndex<br>   &#x2F;&#x2F; str[minACSIndex] 剩下的字符串str[minACSIndex+1…] -&gt; 去掉str[minACSIndex]字符 -&gt; s’<br>   &#x2F;&#x2F; s’…<br>   <strong>return <strong>String.valueOf</strong>(<strong>str.charAt</strong>(<strong>minACSIndex</strong>)) <strong>+ removeDuplicateLetters1</strong>(<br>         <strong>str.substring</strong>(<strong>minACSIndex + 1</strong>)</strong>.replaceAll</strong>(<strong>String.valueOf</strong>(<strong>str.charAt</strong>(<strong>minACSIndex</strong>))</strong>, <strong>“”))</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>复杂度</strong><br>遍历一遍总会保留一个字符, 而且以后的字符串中是不含有这个字符的。<br>所以你str中如果含有 K 种字符，复杂度就是O(K*N)。这个 K 大写加小写也不就是 52 种字符, 所以O(N)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940987-5cb7a264-d11d-41c0-b9e1-8e61798e55c6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u7ac43425&margin=%5Bobject%20Object%5D&originHeight=458&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69a4ec90-04ea-41f8-acde-5152dda5a2b&title=&width=586"></p><h2 id="·-15-三数之和-M"><a href="#·-15-三数之和-M" class="headerlink" title="· 15.三数之和 [M]"></a>· 15.三数之和 [M]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168720-6b744df4-7946-45c9-a331-a2bea7ca808b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u91a5461c&margin=%5Bobject%20Object%5D&originHeight=418&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47aed55e-205d-42c8-b687-db174d78dfa&title=&width=466"><br>字面值都不一样，就算不同的，有几个三元组全返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168713-93b17778-7f67-446e-90c9-05862b57e449.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ubaf6ddac&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=964&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u18986bf3-72d6-45ce-9a40-801113f1696&title=&width=440"><br><strong>题解</strong><br>2sum<br>双指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168718-d3daae68-041e-4709-83d2-24ed9706dcf1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=u3abbd115&margin=%5Bobject%20Object%5D&originHeight=244&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u13162b89-c8f0-4a19-a91b-a82270cb67d&title=&width=665"><br><strong>去重复:</strong></p><ol><li>收集所有二元组, 过滤</li><li>通过好的流程设计规避重复<br>L移动到下一个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168760-f5557fad-41a1-4981-9a4a-e7b1be9554d8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ue9ce0c40&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=1076&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1155980f-554e-48b9-9513-a53e4dfc988&title=&width=574"><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168722-ed693ec3-17f3-40db-875b-40df7a3e3bc2.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc9bb16c8&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=604&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3cc0675-8fd4-41a6-82ad-5ab956d174d&title="><br><strong>题解</strong><br>你只要保证第1个数字不一样后面就是二元组的问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169245-eb3b0c0f-0f36-4691-9b6d-a4d24f65c0f9.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=ubddc1e46&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9cfee96b-8401-44c4-8bfc-7cbfccc2aa1&title=&width=623"><br>避免arrayList插到开头的代价有点高, 所以从右往左生成所有的三元组, 把一个数塞在最后<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169284-19a38708-e6da-4a5e-bb4a-20a29232ee3c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=u9d26ce66&margin=%5Bobject%20Object%5D&originHeight=520&originWidth=1064&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f65a980-7862-4577-af50-86a27112905&title=&width=614"><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169425-e3392844-3840-45f1-9ab5-46624ba97638.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue27c0fc3&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=689&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc8ba67a7-38d3-4a72-af12-8e3c795c18e&title="></li></ol><p>| **public static **List&lt;List<Integer>&gt; threeSum(<strong>int</strong>[] nums) {<br>   Arrays.<em>sort</em>(nums);<br>   **int **N &#x3D; nums.<strong>length</strong>;<br>   List&lt;List<Integer>&gt; ans &#x3D; **new **ArrayList&lt;&gt;();<br>   **for **(**int **i &#x3D; N - 1; i &gt; 1; i–) { _&#x2F;&#x2F; 三元组最后一个数，是arr[i]   之前….二元组 + arr[i]<br>      _**if **(i &#x3D;&#x3D; N - 1 &amp;#124;&amp;#124; nums[i] !&#x3D; nums[i + 1]) {<br>         List&lt;List<Integer>&gt; nexts &#x3D; <em>twoSum</em>(nums, i - 1, -nums[i]);<br>         **for **(List<Integer> cur : nexts) {<br>            cur.add(nums[i]);<br>            ans.add(cur);<br>         }<br>      }<br>   }<br>   **return **ans;<br>}</p><p>_&#x2F;&#x2F; nums[0…end]这个范围上，有多少个不同二元组，相加&#x3D;&#x3D;target，全返回<br>&#x2F;&#x2F; {-1,5}     K &#x3D; 4<br>&#x2F;&#x2F; {1, 3}<br>_**public static **List&lt;List<Integer>&gt; twoSum(<strong>int</strong>[] nums, **int **end, **int **target) {<br>   **int **L &#x3D; 0;<br>   **int **R &#x3D; end;<br>   List&lt;List<Integer>&gt; ans &#x3D; **new **ArrayList&lt;&gt;();<br>   **while **(L &lt; R) {<br>      **if **(nums[L] + nums[R] &gt; target) {<br>         R–;<br>      } **else if **(nums[L] + nums[R] &lt; target) {<br>         L++;<br>      } **else **{ _&#x2F;&#x2F; nums[L] + nums[R] &#x3D;&#x3D; target<br>         _**if **(L &#x3D;&#x3D; 0 &amp;#124;&amp;#124; nums[L - 1] !&#x3D; nums[L]) {<br>            List<Integer> cur &#x3D; **new **ArrayList&lt;&gt;();<br>            cur.add(nums[L]);<br>            cur.add(nums[R]);<br>            ans.add(cur);<br>         }<br>         L++;<br>      }<br>   }<br>   **return **ans;</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-小朋友排队的最高分数"><a href="#·-小朋友排队的最高分数" class="headerlink" title="· 小朋友排队的最高分数"></a>· 小朋友排队的最高分数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652536502099-7223e529-c2d9-4f8f-a4a9-a6ab1fcd7ad3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=91&id=u6ea2c2e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22491&status=done&style=none&taskId=u67386263-86db-4666-a03d-34b0bd10782&title=&width=665.6" alt="image.png"><br>暴力递归，把所有的全排列(N!)搞出来, 分数最大的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537096712-968d9c3d-2f9f-44bc-b6e9-a801cf34a8ba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=ue4cc4511&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub1f9f15f-045e-4823-bf05-f159007dd6a&title=&width=597"></p><p>| **public static int <strong>process</strong>(int[][] **matrix,**int **index,**int <strong>score</strong>) {<br>    int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>    **int **ans &#x3D; 0;<br>    **if (**index &#x3D;&#x3D; matrix.**length) {<br>        return **score;<br>    <strong>} else {<br>        for (int <strong>i &#x3D; index; i &lt; matrix.<strong>length</strong>; i++</strong>) {<br>            int <strong>num &#x3D; 0;<br>            swap</strong>(<strong>matrix,index,i</strong>)</strong>;</p><pre><code>        **if (**i-1&gt;0 &amp;&amp; matrix**[**i**][**0**] **&gt; matrix**[**i-1**][**0**]) &#123;            **num += 1;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**]) &#123;            **num += 2;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**] **&amp;&amp; matrix**[**i+1**][**0**] **&gt; matrix**[**i**][**0**]) &#123;            **num += 5;        **&#125;        **ans = process**(**matrix,index+1,score+num**)**;        max = Math.max**(**max,ans**)**;        swap**(**matrix,index,i**)**;    **&#125;    return **max;**&#125;</code></pre><p>}<br>public static void <strong>swap</strong>(int[][] <strong>matrix,<strong>int <strong>i,<strong>int <strong>j</strong>) {<br>    int[] <strong>temp &#x3D; matrix</strong>[<strong>i</strong>]</strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>0</strong>] <strong>&#x3D; matrix</strong>[<strong>j</strong>][<strong>0</strong>]</strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>1</strong>] <strong>&#x3D; matrix</strong>[<strong>j</strong>][<strong>1</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>0</strong>] <strong>&#x3D; temp</strong>[<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>1</strong>] <strong>&#x3D; temp</strong>[<strong>1</strong>]**;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-❓乐队演出的最少花费"><a href="#·-❓乐队演出的最少花费" class="headerlink" title="· ❓乐队演出的最少花费"></a>· ❓乐队演出的最少花费</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537423682-efe033ec-3f72-424f-bde7-e5014b897bef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u4f042f4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43808&status=done&style=none&taskId=u0e6f551b-d211-4ea1-b57c-7c37cc19b72&title=&width=676" alt="image.png"><br>题意<br>乐队数量编号跟numbers*2是严格绑定的<br>nums&#x3D;5, 乐队数量下标一定是0~9<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448658-3dab8950-a21f-43a1-b17b-7ed848f64840.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=u7d539c9d&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uacdc5ae2-9463-4236-b703-588b8875dfa&title=&width=592"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448639-8358f990-06dd-4df5-92ae-7f64d89c5234.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=u8052bab1&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1124&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u76a2c942-9cfb-413c-87b0-e6c87ef102c&title=&width=585"><br>nums&#x3D;1, 一定有0,1两支乐队<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448741-b140f77d-7e96-44c8-84b8-5fc2a709c6d8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=285&id=u403bc2c5&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucb4940ea-7279-443e-9b7d-0ae124ea889&title=&width=583"><br>nums&#x3D;2, 一定有0,1, 2, 3 四支乐队<br>一个乐队只能在一个项目里被挑到，它不能同时为两个项目挑到, 把所有乐队都挑全, 返回最低报价</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448667-377bf58a-896b-4092-92b2-f8b2a5e09815.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=286&id=u32fa3de3&margin=%5Bobject%20Object%5D&originHeight=531&originWidth=1106&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u65c2b037-7834-4cf3-ab10-f0b6e2bf05e&title=&width=596"><br>题解<br>乐队数量16只, 任何两个乐队的组合为C_16^2, 共120种情况, 现在题目中有500组,<br>有大量冗余项目, 只选报价低的, 剩余的删掉<br>如果某个乐队不在报价中返回-1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448679-f9b98e3e-d745-4b02-bdae-869c77c67a26.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u6948a087&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=1137&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucaf4f2e9-9d3d-4a61-975f-3175ffd7c66&title=&width=589"><br>洗数据<br>调整乐队编号, 两个乐队最小值放第一位, 最大值放第二位, 最后是花费<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449231-9d45d470-a1c6-43c9-9588-469ca0f1e264.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u46433d67&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=1033&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8f5bb06b-f43c-4077-8a14-5d13c732d90&title=&width=647"><br>排序: 第一维小的排前面，第一维数据相等的，根据第二维数据小的排前面，前两维数据都相同的，<br>根据报价小的排前面<br>前两项一样的这一组，我只要第一个, 剩下的都删掉<br>把价格大的都删掉。两个乐队之间最低报价的留下来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449453-bf550b3c-8f14-4478-83d9-7deee2932b11.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=ud0a23bf4&margin=%5Bobject%20Object%5D&originHeight=491&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ee4650d-6457-4fb0-9ab1-c041cd0877a&title=&width=541"><br>暴力递归<br>通过size控制<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449574-6cc51376-eedc-4492-9837-2b7fe7a5137b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=441&id=u19699120&margin=%5Bobject%20Object%5D&originHeight=586&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue22b83d6-55e4-4b95-829f-40f960b64cd&title=&width=586"><br>可以用一个整数的二进制状态，表示哪个乐队挑了哪个没挑<br>一共就8组, 16个乐队<br>最低位就代表0号乐队挑没有挑, 上面如果是1代表挑了, 上面如果是 0 , 代表没挑</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449591-6da74ef6-513b-4524-9b3a-b672e0db5668.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=u2fe508db&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1006&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94eb5d67-dd4e-4672-9456-0ae104e69b9&title=&width=554"><br>乐队全挑是啥样？<br>应该是某一个整数，后面 16 位全是1，前面 16 位全是0。这个状态就表示你所有的都挑到了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449813-4c4d0188-00e0-4d90-94b2-91dde3d4e2ee.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=u2abab5d3&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7278723a-a0c2-4568-a86d-a0851da4baf&title=&width=555"><br>之前 5 位置的 5 乐队已经考虑过了，此时的项目无论如何不能考虑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449921-dabce459-c444-48ca-9b0d-38842a88bea8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=276&id=u91c52048&margin=%5Bobject%20Object%5D&originHeight=543&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69d7ed52-13ce-44af-b614-77ad78833ad&title=&width=534"><br>不能改动态规划, 可变参数太多了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450094-53b89c36-d138-4950-9855-9eb41da56b81.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaefbf1e8&margin=%5Bobject%20Object%5D&originHeight=1189&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f03743c-eabf-4d20-b806-7572874a0d2&title="><br>优化<br>可以省掉done参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450158-14d02b8e-1908-4948-8d94-927946c3838e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4a13716a&margin=%5Bobject%20Object%5D&originHeight=369&originWidth=825&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1a8774c-e654-4e8e-80e7-5bbedb5bdff&title="><br>复杂度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450320-12c34c5a-b718-43e3-b910-ce5cd6be6e48.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5fa9848d&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0d5c8479-84af-4bde-b87e-fdc85878b0a&title="><br><br>分治<br>复杂度<br>一共 120 个项目挑 8 个项目就停。<br>C_{120}^8_C_1208 超过 10^8了, 这个方法不行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450494-e0629605-12c2-45c0-ba4d-8981a6fc2e84.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue97cf8a0&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u40393ab8-0e3f-4b26-ae96-d80c6c2c4d1&title="><br>特殊情况, num&#x3D;7<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450801-bf9dd979-4d42-4c30-9acd-45c6b4e7f866.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u628d5bce&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u16e23e4a-120c-4887-adee-11b29cab4e1&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450938-6f42c655-5387-4db9-b9db-d38ddc55848f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7ea57ad3&margin=%5Bobject%20Object%5D&originHeight=767&originWidth=713&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u340a0fea-3523-4622-b767-bc6d89db7eb&title="></p><h2 id="·-❓题目2-企鹅的最少数量-781-森林中的兔子-M"><a href="#·-❓题目2-企鹅的最少数量-781-森林中的兔子-M" class="headerlink" title="· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]"></a>· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537527351-44459aaf-41e1-458d-bae2-5ce71a0191b1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=176&id=u67946780&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40177&status=done&style=none&taskId=u47ce9f2e-8b46-4f21-a705-0ea9eefe640&title=&width=637.6" alt="image.png"><br>题意</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-b877c03c-a285-4712-9615-258c243e8ed7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u5b0b2b90&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufafc36af-a0b5-4e28-9db2-89eb9b6b178&title=&width=570"><br>a,b必然不同<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512800-25772203-c346-4bbe-8237-30518dbdb60b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9a8e07f0&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=228&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c66b2ce-92ce-46a9-b14b-4a3751310b8&title="><br><br>题解<br><br>排序, 让说的一样数量的人在一起<br>自我消化<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-cf987f51-87b0-448b-ac46-e9d5faf98eb3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=uaaa8f52f&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=1092&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud38b542a-cec3-4e17-b52e-70e2f50bd8f&title=&width=570"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512924-12bacc17-7f26-4686-85f0-7f71db1bfa89.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=uf697393a&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7604ddcd-7966-4e3a-b5d3-8f4cabf5c5a&title=&width=573"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512826-891ffc75-377e-4fc5-9d7a-da4028ceae6f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u2a3485d2&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6df243e7-fbc7-4a92-ab5c-bae5a440dbc&title=&width=559"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513286-e4853f30-976d-4afb-a9c2-1c0843765303.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=uc338299f&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf7ddc6e6-1972-40c5-8878-9a5754d7b21&title=&width=553"><br>规律, 如果当前数是x, 有c个, 有几组?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513383-501045f8-319a-4179-b47c-9c0c02e0badf.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u5d11b8c0&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=869&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4c2f6b9e-c173-4c10-9c13-75c4fbdd5e3&title=&width=503"><br>a&#x2F;b怎么向上取整<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513552-6e8d37f3-9848-4900-8eda-b864d1d22c3c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u20f90519&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=1146&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u396d7a21-be1d-44e9-877e-02a28b7fadc&title=&width=525"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513704-ac750a4e-7f0b-4700-8c7d-443c6aff347c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ucf35688f&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u103b599a-2ac9-4946-ae00-a479d0b8f24&title=&width=560"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513881-861b81c5-c61d-4e5d-92f4-e7f56b5dc042.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=150&id=u74b861b9&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75cc545e-f180-4c5d-90b8-b2e36446e6f&title=&width=544"><br>代码<br>不能约<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514082-45e66cf1-cbdf-48bd-80ce-7343743b8fca.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u32d23b83&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1010&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1f8888e6-27db-45fb-867a-dc516aff8af&title=&width=503"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514370-fba438f5-6e52-45a9-b7ff-ffe1427d7e10.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udbfd29aa&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=447&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u877d5405-cfd1-4b2e-b825-ffe2521430e&title="></p>]]></content>
      
      
      
        <tags>
            
            <tag> -Markdown -外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/08/09/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/09/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>多练的代码也就是不容易写出来的：✊<br>困难的代码：😡<br>了解：👌</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>PriorityQueue**&lt;**Node**&gt; **heap &#x3D; **new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) **-&gt; a.**value **- b.<strong>value)</strong>;<br>要练熟的代码：</p><p>排序：Arrays.sort()<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650254542022-b29c6afb-07da-458f-aad0-d9195e2cbb60.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=37&id=BvypH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=46&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29461&status=done&style=none&taskId=ue1e9cf3b-75fb-4abc-a0d2-566f55d0aec&title=&width=466.4" alt="image.png"></p><p>子串子数组想到以i结尾往左推 class3例子</p><h2 id="·-返回离非负整数num最近的2的某次方"><a href="#·-返回离非负整数num最近的2的某次方" class="headerlink" title="· 返回离非负整数num最近的2的某次方"></a>· 返回离非负整数num最近的2的某次方</h2><p><strong>题意</strong><br>num&#x3D;7, 返回8   num&#x3D;8，返回8   num&#x3D;13，返回6<br><strong>题解</strong><br>二进制第一个1后面全部填充完1后加1返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606374038-5dc3bdff-f8db-4cea-b539-13bc0f241519.png#clientId=u24411928-8d24-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=348&id=u6f518ae8&margin=%5Bobject%20Object%5D&name=DEF082573F9BE5D1BD2D58935BF11CDD.png&originHeight=1166&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=328379&status=done&style=none&taskId=uc329201a-a346-4a48-9408-2ab96b91a62&title=&width=448.2857666015625" alt="DEF082573F9BE5D1BD2D58935BF11CDD.png"></p><p>| &#x2F;&#x2F; 已知n是正数<br>&#x2F;&#x2F; 返回大于等于，且最接近n的，2的某次方的值<br>public static final int tableSizeFor(int n) {<br>   &#x2F;&#x2F;这个是为了如果正好是2的某次方，打散！！<br>   n–;<br>   &#x2F;&#x2F;&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补0。<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 1;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 2;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 4;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 8;<br>   &#x2F;&#x2F;整型最多32位<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 16;<br>   return (n &lt; 0) ? 1 : n + 1;&#x2F;&#x2F;负数最高位是1，填满32个1，返回1</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-相邻字符的交换次数"><a href="#·-相邻字符的交换次数" class="headerlink" title="· 相邻字符的交换次数"></a>· 相邻字符的交换次数</h2><p><strong>题意</strong><br>刻意的说两个标准, 搞你一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704873615-836bf286-fab2-47cb-8817-a817f740da5d.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=70&id=u73201307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=88&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19948&status=done&style=none&taskId=ub30207ba-f24d-4b60-884e-75662524657&title=&width=660.8" alt="image.png"><br><strong>题解</strong><br>贪心:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704850684-0c6b231e-483f-4ad1-99fb-9b7d76b6ffc9.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u5d3653f9&margin=%5Bobject%20Object%5D&originHeight=398&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u976907e3-3bde-438a-891c-5605344be3c&title=&width=556"><br><strong>两个指针</strong><br>index: 往右扫, 不是G就往右飘<br>L: 如果发现了放到哪儿的位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606588940-7b194664-6549-49a7-bec8-3209b6c93f08.png#clientId=u24411928-8d24-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=249&id=uab987630&margin=%5Bobject%20Object%5D&name=39A8E84629C793605662823ED198A9D4.png&originHeight=718&originWidth=1126&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126502&status=done&style=none&taskId=uc016d720-79cd-42d8-8978-bf6dafda160&title=&width=390.2857666015625" alt="39A8E84629C793605662823ED198A9D4.png"><br>如何确定这是最优解?<br>这个过程, L, index都不回退, 复杂度O(N)<br>原题: 你可以选择让 G 在左边B 在右边或者你可以选择让 B 在左边G在右边哪种更省。<br>哪种更剩你用哪种, 问你最小的用代价</p><p>| _&#x2F;&#x2F; 可以让G在左，或者在右<br>_**public static int **minSteps2(String s) {<br>   **if **(s &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; s.equals(</strong>“”</strong>)) {<br>      **return **0;<br>   }<br>   <strong>char</strong>[] str &#x3D; s.toCharArray();<br>   **int **step1 &#x3D; 0;<br>   **int **step2 &#x3D; 0;<br>   **int **gi &#x3D; 0;<br>   **int **bi &#x3D; 0;<br>   **for **(**int **i &#x3D; 0; i &lt; str.<strong>length</strong>; i++) {<br>      **if **(str[i] &#x3D;&#x3D; <strong>‘G’</strong>) { _&#x2F;&#x2F; 当前的G，去左边   方案1<br>         <em>step1 +&#x3D; i - (gi++);<br>      } **else **{</em>&#x2F;&#x2F; 当前的B，去左边   方案2<br>         _step2 +&#x3D; i - (bi++);<br>      }<br>   }<br>   **return **Math.<em>min</em>(step1, step2);</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-无序数组需要排序的最短子数组长度"><a href="#·-无序数组需要排序的最短子数组长度" class="headerlink" title="· 无序数组需要排序的最短子数组长度"></a>· 无序数组需要排序的最短子数组长度</h2><p><strong>题意</strong><br>想让整体有序<br>时间复杂度 O(N)额外空间复杂度O(1)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710897296-aa25c260-3795-403f-a63d-abcb51e33ff8.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u907fe5bc&margin=%5Bobject%20Object%5D&originHeight=593&originWidth=1216&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e7d06d1-a6cb-4207-a123-ea9ca887b8c&title=&width=477"><br><strong>题解</strong><br>最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654696304737-51815bbc-5fb1-4258-8122-5b4218ecc06f.png#clientId=uaf1c0b48-9cd0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=2891&id=u37b19965&margin=%5Bobject%20Object%5D&name=63E3A64272C54C218FDD9192B70053CB.png&originHeight=5059&originWidth=1612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=673473&status=done&style=none&taskId=u1c723737-203b-4864-b838-1417ede3aeb&title=&width=921.1428571428571" alt="63E3A64272C54C218FDD9192B70053CB.png"><br>需要排序范围2~5<br>你第一回从左往右遍历最右的违规，然后从右往左遍历最左的违规这之间需要排序。</p><p>左面max&lt;&#x3D;当前数, 比如左max&#x3D;6, 最后8,9是对号, 说明如果真要排序的话, 8不必给前面的最大值让位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898543-234a31d2-30e8-43f4-8676-33e52a7b9d25.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u2443991c&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90eff19c-58f3-47d7-a63a-a785a4fd9f9&title=&width=572"><br>9不必给前面的最大值让位置<br>10也不必给前面的最大值让位置<br>你后面连续的对号说明如果真的排序的话，它们动都不需要动<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898593-d8fbbadb-d557-419e-867b-23549142645e.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=u9fabbcb7&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1258&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6eca0a4-35e4-44ff-9ecc-aeb906a1b14&title=&width=631"><br>从右往左滑同理, 最左的对号说明在往左一直到开头全是对号,<br>说明如果真的排序的话，这些数据也不用给右边部分的最小值让位置。<br>你确定了一个右边不需要排的部分, 确定了一个左边不需要排的部分，那中间就是需要排序的部分, 搞定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898762-58901f0c-bbed-431c-a9f4-1bbd7fea4661.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u670e797a&margin=%5Bobject%20Object%5D&originHeight=609&originWidth=1212&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4471b33b-6b3d-4372-8a6b-4a2b4749e8c&title=&width=484"><br>第一个X到最后一个X中间直接排序不行吗?<br>不行, 因为你只关注了最大值, 例子中8没有人处理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710899406-b03a72c2-596b-40b2-b0a1-9d726f5d16a4.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u033c7053&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=1204&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u59606f10-dbf2-4450-924e-ed0813e7169&title="></p><p>| **public static int **findUnsortedSubarray2(<strong>int</strong>[] nums) {</p><p>   **if **(nums &#x3D;&#x3D; **null **&amp;#124;&amp;#124; nums.**length **&lt; 2) {<br>      **return **0;<br>   }<br>   **int **N &#x3D; nums.<strong>length</strong>;<br>   **int **right &#x3D; -1;<br>   <strong>int <strong>max &#x3D; Integer.</strong><em>MIN_VALUE</em></strong>;</p><p>   **for **(**int **i &#x3D; 0; i &lt; nums.**length**; i++) {<br>      **if **(nums[i] &gt;&#x3D; max) {<br>         max &#x3D; nums[i];<br>      } **else **{<br>         right &#x3D; i;<br>      }</p><p>   }<br>   **int **left &#x3D; N;<br>   <strong>int <strong>min &#x3D; Integer.</strong><em>MAX_VALUE</em></strong>;</p><p>   **for **(**int **i &#x3D; N - 1; i &gt;&#x3D; 0; i–) {<br>      **if **(nums[i] &lt; min) {<br>         min &#x3D; nums[i];<br>      } **else **{<br>         left &#x3D; i;<br>      }<br>   }<br>   **return **Math.<em>max</em>(0,right-left+1);</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-字符串种类"><a href="#·-字符串种类" class="headerlink" title="· 字符串种类"></a>· 字符串种类</h2><p>你只有26种字符，一个整数是不是有32位了，<br>你就拿这个整数的第0位表示a从没出现过，它是1是出现过，它是0就没出现过，<br>你拿这个整数第1位表示b拿这个整数，第2位表示c拿一个整数，第25位表示z，<br>你还结余了这么多倍不用了，那你的摘要是不是就不用是str类型了，变成一个<br>整数就可以表示一个摘要了<br>最后看这个set中留下了多少不同的整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351350-dc64aa66-e5f5-44a0-a5d7-96736ca8680d.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=207&id=u5fa830fc&margin=%5Bobject%20Object%5D&originHeight=582&originWidth=1183&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue6d9144b-3a7b-4eca-8c40-f73d1b2aa6d&title=&width=420"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351667-30911ef7-b885-449e-ab70-5c2e626b1445.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u6191cdd4&margin=%5Bobject%20Object%5D&originHeight=257&originWidth=422&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uece8ee91-b5ee-4851-a947-dd631519c75&title=&width=358"></p><h2 id="·-最大的以-1-为边界的正方形-M"><a href="#·-最大的以-1-为边界的正方形-M" class="headerlink" title="· 最大的以 1 为边界的正方形 [M]"></a>· 最大的以 1 为边界的正方形 [M]</h2><p><strong>题意</strong><br>边框全是1就达标，它不要求内部也有1, 内部有1, 也可以没有1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-9c36b203-d37d-46a9-9483-0348e3180719.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=ub37f09bb&margin=%5Bobject%20Object%5D&originHeight=578&originWidth=1082&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a91b9c9-d45e-406e-9103-c6290e2fc15&title=&width=427"><br><strong>题解</strong><br>预处理数组技巧</p><p><strong>前置</strong><br>N<em>N区域中长方形正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399168-04bf1552-399a-4c84-9e06-1ba7badf959e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=151&id=ud0e60c23&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=1167&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1bf94e4e-6018-42e3-bfac-44286cc6e9a&title=&width=311.0000305175781"><br>N</em>N区域中正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399176-f2349f13-30c8-4f6b-8779-a086f36cb16e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=163&id=u2f2a5857&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1160&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a4e536e-ea47-4b8f-acd2-17bb7283331&title=&width=359"><br><strong>代码</strong><br>所以边长的枚举一定是哪个少，就到那个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-09736a59-aa8a-4393-b496-335dd697275c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u3d7bd96a&margin=%5Bobject%20Object%5D&originHeight=501&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u924c016e-b4a5-492d-890b-d66b64c878a&title=&width=403"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399153-31e8e2ec-e0f7-4ab7-a328-8b2e74742a8f.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u6d60a1cb&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1011&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0b2a46c-d586-4bff-99d6-7555284bbb0&title=&width=414"><br>当我们点一个点的时候，我们只要那个长方形，它往右下方向拉, 然后看你能拉多远<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401624-62771dcc-0e46-4e02-95be-f03c4a11dd8d.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u20bd98fa&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=741&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9ee39ed7-94fc-449b-ba80-16d2550e136&title=&width=487"><br>验证过程能不能快一点 O(1)内<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401970-88428577-d5a9-4b70-8787-83d3001063ea.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uada68211&margin=%5Bobject%20Object%5D&originHeight=304&originWidth=692&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua0608d42-bb77-46f4-b982-6c6e649dd36&title="><br>假设我知道任何一个(i,j)位置右边有多少个连续的1, 下方有多少个连续的1(包括自己在内)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402673-739ba559-43f0-4cfc-9907-3a8c7357f9aa.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=359&id=uda259ca9&margin=%5Bobject%20Object%5D&originHeight=603&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uef3ee539-2f80-47f9-813c-47d085e71b8&title=&width=399"><br>17,29的左上顶点, 边长是7的这么一个正方形。<br>怎么验证?<br>你先看看(7,29)右方连续的1够不够 7 个，你再看看(7,29)这个点下方连续的1够不够 7个<br>…<br>只需要调出这 3 个点的信息, O(1)的过程<br>接下来就是求任何一个(i,j)点，让它右方和下方有这个信息</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402900-dc768550-cd1a-4853-a5d8-f871f5fcabfc.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=uc6970c91&margin=%5Bobject%20Object%5D&originHeight=547&originWidth=995&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08ef4750-7959-4b40-969e-e9a6bda8fc0&title=&width=572"><br>怎么求这个信息呢?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781186419-16a3698d-6e4e-4407-9643-68dfc9156b32.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=810&id=u0773d943&margin=%5Bobject%20Object%5D&name=8594CD1133E89D6E5D0DE8C781C7E60E.png&originHeight=1418&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=457290&status=done&style=none&taskId=ub2bac3a4-0128-47f0-b5ea-c0907f659e3&title=&width=590.8571428571429" alt="8594CD1133E89D6E5D0DE8C781C7E60E.png"><br>咋知道这个O(N^3)的解需不需要继续优化?<br>矩阵规模告诉你, 最多100*100, 你拿N^3一套没到10^8这个级别,<br>你知道O(N^3)的这个解不需要再优化了, 这个题目必过.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403570-4bf72a85-3dce-4515-959c-f1866430fbbd.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8da21f2c&margin=%5Bobject%20Object%5D&originHeight=63&originWidth=246&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc724a96e-b8cd-4797-97b5-7198d88597b&title="></p><p>怎么想到是预处理数组呢?<br>当写完3个for循环之后, 底层一个正方形再验的时候不想再遍历了,<br>势必会设计一种查询的结构来支持它, 不让它遍历来保证O(1)<br>这就是思想的开端,<br>预处理数组怎么用?<br>就是当你最后卡在最后一步，一个小的元件需要遍历搞定，这样的时候特别的多，<br>你就想着我怎么样做出一个能够提前查询的结构，到这一步的时候把遍历省掉, 比如前缀数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403652-75a89599-d8f8-43a3-a1e1-5d2643008a8c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=ub5033baf&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=884&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1f7af3b0-f56a-4be7-b7cc-baeebc9e05a&title=&width=492"></p><p>| **public static int <strong>largest1BorderedSquare</strong>(int[][] <strong>m</strong>) {<br>   int[][] **right &#x3D; **new int[**m.<strong>length][<strong>m</strong>[<strong>0</strong>]</strong>.<strong>length]</strong>;<br>   **int[][] <strong>down &#x3D; <strong>new int[<strong>m.<strong>length][<strong>m</strong>[<strong>0</strong>]</strong>.<strong>length]</strong>;<br>   &#x2F;&#x2F;&#x3D;&#x3D;生成右信息 下信息<br>   setBorderMap</strong>(<strong>m, right, down</strong>)</strong>;<br>   <strong>for (int <strong>size &#x3D; Math.min</strong>(<strong>m.<strong>length</strong>, m</strong>[<strong>0</strong>]</strong>.<strong>length)</strong>; size !&#x3D; 0; size–</strong>) {<br>      if (<strong>hasSizeOfBorder</strong>(<strong>size, right, down</strong>)) {<br>         return **size * size;<br>      **}<br>   }<br>   return **0;<br>**}<br>**<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781251250-6c80220e-fc56-430a-b4c9-377e6c3fa002.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=455&id=uadd39646&margin=%5Bobject%20Object%5D&name=image.png&originHeight=797&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&size=221761&status=done&style=none&taskId=udef49ab0-cccf-4360-9f48-ec0dcec606e&title=&width=568.5714285714286" alt="image.png">****public static void <strong>setBorderMap</strong>(int[][] **m, **int[][] **right, **int[][] <strong>down</strong>) {<br>   int **r &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>c &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   &#x2F;&#x2F;右下角<br>   **if (<strong>m</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>      <strong>right</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] <strong>&#x3D; 1;<br>      down</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] **&#x3D; 1;<br>   **}<br>   **&#x2F;&#x2F;最右侧的数据<br>   **for (int <strong>i &#x3D; r - 2; i !&#x3D; -1; i–</strong>) {<br>      if (<strong>m</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>         <strong>right</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D; 1;<br>         &#x2F;&#x2F;等于1的话九四下一行加1<br>         down</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D; down</strong>[<strong>i + 1</strong>][<strong>c - 1</strong>] **+ 1;<br>      **}<br>   }<br>   **&#x2F;&#x2F;最后一行的数据<br>   **for (int <strong>i &#x3D; c - 2; i !&#x3D; -1; i–</strong>) {<br>      if (<strong>m</strong>[<strong>r - 1</strong>][<strong>i</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>         <strong>right</strong>[<strong>r - 1</strong>][<strong>i</strong>] <strong>&#x3D; right</strong>[<strong>r - 1</strong>][<strong>i + 1</strong>] <strong>+ 1;<br>         down</strong>[<strong>r - 1</strong>][<strong>i</strong>] **&#x3D; 1;<br>      **}<br>   }<br>   **&#x2F;&#x2F;然后从倒数第二行开始，从倒数第二列往前一行一行的推 &lt;–  ^<br>   **for (int <strong>i &#x3D; r - 2; i !&#x3D; -1; i–</strong>) {<br>      for (int <strong>j &#x3D; c - 2; j !&#x3D; -1; j–</strong>) {<br>         if (<strong>m</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>            <strong>right</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D; right</strong>[<strong>i</strong>][<strong>j + 1</strong>] <strong>+ 1;<br>            down</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D; down</strong>[<strong>i + 1</strong>][<strong>j</strong>] **+ 1;<br>         **}<br>      }<br>   }<br>}</p><table><thead><tr><th>**</th></tr></thead></table><p>| **public static boolean <strong>hasSizeOfBorder</strong>(int **size, **int[][] **right, **int[][] <strong>down</strong>) {<br>   for (int **i &#x3D; 0; i !&#x3D; right.<strong>length <strong>- size + 1; i++</strong>) {<br>      for (int <strong>j &#x3D; 0; j !&#x3D; right</strong>[<strong>0</strong>]</strong>.**length <strong>- size + 1; j++</strong>) {<br>         **&#x2F;&#x2F;找那三个点！！  左上的那个点              下方的那个点<br>         <strong>if (<strong>right</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size &amp;&amp; down</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size &amp;&amp; right</strong>[<strong>i + size - 1</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size<br>               &#x2F;&#x2F;右边的那个点<br>               &amp;&amp; down</strong>[<strong>i</strong>][<strong>j + size - 1</strong>] <strong>&gt;&#x3D; size</strong>) {<br>            return true</strong>;<br>         <strong>}<br>      }<br>   }<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-乘客坐船使用的最少船数"><a href="#·-乘客坐船使用的最少船数" class="headerlink" title="· 乘客坐船使用的最少船数"></a>· 乘客坐船使用的最少船数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266540654-bc52c017-346b-4c9c-ba85-2f8363a2f43d.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=123&id=u90d68d8f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20339&status=done&style=none&taskId=ua7a2c8fd-24f1-479b-b9e4-4bb22b8c84a&title=&width=412.8" alt="image.png"><br><strong>题意</strong><br>每艘船最多坐两人，且不能超过载重。问你让所有人同时过河，并且用最好的分配方法，<br>使船尽量少返回最少的船数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754920033-d23a14f3-997f-4f13-a9f0-7b561f79d2f2.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u96abc735&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1151&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25fc0b67-d916-4e77-8078-1029b98c178&title=&width=428"><br><strong>题解</strong><br>你先遍历一遍数组，如果有单独一个人的体重已经超过了limit返回无穷大。<br>多少条船都搞不定的<br><strong>流程</strong><br>先排序<br>从中间分界点开始往左右两边滑</p><p>找&lt;&#x3D;limit&#x2F;2最右的位置, 做为L指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919993-2fc7575c-c414-4b7e-a832-5bf0bcb40ff6.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=ufb0881ef&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75a44641-53ce-4de8-8f74-8ac55b102d0&title=&width=446"><br>R指针: 第一个超过limit&#x2F;2的位置<br>看L位置和R位置能否凑一个船, 不能, 超了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919953-4a90aa2e-3033-4477-8930-018ff980a464.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u95912d5e&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1102&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue7bf048f-aaa8-4400-803d-9d57b976d24&title=&width=538"><br>L往左飘, L来到3, 可以<br>先不忙分配船, R往右滑, 一直划到R再往下进一个就没有办法跟 3凑一船为止<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919952-f9d1b099-1792-43c3-931a-0e97bdbaec96.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u65f47ec7&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1076&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u854235fa-c1f2-44a8-9746-bc7d404a688&title=&width=522"><br>贪心的核心点:<br>从3出发往左数6个的这6个，去消化这6个，一定是最省的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919986-6ed6fbd8-2c1a-41ba-9150-e1e3bb4a60e3.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u93e568a4&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1162&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u91791187-7421-4fec-b6c7-edf0f6db13c&title=&width=445"><br><strong>例子1: 右侧先耗尽</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921589-39ec9db9-b791-4250-84a0-959f28c10384.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u89cdb406&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5babd024-fc3f-4e18-897a-c9982047463&title=&width=475"><br>俩对号装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921991-8f261b8f-5962-4c73-85b3-f6a17ed90471.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u2d0e63b4&margin=%5Bobject%20Object%5D&originHeight=558&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08d96e78-dff0-43b7-a5d1-52d57f628ed&title=&width=503"><br>X号两两可以装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922406-6a35f17e-24ef-4b59-92c8-c94d60e2eeaa.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u608ae23c&margin=%5Bobject%20Object%5D&originHeight=548&originWidth=1040&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud57e21a5-c48a-4d3e-a609-646cb20f153&title=&width=439"><br><strong>例子2: 左侧先耗尽</strong><br>最后对号的数量除2，加上×号的数量除2(向上取整)，加上右侧剩几个数它们一定单独一艘船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922475-c578911c-83dd-4b73-a887-e8c5088bf359.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=u2c8f3183&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=1191&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua593a755-3782-413c-ab6c-595e375b6c0&title=&width=456"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654782938733-ff5ae0ad-f593-4836-8ee2-b595c618751a.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=867&id=u98f15db6&margin=%5Bobject%20Object%5D&name=2B163C063CD4521C4323347FAFB38F50.png&originHeight=1518&originWidth=1036&originalType=binary&ratio=1&rotation=0&showTitle=false&size=511608&status=done&style=none&taskId=uee0c2454-79c7-4464-a51a-0459a5ae855&title=&width=592" alt="2B163C063CD4521C4323347FAFB38F50.png"></p><p>| public static int numRescueBoats(int[] arr, int limit) {<br>   if (arr &#x3D;&#x3D; null &amp;#124;&amp;#124; arr.length &#x3D;&#x3D; 0) {<br>      return 0;<br>   }<br>   int N &#x3D; arr.length;<br>   Arrays.sort(arr);<br>   if (arr[N - 1] &gt; limit) {<br>      return -1;<br>   }<br>   int lessR &#x3D; -1;<br>   &#x2F;&#x2F;找到 最左侧里 limit&#x2F;2最接近的数<br>   for (int i &#x3D; N - 1; i &gt;&#x3D; 0; i–) {<br>      if (arr[i] &lt;&#x3D; (limit &#x2F; 2)) {<br>         lessR &#x3D; i;<br>         break;<br>      }<br>   }<br>   if (lessR &#x3D;&#x3D; -1) {<br>      return N;<br>   }<br>   int L &#x3D; lessR;<br>   int R &#x3D; lessR + 1;<br>   int noUsed &#x3D; 0;<br>   while (L &gt;&#x3D; 0) {<br>      int solved &#x3D; 0;&#x2F;&#x2F;用来更新L下标的<br>      while (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;&#x3D; limit) {<br>         R++;<br>         solved++;<br>      }<br>      &#x2F;&#x2F;表示上述结束了右边没有一个能和当前的L乘坐<br>      if (solved &#x3D;&#x3D; 0) {<br>         noUsed++;&#x2F;&#x2F;左侧未使用的<br>         L–;<br>      } else {<br>         L &#x3D; Math.max(-1, L - solved);<br>      }<br>   }<br>  &#x2F;&#x2F;下面的要用具体的例子来换算下标<br>   int leftAll &#x3D; lessR + 1;&#x2F;&#x2F;理解的好方法：因为数组是下标0开始的 +1就表示左侧的全部数量<br>   int leftUsed &#x3D; leftAll - noUsed;&#x2F;&#x2F;左侧的全部数量-未使用的就是使用的<br>   &#x2F;&#x2F;右侧还剩下未使用的<br>   int rightUnsolved &#x3D; (N - all) - used;<br>   return used + ((noUsed + 1) &gt;&gt; 1) + moreUnsolved;</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-子数组最大累加和"><a href="#·-子数组最大累加和" class="headerlink" title="· 子数组最大累加和"></a>· 子数组最大累加和</h2><p><strong>题解</strong><br>看到子数组子串想想每个位置结尾是答案是什么<br>如果子数组必须以0结尾, 它往左扩到什么程度，能让累加和最大<br>如果子数组必须以1位置结尾, 它往左扩到什么程度，能让累加和最大</p><p><strong>大流程</strong><br><strong>可能性划分</strong><br>必须以i位置结尾答案可能来自什么?</p><ol><li>完全不向左扩, 只有自己<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677717-e5aafff1-1b52-4e5e-80db-0a14e490e373.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=194&id=uea3b3eb0&margin=%5Bobject%20Object%5D&originHeight=389&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u498816dd-5c0d-429b-81ef-e611245e7c0&title=&width=489"></li><li>要向左扩， i-1结尾的时候扩出来的最好决定了当前能扩出来的最好<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677743-cc8cf0a5-a0c2-459a-abbe-6d083b658117.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=315&id=ue16cd42f&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=863&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89741c3c-0ea1-41a0-8082-0ac2dd610c1&title=&width=559"><br><strong>例子</strong><br>dp[i]: 必须以i位置的数结尾的时候最好累加和多少<br>dp中的max就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677733-ba8e98b6-b4cd-4ab5-8570-929835020c5b.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u3525b401&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1029&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udbb81fdc-2585-4a4b-9adb-f55a90e2193&title=&width=470"><br><strong>代码</strong><br>没有必要准备一整个 BP 有几个变量滚动更新下去就完了<br>因为它只依赖左边的一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756678781-859e8520-7df4-4d2f-887d-9be3467f97b0.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubf36503d&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=788&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u515da530-1d5b-46cd-8343-4404bd2aed8&title="></li></ol><h2 id="·-😡子矩阵最大累加和-H"><a href="#·-😡子矩阵最大累加和-H" class="headerlink" title="· 😡子矩阵最大累加和 [H]"></a>· 😡子矩阵最大累加和 [H]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655000610147-a7d3a92b-d3ae-4465-94ce-a8a8d694215c.png#clientId=u7bc39c19-43ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=313&id=u0e2403c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92137&status=done&style=none&taskId=u927eb0d4-d5e2-468d-8556-18104e0bc5a&title=&width=668.5714285714286" alt="image.png"><br><strong>题解</strong><br>大流程<br>矩形必须包含第0行数据, 且只包含第0行的情况下, 最大累加和是多少?<br>矩形必须包含0,1两行数据, 且只包含0,1两行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2三行数据, 且只包含0,1,2三行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2,3四行数据, 且只包含0,1,2,3四行的情况下, 最大累加和是多少?<br>….<br>然后<br>1行<del>1行<br>1行</del>2行<br>1行<del>3行<br>1行</del>4行<br>…<br>然后<br>2行<del>2行<br>2行</del>3行<br>2行<del>4行<br>…<br>然后<br>3行</del>3行<br>…<br>然后<br>4行~4行<br>如果我们能够每一个都求出来，答案一定在其中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884708-799a0b20-7c1c-47b3-977e-90592414790a.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u0156074e&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7b53efdb-4fdf-4833-8ad0-bd3bc9bb71d&title=&width=432"><br>如果我们能够每一个都求出来答案一定在其中</p><p>压缩数组技巧<br>0行<br>必须包含第0行数据，且只有第0行情况下画框, 最大累加和多少?<br>就是子数组的最大累加和问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884722-2be04454-65aa-4ab1-bf9a-f9b97da2206c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4164a828&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1f9b8e9-8a11-4a1f-9e61-14d37d138b3&title=&width=554"><br>下面<br>矩形必须包含0, 1两行数据, 且只包含0, 1两行的情况下, 最大累加和是多少?<br>两行上下数据压在一起,形成一个新数组<br>对这个数组求最大累加和就代表必须包含0, 1两行数据，且只包含01两行数据画框的最好答案是啥。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884649-aa42ef84-bb7a-4136-98bb-9fd3691bc443.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ude7883e6&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2740ec61-35a4-4813-9a55-36c15b2fcb8&title=&width=526"><br>复杂度O(行^2*列)<br>在行上玩了一个O(行^2)的事<br>0<del>0<br>0</del>1<br>…<br>1<del>1<br>1</del>2<br>…<br>但你每次解决一个子任务它就是过一遍数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884664-75b98c0a-3eaa-493f-bfb2-184b1e00835a.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=ue4e4a946&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u95e57951-deb2-47df-983f-7072b817740&title=&width=506"><br>进一步优化: 让行列小的当平方项<br>如果是5行, 100列, 选择让行做平方项<br>如果是100行, 5列, 选择让列做平方项</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884772-ba08c36e-d98b-45f2-8291-2432422e914c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=uf99229ea&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=1061&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a44cb24-c550-46f5-888f-c474dd72d23&title=&width=559"><br><strong>代码</strong></p><p>| **public static int <strong>maxSum</strong>(int[][] <strong>m</strong>) {<br>   if (**m &#x3D;&#x3D; **null **&amp;#124;&amp;#124; m.<strong>length <strong>&#x3D;&#x3D; 0 &amp;#124;&amp;#124; m</strong>[<strong>0</strong>]</strong>.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   **&#x2F;&#x2F; O(N^2 * M)<br>   **int **N &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      **&#x2F;&#x2F; i行~j行<br>      **int[] **s &#x3D; <strong>new int[<strong>M</strong>]</strong>;<br>      <strong>for (int <strong>j &#x3D; i; j &lt; N; j++</strong>) {<br>         for (int <strong>k &#x3D; 0; k &lt; M; k++</strong>) {<br>            <strong>s</strong>[<strong>k</strong>] <strong>+&#x3D; m</strong>[<strong>j</strong>][<strong>k</strong>]</strong>;<br>         <strong>}<br>         <strong>max &#x3D; Math.max</strong>(<strong>max, maxSubArray</strong>(<strong>s</strong>))</strong>;<br>      **}<br>   }<br>   return **max;<br>**}</p><p>public static int <strong>maxSubArray</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   <strong>int <strong>cur &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>cur +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      max &#x3D; Math.max</strong>(<strong>max, cur</strong>)</strong>;<br>      cur &#x3D; cur &lt; 0 ? 0 : cur;<br>   **}<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>LeetCode原题<br>需要返回最大累加和矩形的左上角跟右下角点<br>当你发现了更大的答案， 你把它左上角点跟右下角点抓一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655001837943-7e030c8e-9549-42e0-a28a-31e013cd2d7b.png#clientId=ub6405de6-621a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=530&id=u0049c974&margin=%5Bobject%20Object%5D&name=A19EA1E0AF7663EFCF77985E2517F6F4.png&originHeight=1296&originWidth=1216&originalType=binary&ratio=1&rotation=0&showTitle=false&size=510166&status=done&style=none&taskId=u1f0706bf-c56b-4e69-9411-9025019afa5&title=&width=497.2857360839844" alt="A19EA1E0AF7663EFCF77985E2517F6F4.png"></p><p>| &#x2F;&#x2F;返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。<br>&#x2F;&#x2F; 本题测试链接 : <a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">https://leetcode-cn.com/problems/max-submatrix-lcci/</a><br>**public static int[] <strong>getMaxMatrix</strong>(int[][] <strong>m</strong>) {<br>   int **N &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **int **cur &#x3D; 0;<br>   **int **a &#x3D; 0;<br>   **int **b &#x3D; 0;<br>   **int **c &#x3D; 0;<br>   **int **d &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      int[] **s &#x3D; <strong>new int[<strong>M</strong>]</strong>;<br>      **for (int <strong>j &#x3D; i; j &lt; N; j++</strong>) {<br>         **cur &#x3D; 0;<br>         &#x2F;&#x2F;记录左上角的列<br>         <em>*int <strong>begin &#x3D; 0;<br>         &#x2F;</strong><br>          * [1 1 1 1]<br>          * [0 1 1 2]<br>          * [2 1 0 1]<br>          *&#x2F;<br>         <strong>for (int <strong>k &#x3D; 0; k &lt; M; k++</strong>) {<br>            <strong>s</strong>[<strong>k</strong>] <strong>+&#x3D; m</strong>[<strong>j</strong>][<strong>k</strong>]</strong>;<br>            cur +&#x3D; s**[<strong>k</strong>]</em>*;<br>            **if (<strong>max &lt; cur</strong>) {<br>               **max &#x3D; cur;<br>               a &#x3D; i;<br>               &#x2F;&#x2F;主要这一句<br>               b &#x3D; begin;<br>               &#x2F;&#x2F;<br>               c &#x3D; j;<br>               d &#x3D; k;<br>            **}<br>            **&#x2F;&#x2F;只有一开始就为负数的情况下，0列<br>            **if (<strong>cur &lt; 0</strong>) {<br>               **cur &#x3D; 0;<br>               begin &#x3D; k + 1;<br>            **}<br>         }<br>      }<br>   }<br>   return new int[] { **a, b, c, d <strong>}</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-135-分糖果问题-H"><a href="#·-135-分糖果问题-H" class="headerlink" title="· 135.分糖果问题 [H]"></a>· 135.分糖果问题 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757640476-f9879a7a-09ff-4b7e-9894-dcc5fb7a88f1.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=294&id=uefc12a68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26786&status=done&style=none&taskId=u1a5c1fb5-6fbe-4e76-9b2f-86a45e8de44&title=&width=573.6" alt="image.png"><br><strong>原问题</strong><br>一个数组是所有孩子的得分, 规则是，每个孩子至少一颗糖。相等不管, 只管严格大小关系<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486177-e5f2c5b1-bff0-4a8a-b27f-80ba3eac2b1c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=u249a86d3&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8840862e-eeb8-4455-87ff-fdf3aa4e161&title=&width=504"><br><strong>题解</strong><br><strong>预处理数组+贪心</strong><br>左边没东西1块糖, 比左边大, 数字就++, 不再大了就返回1, left代表每一个点左边的坡度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486316-27402c6e-a9dd-4a3a-b72e-c09cae8103ee.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u59a65f06&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=1093&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u999c1aa3-b272-4cb8-9003-279e9af6e87&title=&width=499"><br>右边没东西1块糖, 比右边打了就++, 不再大了就回1<br>每个位置的max就是分糖数量，因为左坡跟右坡以较大坡为准<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486225-aba65e85-23b1-4233-a76e-2e967ed35bc0.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ud59977cd&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf3423d64-9cb4-4a2c-9e49-352f333674a&title=&width=652"><br><strong>复杂度</strong><br>时间复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757488676-248c8add-ee09-4fe4-9157-ff396f83324e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ued7c1b61&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=913&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u552fabd9-cd94-48a3-bc14-1d1ab0ac4fe&title=&width=479"><br><strong>最优解</strong><br>我遍历的过程中，我先认为进入到上坡阶段和下坡阶段，我如果能找出一个坡来<br>就是上坡跟下坡共同构成这么一个坡度的话，该怎么分糖我就知道了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489305-1d4f8a25-b3af-43b7-9067-6174a5c50d95.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=180&id=ucfc19315&margin=%5Bobject%20Object%5D&originHeight=329&originWidth=1101&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8812c98d-eef3-4d11-8bbc-cbd7af31d8c&title=&width=603"><br>对coding要求比较高<br>Coding技巧可以让我找到一组上坡下坡, 等找到的时候, 再回过去给糖</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489355-8a08973f-476c-46d2-8817-37ea96dc2203.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ua20e6791&margin=%5Bobject%20Object%5D&originHeight=412&originWidth=942&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9aab8328-aca0-4baa-acf8-3a67fc6e1b5&title=&width=646"><br>没有重复值的例子<br>先遍历一遍找到坡, 然后再回去给糖, 两个坡度较大的那个+1<br>然后处理下个坡<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489655-913e2252-71e6-43df-9f0f-e11e4963f752.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u9023b751&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u293717ff-dce2-472f-a9bc-18f6b77868d&title=&width=525"><br>要保证两个坡中间同样的那个1不要重复给<br>相当于遍历两遍这个事儿就出来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489683-68970db3-f71e-47f9-a62e-43d3352f2041.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ud4227d7e&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u373ac26e-6280-4b9b-9741-d0f405fca4a&title=&width=567"><br>有相等值就更考验coding<br>相等是无非就是你认为上坡停止下会停止, 更考研Coding技巧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490765-ec269bd1-cd03-4caf-a292-1556e258aaed.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=uf2363b7e&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=751&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1aa1af8b-180e-44d1-adbd-6f02d306b85&title=&width=498"><br>补充问题<br>相邻孩子分数一样, 糖的数量必须一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490609-1e02392c-0c28-4911-aabe-a0e441adc3b2.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u9114b783&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1041&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u74edf940-9fec-4510-bf50-509068979ff&title=&width=441"><br><strong>例子</strong><br>生成辅助数组<br>三个原则，第一比左边大就++，<br>第二，跟左边相等就继承, 就是不变，<br>第三比左边小就归1<br>同样方法生成right<br>还是每个位置的值求max</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490724-1661c665-c1f5-4df8-8d39-1a84b646d746.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ubc071e71&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubd737b23-0203-49bd-9d92-6f6dddc3625&title=&width=492"><br>可以Coding省掉辅助数组, 更难（idea上有代码）<br>相等认为坡没变<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757491157-d5860f2a-c415-4dba-a996-a2ef506de57f.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=u5b8b35db&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=971&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8911ce37-03e3-4967-8e7d-037c74c385c&title=&width=426"></p><p>| &#x2F;&#x2F; 这是原问题的优良解<br>&#x2F;&#x2F; 时间复杂度O(N)，额外空间复杂度O(N)<br>**public static int <strong>candy1</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   **int[] **left &#x3D; <strong>new int[<strong>N</strong>]</strong>;<br>   **for (int <strong>i &#x3D; 1; i &lt; N; i++**) {<br>      if (**arr**[**i - 1**] **&lt; arr**[**i**]) {<br>         **left**[**i**] **&#x3D; left**[**i - 1**] **+ 1;<br>      **}<br>   }<br>   int[] **right &#x3D; **new int[**N**]**;<br>   **for (int **i &#x3D; N - 2; i &gt;&#x3D; 0; i–</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; arr</strong>[<strong>i + 1</strong>]) {<br>         <strong>right</strong>[<strong>i</strong>] <strong>&#x3D; right</strong>[<strong>i + 1</strong>] **+ 1;<br>      <strong>}<br>   }<br>   int <strong>ans &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      <strong>ans +&#x3D; Math.max</strong>(<strong>left</strong>[<strong>i</strong>]</strong>, right</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   return **ans + N;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-小人过有鳄鱼的河-博弈论"><a href="#·-小人过有鳄鱼的河-博弈论" class="headerlink" title="· 小人过有鳄鱼的河(博弈论)"></a>· 小人过有鳄鱼的河(博弈论)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757912442-ad573f17-7f4a-489a-ad67-3e78f85412e8.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=76&id=uacedcc1b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17519&status=done&style=none&taskId=u60591a67-ac3f-4cdc-b743-12dc5bc1e43&title=&width=669.6" alt="image.png"><br><strong>题解</strong><br>思路: 从小推到大<br>这个人在一只鳄鱼的时候就过不了河了，<br>两只鳄鱼的时候就可以过河<br>三只鳄鱼等同于一个人两条鳄鱼的时候, 也不能过河, 因为任何一个鳄鱼吃掉人是没风险的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885276-012e6b97-e501-4f4e-be4b-fa012f482633.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u9ca7460a&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=937&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1dff254-e3ae-49c7-94e2-2f88822fd1d&title=&width=530"><br>奇数能过河, 偶数不能过河<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885221-16ccb180-9d2a-48a8-bd80-9148fde82953.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u2548e3b4&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u299d4d20-2cf8-471b-8a64-0863faf084d&title=&width=457"></p><h2 id="·-Nim博弈问题"><a href="#·-Nim博弈问题" class="headerlink" title="· Nim博弈问题"></a>· Nim博弈问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800477496-814bb547-f09d-498f-abe5-e2c0e47bb5df.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=79&id=u4fd49066&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22068&status=done&style=none&taskId=uc93319c5-ad21-4523-9ae1-dc89387a500&title=&width=674.4" alt="image.png"><br><strong>题意</strong><br>所有的数&gt;&#x3D;0, 每一轮不管谁都不能拿0<br>谁最先把最后一点数拿完谁赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457877-281d0894-d81e-47d0-987e-47ebb159a8b0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u3d1eed1b&margin=%5Bobject%20Object%5D&originHeight=607&originWidth=1273&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7304e460-0286-465e-aee9-75c63e9b7ec&title=&width=478"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457894-773ef509-f81a-4726-b0ee-d9cf10ef31bd.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=uf044b29a&margin=%5Bobject%20Object%5D&originHeight=468&originWidth=672&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue799c9d7-94cb-4cac-8596-1d6808cdfa8&title=&width=342"><br>先手跟后手，绝顶聪明，每一个人都充分为所有为自己打算，<br>而且绝对理智，问你，给你一个数组状况返回谁会赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800467223-97b4ba95-223a-4115-827b-edf542fc7b0c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=ud3a77b39&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=734&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue582679d-eb0a-4430-ac2a-50f530a132f&title=&width=410"><br>先手第一回拿把它拿成两个数都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458021-1b935de2-12bb-47d3-8f26-530ef46b89a0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=udc3de2b1&margin=%5Bobject%20Object%5D&originHeight=515&originWidth=693&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u18bf42a8-f831-4160-8833-13cff2b33f1&title=&width=378"><br>后手接下来不管拿多少, 先手都让它两个数一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457964-b74ab48f-bb7e-453a-beb0-160600a24846.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=u85f511af&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u107afaec-9b34-4b96-8fe4-32cb147b4a3&title=&width=418"><br>这样先手一定会赢<br>这是两个数的规律<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458667-6220c51c-3dd2-47e9-bde9-b5b33c5a54a4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=u163724fc&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=862&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufbf57780-7d21-4ca3-8ca3-77502419af6&title=&width=391"><br><strong>题解</strong><br>由1900年数学家尼姆搞出来一个非常牛逼的解，<br>结论:<br>所有的数异或起来，如果异或和不等于零先手赢，如果异或和等于0后手赢</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458782-28023103-8346-46b2-a8dc-de62f52c13ac.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=u8660b253&margin=%5Bobject%20Object%5D&originHeight=563&originWidth=987&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua5dfad24-d8cf-4843-9bf3-a66fb04062c&title=&width=442"><br>先手的大目标:<br>让后手最先面对所有数组中都是 0 的状态。<br>大目标不知道怎么实现, 转换一下目标</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458900-733597fd-a958-4f2d-bd91-7dee949c8ffa.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u50188994&margin=%5Bobject%20Object%5D&originHeight=459&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud4ecb940-750d-4418-b3c3-e54b7d7592a&title=&width=446"></p><p>所有数都异或起来的异或和, 我如果先手能够做到我面对这坨数的异或和它不等于零，<br>但是我拿完之后每一次都让后手面对的异或和等于0，那么最后胜利是先手<br>我们知道最后全 0 的时候异或和是0。所以就这么玩下去，它总有一个时刻全 0 的时候，<br>而我是遇不到的，只会让后手遇到，所以我必胜的大目标被我们变成一个看似更难的目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458936-68a35d98-dbb4-4fbc-8eb7-a1dd85180307.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=uda72b545&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u505fe591-a3c8-41b2-ab41-bd6884a1f14&title=&width=500"><br><strong>例子</strong><br>把二进制写出来, 数组7,5,3 整体异或和001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459312-eddefebf-42c9-45db-9b8e-ddbd313e4e16.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=ua7fccb0e&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud2f98016-c6b9-4d1d-a11e-a52172c1446&title=&width=560"><br>先手在1这拿一个, 变成6, 更后面的5,3异或和为6的合起来异或和为0<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459424-4f4051be-b558-49e1-90b9-860f4b9f0660.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u72048edf&margin=%5Bobject%20Object%5D&originHeight=617&originWidth=1318&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e0608f9-d441-45c1-80f0-19fbc6e06d1&title=&width=491"><br>后手再拿的时候，他不管在哪个位置上拿哪个数都一定会让异或和从 0 变成不是零，<br>因为他必然会改变某一个位置上一的数量, 改变了它的异或和就不是0，然后先手继续让<br>它异或和变0, 先手必胜.<br>但是这样做的前提是什么?初始的时候异或和得是非零的先手才能这么干，如果先手面<br>对一个一上来就是异或和等于0的状态，后手赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459439-1138e3cb-d17b-4fe9-810b-e54a6fc1742f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u2905cd61&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1307&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf2bff4b1-484e-4ee0-9b03-d077dffc405&title=&width=510"><br>先手不一定在最大值上拿</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459509-11aaa21d-d569-4be6-9afa-9d6e11b76fa1.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u5f1b26a9&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1179&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3841b959-e751-45bc-9027-7d4efd1ad33&title=&width=507"><br>就是先手一定能做到一个不是0 异或和的东西变成全零，但不一定是在最大值上拿的，但是他一定能做到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800460027-d4c6583e-9e89-43ce-92f4-10ed5c3be356.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=uc64a46f9&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1331&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8bef9a58-5ca7-415c-85d2-26b3416a918&title=&width=566"></p><p>| &#x2F;&#x2F; 保证arr是正数数组<br>**public static void <strong>printWinner</strong>(int[] <strong>arr</strong>) {<br>   int **eor &#x3D; 0;<br>   **for (int <strong>num : arr</strong>) {<br>      **eor ^&#x3D; num;<br>   <strong>}<br>   if (<strong>eor &#x3D;&#x3D; 0</strong>) {<br>      <strong>System.<strong>out</strong>.println</strong>(“后手赢”)</strong>;<br>   <strong>} else {<br>      <strong>System.<strong>out</strong>.println</strong>(“先手赢”)</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><h2 id="·-非负数组中两个数相与的最大结果"><a href="#·-非负数组中两个数相与的最大结果" class="headerlink" title="· 非负数组中两个数相与的最大结果"></a>· 非负数组中两个数相与的最大结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650113590488-8110c2b9-7a47-41d5-a42b-f0a7399ead91.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=u485e8bbb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15539&status=done&style=none&taskId=u122a7d6b-ae77-4da4-8b41-ac244820e50&title=&width=315.2" alt="image.png"><br><strong>题解</strong><br>可以用前缀树, 额外空间比较大, 存在更好的解法<br>思路: 高位尽量变1<br>因为我如果选一些数让30位变成0，它就不如30位变成1的值大</p><p>先遍历一遍所有的数字, 只考察30位是1的有几个, 分情况</p><ol><li>小于两个<br>这说明最终的结果30位上肯定不是1，因为你小于两个就不存在任何两个数，两个两个数与玩之后第30位是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800811891-1b46d42a-fe12-4196-af17-9775c90ea3a4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u164ba3a7&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf326dddf-1871-4357-abfd-fc5d79a368e&title=&width=518"></li><li>正好有两个数， 就是这两个数与完的结果最大， 直接返回就行<br>3） 大于两个数<br>那我就把这100个数淘汰掉，剩下的我只留这23个数，我再去看第29位</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812084-94f090b2-a658-437e-8dc0-a7931e7bc517.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u2d559d95&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub142840c-3848-4aa9-ae7d-5317a77cf57&title=&width=549"><br>假设目前这一批数还剩20个， 来到第i位<br>第i位上有1的数：<br>1） &lt;2个<br>2） &#x3D;2个<br>3） &gt; 2个</p><p>我们遍历一遍整个数组，如果有第i位上有1的数，<br>第1种情况小于两个，那么这20个数一个也不淘汰，你接下来去看a减，<br>第2种情况如果这20个数中第i位上1的只有两个数，你不用再看，就这两个是结果<br>第3种情况如果大约在在地在第i位上有1的数是大于两个的，比如说他有7个，那么删掉剩余的13个，只留这7个数去搞安检一位不就玩儿去了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812139-21391412-9c69-4642-866d-d3f960d20bc7.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=ucefcac7f&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=1083&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54468d3d-1d2f-4ae3-b207-9d23095f3ba&title=&width=504"><br><strong>时间复杂度</strong><br>30位遍历一遍数组， 29位遍历一遍数组…<br>一共遍历32遍数组, O(32N)</p><p><strong>空间复杂度怎么计算</strong><br>如果删到只剩下6个数, 17位的时候<br>保留数字这件事情, 在原数组上操作, 原数组末尾做垃圾区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812121-214352ae-98c3-4159-91d0-39878e511b6c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u73578c17&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=833&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue4361ff8-1204-42b3-9953-9cab2cc1866&title="><br><strong>代码</strong><br>垃圾区<br>&lt;2个, 一个数也不淘汰, 让M跳回去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812117-fb4a8866-f4ce-4796-9d6f-e723dcabb358.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u3dfa6e88&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=895&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud964a6ce-61a5-49cc-bd8b-f81d3549e57&title=&width=483"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812536-2890f02a-970d-48af-90d3-2e5b41d3edb8.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0869c0ec&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=575&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u146e66a2-ea4d-4abe-92ce-6d990b399e2&title="></p><p>| **public static int <strong>maxAndValue2</strong>(int[] <strong>arr</strong>) {<br>   **&#x2F;&#x2F; arr[0…M-1]  arr[M….]<br>   **int **M &#x3D; arr.<strong>length</strong>;<br>   **int **ans &#x3D; 0;<br>   **for (int <strong>bit &#x3D; 30; bit &gt;&#x3D; 0; bit–</strong>) {<br>      **&#x2F;&#x2F; arr[0…M-1] arr[M…]<br>      **int **i &#x3D; 0;<br>      **int **tmp &#x3D; M;&#x2F;&#x2F;有可能跳回去<br>      **while (**i &lt; M**) { **&#x2F;&#x2F; arr[0…M-1]<br>         **if ((**arr**[**i**] **&amp; **(**1 &lt;&lt; bit**)) **&#x3D;&#x3D; 0**) {<br>            **swap**(**arr, i, –M**)**;<br>         **} else {<br>            **i++;<br>         **}<br>      }<br>      if (**M &#x3D;&#x3D; 2**) { **&#x2F;&#x2F; arr[0,1]<br>         **return **arr**[**0**] **&amp; arr**[**1**]**;<br>      **}<br>      **&#x2F;&#x2F;&#x3D;&#x3D;<br>      **if (**M &lt; 2**) {**&#x2F;&#x2F;当前bit为无法得到1，M跳回原来位置，一个数也不删****         **M &#x3D; tmp;<br>      **} else { **&#x2F;&#x2F; &gt; 2个数  bit位上有1<br>         ans &amp;#124;&#x3D; <strong>(<strong>1 &lt;&lt; bit</strong>)</strong>;<br>      **}<br>   }<br>   return **ans;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊括号嵌套系列问题"><a href="#·-✊括号嵌套系列问题" class="headerlink" title="· ✊括号嵌套系列问题"></a>· ✊括号嵌套系列问题</h2><h3 id="①计算str表达式结果"><a href="#①计算str表达式结果" class="headerlink" title="①计算str表达式结果"></a>①计算str表达式结果</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650098950782-2396606a-0bbb-4b55-9cb6-f263b9578ad9.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=uaeee7735&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49751&status=done&style=none&taskId=u4b5b7ea1-393b-431b-8ac2-e4790d56699&title=&width=679.2" alt="image.png"><br><strong>题意</strong><br>负数作为公式的开头 或括号部分的开头，可以没有括号<br><strong>题解</strong><br>先处理没有小括号的情况</p><p>指针从零开始就有两种情况:</p><ol><li>当前压中的是数字</li><li>当前压中的是符号<br>准备一个栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569314-732407d5-15f9-4a7e-955b-af2e37ff100f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u1a923818&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=1096&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc508edf6-c054-45e5-b769-4791d54b022&title=&width=505"><br>压中运算符号, 当初过数字阶段结束了, 找到了34<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569315-adc8cd07-34b4-4302-9e41-3b97c55765fb.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=uce5b21e3&margin=%5Bobject%20Object%5D&originHeight=493&originWidth=1115&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua15fcfcf-0634-4317-b4a3-83765138bda&title=&width=536"><br>**1, * **入栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569327-d3093cd3-afae-4027-a13c-21a795ed98e4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u8b5cb035&margin=%5Bobject%20Object%5D&originHeight=477&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0f70762-e91b-40e6-ad16-29f364c33ce&title=&width=567"><br>栈顶乘除, 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569326-10c63ce7-1bb7-4088-b202-5669ddcfa1ce.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0ca380b&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=1116&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u19d8bda1-3868-4505-8ef6-06decfae122&title="><br>栈顶 &#x2F; 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569330-71ccfd20-9804-4216-a208-53f5b5d350c1.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=uaea7846f&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69bde130-2897-4078-9dfd-67844659fef&title=&width=570"><br>最后位置， 7 入栈， 栈里只有+-符号了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802570274-71211b4b-b360-454e-af84-04dd0cae9fc3.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=ub7bce47c&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1112&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8191caa6-71ac-442a-8cc3-02e1fd3d0ff&title=&width=558"><br>定义递归函数f<br>int[] f(int i)<br>从i位置出发, 遇到右括号或者整个字符串终止位置停止， 返回两个值</li></ol><ul><li><ol><li>answer</li></ol></li><li><ol start="2"><li>F函数算到哪个位置了</li></ol></li></ul><p>条件情况：<br>①遇到数字</p><ul><li>设置cur</li></ul><p>②遇到运算符，结合cur加入到队列中<br>③遇到左括号就交给递归去搞，递归返回两个值</p><ul><li><ol><li>answer</li></ol></li><li><ol start="2"><li>F函数算到哪个位置了</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127597996-d7be7b6e-c490-4bea-bd31-166716737d7e.png#clientId=u7251bedd-719d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=504&id=u8c22e28e&margin=%5Bobject%20Object%5D&name=B03D96AEEDFC16F1164F383A3C4FA837.png&originHeight=1081&originWidth=1739&originalType=binary&ratio=1&rotation=0&showTitle=false&size=456166&status=done&style=none&taskId=u8a1e2898-b1b8-4344-a8d0-08c331b7bf2&title=&width=811.0000610351562" alt="B03D96AEEDFC16F1164F383A3C4FA837.png"></p><p><strong>例子2</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802571970-a1640f24-2c37-483d-b77a-efbb1b989559.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=ua50d068b&margin=%5Bobject%20Object%5D&originHeight=445&originWidth=1107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u99525ff6-64ba-48bf-b068-cce57175db3&title=&width=506"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572172-4a4912ea-4cde-4445-8205-a79369f2c4ca.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=187&id=u81b31c60&margin=%5Bobject%20Object%5D&originHeight=416&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf9fcaa9a-38b5-4adf-97e8-c0b34eab9cd&title=&width=498"><br>遇到左括号了就调递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572369-f6d4f508-2cf3-4096-944a-dd73f55c5d87.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u0ecc431b&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1103&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub543cc02-862d-4386-ac2e-09562639620&title=&width=546"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572690-1f71ba4c-d5a1-4bca-b4b9-84e14c4ec028.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u1ef6c4e6&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=1112&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u81b410fe-4bce-4b03-ae45-37ae4dc0511&title=&width=543"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572941-2ab03421-1f4d-4d27-89e2-904c73ddb9d8.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u5a645239&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1105&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u43dfc911-4281-454a-8e5d-0e49de897e6&title=&width=515"><br>压缩数组例子<br>只要是括号嵌套的都这玩意儿。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573019-d4ab5767-707d-4c9e-b387-12602d4bcdc0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=206&id=u794d34bb&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=940&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u011e5f47-e7bf-4aeb-9bb3-746df83d1bb&title=&width=498"><br>开头为负怎么计算<br>一上来碰到-号, 0, -, 压栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573351-066ab599-0ef9-4c1a-9f56-c63f6a74181f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u36ef568b&margin=%5Bobject%20Object%5D&originHeight=464&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud82d0514-6263-41c7-b9d5-faaef151f10&title=&width=485"><br><strong>代码</strong><br>最后一个数字还没入栈， 放进去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573451-a23baef1-630a-43f3-89a6-cd2766a53edd.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=312&id=u878bd00f&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0b6eb0c-a03c-4a1a-8d42-f425afa6344&title=&width=582"><br>这种方法一定要牢牢掌握，因为任何括号嵌套的题都可以这么改</p><p>| **public static int[] <strong>f</strong>(char[] **str, **int <strong>i</strong>) {<br>   <strong>LinkedList</strong>&lt;**String**&gt; **que &#x3D; <strong>new <strong>LinkedList</strong>&lt;**String**&gt;()</strong>;<br>   **int **cur &#x3D; 0;<br>   **int[] **bra &#x3D; <strong>null</strong>;<br>   &#x2F;&#x2F; 从i出发，开始撸串<br>   **while (**i &lt; str.**length **&amp;&amp; str**[**i**] **!&#x3D; **’)’) {<br>      if (**str**[**i**] **&gt;&#x3D; **’0’ <strong>&amp;&amp; str</strong>[<strong>i</strong>] <strong>&lt;&#x3D; <strong>‘9’) {<br>         <strong>cur &#x3D; cur * 10 + str</strong>[<strong>i++</strong>] <strong>- <strong>‘0’</strong>;<br>      <strong>} else if (<strong>str</strong>[<strong>i</strong>] <strong>!&#x3D; <strong>‘(‘) { <strong>&#x2F;&#x2F; 遇到的是运算符号<br>         addNum</strong>(<strong>que, cur</strong>)</strong>;&#x2F;&#x2F;比如队列中此时有 1 +   cur &#x3D; 2  来到+ 放入 2 +<br>         que.addLast</strong>(<strong>String.valueOf</strong>(<strong>str</strong>[<strong>i++</strong>]))</strong>;<br>         cur &#x3D; 0;<br>      <strong>} else { <strong>&#x2F;&#x2F; 遇到左括号了<br>         bra &#x3D; f</strong>(<strong>str, i + 1</strong>)</strong>;<br>         cur &#x3D; bra</strong>[<strong>0</strong>]</strong>;<br>         i &#x3D; bra</strong>[<strong>1</strong>] **+ 1;<br>      <strong>}<br>   }<br>   <strong>&#x2F;&#x2F;注意！要结束了，把最后一个数字放进去<br>   addNum</strong>(<strong>que, cur</strong>)</strong>;<br>   <strong>return new int[] { <strong>getNum</strong>(<strong>que</strong>)</strong>, i <strong>}</strong>;<br>**}</p><p>public static void <strong>addNum</strong>(<strong>LinkedList</strong>&lt;<strong>String**&gt; <strong>que, <strong>int <strong>num</strong>) {<br>   if (</strong>!que.isEmpty</strong>()) {<br>      int <strong>cur &#x3D; 0;<br>      String top &#x3D; que.pollLast</strong>()</strong>;<br>      <strong>if (<strong>top.equals</strong>(“+”) <strong>&amp;#124;&amp;#124; top.equals</strong>(“-“)) {<br>         <strong>que.addLast</strong>(<strong>top</strong>)</strong>;<br>      <strong>} else {<br>         <strong>cur &#x3D; Integer.valueOf</strong>(<strong>que.pollLast</strong>())</strong>;<br>         num &#x3D; top.equals**(“*”) **? **(<strong>cur * num</strong>) **: <strong>(<strong>cur &#x2F; num</strong>)</strong>;<br>      <strong>}<br>   }<br>   <strong>que.addLast</strong>(<strong>String.valueOf</strong>(<strong>num</strong>))</strong>;<br><strong>}</strong><br>**public static int <strong>getNum</strong>(<strong>LinkedList</strong>&lt;**String**&gt; <strong>que</strong>) {<br>   int **res &#x3D; 0;<br>   **boolean **add &#x3D; <strong>true</strong>;<br>   String cur &#x3D; <strong>null</strong>;<br>   <strong>int <strong>num &#x3D; 0;<br>   <strong>while (</strong>!que.isEmpty</strong>()) {<br>      <strong>cur &#x3D; que.pollFirst</strong>()</strong>;<br>      **if (<strong>cur.equals</strong>(“+”)) {<br>         **add &#x3D; <strong>true</strong>;<br>      <strong>} else if (<strong>cur.equals</strong>(“-“)) {<br>         <strong>add &#x3D; <strong>false</strong>;<br>      <strong>} else {<br>         <strong>num &#x3D; Integer.valueOf</strong>(<strong>cur</strong>)</strong>;<br>         res +&#x3D; add ? num : <strong>(</strong>-num</strong>)</strong>;<br>      **}<br>   }<br>   return **res;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h3 id="②字符串解码"><a href="#②字符串解码" class="headerlink" title="②字符串解码"></a>②字符串解码</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127913238-063d6a0a-b032-4ca8-89e2-5dc17f30d0be.png#clientId=u7251bedd-719d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u2e367064&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22499&status=done&style=none&taskId=u6402f452-c01d-4576-b24d-7d027b199f9&title=&width=440.57142857142856" alt="image.png"></p><p>| **public static **String calculate(String str) {<br>        **return **f(str.toCharArray(), 0)[0];<br>    }</p><pre><code>**public static **String[] f(**char**[] str, **int **i) &#123;    String ans = **&quot;&quot;**;    **int **cur = 0;    // 从i出发，开始撸串    **while **(i &lt; str.**length **&amp;&amp; str[i] != **&#39;]&#39;**) &#123;        //遇到数字        **if **(str[i] &gt;= **&#39;0&#39; **&amp;&amp; str[i] &lt;= **&#39;9&#39;**) &#123;            cur = cur * 10 + str[i++] - **&#39;0&#39;**;        &#125; **else if **(str[i] &gt;= **&#39;a&#39; **&amp;&amp; str[i] &lt;= **&#39;z&#39;**) &#123; //            ans += str[i++];        &#125; **else **&#123; // 遇到左括号了            String[] f = f(str, i + 1);            **for **(**int **j = 0; j &lt; cur; j++) &#123;                ans += f[0];            &#125;            cur = 0;            i = Integer.valueOf(f[1]);            i++;        &#125;    &#125;    **return new **String[] &#123; ans, String.valueOf(i) &#125;;&#125; |</code></pre><p>| — |</p><h3 id="③❓原子的数量"><a href="#③❓原子的数量" class="headerlink" title="③❓原子的数量"></a>③❓原子的数量</h3><p><strong>扩展：计算括号字符串的分数</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650109458205-b1b14786-40bd-4f1c-bfa1-9a055b24847d.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=uabd6313c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=711&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36399&status=done&style=none&taskId=u2890ec75-3800-40a2-aabe-f170319bf19&title=&width=568.8" alt="image.png"><br>记住代码，比较难理解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650110035627-385b43a8-6afc-437b-bb16-74508df9d7f8.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u52f0ac7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111603&status=done&style=none&taskId=uc24e086b-659c-49f0-b945-4a1fb06b24d&title=&width=304" alt="image.png"></p><h2 id="·-盛最多水的容器"><a href="#·-盛最多水的容器" class="headerlink" title="· 盛最多水的容器"></a>· 盛最多水的容器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652803229358-74a054ba-5506-4cb4-888f-08fb6bd8faed.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=uab3100b9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=609&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40053&status=done&style=none&taskId=u5e22d377-cb6c-42c5-a11e-f25dd5bf093&title=&width=514.7999877929688" alt="image.png"><br><strong>题解</strong><br>先假设无重复值, 左右两个指针<br>左边跟右边比大小， 谁小结算谁的水量<br>两个左右两个指针依次划的过程中算出所有水量的最大值就是答案</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603322-564cdac1-d9b0-46b5-ae4f-e90597069858.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=ue0abe2ca&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u56957f64-7d7b-4946-9167-ea72d58d406&title=&width=462"><br>而事实上3可以继续往右扩大，那我为什么不求出唯一的正确答案，<br>只求3~8这一段的答案呢，这是因为a的答案包含这一段，所以我只关注会不会有把答案推高的可能性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603354-4d6989ad-b2b5-4a05-8c69-6f7008972fd5.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=uf256ec8f&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uba4cb029-1101-4abf-a81a-be756f71cbe&title=&width=496"><br>它不是严格要求每一个数都能够准确的算出来它的答案, 它只关心有没有推高答案的可能性<br>为啥你不知道这道题怎么做?<br>但是你看数据量，你就知道自己一定会憋出一个O(N)的解，<br>那势必可能会想到双指针，谁大移动谁跟谁小移动谁都试一遍这题就出来了，不用知道为什么有可能都能猜出来<br>复杂度O(N)<br>我不去严格纠结到底这个值他真实的最优解是什么，我只纠结会不会让答案变大<br>ref： 数组三连第三连<br><strong>例子</strong><br>只关注它推高答案的可能性，但是我们不去严格纠结每一个位置的值，它具体答案是多少<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603343-312db809-99e8-414c-a228-7fc6ae108e0c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=200&id=u90840346&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=928&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u82dc8d2e-0c79-4da0-9b9b-729957c3535&title=&width=419"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603345-91268f80-07fa-46fd-9be0-2ac568756483.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u9a46939d&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=1092&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2229fb65-1462-44d2-a2f2-ad111e6093d&title=&width=475"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603340-dff504be-50d9-4110-bde8-60d0eaa86e2f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u5153fc20&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1094&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54178eed-544a-423b-9a03-b4e0b59ea95&title=&width=488"></p><p>| **public static int <strong>maxArea1</strong>(int[] <strong>h</strong>) {<br>   int **max &#x3D; 0;<br>   **int **N &#x3D; h.<strong>length</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) { <strong>&#x2F;&#x2F; h[i]<br>      <strong>for (int <strong>j &#x3D; i + 1; j &lt; N; j++</strong>) { <strong>&#x2F;&#x2F; h[j]<br>         max &#x3D; Math.max</strong>(<strong>max, Math.min</strong>(<strong>h</strong>[<strong>i</strong>]</strong>, h</strong>[<strong>j</strong>]) *** <strong>(<strong>j - i</strong>))</strong>;<br>      **}<br>   }<br>   return **max;<br>**}</p><p>public static int <strong>maxArea2</strong>(int[] <strong>h</strong>) {<br>   int **max &#x3D; 0;<br>   **int **l &#x3D; 0;<br>   **int **r &#x3D; h.**length **- 1;<br>   **while (<strong>l &lt; r**) {<br>      **max &#x3D; Math.max**(**max, Math.min**(**h**[**l**]**, h**[**r**]) *** **(**r - l**))**;<br>      **if (**h**[**l**] **&gt; h</strong>[<strong>r</strong>]) {<br>         **r–;<br>      **} else {<br>         **l++;<br>      **}<br>   }<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-多个有序list中的top-100-大"><a href="#·-多个有序list中的top-100-大" class="headerlink" title="· 多个有序list中的top 100 大"></a>· 多个有序list中的top 100 大</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882236750-67c0af3e-05fa-4bed-98b7-fcf80e36b74c.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=30&id=ufd509bb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=38&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7392&status=done&style=none&taskId=uef743611-362e-49ac-b624-c0c7dc58095&title=&width=509.6" alt="image.png"><br>大根堆<br>先把链表逆序<br>所有头部拿出来组成一个大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882248310-fbb2aa87-caa0-422c-a083-a8713a7d4694.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u5395c82a&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1291&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u437d1bae-2ae6-40d8-a1af-96d46908e56&title=&width=624"></p><h2 id="·-跳跃游戏Ⅱ"><a href="#·-跳跃游戏Ⅱ" class="headerlink" title="· 跳跃游戏Ⅱ"></a>· 跳跃游戏Ⅱ</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650029478423-12a50e13-5642-45ad-9e9e-04f762f5b727.png#clientId=u98aeb21b-e583-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u7efc409b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37693&status=done&style=none&taskId=u765ebde4-b464-4164-bf78-e8a292676f9&title=&width=532.8" alt="image.png"><br><strong>题意</strong><br>存在一个选择<br>如果尽着最大步数跳他可能得不到最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305648-957d0562-d157-4d3d-ae6c-fc146f1a4502.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u7daad865&margin=%5Bobject%20Object%5D&originHeight=510&originWidth=1237&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3f318203-80a6-4650-85bf-4d1f226ff95&title=&width=609"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305602-7f9f8032-223f-476c-b74f-d76bef9d32ac.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=210&id=u21788ad8&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1216&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufb841da7-04af-4c5b-907e-0212ae690a1&title=&width=524"><br>用贪心, 老紧着最大步数跳是不对的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305681-d01ab949-c241-4243-bac5-4c66c124efae.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=uc2a1cfe5&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1252&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u926d9fc0-6e2a-4122-a843-128c9c2436c&title=&width=521"><br><strong>题解</strong><br>流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655211162287-fd0710b0-b985-4a90-bfed-0abe223715f1.png#clientId=u83bd60c9-5fa5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=812&id=u6a026509&margin=%5Bobject%20Object%5D&name=41D4CCD93F04922A9F2D17AA467437A5.png&originHeight=1421&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&size=417915&status=done&style=none&taskId=u26adf01b-d2c7-4f51-8d3d-1813a4c2bf8&title=&width=704" alt="41D4CCD93F04922A9F2D17AA467437A5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882306957-1850e9b7-de8b-4a4a-adea-eb2cfffcc9eb.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ufbe8fdc9&margin=%5Bobject%20Object%5D&originHeight=579&originWidth=1043&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc564cc66-4380-40a6-a766-66d63c6b832&title=&width=509"><br>反例<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307533-6f1f96c5-ad80-4f9e-9ab2-54da1412c258.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=uc54b612f&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=1132&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3debd364-ff69-4b03-b637-3746408f53d&title=&width=507"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307672-7a9a40e1-5757-4e56-8392-55c6b983411e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u9fe696a3&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=797&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u381a4f25-cc9a-4da0-94f2-80b9ae28f16&title=&width=428"><br><strong>代码</strong></p><p>| **public static int <strong>jump</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **step &#x3D; 0;&#x2F;&#x2F;目前位置跳了几步<br>   **int **cur &#x3D; 0;&#x2F;&#x2F;如果你不增加步数，step以内，你最远能到哪儿<br>   <strong>int <strong>next &#x3D; 0;&#x2F;&#x2F;如果允许我多跳一步，请问我最远的到哪儿<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882687455-34de4ef7-d45e-4515-8847-2cdd7261f16a.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=141&id=u998e7fdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=219&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15857&status=done&style=none&taskId=uf377eb45-a694-43de-80a6-f4277e28737&title=&width=292.8000183105469" alt="image.png"></strong></strong>      if (<strong>cur &lt; i</strong>) {<br>         **step++;<br>         cur &#x3D; next;<br>      <strong>}<br>      <strong>next &#x3D; Math.max</strong>(<strong>next, i + arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   return **step;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·✊在两个都有序的数组找整体第k小的数"><a href="#·✊在两个都有序的数组找整体第k小的数" class="headerlink" title="·✊在两个都有序的数组找整体第k小的数"></a><strong>·✊在两个都有序的数组找整体第k小的数</strong></h2><h3 id="①算法模型：在两个都有序的数组中找上中位数"><a href="#①算法模型：在两个都有序的数组中找上中位数" class="headerlink" title="①算法模型：在两个都有序的数组中找上中位数"></a>①算法模型：在两个都有序的数组中找上中位数</h3><p><strong>题意</strong><br>O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884443226-1de0ecb3-1471-4e81-899c-0e32b5ca4a66.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ub50901c6&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua642aa49-06f2-439b-a489-64f4f71a01d&title=&width=426"><br><strong>题解</strong><br>分情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655299291411-6ecd16bb-340f-4d93-9539-e4bb4a986a8a.png#clientId=u02685321-15d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1841&id=uf949730e&margin=%5Bobject%20Object%5D&name=7A99CC63E8320AA8102F6ACA846A0A14.png&originHeight=3222&originWidth=1849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1850552&status=done&style=none&taskId=ucde9adac-f3e4-459e-a56d-0b19154fa4c&title=&width=1056.5714285714287" alt="7A99CC63E8320AA8102F6ACA846A0A14.png"><br><strong>代码</strong></p><p>| **public static int <strong>getUpMedian</strong>(int[] **A, **int **s1, **int **e1, **int[] **B, **int **s2, **int <strong>e2</strong>) {<br>   int **mid1 &#x3D; 0;<br>   **int **mid2 &#x3D; 0;<br>   **while (**s1 &lt; e1**) {<br>      **&#x2F;&#x2F; mid1 &#x3D; s1 + (e1 - s1) &gt;&gt; 1<br>      mid1 &#x3D; **(<strong>s1 + e1</strong>) **&#x2F; 2;<br>      mid2 &#x3D; **(<strong>s2 + e2</strong>) **&#x2F; 2;<br>      <strong>if (<strong>A</strong>[<strong>mid1</strong>] <strong>&#x3D;&#x3D; B</strong>[<strong>mid2</strong>]) {<br>         return <strong>A</strong>[<strong>mid1</strong>]</strong>;<br>      **}<br>      **&#x2F;&#x2F; 两个中点一定不等！<br>      &#x2F;&#x2F;e1 - s1 + 1就是个数 奇数&amp;1 &#x3D;&#x3D; 1<br>      **if (((<strong>e1 - s1 + 1</strong>) <strong>&amp; 1</strong>) <strong>&#x3D;&#x3D; 1</strong>) { **&#x2F;&#x2F; 奇数长度<br>         &#x2F;&#x2F;一定要对着例子<br>         <strong>if (<strong>A</strong>[<strong>mid1</strong>] <strong>&gt; B</strong>[<strong>mid2</strong>]) {<br>            if (<strong>B</strong>[<strong>mid2</strong>] <strong>&gt;&#x3D; A</strong>[<strong>mid1 - 1</strong>]) {<br>               return <strong>B</strong>[<strong>mid2</strong>]</strong>;<br>            **}<br>            **e1 &#x3D; mid1 - 1;<br>            s2 &#x3D; mid2 + 1;<br>         <strong>} else { <strong>&#x2F;&#x2F; A[mid1] &lt; B[mid2]<br>            **if (**A**[**mid1**] **&gt;&#x3D; B</strong>[<strong>mid2 - 1</strong>]) {<br>               return <strong>A</strong>[<strong>mid1</strong>]</strong>;<br>            **}<br>            **e2 &#x3D; mid2 - 1;<br>            s1 &#x3D; mid1 + 1;<br>         **}<br>      } else { **&#x2F;&#x2F; 偶数长度<br>         **if (<strong>A</strong>[<strong>mid1</strong>] <strong>&gt; B</strong>[<strong>mid2</strong>]) {<br>            **e1 &#x3D; mid1;<br>            s2 &#x3D; mid2 + 1;<br>         <strong>} else {<br>            <strong>e2 &#x3D; mid2;<br>            s1 &#x3D; mid1 + 1;<br>         <strong>}<br>      }<br>   }<br>   return <strong>Math.min</strong>(<strong>A</strong>[<strong>s1</strong>]</strong>, B</strong>[<strong>s2</strong>])</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>复杂度</strong><br>每一次比价砍一半, 二分, O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884449524-c998a42f-d576-4006-9cf1-9c30739af9d7.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=342&id=Dep6S&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=945&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25c8aeb9-2c09-4667-9058-e9474a70a88&title=&width=517"></p><h3 id="②进阶：在两个都有序的数组找整体第k小的数"><a href="#②进阶：在两个都有序的数组找整体第k小的数" class="headerlink" title="②进阶：在两个都有序的数组找整体第k小的数"></a><strong>②进阶：在两个都有序的数组找整体第k小的数</strong></h3><p><strong>例子：arr1 17个 arr2 10个</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655300515983-61e193b4-7e6a-4b2e-8067-4cd547c49684.png#clientId=u02685321-15d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1109&id=uc06c0ab8&margin=%5Bobject%20Object%5D&name=ACE1391B1036C5CD896CD36C7A4E1AF8.png&originHeight=1941&originWidth=2212&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1248551&status=done&style=none&taskId=u7e89ae7d-1de4-45b4-a7ae-d3b2e6a1f95&title=&width=1264" alt="ACE1391B1036C5CD896CD36C7A4E1AF8.png"></p><p>| &#x2F;&#x2F; 进阶问题 : 在两个都有序的数组中，找整体第K小的数<br>&#x2F;&#x2F; 可以做到O(log(Min(M,N)))<br>**public static int <strong>findKthNum</strong>(int[] **arr1, **int[] **arr2, **int <strong>kth</strong>) {<br>   int[] **longs &#x3D; arr1.**length **&gt;&#x3D; arr2.**length **? arr1 : arr2;<br>   **int[] **shorts &#x3D; arr1.**length <strong>&lt; arr2.**length **? arr1 : arr2;<br>   **int **l &#x3D; longs.**length**;<br>   **int **s &#x3D; shorts.**length**;<br>   **if (**kth &lt;&#x3D; s**) { **&#x2F;&#x2F; 1)<br>      **return **getUpMedian**(**shorts, 0, kth - 1, longs, 0, kth - 1**)**;<br>   **}<br>   if (**kth &gt; l</strong>) { <strong>&#x2F;&#x2F; 3)  对着例子【例子太重要了，具象化的代码改为抽象化就可以了】看代码就懂了  贴图过来非常简单！<br>      <strong>if (<strong>shorts</strong>[<strong>kth - l - 1</strong>] <strong>&gt;&#x3D; longs</strong>[<strong>l - 1</strong>]) {<br>         return <strong>shorts</strong>[<strong>kth - l - 1</strong>]</strong>;<br>      <strong>}<br>      if (<strong>longs</strong>[<strong>kth - s - 1</strong>] <strong>&gt;&#x3D; shorts</strong>[<strong>s - 1</strong>]) {<br>         return <strong>longs</strong>[<strong>kth - s - 1</strong>]</strong>;<br>      <strong>}<br>      return <strong>getUpMedian</strong>(<strong>shorts, kth - l, s - 1, longs, kth - s, l - 1</strong>)</strong>;<br>   <strong>}</strong><br>****   <strong>&#x2F;&#x2F; 2)  s &lt; k &lt;&#x3D; l<br>   **if (**longs**[**kth - s - 1**] **&gt;&#x3D; shorts</strong>[<strong>s - 1</strong>]) {<br>      return <strong>longs</strong>[<strong>kth - s - 1</strong>]</strong>;<br>   <strong>}<br>   return <strong>getUpMedian</strong>(<strong>shorts, 0, s - 1, longs, kth - s, kth - 1</strong>)</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h3 id="·-394-字符串解码-M"><a href="#·-394-字符串解码-M" class="headerlink" title="· 394. 字符串解码 [M]"></a>· 394. 字符串解码 [M]</h3><p><strong>题意</strong><br>字符串还原成全是小写字母<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500821-75a18c69-29c4-4b24-b7e5-887be3cb6749.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=ucd62da43&margin=%5Bobject%20Object%5D&originHeight=596&originWidth=1175&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u468d9297-5ca7-472c-88dc-6d62e3ef096&title=&width=488"><br>原始串只有a~z<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500842-3195e513-118a-4630-af49-7b8ed4406f4d.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=uf17c79f4&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u987e1af2-77b6-46ca-b800-4512ab05154&title=&width=364"><br><strong>题解</strong><br>定义递归函数:</p><ol><li>返回结果字符串</li><li>处理到的位置</li></ol><p>从压缩串str i位置往后转换, 遇到]或者压缩串结尾停止, 停的时候, 从i…停这段返回, 并返回计算到的位置</p><p>所有的嵌套结构可以用这个递归结构求解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500729-ad1aeada-e94d-4f7f-9263-31b5031971c8.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=ua4899735&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1306&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a9acdf8-1639-498c-b25c-8532d5b9013&title=&width=451"><br>比如表达式计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500774-5f55cb4a-375e-4628-8a25-c5886f9b8ecf.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=ub4b51deb&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6130fe28-6f0f-4e73-8f26-03514873989&title=&width=505"><br>例子<br>一个字符串的总结果， ans<br>一个收集数字的 cur</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500812-577e8e62-310b-441d-b5fc-70f6264da78d.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ueb3f028b&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=1249&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e762acf-74d3-4f32-a96c-9b00be09246&title=&width=643"><br>2位置遇到左括号, 调子过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504551-ef54c717-a12c-4ef7-a8e6-1dea07860e9f.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u174ad8d4&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=1290&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb7240e5-7fd4-4f17-9d0c-dc13026baee&title=&width=530"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504525-6706a8a2-0c1d-4b36-941c-b9c59ded0d45.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u689b0aea&margin=%5Bobject%20Object%5D&originHeight=668&originWidth=1371&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7f4f3313-621b-4ad6-a317-6341b366355&title=&width=513"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504536-785698a9-0b58-4ea5-bb85-e5870cbed403.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u107f1f9b&margin=%5Bobject%20Object%5D&originHeight=665&originWidth=1262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8359b1d3-cd55-4872-a3b1-24b10aa2d4d&title=&width=468"><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504635-339d1550-5bd7-4f34-8eca-7de606f92831.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3a36b325&margin=%5Bobject%20Object%5D&originHeight=795&originWidth=747&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5993c173-de94-4eac-806d-e4d0ee9a8b5&title="></p><p>| <strong>public static <strong>String decodeString</strong>(<strong>String s</strong>) {<br>   char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>   <strong>return <strong>process</strong>(<strong>str, 0</strong>)</strong>.<strong>ans</strong>;<br>**}</p><p>public static class **Info **{<br>   public **String <strong>ans</strong>;<br>   <strong>public int stop</strong>;</p><p>   **public <strong>Info</strong>(**String a, **int <strong>e</strong>) {<br>      ans **&#x3D; a;<br>      **stop **&#x3D; e;<br>   **}<br>}</p><p>**&#x2F;&#x2F; s[i….]  何时停？遇到   ‘]’  或者遇到 s的终止位置，停止<br>&#x2F;&#x2F; 返回Info<br>&#x2F;&#x2F; 0) 串<br>&#x2F;&#x2F; 1) 算到了哪<br>**public static <strong>Info process</strong>(char[] **s, **int <strong>i</strong>) {<br>   **StringBuilder ans &#x3D; <strong>new <strong>StringBuilder</strong>()</strong>;<br>   **int **count &#x3D; 0;<br>   **while (**i &lt; s.**length **&amp;&amp; s**[**i**] **!&#x3D; **’]’) {<br>      if ((**s**[**i**] **&gt;&#x3D; **’a’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’z’) **&amp;#124;&amp;#124; **(**s**[**i**] **&gt;&#x3D; **’A’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’Z’)) {<br>         **ans.append**(**s**[**i++**])**;<br>      **} else if (**s**[**i**] **&gt;&#x3D; **’0’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’9’) {<br>         <strong>count &#x3D; count * 10 + s</strong>[<strong>i++</strong>] <strong>- <strong>‘0’</strong>;<br>      <strong>} else { <strong>&#x2F;&#x2F; str[index] &#x3D; ‘[‘<br>         Info next &#x3D; process</strong>(<strong>s, i + 1</strong>)</strong>;<br>         ans.append</strong>(<strong>timesString</strong>(**count, next.<strong>ans))</strong>;<br>         &#x2F;&#x2F;<br>         count &#x3D; 0;<br>         i &#x3D; next.<strong>stop <strong>+ 1;<br>      <strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>ans.toString</strong>()</strong>, i</strong>)</strong>;<br>**}</p><p>public static <strong>String timesString</strong>(int <strong>times, String str</strong>) {<br>   **StringBuilder ans &#x3D; <strong>new <strong>StringBuilder</strong>()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; times; i++</strong>) {<br>      <strong>ans.append</strong>(<strong>str</strong>)</strong>;<br>   <strong>}<br>   return <strong>ans.toString</strong>()</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-最长连续序列"><a href="#·-最长连续序列" class="headerlink" title="· 最长连续序列"></a>· 最长连续序列</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650027587467-9c71453c-132e-4e65-92ea-5e95c4838e80.png#clientId=u98aeb21b-e583-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=341&id=uc6150b29&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35602&status=done&style=none&taskId=u165c0c4b-a7e3-4fba-bdad-65d2fc46eed&title=&width=666.4" alt="image.png"><br><strong>题解</strong><br>连续区间头表+连续区间尾表<br>100来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450085-90058467-9331-4e7f-afc9-abfc89b72c9e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u25beeefc&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=1139&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e7bb74f-ea0e-4c9a-93a4-d29beffe1e0&title=&width=530"><br>3来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450084-3d961eca-d28d-4f43-b7fe-e707f3e47a19.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=uac2eb7d7&margin=%5Bobject%20Object%5D&originHeight=461&originWidth=1141&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u17d37d9c-915a-46fd-ab24-ef6eb833409&title=&width=498"><br>4来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450169-15fadec0-cbd9-4797-82c9-51f4aa1f8295.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u4eee0f77&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9de3535e-8e32-4ff8-bc47-4d00a37927c&title=&width=480"><br>合并<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450083-6829ff9b-d260-46f0-b4f6-170148bd867e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ud0fd55ea&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1511e11d-3175-4713-8409-9f9a8863080&title=&width=457"><br>6来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450067-4a7f66f8-a015-411b-a4cc-095f219446d4.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u00347243&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90b8fbaa-d0f1-43c4-8845-9a8afae0a7f&title=&width=480"><br>7来了<br>5<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450782-178be574-6064-458a-9275-a8f116757def.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u9c05a450&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u85da3f43-5abc-4192-bdfc-dccfad0d0ca&title=&width=472"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450958-39fc9099-3c15-44d8-bc54-5f2a4a86304a.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=uaca38d01&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udcfcab17-b0c7-49d5-b493-4931f6a3233&title=&width=448"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450977-0bb7308a-fa05-40a5-9dcf-9540516264b5.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=uedf3ad85&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=1091&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u863f4790-bc00-4d11-b7ac-4d41a2ecfc5&title=&width=428"><br>总结<br>每个数来的时候都自己建出自己的区间，看看跟之前都不能合，看看后面能不能合,<br>你每次都严严格格的合完之后，你问我最后有多长的连续区间，你随便找一张表，把value最大值拿出来<br>每一个数来到的时候, 对于哈希表的操作都是O(1)<br><strong>代码</strong><br>难点在于它怎么只用一张哈表搞出来。</p><p>| **public static int <strong>longestConsecutive</strong>(int[] <strong>nums</strong>) {<br>   <strong>HashMap</strong>&lt;**Integer, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>len &#x3D; 0;<br>   <strong>for (int <strong>num : nums</strong>) {<br>      if (</strong>!map.containsKey</strong>(<strong>num</strong>)) {<br>         <strong>map.put</strong>(<strong>num, 1</strong>)</strong>;<br>         <strong>int <strong>preLen &#x3D; map.containsKey</strong>(<strong>num - 1</strong>) <strong>? map.get</strong>(<strong>num - 1</strong>) <strong>: 0;<br>         <strong>int <strong>posLen &#x3D; map.containsKey</strong>(<strong>num + 1</strong>) <strong>? map.get</strong>(<strong>num + 1</strong>) <strong>: 0;<br>         <strong>int <strong>all &#x3D; preLen + posLen + 1;<br>         map.put</strong>(<strong>num - preLen, all</strong>)</strong>;<br>         map.put</strong>(<strong>num + posLen, all</strong>)</strong>;<br>         len &#x3D; Math.max</strong>(<strong>len, all</strong>)</strong>;<br>      **}<br>   }<br>   return **len;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-超级洗衣机（硬记）"><a href="#·-超级洗衣机（硬记）" class="headerlink" title="· 超级洗衣机（硬记）"></a><strong>· 超级洗衣机（硬记）</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932367995-bbe4de73-2904-4594-916c-9533bbc0f67e.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=uea6a2d41&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39680&status=done&style=none&taskId=u8f0f91ee-9a43-4785-a206-f20939def19&title=&width=668" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403145-b876e20d-8562-4eff-b4f8-d442cf06b0f4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=u3a840e1e&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0ffadcba-008c-4d96-b91e-d0ebf518fa5&title=&width=482"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403138-c0c32760-5291-473e-8c7b-ed2d0d17ab3d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=u2bc83435&margin=%5Bobject%20Object%5D&originHeight=569&originWidth=1275&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udf474620-5c39-4ccf-9947-d5377322ff9&title=&width=432"><br><strong>题解</strong><br>大过滤器<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403158-39eaeb21-beea-423a-9a81-ab1b3e4f0c8a.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u5dbce6c0&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=889&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b72d3a9-8d80-444f-a2a7-71510f9fd37&title=&width=381"><br>思想传统: 算单点的瓶颈, 最后看总答案跟单点瓶颈之间的关系</p><p>假设来到某一台(i号)洗衣机, 衣服数量?<br>假设每台机器该有的平均数我们知道<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403159-bc4570ef-622d-4f66-b7b2-806dd142a67c.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=uaf6e2a70&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1229&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc26ff0ff-3a4e-4e24-ae5a-aa0f7723c5f&title=&width=589"><br><strong>第一种情况</strong><br>左右两侧有一个为正数有一个为负数<br>左侧整体欠15件。而它右侧整体多10件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403191-6e7e37d7-0bf5-4987-a6ce-5be5b43a0741.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u95da6da5&margin=%5Bobject%20Object%5D&originHeight=622&originWidth=837&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u070d6067-1b7d-42c5-b8ff-3bc599784ca&title=&width=386"><br>左侧整体欠15件。而它右侧整体多20件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932412835-bcbf1abd-1049-4490-a288-38569f24b131.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u491fbc95&margin=%5Bobject%20Object%5D&originHeight=604&originWidth=899&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua656072e-d9c0-41e4-8e4c-954b2598c76&title=&width=402"><br><strong>总结</strong><br>左右两侧有一个为正数有一个为负数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932414115-732d2fca-785a-4f8e-a095-b8ca0fbe23b4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=ucc357489&margin=%5Bobject%20Object%5D&originHeight=546&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5290c3aa-c695-47a0-9411-e0238a73417&title=&width=394"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932417841-5e9e3984-a2c9-4e68-9694-6b85c58bafd0.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u6fe2d0e8&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=971&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ac861c9-058d-4e4e-8e96-d5996a3c43d&title=&width=365"><br><strong>第二种情况</strong><br>左右两侧都为正数<br>i如果衣服特别少就可能左右两侧都要给它衣服<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932420558-7c95096e-d93b-4f93-b6f3-4eb0b7ca8c5c.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=ud8e9e4fd&margin=%5Bobject%20Object%5D&originHeight=638&originWidth=857&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6165a81f-c605-4f9c-a6aa-8fe99ad651f&title=&width=296"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421080-d8bf23ca-28a5-4431-aa0e-425b360ae4bd.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u2fc15dd2&margin=%5Bobject%20Object%5D&originHeight=561&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u720e32f9-1f9c-4cd3-bec7-e5cff31ee20&title=&width=394"><br><strong>最后一种情况</strong><br>左右两侧都为负数<br>如果左侧欠15件。右侧欠7件，我问你是要搬多少轮, 两侧都指望着i出力, 它一次只能扔一件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421484-2e38c5da-e2b5-44fc-b02a-0f6932eb9510.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=udc41672d&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=745&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6afbd492-5e3d-4243-ae8d-d15ddd0797d&title=&width=408"><br>先算一个总衣服的数量，你再算一个左侧部分的累加和, i位置自己有值。<br>左侧部分欠几件还多几件, 右侧部分欠几件还是多几件。都能算出来<br>有一个衣服的总数量，有一个i左侧的累加和, 接下来你到任何一个i位置。<br>你左侧, 右侧到底是多还是少？你都能算出来</p><p>根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,<br>2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。<br>因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了<br>因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421558-5fddfdda-a71d-4671-aece-dc0b34e07408.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u75e1afcf&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1024&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u550aae88-3e80-416e-bdc1-1f855da6fc1&title=&width=445"><br><strong>单点思维传统</strong><br>接雨水的问题, 左侧最大值最小值问题，这些东西都是以单点算出来一个答案，然后去决策等。<br>洗衣机问题它属于我把整个问题，我不去想它整体我就想它单点的答案是啥，你给我整出一个答案，<br>然后我去决策出来什么东西，以后单点去求然后再得到整体答案的办法，将会成为我们的一个思想传统。<br>类似子串子数组问题, 每个位置结尾时候啥答案。其实这也是<strong>单点思维。</strong><br><strong>代码</strong></p><p>| **public static int <strong>findMinMoves</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **size &#x3D; arr.<strong>length</strong>;<br>   **int **sum &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; size; i++</strong>) {<br>      <strong>sum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   **}<br>   if (<strong>sum % size !&#x3D; 0</strong>) {<br>      return **-1;<br>   **}<br>   int **avg &#x3D; sum &#x2F; size;<br>   &#x2F;&#x2F;左侧部分累加和<br>   **int **leftSum &#x3D; 0;<br>   **int **ans &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      **&#x2F;&#x2F;左侧部分剩余<br>      **int **leftRest &#x3D; leftSum - i * avg;<br>      &#x2F;&#x2F;右侧部分剩余<br>      **int **rightRest &#x3D; **(<strong>sum - leftSum - arr</strong>[<strong>i</strong>]) <strong>- <strong>(<strong>size - i - 1</strong>) *** avg;<br>      <strong>if (<strong>leftRest &lt; 0 &amp;&amp; rightRest &lt; 0</strong>) {<br>         <strong>ans &#x3D; Math.max</strong>(<strong>ans, Math.abs</strong>(<strong>leftRest</strong>) <strong>+ Math.abs</strong>(<strong>rightRest</strong>))</strong>;<br>      <strong>} else {<br>         <strong>ans &#x3D; Math.max</strong>(<strong>ans, Math.max</strong>(<strong>Math.abs</strong>(<strong>leftRest</strong>)</strong>, Math.abs</strong>(<strong>rightRest</strong>)))</strong>;<br>      <strong>}<br>      <strong>leftSum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   **}<br>   return **ans;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-缺失的第一个正数"><a href="#·-缺失的第一个正数" class="headerlink" title="· 缺失的第一个正数"></a><strong>· 缺失的第一个正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922711623-5f275d70-6ad9-4a85-b908-b754c4c08188.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=377&id=u10e943fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31833&status=done&style=none&taskId=u01469d94-35f3-4ad3-8669-3edd28f7319&title=&width=536.8" alt="image.png"><br>核心就是<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922917933-411751da-967b-4a5a-bba8-08ca6afba789.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u1d4d9e20&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81409&status=done&style=none&taskId=uea4d21e0-d3fc-4dc9-be76-12aa8351e2e&title=&width=503.2" alt="image.png"><br>分为有效区和垃圾区<br>核心</p><ul><li>如果L位置上的数 &lt;&#x3D;L跟垃圾区交换</li><li><blockquote><p>R位置的数 跟垃圾区交换</p></blockquote></li><li>等于 arr[arr[L]-1]的数也交换<br>| **public static int <strong>firstMissingPositive</strong>(int[] <strong>arr</strong>) {<br> **&#x2F;&#x2F; l是盯着的位置<br> &#x2F;&#x2F; 0 ~ L-1有效区<br> **int **L &#x3D; 0;<br> **int **R &#x3D; arr.<strong>length</strong>;<br> **while (<strong>L !&#x3D; R</strong>) {<br>**&#x2F;&#x2F;有效区向右扩<br>**if (<strong>arr</strong>[<strong>L</strong>] <strong>&#x3D;&#x3D; L + 1</strong>) {<br>   **L++;<br><strong>} else if (<strong>arr</strong>[<strong>L</strong>] <strong>&lt;&#x3D; L &amp;#124;&amp;#124; arr**[**L**] **&gt; R &amp;#124;&amp;#124; arr</strong>[<strong>arr</strong>[<strong>L</strong>] <strong>- 1</strong>] <strong>&#x3D;&#x3D; arr</strong>[<strong>L</strong>]) { <strong>&#x2F;&#x2F; 垃圾的情况<br>   swap</strong>(<strong>arr, L, –R</strong>)</strong>;<br><strong>} else {<br>   <strong>swap</strong>(<strong>arr, L, arr</strong>[<strong>L</strong>] <strong>- 1</strong>)</strong>;<br>**}<br> }<br> return **L + 1;<br>**}</li></ul><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-数组的自己不能累加和出的最小正数"><a href="#·-数组的自己不能累加和出的最小正数" class="headerlink" title="· 数组的自己不能累加和出的最小正数"></a><strong>· 数组的自己不能累加和出的最小正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649908121718-8953c38b-c4f7-47ac-ae29-35e9ffd72e37.png#clientId=u66160ce2-b06d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=99&id=u1ea6fc03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=366&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12897&status=done&style=none&taskId=u8559eaa1-8292-41bd-a5cc-ca091503438&title=&width=292.8" alt="image.png"><br><strong>第一问</strong><br>同上问<br>arr所有值的累加和从一个负数到一个整数做出一张表, 然后看最后一行<br>arr 0~N-1宿友的值能不能搞定1, 2, 3…, 哪一个最早不行的, 返回就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274512-42b3c5d7-4c34-41d1-90af-b01987c4bcf7.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=ub0253dce&margin=%5Bobject%20Object%5D&originHeight=664&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4c3059f8-c8ca-4e0e-8def-f24e2bb3715&title=&width=434"></p><p>| **public static int <strong>unformedSum2</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **1;<br>   **}<br>   int **sum &#x3D; 0;<br>   <strong>int <strong>min &#x3D; Integer.<strong>MAX_VALUE</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>sum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      min &#x3D; Math.min</strong>(<strong>min, arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   **&#x2F;&#x2F; boolean[][] dp …<br>   **int **N &#x3D; arr.<strong>length</strong>;<br>   **boolean[][] **dp &#x3D; <strong>new boolean[<strong>N</strong>][<strong>sum + 1</strong>]</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++**) {**&#x2F;&#x2F; arr[0..i] 0<br>      dp**[**i**][**0**] **&#x3D; **true**;<br>   **}<br>   **dp**[**0**][**arr**[**0**]] **&#x3D; **true**;<br>   **for (int **i &#x3D; 1; i &lt; N; i++**) {<br>      for (int **j &#x3D; 1; j &lt;&#x3D; sum; j++**) {<br>         **dp**[**i**][**j**] **&#x3D; dp**[**i - 1**][**j**] **&amp;#124;&amp;#124; **((**j - arr**[**i**] **&gt;&#x3D; 0</strong>) <strong>? dp</strong>[<strong>i - 1</strong>][<strong>j - arr</strong>[<strong>i</strong>]] <strong>: <strong>false)</strong>;<br>      <strong>}<br>   }<br>   for (int <strong>j &#x3D; min; j &lt;&#x3D; sum; j++</strong>) {<br>      if (</strong>!dp</strong>[<strong>N - 1</strong>][<strong>j</strong>]) {<br>         return **j;<br>      **}<br>   }<br>   return **sum + 1;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>第二问</strong><br>先把array排序, 正数数组排完序, 左边0位置肯定是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274407-d5bb7112-75b6-4c1a-8c5a-636c29d2da74.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=u7c7998e0&margin=%5Bobject%20Object%5D&originHeight=598&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6d443944-221f-4578-af40-df6b9538517&title=&width=428"><br>定义变量range &#x3D;1, 表示从1<del>1范围上的正数都能累加出来<br>range&#x3D;k, 代表1</del>k上的所有正数都能搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-064d2ceb-c903-444a-8b3b-def179bd1054.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=udb091615&margin=%5Bobject%20Object%5D&originHeight=627&originWidth=1208&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87640a35-779d-455c-92d7-3d66170c5b2&title=&width=451"><br>当arr 0位置是1的情况下, range&#x3D;1, 代表1<del>1范围的正数都可以搞出来<br>如果1位置也是1, range变成2, 代表1</del>2范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-3a9c1b06-df19-4cbf-a1a0-8890c1df2d33.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u4a638e7d&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uacb8b2ee-8e40-476b-b0e6-d3dd0902597&title=&width=546"><br>如果2位置也是2, range变成4, 代表1<del>4范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274433-c44f8de2-ab64-4735-a4ae-0d303eaeb2be.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=u36d33f1c&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=1218&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75c49504-7235-4203-9e18-e0efd1c066a&title=&width=500"><br>如果0</del>i-1是0~100, range&#x3D;100<br>i位置17, 可以让range扩充到117</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276639-76ea18e4-1553-4416-b729-602f169e4256.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=ud24b4420&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf800b3ae-b828-40f4-9f35-e53b5b30e59&title=&width=540"><br>注意一点<br>如果0<del>i-1能搞定的数是1</del>100, 此时i位置是102, 那么101不可以搞定<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276627-25522d30-aa31-47f1-a2c0-70754b005b35.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=ub8d18f54&margin=%5Bobject%20Object%5D&originHeight=641&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c78c50f-b4c4-4174-aeb2-65532acedc1&title=&width=484"><br><strong>抽象化</strong><br>如果0<del>i-1搞定1</del>a, 如果i位置上是b:<br>1)如果b&lt;&#x3D; a+1, 能扩充, 范围到1~a+b<br>2)如果b&gt; a+1, a+1就是搞定不了的最小正整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276617-5b986e34-cf33-4d56-a953-8b54313b7cb9.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=309&id=u561892aa&margin=%5Bobject%20Object%5D&originHeight=661&originWidth=1101&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8618d200-7b25-4c41-89a5-14bb0c7e026&title=&width=515"><br><strong>代码</strong></p><p>| **&#x2F;&#x2F; 已知arr中肯定有1这个数<br>**public static int <strong>unformedSum3</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   <strong>}<br>   <strong>Arrays.sort</strong>(<strong>arr</strong>)</strong>; &#x2F;&#x2F; O (N * logN)<br>   **int **range &#x3D; 1;<br>   &#x2F;&#x2F; arr[0] &#x3D;&#x3D; 1<br>   **for (int <strong>i &#x3D; 1; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; range + 1</strong>) {<br>         return **range + 1;<br>      <strong>} else {<br>         <strong>range +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      **}<br>   }<br>   return **range + 1;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>原题<br>arr是正数, 要求子集不能是空集, 最小子集累加和到最大子集累加和的范围中哪个数是最小不可组成的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927277249-0071ad5e-e13b-4370-bfe9-c4e82ef62414.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=202&id=u10a4ace4&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1230&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6504140f-42f0-4cdd-ab09-4e8752f37b5&title=&width=385"></p><h2 id="·-按要求补齐数组"><a href="#·-按要求补齐数组" class="headerlink" title="· 按要求补齐数组"></a>· 按要求补齐数组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649917704725-47286ee2-4581-440e-87d2-40217bdc6892.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=401&id=uafa838b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=501&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36432&status=done&style=none&taskId=u650b2498-cf20-4fe1-bdde-0a59049f6aa&title=&width=656.8" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555620-061a554b-82b5-41e0-9e92-a690ce40510d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=ud98747b1&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=1248&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc3bcf646-19ce-4700-8f4a-bd401665f44&title=&width=389"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555641-e30d7e5e-1c75-4f52-a033-af5aee074d54.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u7ba03d88&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=1240&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a3bc28c-d3a2-4b58-ba9a-de9d7ca6744&title=&width=477"><br>到达数字+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555680-c1d3ccf6-3771-4e93-96b8-39c885a5a4bf.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=211&id=ub2e23613&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc2cbb657-a0c0-4d31-afee-d802e35c8fe&title=&width=417"><br><strong>题解</strong><br>先把数组排序<br>数组中每个数最经济的使用<br>只能是 1<del>3 范围，你先都搞定之后，你舒舒服服，使用这个4，就能扩到1</del>7了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555600-28054282-00a3-4ada-b588-8c83daa1343d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u36009711&margin=%5Bobject%20Object%5D&originHeight=414&originWidth=1355&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c1ace8f-dc3d-4e30-aa37-c80e0af525c&title=&width=540"><br>给自己提了小目标，这个小目标是搞定1<del>3 范围上，你缺几个数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555576-2c52f0c4-a3ee-4fe0-99fd-d5ad4194db98.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=u2bb70482&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1326&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u30cd7616-6530-4109-9843-187a632bcd8&title=&width=539"><br>对于5, 小目标1</del>4范围上都可以搞定, 已经满足了<br>可以直接使用这个5，让它变成12，不用添任何数字</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559417-d4b87abf-d387-42d2-8d80-4a0a8ec4f0c4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u32d93753&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=1317&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u127e139e-6b60-4227-ad19-1e323514d0d&title=&width=521"><br>想使用17, 要求目标1<del>16必须具备<br>目前有1</del>12, 缺13, 补13之后范围扩到1~25<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559808-215561a1-ff63-415f-bf78-fad7b73a64ba.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=uea5b1f49&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1322&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2cc09c61-ee32-4302-b314-4ba0be0fea5&title=&width=507"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927560402-d3d539ae-2061-402e-8409-47fe164264a2.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=227&id=u09c809c8&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1338&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7877baab-db60-4c74-96b5-33a014c76fd&title=&width=491"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561057-82a9fd44-9823-4f41-858c-acdcdc07147b.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u1757f08b&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1340&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucad0fd2b-6999-4754-89cb-2a2fdc5f0e0&title=&width=468"><br><strong>例子</strong><br>如果n特别大, 整个数组都使用完以后范围是1~3050, 先补3051<br>整个数组都使完之后，如果你还没到，接下来的过程就等同于给了你一个范围，你一个数也没有了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561285-f47b7093-d077-49ef-9d8a-40af2438e4b0.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u48355d80&margin=%5Bobject%20Object%5D&originHeight=587&originWidth=1165&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25fd03f5-cf32-4ea9-b5a2-10523fc59b6&title=&width=399"><br>注意点<br>只要范围扩充了，我就盯着总目标有没有实现，我不一定要使用完所有数字，我可能已经提前搞定考了，<br>我缺了多少数字，如果发现我range已经到它了，直接返回就可以了，不用看后面的数字<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927562331-6d5e0b3b-b786-468c-a940-7c5b9ed70aa2.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=u84594179&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1341&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d649c1a-e5d8-43f0-87e0-47de55d83b7&title=&width=510"></p><p>| &#x2F;&#x2F; arr请保证有序，且正数  1~aim<br>**public static int <strong>minPatches</strong>(int[] **arr, **int <strong>aim</strong>) {<br>   int **patches &#x3D; 0; &#x2F;&#x2F; 缺多少个数字<br>   <strong>long <strong>range &#x3D; 0; &#x2F;&#x2F; 已经完成了1 ~ range的目标<br>   Arrays.sort</strong>(<strong>arr</strong>)</strong>;<br>   **for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      **&#x2F;&#x2F; arr[i]<br>      &#x2F;&#x2F; 要求：1 ~ arr[i]-1 范围被搞定！<br>      **while (<strong>arr</strong>[<strong>i</strong>] <strong>- 1 &gt; range</strong>) { **&#x2F;&#x2F; arr[i] 1 ~ arr[i]-1<br>         range +&#x3D; (range + 1); &#x2F;&#x2F; range + 1 是缺的数字<br>         patches++;<br>         &#x2F;&#x2F;只要范围一变化就盯着目标<br>         **if (<strong>range &gt;&#x3D; aim</strong>) {<br>            return **patches;<br>         <strong>}<br>      }<br>      <strong>&#x2F;&#x2F; 要求被满足了！<br>      range +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      **if (<strong>range &gt;&#x3D; aim</strong>) {<br>         return **patches;<br>      **}<br>   }<br>   while (<strong>aim &gt;&#x3D; range + 1</strong>) {<br>      **range +&#x3D; range + 1;<br>      patches++;<br>   **}<br>   return **patches;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="x2F-x2F-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x2F-x2F-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><h2 id="·-240-行列递增矩阵的查找-搜索二维矩阵-II-M"><a href="#·-240-行列递增矩阵的查找-搜索二维矩阵-II-M" class="headerlink" title="· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]"></a>· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538431656-6b591c24-62b5-4f4d-a992-0e2ee6455b85.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=ucaa40dd5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11740&status=done&style=none&taskId=u76050ce0-5216-4663-83e4-b58fdd5ced0&title=&width=439.2" alt="image.png"><br><strong>题意</strong><br>让你找某一个数字在其中是否存在<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537626124-5e69971c-798a-4382-a6c0-56062f07a154.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u825d9625&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=642&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u938e2c19-6aff-4589-84b0-79641bb03ae&title=&width=348"><br><strong>题解</strong><br>经典解法:<br>从右上角开始找<br>复杂度O(N+M)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624515-057e50f5-c481-4b0a-8091-003f019142d4.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u86a3eab4&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1257&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufda2a2e9-c766-4bc5-9780-98846953c45&title=&width=553"><br>从左下角走</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624507-9f4bca2b-fa51-4bd1-ae0a-cc127e634a97.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=ubf5cba53&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0f5c24b9-5e75-475b-96da-fcd5f286991&title=&width=515"></p><p>| **public static boolean <strong>isContains</strong>(int[][] **matrix, **int <strong>K</strong>) {<br>   int **row &#x3D; 0;<br>   <strong>int <strong>col &#x3D; matrix</strong>[<strong>0</strong>]</strong>.**length **- 1;<br>   <strong>while (<strong>row &lt; matrix.**length **&amp;&amp; col &gt; -1</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&#x3D;&#x3D; K</strong>) {<br>         return true</strong>;<br>      **} else if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&gt; K</strong>) {<br>         **col–;<br>      **} else {<br>         **row++;<br>      <strong>}<br>   }<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊378-行列递增矩阵中的第K小-M"><a href="#·-✊378-行列递增矩阵中的第K小-M" class="headerlink" title="· ✊378.行列递增矩阵中的第K小 [M]"></a>· ✊378.行列递增矩阵中的第K小 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538447469-55d93518-20af-4ac9-bb0d-cc650b505a39.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=75&id=ue2220b92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=94&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12027&status=done&style=none&taskId=u7642227d-241c-4306-8adb-3d21d1474a6&title=&width=434.4" alt="image.png"><br><strong>最优解</strong><br>给定一个目标, 想知道&lt;&#x3D;100的数有几个, 怎么快能求出来?<br>往左走, 获得0个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464907-2dead8bf-8612-4941-8c80-3b22ba09131b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u2e5cfef4&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=1302&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua5722571-1037-41c0-a18e-d6fb6cb934b&title=&width=427"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464900-3f1bafb2-1bae-4cdb-8c53-cc846c69f134.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u4704966e&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1269&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4d022a33-b6ba-45b1-8229-acd68f70a81&title=&width=500"><br>就这样一直卡到结束，你正确的获得整个数组中有多少个数&lt;&#x3D;100<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464925-50973775-2761-4ed9-8cd5-5337041bf338.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=ua11d3edf&margin=%5Bobject%20Object%5D&originHeight=636&originWidth=1279&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueff346fb-ab57-4bd5-9a3e-3880b1e4b7b&title=&width=534"><br>**例子**<br>&lt;&#x3D;100的有几个, 同时也可以知道最接近100的是啥数?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464932-49c9b5d2-a01d-4a5c-8975-50303fa6a936.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u56983f42&margin=%5Bobject%20Object%5D&originHeight=588&originWidth=1296&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u67098799-26c6-4f3c-8175-19f94ecb673&title=&width=521"><br>120&gt;100获得0个</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464930-de301eda-d2b0-440b-b938-1bc52130534e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=u2cdb7407&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1311&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b4b31cf-26dc-496f-8390-87189a86c68&title=&width=411"><br>100&gt;90 假设90所在的列是col<br>获得的个数是rol+1<br>同时更新接近100的数字为90</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465650-44206736-0a80-4be1-b524-3e42d7c92086.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u653e1491&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=1304&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uefd5909b-1438-4e68-8c39-07bb5605a84&title=&width=549"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465710-67505b3a-0cc8-4c66-b908-40ff88ecab43.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u66d628df&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufefde839-ee65-4893-88e1-ff39a92a975&title=&width=431"><br>解决原问题<br><strong>二分</strong><br>整个数组中最小的是谁？左上角的数<br>那整个数组中，最大的数是谁？右下角的数<br>第一百小的数一定在一到1000之间, 看看&lt;&#x3D;500的数有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465810-e8be4f70-42f7-4fa5-b7a0-c81514b2ff5d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=256&id=u9bcf7146&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1219&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u479e614c-408d-4eb6-9c84-94373d1aa27&title=&width=521"><br>如果&lt;&#x3D;500有200个, 目标大了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465999-a6e86772-a3ac-4585-a06c-2081f5cdd43e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=284&id=uddbef8b1&margin=%5Bobject%20Object%5D&originHeight=650&originWidth=1265&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u361c54da-f6cb-48a8-9aaf-db96a0a03c1&title=&width=553"><br>有可能最后得到&lt;&#x3D;785的数有100个, 但是数组中没有这个数, 应该是&lt;&#x3D;785并离它最近<br>的数<br>我每次让你过的时候求俩信息，</p><ul><li>第一小于等于某一个值个数有几个</li><li>第二，最接近它的是谁？</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466133-869c69d6-fbbd-4e08-b85f-e7affbbdba50.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=u32fd171a&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1263&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf7b5a0ae-78a1-4110-90ef-898624a9d91&title=&width=560"><br><strong>复杂度</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466525-0b2fee08-0f44-4e91-b063-3992ab4853f0.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=268&id=ucbc9934f&margin=%5Bobject%20Object%5D&originHeight=659&originWidth=1263&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua58a75d8-03db-4569-b937-1af685bff8d&title=&width=513"><br><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466467-9e5f348e-c41d-4268-9b00-b0c0e20be6de.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u762a2f31&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1285&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8fa0287d-25c4-48b9-a7cf-aa1e3e128a1&title=&width=516"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466606-1c01a2b3-8288-4f63-a32f-5ef20107ec9d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=ua6082d71&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=912&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1827838a-ed61-4d55-b0e4-80808063065&title=&width=564"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466819-f599b5d1-bfaf-409d-9a8b-05f51b31ee1a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u7c9fce28&margin=%5Bobject%20Object%5D&originHeight=671&originWidth=1356&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u150b1272-8545-4d16-8622-d69dad22697&title=&width=544"><br><strong>代码</strong></p><p>| &#x2F;&#x2F; 二分的方法<br>**public static int <strong>kthSmallest2</strong>(int[][] **matrix, **int <strong>k</strong>) {<br>   int **N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   <strong>int <strong>left &#x3D; matrix</strong>[<strong>0</strong>][<strong>0</strong>]</strong>;<br>   <strong>int <strong>right &#x3D; matrix</strong>[<strong>N - 1</strong>][<strong>M - 1</strong>]</strong>;<br>   <strong>int <strong>ans &#x3D; 0;<br>   <strong>while (<strong>left &lt;&#x3D; right**) {<br>      int **mid &#x3D; left + **((**right - left**) **&gt;&gt; 1</strong>)</strong>;<br>      &#x2F;&#x2F; &lt;&#x3D;mid 有几个 &lt;&#x3D; mid 在矩阵中真实出现的数，谁最接近mid<br>      Info info &#x3D; noMoreNum</strong>(<strong>matrix, mid</strong>)</strong>;<br>      **if (**info.**num <strong>&lt; k</strong>) {<br>         **left &#x3D; mid + 1;<br>      **} else {<br>         **&#x2F;&#x2F;这里就是有可能&lt;&#x3D;785的数有100个，但是数组中没有这个数，所以要记录与他最接近的<br>         ans &#x3D; info.<strong>near</strong>;<br>         right &#x3D; mid - 1;<br>      **}<br>   }<br>   return **ans;<br>**}</p><p>public static class **Info <strong>{<br>   public int near</strong>;<br>   <strong>public int num</strong>;</p><p>   **public <strong>Info</strong>(int **n1, **int <strong>n2</strong>) {<br>      near **&#x3D; n1;<br>      **num **&#x3D; n2;<br>   **}<br>}</p><p>public static <strong>Info noMoreNum</strong>(int[][] **matrix, **int <strong>value</strong>) {<br>   int **near &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **int **num &#x3D; 0;<br>   **int **N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **row &#x3D; 0;<br>   **int **col &#x3D; M - 1;<br>   <strong>while (<strong>row &lt; N &amp;&amp; col &gt;&#x3D; 0</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&lt;&#x3D; value</strong>) {<br>         <strong>near &#x3D; Math.max</strong>(<strong>near, matrix</strong>[<strong>row</strong>][<strong>col</strong>])</strong>;<br>         num +&#x3D; col + 1;<br>         row++;<br>      **} else {<br>         **col–;<br>      <strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>near, num</strong>)</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>| &#x2F;&#x2F; 堆的方法<br><strong>public static int <strong>kthSmallest1</strong>(int[][] <strong>matrix, <strong>int <strong>k</strong>) {<br>   int <strong>N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   PriorityQueue</strong>&lt;**Node**&gt; <strong>heap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;(new <strong>NodeComparator</strong>())</strong>;<br>   <strong>boolean[][] <strong>set &#x3D; <strong>new boolean[<strong>N</strong>][<strong>M</strong>]</strong>;<br>   heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>0</strong>][<strong>0</strong>]</strong>, 0, 0</strong>))</strong>;<br>   set</strong>[<strong>0</strong>][<strong>0</strong>] <strong>&#x3D; <strong>true</strong>;<br>   <strong>int <strong>count &#x3D; 0;<br>   Node ans &#x3D; <strong>null</strong>;<br>   <strong>while (</strong>!heap.isEmpty</strong>()) {<br>      <strong>ans &#x3D; heap.poll</strong>()</strong>;<br>      <strong>if (</strong>++count &#x3D;&#x3D; k</strong>) {<br>         break</strong>;<br>      <strong>}<br>      int <strong>row &#x3D; ans.<strong>row</strong>;<br>      <strong>int <strong>col &#x3D; ans.<strong>col</strong>;<br>      <strong>if (<strong>row + 1 &lt; N &amp;&amp; !set</strong>[<strong>row + 1</strong>][<strong>col</strong>]) {<br>         <strong>heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>row + 1</strong>][<strong>col</strong>]</strong>, row + 1, col</strong>))</strong>;<br>         set</strong>[<strong>row + 1</strong>][<strong>col</strong>] <strong>&#x3D; <strong>true</strong>;<br>      <strong>}<br>      if (<strong>col + 1 &lt; M &amp;&amp; !set</strong>[<strong>row</strong>][<strong>col + 1</strong>]) {<br>         <strong>heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>row</strong>][<strong>col + 1</strong>]</strong>, row, col + 1</strong>))</strong>;<br>         set**[<strong>row</strong>][<strong>col + 1</strong>] **&#x3D; <strong>true</strong>;<br>      **}<br>   }<br>   return **ans.<strong>value</strong>;<br>**}</p><p>public static class **Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   **public <strong>Node</strong>(int **v, **int **r, **int <strong>c</strong>) {<br>      value **&#x3D; v;<br>      **row **&#x3D; r;<br>      **col **&#x3D; c;<br>   **}</p><p>}</p><p>public static class **NodeComparator **implements <strong>Comparator</strong>&lt;**Node**&gt; {</p><p>   **@Override<br>   **public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return **o1.**value **- o2.<strong>value</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><h2 id="·-940-不同的子序列-II-H"><a href="#·-940-不同的子序列-II-H" class="headerlink" title="· 940.不同的子序列 II [H]"></a>· 940.不同的子序列 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538612708-fda8d9fb-bb27-4677-8080-a6c88db86f79.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=u64377b4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=412&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24324&status=done&style=none&taskId=ub9741443-896e-42ce-8c56-8a848253493&title=&width=529.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-ffb30de6-f89e-4cc2-97f9-f689fa201501.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=u1fea0879&margin=%5Bobject%20Object%5D&originHeight=587&originWidth=1215&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u55df378d-a803-40de-a808-0dedf0ccfe0&title=&width=458"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-f0b61739-d00f-48b6-998c-26a3711ea3bf.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u1df3788a&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1042&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4f9cf5bd-ef8b-440e-8b26-ba037940ecf&title=&width=429"><br><strong>题解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655384932788-bf089bd0-c6f2-473c-a397-a313422b8837.png#clientId=u782dedcd-cafb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1810&id=ua0fa29c9&margin=%5Bobject%20Object%5D&name=779E39B64BA9EC69E5A1C515E4200530.png&originHeight=3168&originWidth=1424&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1164522&status=done&style=none&taskId=udfa184cd-8bbd-4169-93f5-29e4850f4c6&title=&width=813.7142857142857" alt="779E39B64BA9EC69E5A1C515E4200530.png"><br>模操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538826795-e3410ba0-a512-485d-951d-69bb5cb981a6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9b1dd3e0&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=755&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u811d823a-3961-4f75-b8f3-4b6d6da427b&title="></p><p>| **public static int <strong>zuo1</strong>(<strong>String s</strong>) {<br>      if (**s &#x3D;&#x3D; **null <strong>&amp;#124;&amp;#124; s.length</strong>() <strong>&#x3D;&#x3D; 0</strong>) {<br>         return **0;<br>      **}<br>      int <strong>m &#x3D; 1000000007;<br>      <strong>char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>      HashMap</strong>&lt;**Character, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>      **int **all &#x3D; 1; &#x2F;&#x2F; 一个字符也没遍历的时候，有空集<br>      **for (char <strong>x : str</strong>) {<br>         **&#x2F;&#x2F;新加出来的玩意儿就是以什么结尾的数量<br>         **int **newAdd &#x3D; all;<br>         <strong>int <strong>curAll &#x3D; all + newAdd - <strong>(<strong>map.containsKey</strong>(<strong>x</strong>) <strong>? map.get</strong>(<strong>x</strong>) <strong>: 0</strong>)</strong>;<br>         all &#x3D; curAll;<br>         map.put</strong>(<strong>x, newAdd</strong>)</strong>;<br>      **}<br>      return **all;<br>   **}<br>   public static int <strong>zuo</strong>(<strong>String s</strong>) {<br>      if (**s &#x3D;&#x3D; **null <strong>&amp;#124;&amp;#124; s.length</strong>() <strong>&#x3D;&#x3D; 0</strong>) {<br>         return **0;<br>      **}<br>      int <strong>m &#x3D; 1000000007;<br>      <strong>char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>      HashMap</strong>&lt;**Character, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>      **int **all &#x3D; 1; &#x2F;&#x2F; 一个字符也没遍历的时候，有空集<br>      **for (char <strong>x : str</strong>) {<br>         int **newAdd &#x3D; all;<br>&#x2F;&#x2F;       int curAll &#x3D; all + newAdd - (map.containsKey(x) ? map.get(x) : 0);<br>         **int **curAll &#x3D; all;<br>         curAll &#x3D; **(<strong>curAll + newAdd</strong>) **% m;<br>         &#x2F;&#x2F;减完可能为负数，所以要先加<br>         curAll &#x3D; **(**curAll - <strong>(<strong>map.containsKey</strong>(<strong>x</strong>) <strong>? map.get</strong>(<strong>x</strong>) <strong>: 0</strong>) <strong>+ m</strong>) <strong>% m;<br>         all &#x3D; curAll;<br>         map.put</strong>(<strong>x, newAdd</strong>)</strong>;<br>      **}<br>      return **all;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-汉诺塔游戏中的最优状态"><a href="#·-汉诺塔游戏中的最优状态" class="headerlink" title="· 汉诺塔游戏中的最优状态"></a>· 汉诺塔游戏中的最优状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539211568-a1dd0839-322f-4a09-8fbb-4427209b059d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=u5e9bcd3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40554&status=done&style=none&taskId=u75553f41-4211-4e03-b1c3-af09e2d344e&title=&width=489.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187846-f70f3d8f-0157-43bd-b853-e65f7208f8ce.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=ua14962a4&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1280&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u50a5c929-49c5-44bd-bc95-307b8dadc4c&title=&width=585"><br>7层汉诺塔问题的一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187621-d66d9436-5fa6-4b96-8665-50fa8b081a64.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=uc20ed9ff&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1260&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1831e6fb-2ea6-4897-b345-95c2d0e887b&title=&width=559"><br>最优解的第一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187608-84fce00e-ce50-476f-8097-9a88be815ab3.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=188&id=u606020c1&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=1323&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udc765580-8b82-4da7-9d75-d59459d93e9&title=&width=666"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187793-ebb720d3-d2df-44dd-b600-10e2915349d5.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=ue283094b&margin=%5Bobject%20Object%5D&originHeight=633&originWidth=1368&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub9dc08a9-ad4f-48c3-9036-b1723d5d890&title=&width=595"><br><strong>题解</strong><br>复杂度 O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187754-902ce282-eb4d-4ffa-b9f2-08d5bb24a1ca.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=ueee15b1a&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5fe3be44-3808-4c07-a651-80f9cb66498&title=&width=523"><br>先忘掉左中右, 目标是逐渐分解的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281818-8f55bc3d-600b-4fe1-9a28-194a2e14b313.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=uc72a3d6d&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1309&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9972a330-30f9-4bb4-b8c7-08fe6f74d00&title=&width=560"><br><strong>抽象</strong><br>i: 1<del>i的圆盘需要移动<br>F: 1</del>i的圆盘现在处在什么圆盘上, 可能是左, 中, 右<br>t: 需要去的位置, 可能是左, 中, 右<br>other: 除了from, to的另外一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281875-9d349353-6eed-4b5a-9c10-e6e7433d67c4.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=ua78ed761&margin=%5Bobject%20Object%5D&originHeight=633&originWidth=1251&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued654e3c-92fc-4ef3-a314-9c63cc17362&title=&width=574"><br><strong>代码</strong><br>i层的圆盘没有任何道理是在other上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358889-bf247fdd-e580-4abd-8d24-c40995fab0f6.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=316&id=u5e1ef882&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1171&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d288535-fb85-41b3-98d3-2cf5fb5d4b2&title=&width=591"><br>如果index还在From上, 说明第一大步没走完<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358848-516f2145-a3f9-46ba-81c9-e9ce28edee97.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=293&id=u07d3b69a&margin=%5Bobject%20Object%5D&originHeight=651&originWidth=1255&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u48e1996c-d742-490a-96d7-66c6462a3a3&title=&width=565"><br><strong>n层汉诺塔最优解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358910-0c4cbbd5-0292-44fe-b9d6-b53981389b71.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=ua0d8af67&margin=%5Bobject%20Object%5D&originHeight=654&originWidth=879&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d18edcc-fa98-42fc-8d83-170aa0206d6&title=&width=386"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028378401-1aa4cb61-81e0-4606-934e-dbf7cd028030.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u5785399a&margin=%5Bobject%20Object%5D&originHeight=612&originWidth=1203&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uea4922b0-8da4-4a95-abb3-8986b68ee4c&title=&width=491"><br>后续有任何一点点无效，你整体就无效</p><p>| **public static int <strong>kth</strong>(int[] <strong>arr</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>return <strong>step</strong>(<strong>arr, N - 1, 1, 3, 2</strong>)</strong>;<br>**}</p><p>**&#x2F;&#x2F; 0…index这些圆盘，arr[0..index] index+1层塔<br>&#x2F;&#x2F; 在哪？from 去哪？to 另一个是啥？other<br>&#x2F;&#x2F; arr[0..index]这些状态，是index+1层汉诺塔问题的，最优解第几步<br>**public static int <strong>step</strong>(int[] **arr, **int **index, **int **from, **int **to, **int <strong>other</strong>) {<br>   if (<strong>index &#x3D;&#x3D; -1</strong>) {<br>      return **0;<br>   **}<br>   if (<strong>arr</strong>[<strong>index</strong>] <strong>&#x3D;&#x3D; other</strong>) {<br>      return **-1;<br>   **}<br>   **&#x2F;**多想想就明白了<br>    * 比如 arr[3,2,1] 三层汉诺塔问题<br>    *<br>    * 第一个在to区<br>    * 第二个在<br>    *<br>    *&#x2F;<br>   &#x2F;&#x2F; arr[index] &#x3D;&#x3D; from arr[index] &#x3D;&#x3D; to;<br>   <strong>if (<strong>arr</strong>[<strong>index</strong>] <strong>&#x3D;&#x3D; from</strong>) {<br>      return <strong>step</strong>(<strong>arr, index - 1, from, other, to</strong>)</strong>;<br>   **} else {<br>      int **p1 &#x3D; **(<strong>1 &lt;&lt; index</strong>) **- 1;<br>      **int **p2 &#x3D; 1;<br>      <strong>int <strong>p3 &#x3D; step</strong>(<strong>arr, index - 1, other, to, from</strong>)</strong>;<br>      **if (<strong>p3 &#x3D;&#x3D; -1</strong>) {<br>         return **-1;<br>      **}<br>      return **p1 + p2 + p3;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><p><strong>复杂度</strong><br>单决策递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028426636-08060a50-74cc-4c62-8e62-424f512cf88c.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=338&id=u443ec777&margin=%5Bobject%20Object%5D&originHeight=634&originWidth=943&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u203f3cdf-b1ab-456b-b0c3-d0034313049&title=&width=502"></p><h2 id="·-两个有序数组间相加和的Topk问题"><a href="#·-两个有序数组间相加和的Topk问题" class="headerlink" title="· 两个有序数组间相加和的Topk问题"></a>· 两个有序数组间相加和的Topk问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539251891-3de0d850-c8d0-4239-a81d-fa1a2210426c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=ue5640a4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43271&status=done&style=none&taskId=u6feb9167-120c-415a-b74d-95ac0e48b98&title=&width=664" alt="image.png"><br>用大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031978240-dce8b855-e997-478e-933a-aab5c7268225.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=u92e50c4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82696&status=done&style=none&taskId=ue0cf5ae5-f712-4140-aac0-9aa695e0286&title=&width=456.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031989072-10c19f0a-4015-407a-8fb7-176cef820206.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u9583c67c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90083&status=done&style=none&taskId=ufffa987b-c980-44a0-89a3-38926c6b62d&title=&width=478.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032000117-c9d348c8-6b94-4a91-a50e-1a47217c9b57.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u80c59775&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119662&status=done&style=none&taskId=udb562210-be25-49bb-981b-b2ccf26efe2&title=&width=516.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032013255-95030714-b09e-4f25-a865-2758167fb7b1.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u49edc7c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=649&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146468&status=done&style=none&taskId=u5745c217-4dbe-4db4-b967-7cfbd0548ac&title=&width=519.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032038337-4b6eddac-52e2-40b0-ac4f-694be2af4927.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u7efe8179&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145293&status=done&style=none&taskId=uc4397788-c306-4e30-b954-1c34575127e&title=&width=510.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032058547-5ce5c648-4d2f-4c69-a0ca-51424b5f5c83.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=uec145c06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=317&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38852&status=done&style=none&taskId=uee16e7db-0793-4ade-bcf7-ae43094fe60&title=&width=420" alt="image.png"></p><p>| &#x2F;&#x2F; 放入大根堆中的结构<br>**public static class **Node <strong>{<br>   public int index1</strong>;&#x2F;&#x2F; arr1中的位置<br>   <strong>public int index2</strong>;&#x2F;&#x2F; arr2中的位置<br>   <strong>public int sum</strong>;&#x2F;&#x2F; arr1[index1] + arr2[index2]的值</p><p>   **public <strong>Node</strong>(int **i1, **int **i2, **int <strong>s</strong>) {<br>      index1 **&#x3D; i1;<br>      **index2 **&#x3D; i2;<br>      **sum **&#x3D; s;<br>   **}<br>}</p><p>**&#x2F;&#x2F; 生成大根堆的比较器<br>**public static class **MaxHeapComp **implements <strong>Comparator</strong>&lt;**Node**&gt; {<br>   **@Override<br>   **public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return **o2.**sum **- o1.<strong>sum</strong>;<br>   **}<br>}</p><p>public static int[] <strong>topKSum</strong>(int[] **arr1, **int[] **arr2, **int <strong>topK</strong>) {<br>   if (**arr1 &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr2 &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; topK &lt; 1</strong>) {<br>      return null</strong>;<br>   **}<br>   int **N &#x3D; arr1.<strong>length</strong>;<br>   **int **M &#x3D; arr2.<strong>length</strong>;</p><p>   topK &#x3D; Math.min**(<strong>topK, N * M</strong>)**;</p><p>   **int[] **res &#x3D; <strong>new int[<strong>topK</strong>]</strong>;<br>   **int **resIndex &#x3D; 0;</p><p>   PriorityQueue**&lt;<strong>Node**&gt; <strong>maxHeap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;(new <strong>MaxHeapComp</strong>())</strong>;<br>   HashSet</strong>&lt;**Long**&gt; <strong>set &#x3D; <strong>new <strong>HashSet</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>i1 &#x3D; N - 1;<br>   <strong>int <strong>i2 &#x3D; M - 1;<br>   maxHeap.add</strong>(new <strong>Node</strong>(<strong>i1, i2, arr1</strong>[<strong>i1</strong>] <strong>+ arr2</strong>[<strong>i2</strong>]))</strong>;<br>   set.add</strong>(<strong>x</strong>(<strong>i1, i2, M</strong>))</strong>;&#x2F;&#x2F;二维变一维<br>   <strong>while (<strong>resIndex !&#x3D; topK</strong>) {<br>      <strong>Node curNode &#x3D; maxHeap.poll</strong>()</strong>;<br>      res</strong>[<strong>resIndex++</strong>] <strong>&#x3D; curNode.<strong>sum</strong>;<br>      i1 &#x3D; curNode.<strong>index1</strong>;<br>      i2 &#x3D; curNode.<strong>index2</strong>;<br>      set.remove</strong>(<strong>x</strong>(<strong>i1, i2, M</strong>))</strong>;<br>      <strong>if (<strong>i1 - 1 &gt;&#x3D; 0 &amp;&amp; !set.contains</strong>(<strong>x</strong>(<strong>i1 - 1, i2, M</strong>))) {<br>         <strong>set.add</strong>(<strong>x</strong>(<strong>i1 - 1, i2, M</strong>))</strong>;<br>         maxHeap.add**(new <strong>Node</strong>(<strong>i1 - 1, i2, arr1</strong>[<strong>i1 - 1</strong>] <strong>+ arr2</strong>[<strong>i2</strong>]))<strong>;<br>      <strong>}<br>      if (<strong>i2 - 1 &gt;&#x3D; 0 &amp;&amp; !set.contains</strong>(<strong>x</strong>(<strong>i1, i2 - 1, M</strong>))) {<br>         <strong>set.add</strong>(<strong>x</strong>(<strong>i1, i2 - 1, M</strong>))</strong>;<br>         maxHeap.add</strong>(new <strong>Node</strong>(<strong>i1, i2 - 1, arr1</strong>[<strong>i1</strong>] <strong>+ arr2</strong>[<strong>i2 - 1</strong>]))**;<br>      **}<br>   }<br>   return **res;<br>**}</p><p>public static long <strong>x</strong>(int **i1, **int **i2, **int <strong>M</strong>) {<br>   return (long) **i1 * **(long) **M + **(long) **i2;<br>**}</p><table><thead><tr><th>**</th></tr></thead></table><h2 id="·-42-接雨水-H"><a href="#·-42-接雨水-H" class="headerlink" title="· 42. 接雨水 [H]"></a>· 42. 接雨水 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267273178-987b1982-ef81-4324-8306-8f79b8e3d6ff.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=353&id=u9a387aaa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33271&status=done&style=none&taskId=u7e5d0662-374f-45a2-926d-fe2e07cee61&title=&width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653183809624-bfe54faa-fc8e-4c66-a37c-99bf00c7ccb2.png#clientId=u9486b31d-676a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=uc43d2755&margin=%5Bobject%20Object%5D&name=image.png&originHeight=359&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17507&status=done&style=none&taskId=u90fb9776-20c1-498f-95f0-ab5a02da7b7&title=&width=724" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323108-3482efdf-9617-4893-953d-ccef84395862.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uf94fe60c&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=855&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue2587b40-59ad-4b39-8b70-6184ba23117&title=&width=490"><br><strong>题解</strong><br>跟踪坡峰坡谷的Coding解法不正确<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323100-9d08de8c-b1e3-4f1d-9d28-813b0490efef.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=u98c83e06&margin=%5Bobject%20Object%5D&originHeight=366&originWidth=986&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c3e4756-b5a8-4817-8a39-e247925cb50&title=&width=578"><br>i位置自己整个位置上方有几格水?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323023-37d28c90-8cf6-460d-96e9-9cf07801d95d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=298&id=u691728f9&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=984&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5e997542-0ba1-4e3b-9bf7-b430884218a&title=&width=614"><br>边界情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323022-bf49b7ca-7a22-499d-89e4-9ba96be952dc.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u185b9d89&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=681&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1a037bb2-07a4-406b-b36a-a860e287ed7&title=&width=545"><br>i位置的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268325675-aeb3f9d1-c2fd-4218-89f5-368d9ac0bf4f.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ua64db485&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4474289a-e974-4f64-822b-7bed7e7cc27&title=&width=506"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326254-52267b69-79ad-4bf9-9fa8-cd8d26a94a8d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=292&id=u4434b4f8&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=962&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5338f041-b732-47d3-b061-8a59c39d9b4&title=&width=587"><br><strong>辅助数组</strong><br>需要0<del>i范围上的最大值max<br>i</del>N-1范围上的最大值max<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326340-b8cc0df3-73c2-4d4e-a267-dbe509ac09a4.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=u3182ff51&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=710&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e3ff214-4949-458e-a458-e98f1d2275a&title=&width=540"><br><strong>最优解</strong><br>不需要辅助数组<br>0位置最左 20位置最右是不可能留下水的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326487-100d9b8f-7d1c-416f-9c3f-d57fed517bdc.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue35ef49f&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f3ada90-3915-4cab-ae55-b2018430e01&title="><br>19位置的最大高度假设6, 要结算算水量<br>需要求6的左边, 右边部分的max, 以13做瓶颈,<br>因为6它的左边这么多最大值还没看过，但它的最大值是17，恐怕它真实的左边最大值是大于17的。<br>而我右边的最大值，这可是个真实最大值, 所以6位置的水量就是13-6 &#x3D; 7 格子水<br>左边跟右边max谁小就先结算那边的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326627-e696ef0d-bcf9-4c31-b14d-f8340253c3b2.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=278&id=uac262f4d&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=1063&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uecb45efd-f557-48a5-b00f-d7bd73562f1&title=&width=635"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327142-fa9a9589-71a6-4d59-aa66-b7c33cee30c5.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4c693001&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2adf84f1-1a9b-4fe1-b0a8-886ae13e2cf&title=&width=564"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327723-c5a819e2-e219-4a73-a4fb-5d3e37bc01c7.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u59b410f0&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1074&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u401cfdd3-d2fd-4b7e-9f90-aa11bcb92b4&title=&width=568"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327914-13401c07-43a7-45f0-b9fb-be52bf672963.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u0fcb1059&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u33092d65-5421-468c-961f-251f018357f&title=&width=562"><br>相等怎么办<br>可以一起结算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328197-0ef67c95-b205-4b96-bb3b-4861e493c575.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=197&id=u58c81a8a&margin=%5Bobject%20Object%5D&originHeight=340&originWidth=1038&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d5765fc-e857-484a-bb9b-b63c2ef9a07&title=&width=602"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328220-048d534c-040c-4157-851b-81ffab6e636e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ub7259426&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=1024&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud895d562-3d89-4df9-973d-e6e4a3153f3&title=&width=557"><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328354-f6461e69-c9fc-464e-b55d-98e8f7a989f6.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2f50eac9&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=433&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufd62e68c-e8d6-4953-ae67-65811a0750c&title="></p><h2 id="·-✊407-接雨水-II-H"><a href="#·-✊407-接雨水-II-H" class="headerlink" title="· ✊407. 接雨水 II [H]"></a>· ✊407. 接雨水 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267310891-9ae51e62-eb36-4c3d-aecf-42757c8bc9da.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=424&id=u4348eeb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=921&originalType=binary&ratio=1&rotation=0&showTitle=false&size=167029&status=done&style=none&taskId=u12c089cc-f48c-4fe5-b32a-f49a6ad36f5&title=&width=616.7999877929688" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567058-f79a7202-de25-40fb-a9e7-36ee14452e6c.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uf198170f&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=835&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc30f9554-6db3-457f-b0f2-32d091524b1&title=&width=489"><br><strong>题解</strong><br>这一圈的值放到小根堆去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566883-18c6b4b4-30c6-4a82-a82a-59b43835a5db.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=u3d5807f8&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=806&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u427cc3c0-49d7-4081-aa59-7229fad2c68&title=&width=542"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566896-0282f120-5392-4308-9d6e-ecdfee83e80e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=u9d229db5&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=1004&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u218c752a-31e6-48f8-919c-307b08a911f&title=&width=595"><br>都会以max做为瓶颈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567083-2497db05-4afd-4681-82b4-112847d15636.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=316&id=u799526e3&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=957&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc83a1690-d0de-4210-95ad-eb1fbc9439e&title=&width=608"><br>只要max不更新, 都是max的内湖区域<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566876-7b3a2096-ce22-4ac5-90e4-10ffa818dc49.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u8728c50f&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=916&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae7d39ad-2aa8-4dd3-922b-4deb1c5a810&title=&width=608"><br><strong>例子</strong><br>一个数进去的时候结算水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568452-8d0329f2-01e6-457a-af5e-535b96a0aa9e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=324&id=u2d7d0a44&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=962&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2363d263-1b25-4389-b468-1c17f534e8d&title=&width=642"><br><strong>代码</strong><br>max不更新就说明出海口就没有变</p><p>| **public static class **Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   **public <strong>Node</strong>(int **v, **int **r, **int <strong>c</strong>) {<br>      value **&#x3D; v;<br>      **row **&#x3D; r;<br>      **col **&#x3D; c;<br>   **}</p><p>}</p><p>public static int <strong>trapRainWater</strong>(int[][] <strong>heightMap</strong>) {<br>   if (**heightMap &#x3D;&#x3D; **null **&amp;#124;&amp;#124; heightMap.**length <strong>&#x3D;&#x3D; 0 &amp;#124;&amp;#124; heightMap</strong>[<strong>0</strong>] **&#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; heightMap</strong>[<strong>0</strong>]</strong>.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **N &#x3D; heightMap.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; heightMap</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   <strong>boolean[][] <strong>isEnter &#x3D; <strong>new boolean[<strong>N</strong>][<strong>M</strong>]</strong>;<br>   PriorityQueue</strong>&lt;**Node**&gt; <strong>heap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) <strong>-&gt; a.<strong>value <strong>- b.<strong>value)</strong>;<br>   <strong>for (int <strong>col &#x3D; 0; col &lt; M - 1; col++**) {<br>      **isEnter**[**0**][**col**] **&#x3D; **true**;<br>      heap.add**(new **Node**(**heightMap**[**0**][**col**]**, 0, col**))**;<br>   **}<br>   for (int **row &#x3D; 0; row &lt; N - 1; row++**) {<br>      **isEnter**[**row**][**M - 1**] **&#x3D; **true**;<br>      heap.add**(new **Node**(**heightMap**[**row**][**M - 1**]**, row, M - 1**))**;<br>   **}<br>   for (int **col &#x3D; M - 1; col &gt; 0; col–</strong>) {<br>      <strong>isEnter</strong>[<strong>N - 1</strong>][<strong>col</strong>] <strong>&#x3D; <strong>true</strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>N - 1</strong>][<strong>col</strong>]</strong>, N - 1, col</strong>))</strong>;<br>   <strong>}<br>   for (int <strong>row &#x3D; N - 1; row &gt; 0; row–</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>0</strong>] <strong>&#x3D; <strong>true</strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>0</strong>]</strong>, row, 0</strong>))</strong>;<br>   <strong>}<br>   int <strong>water &#x3D; 0;<br>   <strong>int <strong>max &#x3D; 0;<br>   <strong>while (</strong>!heap.isEmpty</strong>()) {<br>      <strong>Node cur &#x3D; heap.poll</strong>()</strong>;<br>      max &#x3D; Math.max</strong>(<strong>max, cur.<strong>value)</strong>;<br>      <strong>int <strong>r &#x3D; cur.<strong>row</strong>;<br>      <strong>int <strong>c &#x3D; cur.<strong>col</strong>;<br>      &#x2F;&#x2F;上下左右去放<br>      &#x2F;&#x2F;有上面<br>      <strong>if (<strong>r &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>])</strong>;<br>         isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>]</strong>, r - 1, c</strong>))</strong>;<br>      <strong>}<br>      <strong>&#x2F;&#x2F;有下<br>      <strong>if (<strong>r &lt; N - 1 &amp;&amp; !isEnter**[**r + 1**][**c**]) {<br>         **water +&#x3D; Math.max**(**0, max - heightMap**[**r + 1**][**c**])**;<br>         isEnter**[**r + 1**][**c**] **&#x3D; **true**;<br>         heap.add**(new **Node**(**heightMap**[**r + 1**][**c**]**, r + 1, c**))**;<br>      **}<br>      **&#x2F;&#x2F;有左<br>      **if (**c &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>])</strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>]</strong>, r, c - 1</strong>))</strong>;<br>      <strong>}<br>      <strong>&#x2F;&#x2F;有右<br>      <strong>if (<strong>c &lt; M - 1 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>])</strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>]</strong>, r, c + 1</strong>))</strong>;<br>      **}<br>   }<br>   return **water;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568940-16d91986-3ce5-4170-995b-25e5eb327a2d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=ua197f36f&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=560&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5856214b-6641-45ba-838e-b397b8823c9&title=&width=378"></p><h2 id="·-找出最大的左部分最大值减去右部分最大值的绝对值"><a href="#·-找出最大的左部分最大值减去右部分最大值的绝对值" class="headerlink" title="· 找出最大的左部分最大值减去右部分最大值的绝对值"></a>· 找出最大的左部分最大值减去右部分最大值的绝对值</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652270318016-0e37cdc1-b8e3-47ba-bf01-6f42eb4e6247.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=ua69a96f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17778&status=done&style=none&taskId=u26260abf-215f-42d6-9e95-5f6eace034c&title=&width=652.8" alt="image.png"><br><strong>题意</strong><br>所以你每切一刀都会有一个左部分的最大值，减去右部分的最大值的绝对值<br>一共有N-1种切法。那么哪一种切法下，这个值能最大, 把这个最大的结果返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009637-2441118c-f8dd-47dd-afef-1bf81668b74a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=pClpf&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f94afae-e9f4-41ae-8f51-6fb3c2947e8&title=&width=485"><br><strong>题解</strong><br>暴力: 遍历<br>当我来到i位置的时候, 0<del>i是左部分, i+1</del>N-1是右部分, 枚举i, 遍历一下找左右部分的最大值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009601-259b07db-0b03-422c-aa80-7360e0e29474.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=zBUSt&margin=%5Bobject%20Object%5D&originHeight=525&originWidth=1171&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u68d556cd-13fd-4bfa-b226-e655edba474&title=&width=605"><br><strong>辅助数组</strong><br>left数组: 记录0~i范围上的最大值<br>当前数跟前一个位置的数, 谁大拷贝谁</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009616-8360c1b6-bd21-47cf-b05a-4894b6301470.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=w2PrR&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=1020&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3dd0bbc-0eb9-4eda-8708-0ac0d2dcf67&title=&width=656"><br>right数组:从右往左生成,i+1<del>N-1范围上的最大值<br>有了两个辅助数组, 再去枚举i的时候<br>0</del>i范围上的最大值直接从left数组里取, i+1~N-1范围上的最大值直接从right数组里拿<br>把O(N^2)的暴力解优化成O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009605-dbca0f91-6ad8-4748-9f10-8885d7311c83.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=337&id=qF9iP&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1035&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8518c4be-731f-43bd-910f-44af73685c7&title=&width=690"></p><p>| **public static int <strong>maxABS2</strong>(int[] <strong>arr</strong>) {<br>   int[] **lArr &#x3D; **new int[**arr.<strong>length]</strong>;<br>   **int[] <strong>rArr &#x3D; <strong>new int[<strong>arr.<strong>length]</strong>;<br>   lArr</strong>[<strong>0</strong>] <strong>&#x3D; arr</strong>[<strong>0</strong>]</strong>;<br>   rArr</strong>[**arr.<strong>length <strong>- 1</strong>] <strong>&#x3D; arr</strong>[<strong>arr.<strong>length <strong>- 1</strong>]</strong>;<br>   <strong>for (int <strong>i &#x3D; 1; i &lt; arr.**length**; i++**) {<br>      **lArr**[**i**] **&#x3D; Math.max**(**lArr**[**i - 1**]**, arr**[**i**])**;<br>   **}<br>   for (int **i &#x3D; arr.**length **- 2; i &gt; -1; i–</strong>) {<br>      <strong>rArr</strong>[<strong>i</strong>] <strong>&#x3D; Math.max</strong>(<strong>rArr</strong>[<strong>i + 1</strong>]</strong>, arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   int **max &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.<strong>length <strong>- 1; i++</strong>) {<br>      <strong>max &#x3D; Math.max</strong>(<strong>max, Math.abs</strong>(<strong>lArr</strong>[<strong>i</strong>] <strong>- rArr</strong>[<strong>i + 1</strong>]))</strong>;<br>   **}<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>最优解</strong><br>arr 遍历一遍找到全局最大值, 然后0位置数跟N-1位置数, 谁小减谁就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009794-49174c11-7c15-4f33-86e2-e55388ed91d5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=cLoHI&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=885&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c009e6b-c545-4de7-913a-67aee64f8ad&title=&width=519"><br>可能性罗列</p><ol><li><p>全局max被划分到了左边</p></li><li><p>全局max被划分到了右边</p></li><li><p>max - 右边的最大值就是答案<br>让右max尽量小<br>右部分一定要有数, 一定会包含N-1位置的数<br>右部分只包含最右边一个数是右边max最小的时候<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010132-31eed44f-ffcb-4639-bc25-e746726c22ef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=D4cKJ&margin=%5Bobject%20Object%5D&originHeight=453&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d6af354-eb1a-467a-8e6e-9faad6833e9&title="></p></li><li><p>左max尽量小, 左部分一定会包含0位置的数<br>就让左部分只包含0位置的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010235-2ac3a3a2-5e64-4573-90c1-1ce1513e4177.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=dhLOT&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1030&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue7dd0c92-9bcb-4ee3-ae1f-c25a9700fb7&title="><br><strong>代码</strong></p></li></ol><p>| &#x2F;&#x2F;amazing！<br><strong>public static int <strong>maxABS3</strong>(int[] <strong>arr</strong>) {<br>   int <strong>max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>max &#x3D; Math.max</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, max</strong>)</strong>;<br>   <strong>}<br>   return <strong>max - Math.min</strong>(<strong>arr</strong>[<strong>0</strong>]</strong>, arr**[**arr.<strong>length <strong>- 1</strong>])</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊最大可整合子数组的长度"><a href="#·-✊最大可整合子数组的长度" class="headerlink" title="· ✊最大可整合子数组的长度"></a>· ✊最大可整合子数组的长度</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532365836-3c8093cf-782d-4f0e-854a-8c3427e0a834.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=u867734bf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=305&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61875&status=done&style=none&taskId=u53f84319-b0b7-4cfb-9d4d-beafbf2b477&title=&width=669.6" alt="image.png"><br><strong>题意</strong><br>排完序之后依次加1得到就是可整合<br>只要有重复值，它就没办法做可整合数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386766-8b1f7bae-ec0c-4109-bd44-011cacc7d351.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=ua84eeb28&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=581&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u015f7cff-9f62-4bfc-954d-9440e8dd640&title=&width=396"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386782-0ba22845-7afc-4f9e-a81b-9283c470caba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u3850d3b2&margin=%5Bobject%20Object%5D&originHeight=438&originWidth=728&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb9990b4-f7ff-479c-94d4-943e8d57ac3&title=&width=449"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386975-f5f84998-bdcd-4f75-8fb4-702dc86cb261.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=udf385003&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=782&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d425bbc-9f7b-4f84-bf26-d91fcd501fa&title=&width=462"><br>哪一个子数组是可整合的而且最长, 返回最长长度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386935-72cadf66-19f6-4562-b619-f95e67f91c55.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=u6cceb4e0&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=694&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4089eb32-f3bb-4b90-9c15-e35b315eb17&title=&width=491"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386866-d20c76bd-4969-4bce-ad9b-c784eb6a76a2.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=224&id=u7df7ee5c&margin=%5Bobject%20Object%5D&originHeight=387&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua502ac2b-174e-47d6-b4d4-4187fa647f2&title=&width=521"><br>不能排序<br>因为他问的就是你原始arr的数据状况，最长可整合子数组是啥？<br>排完序0,1,2原数组没有这个子数组<br>原数据状况是不能够动的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387154-7c295c6a-1838-45a2-ae75-508ced86774f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=320&id=u735cfd92&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=882&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0882a71c-1ed1-4ec5-bce0-e4fbd3b9685&title=&width=625"><br><strong>题解</strong><br>不能用滑动窗口, 没有单调性<br>因为如果一个窗口是可整合的, 它扩大或缩小不一定可整合<br>子数组范围这件事和可整合这件事建立不起单调性。<br>能用滑动窗口的最重要的性质就是某种范围上的单调性<br>子数组范围扩大了，或者子数组范围缩小了，对于可整合的东西，<br>它是有一定的单调性的，我菜可以去利用，而本题是没有的。<br>所以滑动窗口也用不了。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387319-f3df4fef-b417-4636-bfc4-b098e97ad628.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=u07077d33&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6d45fb4c-a596-4283-a50a-b3b83d3dd28&title=&width=496"><br><strong>暴力解:</strong><br>枚举所有子数组<br>比如说我验证从L到R这一段是不是可整合的,<br>可以把它拷贝出来, 拍完序再验证是不是可整合的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387425-c3b5c57f-08b3-4119-a9d3-65813f51fc17.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=307&id=uf7a760b5&margin=%5Bobject%20Object%5D&originHeight=435&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u83b81b1d-d7d6-49c7-ac07-77c4d2696e1&title=&width=636"><br><strong>复杂度</strong><br>子数组数量O(N^2), 子数组平均长度N<br>把子数组拷贝一下O(N), 子数组排序O(N<em>logN), 排序后的验证O(N)<br>取最高阶O(N</em>logN), 最终复杂度O(N^3*logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387470-931d4e55-faee-4d65-aaf2-82ec28e91d09.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=u9026a328&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89e7ad6f-b03b-4734-b328-39d568514d8&title=&width=625"><br><strong>重新定义可整合数组标准！！！</strong></p><ol><li>没有重复值</li><li>数组最大值-最小值&#x3D;个数-1<br>满足这两个条件就是可整合数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387491-c2cc6771-68b6-4a63-a0ab-83e7c4f0ed43.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u4220dfc8&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=965&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23575989-4df0-4efb-a468-212b66ddbef&title=&width=532"><br>简化的过程</li></ol><p>| **public static int <strong>maxLen</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   <strong>}<br>   int <strong>N &#x3D; arr.<strong>length</strong>;<br>   HashSet</strong>&lt;**Integer**&gt; <strong>set &#x3D; <strong>new <strong>HashSet</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>ans &#x3D; 1;&#x2F;&#x2F;答案至少是1<br>   <strong>for (int <strong>L &#x3D; 0; L &lt; N; L++</strong>) {<br>      <strong>set.clear</strong>()</strong>;&#x2F;&#x2F;因为r要归为<br>      <strong>int <strong>min &#x3D; arr</strong>[<strong>L</strong>]</strong>;<br>      <strong>int <strong>max &#x3D; arr</strong>[<strong>L</strong>]</strong>;<br>      set.add</strong>(<strong>arr</strong>[<strong>L</strong>])</strong>;<br>      &#x2F;&#x2F; L..R<br>      <strong>for (int <strong>R &#x3D; L + 1; R &lt; N; R++</strong>) {<br>         <strong>&#x2F;&#x2F; L….R<br>         <strong>if(<strong>set.contains</strong>(<strong>arr</strong>[<strong>R</strong>])) {<br>            break</strong>;<br>         <strong>}<br>         <strong>set.add</strong>(<strong>arr</strong>[<strong>R</strong>])</strong>;<br>         min &#x3D; Math.min</strong>(<strong>min, arr</strong>[<strong>R</strong>])</strong>;&#x2F;&#x2F;可能r的值更小<br>         max &#x3D; Math.max</strong>(<strong>max, arr</strong>[<strong>R</strong>])</strong>;&#x2F;&#x2F;也可能r的值更大<br>         &#x2F;&#x2F;个数：R-L+1,再减个1<br>         <strong>if(<strong>max - min &#x3D;&#x3D; R - L</strong>) {<br>            <strong>ans &#x3D; Math.max</strong>(<strong>ans, R - L + 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   return **ans;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>总结: 改题目的设定让它变得更简洁</strong><br>就是当你发现，比如说面试场上给了你一道题，它的定义部分让你求解的部分是如此之复杂。<br>你不要硬着头皮，就按照他的说法就硬上了，你要改成你自己的定义。比如说我们把这个就<br>拆分成了系统最大值减两头这样一个问题，把可整合数组重新写了定义之后，能让我们验证<br>可整合这个过程变快，这种就属于在面试场上遇到了一类，它给你来一个设定，但是你要改<br>它的设定让它变得更简洁的。要有这个心眼，你发现这道题目设定的部分写得特别的绕。<br>那说明它可能不够简洁，这时要有一个心眼，就是要改设定。这样改设定的题型很多，<br>我们以后遇到再说。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532543649-53d3de55-8561-4ff0-add7-817357bd81ac.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=u7ad3e556&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ce4aaab-9297-47d3-9ce8-fbaa226b91f&title=&width=474"></p><h2 id="·-✊超级水王问题"><a href="#·-✊超级水王问题" class="headerlink" title="· ✊超级水王问题"></a>· ✊超级水王问题</h2><p><strong>题意</strong><br>我给你个数组，如果有水王数你打印出来，如果无水王数，你告诉用户没有<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564573-18f0aae5-4c48-4583-a5fc-908f05f918aa.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ub63ef09a&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb3f9d95-2385-4717-ab8a-502c4ce9c0f&title=&width=489"><br>要求时间复杂度O(N)<br>空间复杂度O(1)<br>把用hash表的路堵死了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564812-7f6017f2-4972-4dde-b65e-5065ad21c9b5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=ua3b9fe6a&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=963&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u345c305d-94e0-4908-a782-ea6311d8772&title=&width=533"><br><strong>题解</strong><br>一次删掉两个不同值的数, 如果arr中真的有水王的话, 这个水王数一定会剩下来<br>因为水王数是大于一半的次数的。哪怕其它所有的数字都跟水王数为敌<br>水王数也会活下来, 更不用说其它数字之间还会有内战的情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564621-4c4d07c4-1905-4d22-8161-ba7827127276.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=ud9c14c93&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uac5cb9f7-4ed2-4d56-99bd-234e14ca061&title=&width=470"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564724-40df89be-6e7c-479d-b755-0479f9168ce6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1df2e5b3&margin=%5Bobject%20Object%5D&originHeight=144&originWidth=382&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94cefb0a-39fc-4749-88dc-a340c7f447b&title="><br>arr一次删掉两个不同的数, 最后剩下的数一定是水王吗?<br>不一定是水王<br>如果有水王的话, 一定会剩下来<br>如果没有水王的话, 如果剩下来的数都不是水王，那就没有数是了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564674-454bc6b4-a8ff-479c-938b-e6e9a24a390d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua49eec8c&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=421&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1cb3b4b7-b9f8-4379-a900-ef09a62f703&title="><br><strong>思路</strong></p><ol><li>arr 一次删除两个不同值的数, 看最终谁会剩下来</li></ol><p>可能性<br>1: 没有数字剩下来: 无水王数<br>2: 有数剩下来<br>x剩下来, 再遍历看x真实出现的次数跟N&#x2F;2对比</p><p><strong>怎么一次删除两个不同的数?</strong><br>时间复杂度O(N)<br>空间复杂度O(1)<br>两个变量</p><ol><li>候选cand</li><li>血量hp<br>当血量&#x3D;0, 认为没有候选人<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565245-13d042e9-15ce-451f-9d00-22fb6b8c37eb.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u22eda463&margin=%5Bobject%20Object%5D&originHeight=431&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua04fdaf1-7f3e-4a6d-9286-dad2914a968&title=&width=542"><br><strong>流程</strong><br>一个一个数遍历, 三条规则:</li><li>如果没有候选, 当前数立为候选, 血量+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565228-0cb5c6f0-77d1-4a27-9618-82f95127135e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u3e918b1a&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=1021&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8d87f13b-7fc7-4e50-aa59-77782c0c05d&title=&width=585"></li><li>如果有候选<br> 1)当前数跟候选不一样,血量–<br> 2)当前数是候选,血量++<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565221-c7dde5a0-148c-4fc2-9ce8-9c33a38b526a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u9c9600a3&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=1032&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c27cf79-9f62-4684-95ac-0cb1bb50623&title=&width=571"><br>解释</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565427-1f53495a-7f90-4a2e-b08b-43af2f9f0147.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u1cb7e569&margin=%5Bobject%20Object%5D&originHeight=506&originWidth=1011&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf9fba9e6-c81e-4f75-a1bc-54ac7326b4d&title=&width=592"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565702-b20446ee-a34b-4303-85dc-18bfb790a1ab.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=u81618e25&margin=%5Bobject%20Object%5D&originHeight=497&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua102ae15-5ac8-4490-a8d4-6d41c0048d7&title=&width=623"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565738-f2a9bd97-215c-4362-9d4d-23af8dc985b1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u9538e7a3&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=1009&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72d5eca0-0819-455a-bb9a-c4de485e2ab&title=&width=634"><br>遍历完成后,如果血量&#x3D;0,表示什么数也没有剩下来,如果血量不等于零，候选就是剩下来的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565794-847db360-2964-4094-8ffe-a086883180e7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u676fec88&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e114edf-2d28-4477-a82d-92b2a494048&title=&width=634"><br><strong>代码</strong></p><p>| **public static void <strong>printHalfMajor</strong>(int[] <strong>arr</strong>) {<br>   int **cand &#x3D; 0;<br>   **int **HP &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.**length**; i++**) {<br>      if (**HP &#x3D;&#x3D; 0**) {<br>         **cand &#x3D; arr**[**i**]**;<br>         HP &#x3D; 1;<br>      **} else if (**arr**[**i**] **&#x3D;&#x3D; cand**) {<br>         **HP++;<br>      **} else {<br>         **HP–;<br>      **}<br>   }<br>   if(**HP &#x3D;&#x3D; 0**) {<br>      **System.**out**.println**(“no such number.”)**;<br>      **return**;<br>   **}<br>   **HP &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.**length**; i++**) {<br>      if (**arr**[**i**] **&#x3D;&#x3D; cand**) {<br>         **HP++;<br>      **}<br>   }<br>   if (**HP &gt; arr.<strong>length <strong>&#x2F; 2</strong>) {<br>      <strong>System.<strong>out</strong>.println</strong>(<strong>cand</strong>)</strong>;<br>   <strong>} else {<br>      <strong>System.<strong>out</strong>.println</strong>(“no such number.”)</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><p><strong>扩展</strong><br>给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N&#x2F;K，打印这些数，如果没有不打印</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692268-ec19fdb8-d919-4ff4-989b-a9441d09217c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u794e348d&margin=%5Bobject%20Object%5D&originHeight=467&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c744658-4ae3-453a-95bc-6b4354a53a7&title=&width=532"><br>至多K-1个出现N&#x2F;K次的数（假设k &#x3D; 2，至多只有一个数字）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692364-02aa48c0-9e3a-4054-aaa4-0a8176783fbc.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u7c355bf8&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=820&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u22b99e23-11f2-4517-ad75-24ab4f0e7ac&title=&width=477"><br><strong>例子</strong><br>K&#x3D;4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692393-908c6f08-2bfa-4465-812d-6007cce170df.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=udfebc94e&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=919&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c9dd817-5300-40b5-818b-31b809878ad&title=&width=563"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692292-a6252411-18f3-4e51-a21c-65ab7d2fe782.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=uc29f6c64&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=907&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udfc00b4d-da71-4486-92cc-4c1ec0d3bb6&title=&width=521"><br>4来了, 所有人-1点血量<br>血量是0不要, 删掉, 一次删掉了4个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692349-175242d0-ebac-4c64-8c62-f814f64470dd.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59831a71&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=603&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub7fa5c34-2c6b-4a84-8c3a-dac5f6647df&title="><br><strong>代码</strong><br>必须验证真实次数<br>候选有什么，也不代表它就代表唯一考虑的集合<br>但它是不是, 不收集真实次数没人知道</p><p>| **public static void <strong>printKMajor</strong>(int[] **arr, <strong>int <strong>K</strong>) {<br>   if (<strong>K &lt; 2**) {<br>      **System.**out**.println**(“the value of K is invalid.”)**;<br>      **return**;<br>   **}<br>   **&#x2F;&#x2F; 攒候选，cands，候选表，最多K-1条记录！ &gt; N &#x2F; K次的数字，最多有K-1个<br>   HashMap</strong>&lt;**Integer, Integer**&gt; <strong>cands &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      if (<strong>cands.containsKey</strong>(<strong>arr</strong>[<strong>i</strong>])) {<br>         <strong>cands.put</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, cands.get</strong>(<strong>arr</strong>[<strong>i</strong>]) <strong>+ 1</strong>)</strong>;<br>      <strong>} else { <strong>&#x2F;&#x2F; arr[i] 不是候选<br>         <strong>if (<strong>cands.size</strong>() <strong>&#x3D;&#x3D; K - 1</strong>) { <strong>&#x2F;&#x2F; 当前数肯定不要！，每一个候选付出1点血量，血量变成0的候选，要删掉！<br>            allCandsMinusOne</strong>(<strong>cands</strong>)</strong>;<br>         <strong>} else {<br>            <strong>cands.put</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   **&#x2F;&#x2F; 所有可能的候选，都在cands表中！遍历一遍arr，每个候选收集真实次数</p><p>   HashMap**&lt;<strong>Integer, Integer**&gt; <strong>reals &#x3D; getReals</strong>(<strong>arr, cands</strong>)</strong>;<br>   **boolean **hasPrint &#x3D; <strong>false</strong>;<br>   <strong>for (<strong>Entry</strong>&lt;**Integer, Integer**&gt; <strong>set : cands.entrySet</strong>()) {<br>      <strong>Integer key &#x3D; set.getKey</strong>()</strong>;<br>      **if (<strong>reals.get</strong>(<strong>key</strong>) **&gt; arr.**length <strong>&#x2F; K</strong>) {<br>         <strong>hasPrint &#x3D; <strong>true</strong>;<br>         System.<strong>out</strong>.print</strong>(**key + <strong>“ “)</strong>;<br>      **}<br>   }<br>   <strong>System.<strong>out</strong>.println</strong>(**hasPrint ? **”” **: <strong>“no such number.”)</strong>;<br>**}</p><p>public static void <strong>allCandsMinusOne</strong>(<strong>HashMap</strong>&lt;<strong>Integer, Integer**&gt; <strong>map</strong>) {<br>   <strong>List</strong>&lt;**Integer**&gt; <strong>removeList &#x3D; <strong>new <strong>LinkedList</strong>&lt;**Integer**&gt;()</strong>;<br>   <strong>for (<strong>Entry</strong>&lt;**Integer, Integer**&gt; <strong>set : map.entrySet</strong>()) {<br>      <strong>Integer key &#x3D; set.getKey</strong>()</strong>;<br>      Integer value &#x3D; set.getValue</strong>()</strong>;<br>      <strong>if (<strong>value &#x3D;&#x3D; 1</strong>) {<br>         <strong>removeList.add</strong>(<strong>key</strong>)</strong>;<br>      <strong>}<br>      <strong>map.put</strong>(<strong>key, value - 1</strong>)</strong>;<br>   <strong>}<br>   for (<strong>Integer removeKey : removeList</strong>) {<br>      <strong>map.remove</strong>(<strong>removeKey</strong>)</strong>;<br>   **}<br>}</p><p>public static <strong>HashMap</strong>&lt;**Integer, Integer**&gt; <strong>getReals</strong>(int[] <strong>arr,<br>      HashMap</strong>&lt;**Integer, Integer**&gt; <strong>cands</strong>) {<br>   <strong>HashMap</strong>&lt;**Integer, Integer**&gt; **reals &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      int <strong>curNum &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      <strong>if (<strong>cands.containsKey</strong>(<strong>curNum</strong>)) {<br>         if (<strong>reals.containsKey</strong>(<strong>curNum</strong>)) {<br>            <strong>reals.put</strong>(<strong>curNum, reals.get</strong>(<strong>curNum</strong>) <strong>+ 1</strong>)</strong>;<br>         <strong>} else {<br>            <strong>reals.put</strong>(<strong>curNum, 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   return **reals;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊第k小的数值对"><a href="#·-✊第k小的数值对" class="headerlink" title="· ✊第k小的数值对"></a>· ✊第k小的数值对</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533451839-1dcc4f86-8175-4b98-bb2d-33fab076095b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ucc6bd1e8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43310&status=done&style=none&taskId=udbf48c7b-c5c2-41b0-807a-c792b021443&title=&width=669.6" alt="image.png"><br><strong>题解</strong><br><strong>暴力解</strong><br>两个for循环生成所有数值对, 放到数组里用比较器排序, 取出第K位的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574288-932f369b-6665-4975-870e-8d798fe5b12a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ue3aaa206&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1081&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1fb1f388-552d-4f2a-a109-a817c3ba4b9&title=&width=604"><br>复杂度 O(N^2*logN^2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574337-82315d0f-95c8-492b-9c77-3fc02ea2091e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=u7073562e&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1147&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6c9f817e-0dab-474c-857c-d4fef6c040a&title=&width=655"><br><strong>最优解</strong><br>最优解复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574399-0f80a80f-e29a-446a-91ed-6eb65d947887.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ud6983707&margin=%5Bobject%20Object%5D&originHeight=323&originWidth=806&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u84b6d280-143f-4d10-abd7-57f845288b9&title=&width=626"><br><strong>过程</strong><br>根据第一维数据进行分组<br>第一维的数字是1的叫第1组里的数值对<br>第一维的数字是2的叫第2组里的数值对<br>第一维的数字是3的叫第3组里的数值对<br>第一维的数字是5的叫第4组里的数值对<br>大体上分块就这么多块<br>想知道第70个数是哪个数值对里的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574353-1821c432-0685-4133-b7b9-be12b0b00a2f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaf4e4a03&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=1148&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ded78e1-5092-4773-9c69-8dd1d9d867c&title="><br>假设第70个数是(a,b)这两维数据, 先定位a是谁, 数组长度是11<br>必须以0位置的1做为第一维数据的一共有11个<br>必须以1位置的1做为第一维数据的一共有11个<br>必须以2位置的1做为第一维数据的一共有11个<br>必须以3位置的2做为第一维数据的一共有11个<br>所以你想求第 70 个怎么定位这个a？你就看看它是哪一组里的, 说明它第一维就是那个位置的数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574305-dac448dc-7170-485a-a101-f723d251e819.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueab68af7&margin=%5Bobject%20Object%5D&originHeight=407&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u052e5313-afe0-43a7-8a72-428388a3bf1&title="><br>定位70是哪一组里的,<br>第70个数来自于3的组, 第一维数据是3<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575227-31b8ed61-55a5-4dfe-9627-7c7149d896d6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1a4f9244&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=1133&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucf6b52e7-70e5-4015-a29f-6c52f65ea6e&title="><br>怎么得到b<br>b肯定是3组里的数值对,<br>3之前一共搞定了55个, 所以你要第 70 个，它应该是三大组中的第 15 个。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575288-74bcd08a-9b14-434a-8bff-c504f8dabde3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=ufa15bced&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2db97466-6de6-4213-9d9d-840e2b29949&title=&width=635"><br>3大组中再细分,<br>必须以0位置的1做二维数据的有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575449-630237a5-8e4c-44e5-8adf-02ebd9c41cf7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u2e30a4fd&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1129&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uca568bff-376a-4bb3-812f-4b3fa039d94&title=&width=527"><br>相求3大组中的第15个, 一共有4个3, 所以<br>必须0位置的1做第二维数据的, 4个<br>必须1位置的1做第二维数据的,4个<br>必须2位置的1做第二维数据的,4个<br>必须3位置的2做第二维数据的,4个<br>看看这第15个来自那一组, 就可以定位第二维的数字来自哪儿了</p><p><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575700-2e9c1dc6-1c5a-434e-8f4a-34e244c6162e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=ue603987f&margin=%5Bobject%20Object%5D&originHeight=390&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u494d13cd-e862-4e22-a402-187828b9bf6&title=&width=689"><br>第一维的数字是4<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575882-6c7e9e5d-1b94-4951-841f-d623a6840864.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udeef2653&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u06579f25-1baa-49c4-81f0-bda6a471bfc&title=&width=667"><br>1,2,3开头的一共有70个<br>第一维是4的情况下,<br>4里的12<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576014-43be7fca-337b-4cbf-9dd6-ac93d054933f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6ae98023&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1126&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufe456ad6-a016-4ec4-9226-9d0d844b402&title="><br>4的组细分<br>第二维数字是1,2,3,4的那些<br>第一维数字是 4 的情况下再往下细分组是啥?<br>第二维数据是 1 的那些<br>第二维数据是 2 的那些<br>第二维数据是 3 的那些<br>第二维数据是 4 的那些</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576961-4018a1d4-8795-402b-ad61-9094ebaf856f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=uc4ab67a7&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=1135&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub026b4b3-619a-4a77-a4a5-ae1fc99b04f&title=&width=629"><br>第一维的数字已经确实是4了<br>第二维数据是 1 的那些分为<br>0位置的1做第二维的数据, 3个, 7,8,9位置的4都是<br>1位置的1做第二维的数据, 3个, 7,8,9位置的4都是</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577008-8175b831-2b92-4719-bc9c-ea5b8bf3434e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=372&id=u8e3187a1&margin=%5Bobject%20Object%5D&originHeight=547&originWidth=873&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf2f6ca15-0d35-46b9-be0d-6928f79b21f&title=&width=594"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576966-c18e528a-b6b0-4d36-b9ad-54ce913287a5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=u2b5ae72a&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1121&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uee646ef9-bab2-4946-9ef3-cdd53fb4f48&title=&width=627"><br><strong>抽象化</strong><br>假设一共有N个数,求第K小数值对<br>怎么定位第一维数据?<br>K&#x2F;N的下标对应的值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577141-db303288-f81d-47eb-a691-3490f7349eeb.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u855fa134&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8076f660-ae44-4486-a8c9-004532ef1a2&title=&width=563"><br>边界考虑<br>第一维数字的下标<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577309-cb5440cc-ec6c-42d0-a207-c3f531c35f16.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u3731a3d1&margin=%5Bobject%20Object%5D&originHeight=530&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue81e3ddb-626b-4ef0-b035-e2b5239cb4e&title=&width=508"><br>无序数组中找到第k小, bfprt<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577557-ad44f93d-e7d0-4003-ba23-3ae7897ccd42.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ud35ec140&margin=%5Bobject%20Object%5D&originHeight=557&originWidth=1120&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u38e4bc18-5977-4562-9d02-123c3e64abe&title=&width=545"><br><strong>怎么定义第二维数字</strong><br>你必须数一下小于 7 的数字有几个你才能知道前面做的一位数字的组帮你搞定了几个，<br>然后拿k减去它才是属于7的组，在第一位数字是 7 的情况下，在这个内部组里面我是第几个呢？<br>这事怎么求?<br>你必须数一下前面小于 7 的数字有几个</p><p>**代码 **<br>必须搞清楚的第一维数字小于 5 的，之前的数字有几个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577715-e66d1dd1-8985-476f-a263-11335040c1ba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u9c8a0bcd&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uedae6774-6831-4395-9c5d-11ba2520332&title=&width=551"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577892-e34c0223-de0d-4c47-88cc-c15cd07653ef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=uc48d9a27&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1134&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u939b5448-34f1-459a-a8cb-f98e841f015&title=&width=631"></p><p>| **public static class **Pair <strong>{<br>   public int x</strong>;<br>   <strong>public int y</strong>;</p><p>   Pair**(int **a, **int <strong>b</strong>) {<br>      x **&#x3D; a;<br>      **y **&#x3D; b;<br>   **}<br>}</p><p>public static class **PairComparator **implements <strong>Comparator</strong>&lt;**Pair**&gt; {</p><p>   **@Override<br>   **public int <strong>compare</strong>(<strong>Pair arg0, Pair arg1</strong>) {<br>      return **arg0.**x **!&#x3D; arg1.**x **? arg0.**x **- arg1.**x **: arg0.**y **- arg1.<strong>y</strong>;<br>   **}</p><p>}</p><p>**&#x2F;&#x2F; O(N^2 * log (N^2))的复杂度，你肯定过不了<br>&#x2F;&#x2F; 返回的int[] 长度是2，{3,1} int[2] &#x3D; [3,1]<br>**public static int[] <strong>kthMinPair1</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   **}<br>   <strong>Pair</strong>[] **pairs &#x3D; <strong>new <strong>Pair</strong>[<strong>N * N</strong>]</strong>;<br>   **int **index &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      for (int <strong>j &#x3D; 0; j &lt; N; j++</strong>) {<br>         <strong>pairs</strong>[<strong>index++</strong>] <strong>&#x3D; <strong>new <strong>Pair</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, arr</strong>[<strong>j</strong>])</strong>;<br>      <strong>}<br>   }<br>   <strong>Arrays.sort</strong>(<strong>pairs, <strong>new <strong>PairComparator</strong>())</strong>;<br>   <strong>return new int[] { <strong>pairs</strong>[<strong>k - 1</strong>]</strong>.<strong>x</strong>, pairs</strong>[<strong>k - 1</strong>]</strong>.<strong>y }</strong>;<br>**}</p><table><thead><tr><th>**</th></tr></thead></table><p>| &#x2F;&#x2F; O(N*logN)的复杂度，你肯定过了<br>**public static int[] <strong>kthMinPair2</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   <strong>}<br>   <strong>&#x2F;&#x2F; O(N*logN)<br>   Arrays.sort</strong>(<strong>arr</strong>)</strong>;<br>   &#x2F;&#x2F; 第K小的数值对，第一维数字，是什么 是arr中<br>   <strong>int <strong>fristNum &#x3D; arr</strong>[(<strong>k - 1</strong>) <strong>&#x2F; N</strong>]</strong>;<br>   **int **lessFristNumSize &#x3D; 0;&#x2F;&#x2F; 数出比fristNum小的数有几个<br>   **int **fristNumSize &#x3D; 0; &#x2F;&#x2F; 数出&#x3D;&#x3D;fristNum的数有几个<br>   &#x2F;&#x2F; &lt;&#x3D; fristNum<br>   **for (int <strong>i &#x3D; 0; i &lt; N &amp;&amp; arr</strong>[<strong>i</strong>] <strong>&lt;&#x3D; fristNum; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&lt; fristNum</strong>) {<br>         **lessFristNumSize++;<br>      **} else {<br>         **fristNumSize++;<br>      **}<br>   }<br>   int **rest &#x3D; k - <strong>(<strong>lessFristNumSize * N</strong>)</strong>;<br>   <strong>return new int[] { <strong>fristNum, arr</strong>[(<strong>rest - 1</strong>) <strong>&#x2F; fristNumSize</strong>] }</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>| &#x2F;&#x2F; O(N)的复杂度，你肯定蒙了<br>**public static int[] <strong>kthMinPair3</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   **}<br>   **&#x2F;&#x2F; 在无序数组中，找到第K小的数（k表示下标），返回值<br>   &#x2F;&#x2F; 第K小，以1作为开始<br>   **int <strong>fristNum &#x3D; getMinKth</strong>(**arr, <strong>(<strong>k - 1</strong>) <strong>&#x2F; N</strong>)</strong>;<br>   &#x2F;&#x2F; 第1维数字<br>   **int **lessFristNumSize &#x3D; 0;<br>   **int **fristNumSize &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&lt; fristNum</strong>) {<br>         **lessFristNumSize++;<br>      **}<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&#x3D;&#x3D; fristNum</strong>) {<br>         **fristNumSize++;<br>      **}<br>   }<br>   <strong>&#x2F;&#x2F;切记不能死记硬背<br>   &#x2F;</strong><br>    *  2 1 5 3 6 5 4 7 2 长度为9 求K &#x3D; 58<br>    *  1 2 2 3 4 5 5 6 7   firstNum &#x3D; 5(第6小的数)<br>    *  rest &#x3D; 58 - 45 &#x3D; 13<br>    *&#x2F;<br>   <strong>int <strong>rest &#x3D; k - <strong>(<strong>lessFristNumSize * N</strong>)</strong>;<br>   System.<strong>out</strong>.println</strong>(“rest &#x3D; “ <strong>+ rest</strong>)</strong>;<br>   **return new int[] { <strong>fristNum, getMinKth</strong>(**arr, <strong>(<strong>rest - 1</strong>) <strong>&#x2F; fristNumSize</strong>) }</strong>;<br>**}</p><p>**&#x2F;&#x2F; 改写快排，时间复杂度O(N)<br>&#x2F;&#x2F; 在无序数组arr中，找到，如果排序的话，arr[index]的数是什么？<br>**public static int <strong>getMinKth</strong>(int[] **arr, **int <strong>index</strong>) {<br>   int **L &#x3D; 0;<br>   **int **R &#x3D; arr.**length **- 1;<br>   **int **pivot &#x3D; 0;<br>   **int[] **range &#x3D; <strong>null</strong>;<br>   **while (<strong>L &lt; R**) {<br>      **pivot &#x3D; arr**[**L + **(int) (**Math.random**() *** **(**R - L + 1**))]**;<br>      range &#x3D; partition**(**arr, L, R, pivot**)**;<br>      **if (**index &lt; range**[**0**]) {<br>         **R &#x3D; range**[**0**] **- 1;<br>      **} else if (**index &gt; range</strong>[<strong>1</strong>]) {<br>         <strong>L &#x3D; range</strong>[<strong>1</strong>] **+ 1;<br>      **} else {<br>         return **pivot;<br>      <strong>}<br>   }<br>   return <strong>arr</strong>[<strong>L</strong>]</strong>;<br>**}</p><p>public static int[] <strong>partition</strong>(int[] **arr, **int **L, **int **R, **int <strong>pivot</strong>) {<br>   int **less &#x3D; L - 1;<br>   **int **more &#x3D; R + 1;<br>   **int **cur &#x3D; L;<br>   <strong>while (<strong>cur &lt; more**) {<br>      if (**arr**[**cur**] **&lt; pivot**) {<br>         **swap**(**arr, ++less, cur++**)**;<br>      **} else if (**arr**[**cur**] **&gt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, cur, –more</strong>)</strong>;<br>      **} else {<br>         **cur++;<br>      **}<br>   }<br>   return new int[] { **less + 1, more - 1 <strong>}</strong>;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-数组能不能分成4个相等的部分"><a href="#·-数组能不能分成4个相等的部分" class="headerlink" title="· 数组能不能分成4个相等的部分"></a>· 数组能不能分成4个相等的部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533468062-870ee3db-9ba1-438d-bfba-f1f0eaca5b6e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=139&id=u21da3700&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31102&status=done&style=none&taskId=u552b24ea-96ee-414d-8b28-0f5ce24cea0&title=&width=456.8" alt="image.png"><br><strong>题意</strong><br>N&gt;&#x3D;7, 正数数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471540-fc6df3a7-1744-4cd5-abf5-c52f0a31e14f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u3c662ee6&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u91f5bb87-ba17-433f-954d-94343906014&title=&width=508"><br>你能不能切出四个部分，让四个部分累加和一样。但是切掉的数字是不算的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471734-ee7c3286-54dc-49c0-9841-5a6297def955.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=ucc6800d7&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u02fc3a3e-8ed3-4c74-9bd3-99e837f2411&title=&width=578"><br><strong>题解</strong><br>做出前缀和数组, 假设来到i位置, 想问<br>i位置做第一刀的情况下有没有可能切出4个部分累加和一样<br><strong>例子</strong><br>找209的前缀和<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471524-5d3a4faa-2313-4e57-b4a0-f8c9f5f4cd8b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=u24736741&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=651&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b0e8c1c-ddc2-4fac-829c-3118343a3af&title=&width=483"><br>14位置是第二刀<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471485-660cacba-56bd-4b13-a478-cf66a91eec8a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=uf0101aab&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae1dd84f-46f8-46f8-af79-6a3c3d93766&title=&width=541"><br>验证7位置能不能第一刀, O(1), 然后验证每一个位置做为第一刀, 就可以了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471488-436b2399-5728-40d0-8da9-e1a64ed33a89.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u97f20565&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f84d7de-0496-43f3-a6c5-e1cb29a148d&title="></p><p><strong>代码</strong></p><p>| **public static boolean <strong>canSplits2</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length **&lt; 7**) {<br>      return false**;<br>   **}<br>   **&#x2F;&#x2F; key 某一个累加和， value出现的位置<br>   HashMap**&lt;**Integer, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>int <strong>sum &#x3D; arr</strong>[<strong>0</strong>]</strong>;<br>   <strong>for (int <strong>i &#x3D; 1; i &lt; arr.**length**; i++**) {<br>      **map.put**(**sum, i**)**;<br>      sum +&#x3D; arr**[**i**]**;<br>   **}<br>   int **lsum &#x3D; arr**[**0**]**; &#x2F;&#x2F; 第一刀左侧的累加和<br>   **for (int **s1 &#x3D; 1; s1 &lt; arr.**length **- 5; s1++**) { **&#x2F;&#x2F; s1是第一刀的位置<br>      **int **checkSum &#x3D; lsum * 2 + arr**[**s1**]**; &#x2F;&#x2F; 100 x 100   100*2 + x<br>      **if (**map.containsKey**(**checkSum**)) {<br>         int **s2 &#x3D; map.get**(**checkSum**)**; &#x2F;&#x2F; j -&gt; y<br>         checkSum +&#x3D; (lsum + arr</strong>[<strong>s2</strong>])</strong>;<br>         **if (<strong>map.containsKey</strong>(<strong>checkSum</strong>)) { **&#x2F;&#x2F; 100 * 3 + x + y<br>            <strong>int <strong>s3 &#x3D; map.get</strong>(<strong>checkSum</strong>)</strong>; &#x2F;&#x2F; k -&gt; z<br>            <strong>if (<strong>checkSum + (arr</strong>[<strong>s3</strong>] <strong>+ lsum) &#x3D;&#x3D; sum</strong>) {<br>               return true</strong>;<br>            <strong>}<br>         }<br>      }<br>      <strong>lsum +&#x3D; arr</strong>[<strong>s1</strong>]</strong>;<br>   <strong>}<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊316-去除重复字母-M"><a href="#·-✊316-去除重复字母-M" class="headerlink" title="· ✊316. 去除重复字母  [M]"></a>· ✊316. 去除重复字母  [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533504865-a0411f35-f468-4fe7-ba62-98a6ffb066a1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udc341fe0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32042&status=done&style=none&taskId=u83a362da-6605-45be-b799-61f01d3e0bb&title=&width=662.4" alt="image.png"><br><strong>题意</strong><br>每种字符只保留一个, 请你返回字典序最小的结果<br>相对次序不能乱<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940519-92d4b450-75f4-4738-b2fc-d448dabee78d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=uc3a5dde1&margin=%5Bobject%20Object%5D&originHeight=393&originWidth=973&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7ea7df2e-ecc2-4679-8640-20a95c7d97c&title=&width=502"><br><strong>题解</strong><br>先建立词频统计表, 从左往右划线, 划线的词从词频表里删除</p><p>我如果在这线里面，这条线代表啥意思，我如果要选保留的第一个字符的话，我只能在这条线里选，<br>不能够再把右侧的字符考虑进来了。<br>当我决定保留一个字符的时候，我保留这个字符的同时，左侧字符全不要, 右侧字符可以继续选，<br>我在后面的字符里再选一个字符Y，那么 Y 左边的字符就不能再选了，在后面继续选，这是我的主流程。<br>选ascii码最小的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940426-5bd3de48-60bb-4186-b3f0-dafc220489fd.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=uec914f16&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=931&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d28ade0-97a0-4e57-8028-5f5f382ea6d&title=&width=598"><br>因为如果我这个 C 作为我保留第一个字符的话，后面就没 A 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940449-8ead876f-9228-42c5-9a3a-9e1da7419ba8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u7b220aee&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=918&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb18526a-30cb-44be-9a19-beabfa28a43&title=&width=586"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940483-a32ca227-5889-422a-a8a6-b692068da001.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u476f8fde&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=861&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua441ad0d-c491-4083-8559-fa70fc38f5b&title=&width=550"><br><strong>代码</strong></p><p>| &#x2F;&#x2F;递归版本： 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回<br>**public static <strong>String removeDuplicateLetters1</strong>(<strong>String str</strong>) {<br>   if (**str &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; str.length</strong>() <strong>&lt; 2**) {<br>      return **str;<br>   **}<br>   int[] **map &#x3D; **new int[**256**]**;<br>   **for (int **i &#x3D; 0; i &lt; str.length**()**; i++**) {<br>      **map**[**str.charAt**(**i**)]**++;<br>   **}<br>   int **minACSIndex &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; str.length**()**; i++**) {<br>      **minACSIndex &#x3D; str.charAt**(**minACSIndex**) **&gt; str.charAt</strong>(<strong>i</strong>) <strong>? i : minACSIndex;<br>      <strong>if (</strong>–map</strong>[<strong>str.charAt</strong>(<strong>i</strong>)] <strong>&#x3D;&#x3D; 0</strong>) {<br>         break</strong>;<br>      <strong>}<br>   }<br>   <strong>&#x2F;&#x2F; 0…break(之前) minACSIndex<br>   &#x2F;&#x2F; str[minACSIndex] 剩下的字符串str[minACSIndex+1…] -&gt; 去掉str[minACSIndex]字符 -&gt; s’<br>   &#x2F;&#x2F; s’…<br>   <strong>return <strong>String.valueOf</strong>(<strong>str.charAt</strong>(<strong>minACSIndex</strong>)) <strong>+ removeDuplicateLetters1</strong>(<br>         <strong>str.substring</strong>(<strong>minACSIndex + 1</strong>)</strong>.replaceAll</strong>(<strong>String.valueOf</strong>(<strong>str.charAt</strong>(<strong>minACSIndex</strong>))</strong>, <strong>“”))</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>复杂度</strong><br>遍历一遍总会保留一个字符, 而且以后的字符串中是不含有这个字符的。<br>所以你str中如果含有 K 种字符，复杂度就是O(K*N)。这个 K 大写加小写也不就是 52 种字符, 所以O(N)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940987-5cb7a264-d11d-41c0-b9e1-8e61798e55c6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u7ac43425&margin=%5Bobject%20Object%5D&originHeight=458&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69a4ec90-04ea-41f8-acde-5152dda5a2b&title=&width=586"></p><h2 id="·-15-三数之和-M"><a href="#·-15-三数之和-M" class="headerlink" title="· 15.三数之和 [M]"></a>· 15.三数之和 [M]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168720-6b744df4-7946-45c9-a331-a2bea7ca808b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u91a5461c&margin=%5Bobject%20Object%5D&originHeight=418&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47aed55e-205d-42c8-b687-db174d78dfa&title=&width=466"><br>字面值都不一样，就算不同的，有几个三元组全返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168713-93b17778-7f67-446e-90c9-05862b57e449.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ubaf6ddac&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=964&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u18986bf3-72d6-45ce-9a40-801113f1696&title=&width=440"><br><strong>题解</strong><br>2sum<br>双指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168718-d3daae68-041e-4709-83d2-24ed9706dcf1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=u3abbd115&margin=%5Bobject%20Object%5D&originHeight=244&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u13162b89-c8f0-4a19-a91b-a82270cb67d&title=&width=665"><br><strong>去重复:</strong></p><ol><li>收集所有二元组, 过滤</li><li>通过好的流程设计规避重复<br>L移动到下一个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168760-f5557fad-41a1-4981-9a4a-e7b1be9554d8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ue9ce0c40&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=1076&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1155980f-554e-48b9-9513-a53e4dfc988&title=&width=574"><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168722-ed693ec3-17f3-40db-875b-40df7a3e3bc2.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc9bb16c8&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=604&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3cc0675-8fd4-41a6-82ad-5ab956d174d&title="><br><strong>题解</strong><br>你只要保证第1个数字不一样后面就是二元组的问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169245-eb3b0c0f-0f36-4691-9b6d-a4d24f65c0f9.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=ubddc1e46&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9cfee96b-8401-44c4-8bfc-7cbfccc2aa1&title=&width=623"><br>避免arrayList插到开头的代价有点高, 所以从右往左生成所有的三元组, 把一个数塞在最后<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169284-19a38708-e6da-4a5e-bb4a-20a29232ee3c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=u9d26ce66&margin=%5Bobject%20Object%5D&originHeight=520&originWidth=1064&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f65a980-7862-4577-af50-86a27112905&title=&width=614"><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169425-e3392844-3840-45f1-9ab5-46624ba97638.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue27c0fc3&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=689&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc8ba67a7-38d3-4a72-af12-8e3c795c18e&title="></li></ol><p>| **public static **List&lt;List<Integer>&gt; threeSum(<strong>int</strong>[] nums) {<br>   Arrays.<em>sort</em>(nums);<br>   **int **N &#x3D; nums.<strong>length</strong>;<br>   List&lt;List<Integer>&gt; ans &#x3D; **new **ArrayList&lt;&gt;();<br>   **for **(**int **i &#x3D; N - 1; i &gt; 1; i–) { _&#x2F;&#x2F; 三元组最后一个数，是arr[i]   之前….二元组 + arr[i]<br>      _**if **(i &#x3D;&#x3D; N - 1 &amp;#124;&amp;#124; nums[i] !&#x3D; nums[i + 1]) {<br>         List&lt;List<Integer>&gt; nexts &#x3D; <em>twoSum</em>(nums, i - 1, -nums[i]);<br>         **for **(List<Integer> cur : nexts) {<br>            cur.add(nums[i]);<br>            ans.add(cur);<br>         }<br>      }<br>   }<br>   **return **ans;<br>}</p><p>_&#x2F;&#x2F; nums[0…end]这个范围上，有多少个不同二元组，相加&#x3D;&#x3D;target，全返回<br>&#x2F;&#x2F; {-1,5}     K &#x3D; 4<br>&#x2F;&#x2F; {1, 3}<br>_**public static **List&lt;List<Integer>&gt; twoSum(<strong>int</strong>[] nums, **int **end, **int **target) {<br>   **int **L &#x3D; 0;<br>   **int **R &#x3D; end;<br>   List&lt;List<Integer>&gt; ans &#x3D; **new **ArrayList&lt;&gt;();<br>   **while **(L &lt; R) {<br>      **if **(nums[L] + nums[R] &gt; target) {<br>         R–;<br>      } **else if **(nums[L] + nums[R] &lt; target) {<br>         L++;<br>      } **else **{ _&#x2F;&#x2F; nums[L] + nums[R] &#x3D;&#x3D; target<br>         _**if **(L &#x3D;&#x3D; 0 &amp;#124;&amp;#124; nums[L - 1] !&#x3D; nums[L]) {<br>            List<Integer> cur &#x3D; **new **ArrayList&lt;&gt;();<br>            cur.add(nums[L]);<br>            cur.add(nums[R]);<br>            ans.add(cur);<br>         }<br>         L++;<br>      }<br>   }<br>   **return **ans;</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-小朋友排队的最高分数"><a href="#·-小朋友排队的最高分数" class="headerlink" title="· 小朋友排队的最高分数"></a>· 小朋友排队的最高分数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652536502099-7223e529-c2d9-4f8f-a4a9-a6ab1fcd7ad3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=91&id=u6ea2c2e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22491&status=done&style=none&taskId=u67386263-86db-4666-a03d-34b0bd10782&title=&width=665.6" alt="image.png"><br>暴力递归，把所有的全排列(N!)搞出来, 分数最大的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537096712-968d9c3d-2f9f-44bc-b6e9-a801cf34a8ba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=ue4cc4511&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub1f9f15f-045e-4823-bf05-f159007dd6a&title=&width=597"></p><p>| **public static int <strong>process</strong>(int[][] **matrix,**int **index,**int <strong>score</strong>) {<br>    int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>    **int **ans &#x3D; 0;<br>    **if (**index &#x3D;&#x3D; matrix.**length) {<br>        return **score;<br>    <strong>} else {<br>        for (int <strong>i &#x3D; index; i &lt; matrix.<strong>length</strong>; i++</strong>) {<br>            int <strong>num &#x3D; 0;<br>            swap</strong>(<strong>matrix,index,i</strong>)</strong>;</p><pre><code>        **if (**i-1&gt;0 &amp;&amp; matrix**[**i**][**0**] **&gt; matrix**[**i-1**][**0**]) &#123;            **num += 1;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**]) &#123;            **num += 2;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**] **&amp;&amp; matrix**[**i+1**][**0**] **&gt; matrix**[**i**][**0**]) &#123;            **num += 5;        **&#125;        **ans = process**(**matrix,index+1,score+num**)**;        max = Math.max**(**max,ans**)**;        swap**(**matrix,index,i**)**;    **&#125;    return **max;**&#125;</code></pre><p>}<br>public static void <strong>swap</strong>(int[][] <strong>matrix,<strong>int <strong>i,<strong>int <strong>j</strong>) {<br>    int[] <strong>temp &#x3D; matrix</strong>[<strong>i</strong>]</strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>0</strong>] <strong>&#x3D; matrix</strong>[<strong>j</strong>][<strong>0</strong>]</strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>1</strong>] <strong>&#x3D; matrix</strong>[<strong>j</strong>][<strong>1</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>0</strong>] <strong>&#x3D; temp</strong>[<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>1</strong>] <strong>&#x3D; temp</strong>[<strong>1</strong>]**;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-❓乐队演出的最少花费"><a href="#·-❓乐队演出的最少花费" class="headerlink" title="· ❓乐队演出的最少花费"></a>· ❓乐队演出的最少花费</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537423682-efe033ec-3f72-424f-bde7-e5014b897bef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u4f042f4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43808&status=done&style=none&taskId=u0e6f551b-d211-4ea1-b57c-7c37cc19b72&title=&width=676" alt="image.png"><br>题意<br>乐队数量编号跟numbers*2是严格绑定的<br>nums&#x3D;5, 乐队数量下标一定是0~9<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448658-3dab8950-a21f-43a1-b17b-7ed848f64840.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=u7d539c9d&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uacdc5ae2-9463-4236-b703-588b8875dfa&title=&width=592"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448639-8358f990-06dd-4df5-92ae-7f64d89c5234.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=u8052bab1&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1124&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u76a2c942-9cfb-413c-87b0-e6c87ef102c&title=&width=585"><br>nums&#x3D;1, 一定有0,1两支乐队<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448741-b140f77d-7e96-44c8-84b8-5fc2a709c6d8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=285&id=u403bc2c5&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucb4940ea-7279-443e-9b7d-0ae124ea889&title=&width=583"><br>nums&#x3D;2, 一定有0,1, 2, 3 四支乐队<br>一个乐队只能在一个项目里被挑到，它不能同时为两个项目挑到, 把所有乐队都挑全, 返回最低报价</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448667-377bf58a-896b-4092-92b2-f8b2a5e09815.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=286&id=u32fa3de3&margin=%5Bobject%20Object%5D&originHeight=531&originWidth=1106&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u65c2b037-7834-4cf3-ab10-f0b6e2bf05e&title=&width=596"><br>题解<br>乐队数量16只, 任何两个乐队的组合为C_16^2, 共120种情况, 现在题目中有500组,<br>有大量冗余项目, 只选报价低的, 剩余的删掉<br>如果某个乐队不在报价中返回-1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448679-f9b98e3e-d745-4b02-bdae-869c77c67a26.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u6948a087&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=1137&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucaf4f2e9-9d3d-4a61-975f-3175ffd7c66&title=&width=589"><br>洗数据<br>调整乐队编号, 两个乐队最小值放第一位, 最大值放第二位, 最后是花费<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449231-9d45d470-a1c6-43c9-9588-469ca0f1e264.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u46433d67&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=1033&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8f5bb06b-f43c-4077-8a14-5d13c732d90&title=&width=647"><br>排序: 第一维小的排前面，第一维数据相等的，根据第二维数据小的排前面，前两维数据都相同的，<br>根据报价小的排前面<br>前两项一样的这一组，我只要第一个, 剩下的都删掉<br>把价格大的都删掉。两个乐队之间最低报价的留下来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449453-bf550b3c-8f14-4478-83d9-7deee2932b11.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=ud0a23bf4&margin=%5Bobject%20Object%5D&originHeight=491&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ee4650d-6457-4fb0-9ab1-c041cd0877a&title=&width=541"><br>暴力递归<br>通过size控制<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449574-6cc51376-eedc-4492-9837-2b7fe7a5137b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=441&id=u19699120&margin=%5Bobject%20Object%5D&originHeight=586&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue22b83d6-55e4-4b95-829f-40f960b64cd&title=&width=586"><br>可以用一个整数的二进制状态，表示哪个乐队挑了哪个没挑<br>一共就8组, 16个乐队<br>最低位就代表0号乐队挑没有挑, 上面如果是1代表挑了, 上面如果是 0 , 代表没挑</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449591-6da74ef6-513b-4524-9b3a-b672e0db5668.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=u2fe508db&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1006&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94eb5d67-dd4e-4672-9456-0ae104e69b9&title=&width=554"><br>乐队全挑是啥样？<br>应该是某一个整数，后面 16 位全是1，前面 16 位全是0。这个状态就表示你所有的都挑到了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449813-4c4d0188-00e0-4d90-94b2-91dde3d4e2ee.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=u2abab5d3&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7278723a-a0c2-4568-a86d-a0851da4baf&title=&width=555"><br>之前 5 位置的 5 乐队已经考虑过了，此时的项目无论如何不能考虑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449921-dabce459-c444-48ca-9b0d-38842a88bea8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=276&id=u91c52048&margin=%5Bobject%20Object%5D&originHeight=543&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69d7ed52-13ce-44af-b614-77ad78833ad&title=&width=534"><br>不能改动态规划, 可变参数太多了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450094-53b89c36-d138-4950-9855-9eb41da56b81.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaefbf1e8&margin=%5Bobject%20Object%5D&originHeight=1189&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f03743c-eabf-4d20-b806-7572874a0d2&title="><br>优化<br>可以省掉done参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450158-14d02b8e-1908-4948-8d94-927946c3838e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4a13716a&margin=%5Bobject%20Object%5D&originHeight=369&originWidth=825&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1a8774c-e654-4e8e-80e7-5bbedb5bdff&title="><br>复杂度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450320-12c34c5a-b718-43e3-b910-ce5cd6be6e48.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5fa9848d&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0d5c8479-84af-4bde-b87e-fdc85878b0a&title="><br><br>分治<br>复杂度<br>一共 120 个项目挑 8 个项目就停。<br>C_{120}^8_C_1208 超过 10^8了, 这个方法不行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450494-e0629605-12c2-45c0-ba4d-8981a6fc2e84.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue97cf8a0&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u40393ab8-0e3f-4b26-ae96-d80c6c2c4d1&title="><br>特殊情况, num&#x3D;7<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450801-bf9dd979-4d42-4c30-9acd-45c6b4e7f866.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u628d5bce&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u16e23e4a-120c-4887-adee-11b29cab4e1&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450938-6f42c655-5387-4db9-b9db-d38ddc55848f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7ea57ad3&margin=%5Bobject%20Object%5D&originHeight=767&originWidth=713&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u340a0fea-3523-4622-b767-bc6d89db7eb&title="></p><h2 id="·-❓题目2-企鹅的最少数量-781-森林中的兔子-M"><a href="#·-❓题目2-企鹅的最少数量-781-森林中的兔子-M" class="headerlink" title="· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]"></a>· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537527351-44459aaf-41e1-458d-bae2-5ce71a0191b1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=176&id=u67946780&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40177&status=done&style=none&taskId=u47ce9f2e-8b46-4f21-a705-0ea9eefe640&title=&width=637.6" alt="image.png"><br>题意</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-b877c03c-a285-4712-9615-258c243e8ed7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u5b0b2b90&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufafc36af-a0b5-4e28-9db2-89eb9b6b178&title=&width=570"><br>a,b必然不同<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512800-25772203-c346-4bbe-8237-30518dbdb60b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9a8e07f0&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=228&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c66b2ce-92ce-46a9-b14b-4a3751310b8&title="><br><br>题解<br><br>排序, 让说的一样数量的人在一起<br>自我消化<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-cf987f51-87b0-448b-ac46-e9d5faf98eb3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=uaaa8f52f&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=1092&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud38b542a-cec3-4e17-b52e-70e2f50bd8f&title=&width=570"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512924-12bacc17-7f26-4686-85f0-7f71db1bfa89.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=uf697393a&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7604ddcd-7966-4e3a-b5d3-8f4cabf5c5a&title=&width=573"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512826-891ffc75-377e-4fc5-9d7a-da4028ceae6f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u2a3485d2&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6df243e7-fbc7-4a92-ab5c-bae5a440dbc&title=&width=559"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513286-e4853f30-976d-4afb-a9c2-1c0843765303.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=uc338299f&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf7ddc6e6-1972-40c5-8878-9a5754d7b21&title=&width=553"><br>规律, 如果当前数是x, 有c个, 有几组?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513383-501045f8-319a-4179-b47c-9c0c02e0badf.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u5d11b8c0&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=869&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4c2f6b9e-c173-4c10-9c13-75c4fbdd5e3&title=&width=503"><br>a&#x2F;b怎么向上取整<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513552-6e8d37f3-9848-4900-8eda-b864d1d22c3c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u20f90519&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=1146&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u396d7a21-be1d-44e9-877e-02a28b7fadc&title=&width=525"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513704-ac750a4e-7f0b-4700-8c7d-443c6aff347c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ucf35688f&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u103b599a-2ac9-4946-ae00-a479d0b8f24&title=&width=560"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513881-861b81c5-c61d-4e5d-92f4-e7f56b5dc042.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=150&id=u74b861b9&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75cc545e-f180-4c5d-90b8-b2e36446e6f&title=&width=544"><br>代码<br>不能约<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514082-45e66cf1-cbdf-48bd-80ce-7343743b8fca.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u32d23b83&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1010&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1f8888e6-27db-45fb-867a-dc516aff8af&title=&width=503"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514370-fba438f5-6e52-45a9-b7ff-ffe1427d7e10.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udbfd29aa&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=447&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u877d5405-cfd1-4b2e-b825-ffe2521430e&title="></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2022/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>多练的代码也就是不容易写出来的：✊<br>困难的代码：😡<br>了解：👌</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>PriorityQueue**&lt;**Node**&gt; **heap &#x3D; **new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) **-&gt; a.**value **- b.<strong>value)</strong>;<br>要练熟的代码：</p><p>排序：Arrays.sort()<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650254542022-b29c6afb-07da-458f-aad0-d9195e2cbb60.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=37&id=BvypH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=46&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29461&status=done&style=none&taskId=ue1e9cf3b-75fb-4abc-a0d2-566f55d0aec&title=&width=466.4" alt="image.png"></p><p>子串子数组想到以i结尾往左推 class3例子</p><h2 id="·-返回离非负整数num最近的2的某次方"><a href="#·-返回离非负整数num最近的2的某次方" class="headerlink" title="· 返回离非负整数num最近的2的某次方"></a>· 返回离非负整数num最近的2的某次方</h2><p><strong>题意</strong><br>num&#x3D;7, 返回8   num&#x3D;8，返回8   num&#x3D;13，返回6<br><strong>题解</strong><br>二进制第一个1后面全部填充完1后加1返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606374038-5dc3bdff-f8db-4cea-b539-13bc0f241519.png#clientId=u24411928-8d24-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=348&id=u6f518ae8&margin=%5Bobject%20Object%5D&name=DEF082573F9BE5D1BD2D58935BF11CDD.png&originHeight=1166&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=328379&status=done&style=none&taskId=uc329201a-a346-4a48-9408-2ab96b91a62&title=&width=448.2857666015625" alt="DEF082573F9BE5D1BD2D58935BF11CDD.png"></p><p>| &#x2F;&#x2F; 已知n是正数<br>&#x2F;&#x2F; 返回大于等于，且最接近n的，2的某次方的值<br>public static final int tableSizeFor(int n) {<br>   &#x2F;&#x2F;这个是为了如果正好是2的某次方，打散！！<br>   n–;<br>   &#x2F;&#x2F;&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补0。<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 1;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 2;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 4;<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 8;<br>   &#x2F;&#x2F;整型最多32位<br>   n &amp;#124;&#x3D; n &gt;&gt;&gt; 16;<br>   return (n &lt; 0) ? 1 : n + 1;&#x2F;&#x2F;负数最高位是1，填满32个1，返回1</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-相邻字符的交换次数"><a href="#·-相邻字符的交换次数" class="headerlink" title="· 相邻字符的交换次数"></a>· 相邻字符的交换次数</h2><p><strong>题意</strong><br>刻意的说两个标准, 搞你一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704873615-836bf286-fab2-47cb-8817-a817f740da5d.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=70&id=u73201307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=88&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19948&status=done&style=none&taskId=ub30207ba-f24d-4b60-884e-75662524657&title=&width=660.8" alt="image.png"><br><strong>题解</strong><br>贪心:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704850684-0c6b231e-483f-4ad1-99fb-9b7d76b6ffc9.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u5d3653f9&margin=%5Bobject%20Object%5D&originHeight=398&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u976907e3-3bde-438a-891c-5605344be3c&title=&width=556"><br><strong>两个指针</strong><br>index: 往右扫, 不是G就往右飘<br>L: 如果发现了放到哪儿的位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606588940-7b194664-6549-49a7-bec8-3209b6c93f08.png#clientId=u24411928-8d24-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=249&id=uab987630&margin=%5Bobject%20Object%5D&name=39A8E84629C793605662823ED198A9D4.png&originHeight=718&originWidth=1126&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126502&status=done&style=none&taskId=uc016d720-79cd-42d8-8978-bf6dafda160&title=&width=390.2857666015625" alt="39A8E84629C793605662823ED198A9D4.png"><br>如何确定这是最优解?<br>这个过程, L, index都不回退, 复杂度O(N)<br>原题: 你可以选择让 G 在左边B 在右边或者你可以选择让 B 在左边G在右边哪种更省。<br>哪种更剩你用哪种, 问你最小的用代价</p><p>| _&#x2F;&#x2F; 可以让G在左，或者在右<br>_**public static int **minSteps2(String s) {<br>   **if **(s &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; s.equals(</strong>“”</strong>)) {<br>      **return **0;<br>   }<br>   <strong>char</strong>[] str &#x3D; s.toCharArray();<br>   **int **step1 &#x3D; 0;<br>   **int **step2 &#x3D; 0;<br>   **int **gi &#x3D; 0;<br>   **int **bi &#x3D; 0;<br>   **for **(**int **i &#x3D; 0; i &lt; str.<strong>length</strong>; i++) {<br>      **if **(str[i] &#x3D;&#x3D; <strong>‘G’</strong>) { _&#x2F;&#x2F; 当前的G，去左边   方案1<br>         <em>step1 +&#x3D; i - (gi++);<br>      } **else **{</em>&#x2F;&#x2F; 当前的B，去左边   方案2<br>         _step2 +&#x3D; i - (bi++);<br>      }<br>   }<br>   **return **Math.<em>min</em>(step1, step2);</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-无序数组需要排序的最短子数组长度"><a href="#·-无序数组需要排序的最短子数组长度" class="headerlink" title="· 无序数组需要排序的最短子数组长度"></a>· 无序数组需要排序的最短子数组长度</h2><p><strong>题意</strong><br>想让整体有序<br>时间复杂度 O(N)额外空间复杂度O(1)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710897296-aa25c260-3795-403f-a63d-abcb51e33ff8.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u907fe5bc&margin=%5Bobject%20Object%5D&originHeight=593&originWidth=1216&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e7d06d1-a6cb-4207-a123-ea9ca887b8c&title=&width=477"><br><strong>题解</strong><br>最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654696304737-51815bbc-5fb1-4258-8122-5b4218ecc06f.png#clientId=uaf1c0b48-9cd0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=2891&id=u37b19965&margin=%5Bobject%20Object%5D&name=63E3A64272C54C218FDD9192B70053CB.png&originHeight=5059&originWidth=1612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=673473&status=done&style=none&taskId=u1c723737-203b-4864-b838-1417ede3aeb&title=&width=921.1428571428571" alt="63E3A64272C54C218FDD9192B70053CB.png"><br>需要排序范围2~5<br>你第一回从左往右遍历最右的违规，然后从右往左遍历最左的违规这之间需要排序。</p><p>左面max&lt;&#x3D;当前数, 比如左max&#x3D;6, 最后8,9是对号, 说明如果真要排序的话, 8不必给前面的最大值让位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898543-234a31d2-30e8-43f4-8676-33e52a7b9d25.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u2443991c&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90eff19c-58f3-47d7-a63a-a785a4fd9f9&title=&width=572"><br>9不必给前面的最大值让位置<br>10也不必给前面的最大值让位置<br>你后面连续的对号说明如果真的排序的话，它们动都不需要动<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898593-d8fbbadb-d557-419e-867b-23549142645e.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=u9fabbcb7&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1258&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6eca0a4-35e4-44ff-9ecc-aeb906a1b14&title=&width=631"><br>从右往左滑同理, 最左的对号说明在往左一直到开头全是对号,<br>说明如果真的排序的话，这些数据也不用给右边部分的最小值让位置。<br>你确定了一个右边不需要排的部分, 确定了一个左边不需要排的部分，那中间就是需要排序的部分, 搞定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898762-58901f0c-bbed-431c-a9f4-1bbd7fea4661.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u670e797a&margin=%5Bobject%20Object%5D&originHeight=609&originWidth=1212&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4471b33b-6b3d-4372-8a6b-4a2b4749e8c&title=&width=484"><br>第一个X到最后一个X中间直接排序不行吗?<br>不行, 因为你只关注了最大值, 例子中8没有人处理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710899406-b03a72c2-596b-40b2-b0a1-9d726f5d16a4.png#clientId=u5ffea8cf-8d32-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u033c7053&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=1204&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u59606f10-dbf2-4450-924e-ed0813e7169&title="></p><p>| **public static int **findUnsortedSubarray2(<strong>int</strong>[] nums) {</p><p>   **if **(nums &#x3D;&#x3D; **null **&amp;#124;&amp;#124; nums.**length **&lt; 2) {<br>      **return **0;<br>   }<br>   **int **N &#x3D; nums.<strong>length</strong>;<br>   **int **right &#x3D; -1;<br>   <strong>int <strong>max &#x3D; Integer.</strong><em>MIN_VALUE</em></strong>;</p><p>   **for **(**int **i &#x3D; 0; i &lt; nums.**length**; i++) {<br>      **if **(nums[i] &gt;&#x3D; max) {<br>         max &#x3D; nums[i];<br>      } **else **{<br>         right &#x3D; i;<br>      }</p><p>   }<br>   **int **left &#x3D; N;<br>   <strong>int <strong>min &#x3D; Integer.</strong><em>MAX_VALUE</em></strong>;</p><p>   **for **(**int **i &#x3D; N - 1; i &gt;&#x3D; 0; i–) {<br>      **if **(nums[i] &lt; min) {<br>         min &#x3D; nums[i];<br>      } **else **{<br>         left &#x3D; i;<br>      }<br>   }<br>   **return **Math.<em>max</em>(0,right-left+1);</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-字符串种类"><a href="#·-字符串种类" class="headerlink" title="· 字符串种类"></a>· 字符串种类</h2><p>你只有26种字符，一个整数是不是有32位了，<br>你就拿这个整数的第0位表示a从没出现过，它是1是出现过，它是0就没出现过，<br>你拿这个整数第1位表示b拿这个整数，第2位表示c拿一个整数，第25位表示z，<br>你还结余了这么多倍不用了，那你的摘要是不是就不用是str类型了，变成一个<br>整数就可以表示一个摘要了<br>最后看这个set中留下了多少不同的整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351350-dc64aa66-e5f5-44a0-a5d7-96736ca8680d.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=207&id=u5fa830fc&margin=%5Bobject%20Object%5D&originHeight=582&originWidth=1183&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue6d9144b-3a7b-4eca-8c40-f73d1b2aa6d&title=&width=420"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351667-30911ef7-b885-449e-ab70-5c2e626b1445.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u6191cdd4&margin=%5Bobject%20Object%5D&originHeight=257&originWidth=422&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uece8ee91-b5ee-4851-a947-dd631519c75&title=&width=358"></p><h2 id="·-最大的以-1-为边界的正方形-M"><a href="#·-最大的以-1-为边界的正方形-M" class="headerlink" title="· 最大的以 1 为边界的正方形 [M]"></a>· 最大的以 1 为边界的正方形 [M]</h2><p><strong>题意</strong><br>边框全是1就达标，它不要求内部也有1, 内部有1, 也可以没有1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-9c36b203-d37d-46a9-9483-0348e3180719.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=ub37f09bb&margin=%5Bobject%20Object%5D&originHeight=578&originWidth=1082&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a91b9c9-d45e-406e-9103-c6290e2fc15&title=&width=427"><br><strong>题解</strong><br>预处理数组技巧</p><p><strong>前置</strong><br>N<em>N区域中长方形正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399168-04bf1552-399a-4c84-9e06-1ba7badf959e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=151&id=ud0e60c23&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=1167&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1bf94e4e-6018-42e3-bfac-44286cc6e9a&title=&width=311.0000305175781"><br>N</em>N区域中正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399176-f2349f13-30c8-4f6b-8779-a086f36cb16e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=163&id=u2f2a5857&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1160&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a4e536e-ea47-4b8f-acd2-17bb7283331&title=&width=359"><br><strong>代码</strong><br>所以边长的枚举一定是哪个少，就到那个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-09736a59-aa8a-4393-b496-335dd697275c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u3d7bd96a&margin=%5Bobject%20Object%5D&originHeight=501&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u924c016e-b4a5-492d-890b-d66b64c878a&title=&width=403"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399153-31e8e2ec-e0f7-4ab7-a328-8b2e74742a8f.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u6d60a1cb&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1011&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0b2a46c-d586-4bff-99d6-7555284bbb0&title=&width=414"><br>当我们点一个点的时候，我们只要那个长方形，它往右下方向拉, 然后看你能拉多远<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401624-62771dcc-0e46-4e02-95be-f03c4a11dd8d.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u20bd98fa&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=741&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9ee39ed7-94fc-449b-ba80-16d2550e136&title=&width=487"><br>验证过程能不能快一点 O(1)内<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401970-88428577-d5a9-4b70-8787-83d3001063ea.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uada68211&margin=%5Bobject%20Object%5D&originHeight=304&originWidth=692&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua0608d42-bb77-46f4-b982-6c6e649dd36&title="><br>假设我知道任何一个(i,j)位置右边有多少个连续的1, 下方有多少个连续的1(包括自己在内)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402673-739ba559-43f0-4cfc-9907-3a8c7357f9aa.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=359&id=uda259ca9&margin=%5Bobject%20Object%5D&originHeight=603&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uef3ee539-2f80-47f9-813c-47d085e71b8&title=&width=399"><br>17,29的左上顶点, 边长是7的这么一个正方形。<br>怎么验证?<br>你先看看(7,29)右方连续的1够不够 7 个，你再看看(7,29)这个点下方连续的1够不够 7个<br>…<br>只需要调出这 3 个点的信息, O(1)的过程<br>接下来就是求任何一个(i,j)点，让它右方和下方有这个信息</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402900-dc768550-cd1a-4853-a5d8-f871f5fcabfc.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=uc6970c91&margin=%5Bobject%20Object%5D&originHeight=547&originWidth=995&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08ef4750-7959-4b40-969e-e9a6bda8fc0&title=&width=572"><br>怎么求这个信息呢?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781186419-16a3698d-6e4e-4407-9643-68dfc9156b32.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=810&id=u0773d943&margin=%5Bobject%20Object%5D&name=8594CD1133E89D6E5D0DE8C781C7E60E.png&originHeight=1418&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=457290&status=done&style=none&taskId=ub2bac3a4-0128-47f0-b5ea-c0907f659e3&title=&width=590.8571428571429" alt="8594CD1133E89D6E5D0DE8C781C7E60E.png"><br>咋知道这个O(N^3)的解需不需要继续优化?<br>矩阵规模告诉你, 最多100*100, 你拿N^3一套没到10^8这个级别,<br>你知道O(N^3)的这个解不需要再优化了, 这个题目必过.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403570-4bf72a85-3dce-4515-959c-f1866430fbbd.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8da21f2c&margin=%5Bobject%20Object%5D&originHeight=63&originWidth=246&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc724a96e-b8cd-4797-97b5-7198d88597b&title="></p><p>怎么想到是预处理数组呢?<br>当写完3个for循环之后, 底层一个正方形再验的时候不想再遍历了,<br>势必会设计一种查询的结构来支持它, 不让它遍历来保证O(1)<br>这就是思想的开端,<br>预处理数组怎么用?<br>就是当你最后卡在最后一步，一个小的元件需要遍历搞定，这样的时候特别的多，<br>你就想着我怎么样做出一个能够提前查询的结构，到这一步的时候把遍历省掉, 比如前缀数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403652-75a89599-d8f8-43a3-a1e1-5d2643008a8c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=ub5033baf&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=884&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1f7af3b0-f56a-4be7-b7cc-baeebc9e05a&title=&width=492"></p><p>| **public static int <strong>largest1BorderedSquare</strong>(int[][] <strong>m</strong>) {<br>   int[][] **right &#x3D; **new int[**m.<strong>length][<strong>m</strong>[<strong>0</strong>]</strong>.<strong>length]</strong>;<br>   **int[][] <strong>down &#x3D; <strong>new int[<strong>m.<strong>length][<strong>m</strong>[<strong>0</strong>]</strong>.<strong>length]</strong>;<br>   &#x2F;&#x2F;&#x3D;&#x3D;生成右信息 下信息<br>   setBorderMap</strong>(<strong>m, right, down</strong>)</strong>;<br>   <strong>for (int <strong>size &#x3D; Math.min</strong>(<strong>m.<strong>length</strong>, m</strong>[<strong>0</strong>]</strong>.<strong>length)</strong>; size !&#x3D; 0; size–</strong>) {<br>      if (<strong>hasSizeOfBorder</strong>(<strong>size, right, down</strong>)) {<br>         return **size * size;<br>      **}<br>   }<br>   return **0;<br>**}<br>**<img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781251250-6c80220e-fc56-430a-b4c9-377e6c3fa002.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=455&id=uadd39646&margin=%5Bobject%20Object%5D&name=image.png&originHeight=797&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&size=221761&status=done&style=none&taskId=udef49ab0-cccf-4360-9f48-ec0dcec606e&title=&width=568.5714285714286" alt="image.png">****public static void <strong>setBorderMap</strong>(int[][] **m, **int[][] **right, **int[][] <strong>down</strong>) {<br>   int **r &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>c &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   &#x2F;&#x2F;右下角<br>   **if (<strong>m</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>      <strong>right</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] <strong>&#x3D; 1;<br>      down</strong>[<strong>r - 1</strong>][<strong>c - 1</strong>] **&#x3D; 1;<br>   **}<br>   **&#x2F;&#x2F;最右侧的数据<br>   **for (int <strong>i &#x3D; r - 2; i !&#x3D; -1; i–</strong>) {<br>      if (<strong>m</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>         <strong>right</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D; 1;<br>         &#x2F;&#x2F;等于1的话九四下一行加1<br>         down</strong>[<strong>i</strong>][<strong>c - 1</strong>] <strong>&#x3D; down</strong>[<strong>i + 1</strong>][<strong>c - 1</strong>] **+ 1;<br>      **}<br>   }<br>   **&#x2F;&#x2F;最后一行的数据<br>   **for (int <strong>i &#x3D; c - 2; i !&#x3D; -1; i–</strong>) {<br>      if (<strong>m</strong>[<strong>r - 1</strong>][<strong>i</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>         <strong>right</strong>[<strong>r - 1</strong>][<strong>i</strong>] <strong>&#x3D; right</strong>[<strong>r - 1</strong>][<strong>i + 1</strong>] <strong>+ 1;<br>         down</strong>[<strong>r - 1</strong>][<strong>i</strong>] **&#x3D; 1;<br>      **}<br>   }<br>   **&#x2F;&#x2F;然后从倒数第二行开始，从倒数第二列往前一行一行的推 &lt;–  ^<br>   **for (int <strong>i &#x3D; r - 2; i !&#x3D; -1; i–</strong>) {<br>      for (int <strong>j &#x3D; c - 2; j !&#x3D; -1; j–</strong>) {<br>         if (<strong>m</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D;&#x3D; 1</strong>) {<br>            <strong>right</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D; right</strong>[<strong>i</strong>][<strong>j + 1</strong>] <strong>+ 1;<br>            down</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&#x3D; down</strong>[<strong>i + 1</strong>][<strong>j</strong>] **+ 1;<br>         **}<br>      }<br>   }<br>}</p><table><thead><tr><th>**</th></tr></thead></table><p>| **public static boolean <strong>hasSizeOfBorder</strong>(int **size, **int[][] **right, **int[][] <strong>down</strong>) {<br>   for (int **i &#x3D; 0; i !&#x3D; right.<strong>length <strong>- size + 1; i++</strong>) {<br>      for (int <strong>j &#x3D; 0; j !&#x3D; right</strong>[<strong>0</strong>]</strong>.**length <strong>- size + 1; j++</strong>) {<br>         **&#x2F;&#x2F;找那三个点！！  左上的那个点              下方的那个点<br>         <strong>if (<strong>right</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size &amp;&amp; down</strong>[<strong>i</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size &amp;&amp; right</strong>[<strong>i + size - 1</strong>][<strong>j</strong>] <strong>&gt;&#x3D; size<br>               &#x2F;&#x2F;右边的那个点<br>               &amp;&amp; down</strong>[<strong>i</strong>][<strong>j + size - 1</strong>] <strong>&gt;&#x3D; size</strong>) {<br>            return true</strong>;<br>         <strong>}<br>      }<br>   }<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-乘客坐船使用的最少船数"><a href="#·-乘客坐船使用的最少船数" class="headerlink" title="· 乘客坐船使用的最少船数"></a>· 乘客坐船使用的最少船数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266540654-bc52c017-346b-4c9c-ba85-2f8363a2f43d.png#clientId=u99096dab-5d58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=123&id=u90d68d8f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20339&status=done&style=none&taskId=ua7a2c8fd-24f1-479b-b9e4-4bb22b8c84a&title=&width=412.8" alt="image.png"><br><strong>题意</strong><br>每艘船最多坐两人，且不能超过载重。问你让所有人同时过河，并且用最好的分配方法，<br>使船尽量少返回最少的船数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754920033-d23a14f3-997f-4f13-a9f0-7b561f79d2f2.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u96abc735&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1151&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25fc0b67-d916-4e77-8078-1029b98c178&title=&width=428"><br><strong>题解</strong><br>你先遍历一遍数组，如果有单独一个人的体重已经超过了limit返回无穷大。<br>多少条船都搞不定的<br><strong>流程</strong><br>先排序<br>从中间分界点开始往左右两边滑</p><p>找&lt;&#x3D;limit&#x2F;2最右的位置, 做为L指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919993-2fc7575c-c414-4b7e-a832-5bf0bcb40ff6.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=ufb0881ef&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75a44641-53ce-4de8-8f74-8ac55b102d0&title=&width=446"><br>R指针: 第一个超过limit&#x2F;2的位置<br>看L位置和R位置能否凑一个船, 不能, 超了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919953-4a90aa2e-3033-4477-8930-018ff980a464.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u95912d5e&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1102&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue7bf048f-aaa8-4400-803d-9d57b976d24&title=&width=538"><br>L往左飘, L来到3, 可以<br>先不忙分配船, R往右滑, 一直划到R再往下进一个就没有办法跟 3凑一船为止<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919952-f9d1b099-1792-43c3-931a-0e97bdbaec96.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u65f47ec7&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1076&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u854235fa-c1f2-44a8-9746-bc7d404a688&title=&width=522"><br>贪心的核心点:<br>从3出发往左数6个的这6个，去消化这6个，一定是最省的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919986-6ed6fbd8-2c1a-41ba-9150-e1e3bb4a60e3.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u93e568a4&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1162&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u91791187-7421-4fec-b6c7-edf0f6db13c&title=&width=445"><br><strong>例子1: 右侧先耗尽</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921589-39ec9db9-b791-4250-84a0-959f28c10384.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u89cdb406&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5babd024-fc3f-4e18-897a-c9982047463&title=&width=475"><br>俩对号装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921991-8f261b8f-5962-4c73-85b3-f6a17ed90471.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u2d0e63b4&margin=%5Bobject%20Object%5D&originHeight=558&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08d96e78-dff0-43b7-a5d1-52d57f628ed&title=&width=503"><br>X号两两可以装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922406-6a35f17e-24ef-4b59-92c8-c94d60e2eeaa.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u608ae23c&margin=%5Bobject%20Object%5D&originHeight=548&originWidth=1040&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud57e21a5-c48a-4d3e-a609-646cb20f153&title=&width=439"><br><strong>例子2: 左侧先耗尽</strong><br>最后对号的数量除2，加上×号的数量除2(向上取整)，加上右侧剩几个数它们一定单独一艘船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922475-c578911c-83dd-4b73-a887-e8c5088bf359.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=u2c8f3183&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=1191&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua593a755-3782-413c-ab6c-595e375b6c0&title=&width=456"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654782938733-ff5ae0ad-f593-4836-8ee2-b595c618751a.png#clientId=u514a968e-c04c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=867&id=u98f15db6&margin=%5Bobject%20Object%5D&name=2B163C063CD4521C4323347FAFB38F50.png&originHeight=1518&originWidth=1036&originalType=binary&ratio=1&rotation=0&showTitle=false&size=511608&status=done&style=none&taskId=uee0c2454-79c7-4464-a51a-0459a5ae855&title=&width=592" alt="2B163C063CD4521C4323347FAFB38F50.png"></p><p>| public static int numRescueBoats(int[] arr, int limit) {<br>   if (arr &#x3D;&#x3D; null &amp;#124;&amp;#124; arr.length &#x3D;&#x3D; 0) {<br>      return 0;<br>   }<br>   int N &#x3D; arr.length;<br>   Arrays.sort(arr);<br>   if (arr[N - 1] &gt; limit) {<br>      return -1;<br>   }<br>   int lessR &#x3D; -1;<br>   &#x2F;&#x2F;找到 最左侧里 limit&#x2F;2最接近的数<br>   for (int i &#x3D; N - 1; i &gt;&#x3D; 0; i–) {<br>      if (arr[i] &lt;&#x3D; (limit &#x2F; 2)) {<br>         lessR &#x3D; i;<br>         break;<br>      }<br>   }<br>   if (lessR &#x3D;&#x3D; -1) {<br>      return N;<br>   }<br>   int L &#x3D; lessR;<br>   int R &#x3D; lessR + 1;<br>   int noUsed &#x3D; 0;<br>   while (L &gt;&#x3D; 0) {<br>      int solved &#x3D; 0;&#x2F;&#x2F;用来更新L下标的<br>      while (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;&#x3D; limit) {<br>         R++;<br>         solved++;<br>      }<br>      &#x2F;&#x2F;表示上述结束了右边没有一个能和当前的L乘坐<br>      if (solved &#x3D;&#x3D; 0) {<br>         noUsed++;&#x2F;&#x2F;左侧未使用的<br>         L–;<br>      } else {<br>         L &#x3D; Math.max(-1, L - solved);<br>      }<br>   }<br>  &#x2F;&#x2F;下面的要用具体的例子来换算下标<br>   int leftAll &#x3D; lessR + 1;&#x2F;&#x2F;理解的好方法：因为数组是下标0开始的 +1就表示左侧的全部数量<br>   int leftUsed &#x3D; leftAll - noUsed;&#x2F;&#x2F;左侧的全部数量-未使用的就是使用的<br>   &#x2F;&#x2F;右侧还剩下未使用的<br>   int rightUnsolved &#x3D; (N - all) - used;<br>   return used + ((noUsed + 1) &gt;&gt; 1) + moreUnsolved;</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-子数组最大累加和"><a href="#·-子数组最大累加和" class="headerlink" title="· 子数组最大累加和"></a>· 子数组最大累加和</h2><p><strong>题解</strong><br>看到子数组子串想想每个位置结尾是答案是什么<br>如果子数组必须以0结尾, 它往左扩到什么程度，能让累加和最大<br>如果子数组必须以1位置结尾, 它往左扩到什么程度，能让累加和最大</p><p><strong>大流程</strong><br><strong>可能性划分</strong><br>必须以i位置结尾答案可能来自什么?</p><ol><li>完全不向左扩, 只有自己<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677717-e5aafff1-1b52-4e5e-80db-0a14e490e373.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=194&id=uea3b3eb0&margin=%5Bobject%20Object%5D&originHeight=389&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u498816dd-5c0d-429b-81ef-e611245e7c0&title=&width=489"></li><li>要向左扩， i-1结尾的时候扩出来的最好决定了当前能扩出来的最好<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677743-cc8cf0a5-a0c2-459a-abbe-6d083b658117.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=315&id=ue16cd42f&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=863&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89741c3c-0ea1-41a0-8082-0ac2dd610c1&title=&width=559"><br><strong>例子</strong><br>dp[i]: 必须以i位置的数结尾的时候最好累加和多少<br>dp中的max就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677733-ba8e98b6-b4cd-4ab5-8570-929835020c5b.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u3525b401&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1029&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udbb81fdc-2585-4a4b-9adb-f55a90e2193&title=&width=470"><br><strong>代码</strong><br>没有必要准备一整个 BP 有几个变量滚动更新下去就完了<br>因为它只依赖左边的一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756678781-859e8520-7df4-4d2f-887d-9be3467f97b0.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubf36503d&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=788&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u515da530-1d5b-46cd-8343-4404bd2aed8&title="></li></ol><h2 id="·-😡子矩阵最大累加和-H"><a href="#·-😡子矩阵最大累加和-H" class="headerlink" title="· 😡子矩阵最大累加和 [H]"></a>· 😡子矩阵最大累加和 [H]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655000610147-a7d3a92b-d3ae-4465-94ce-a8a8d694215c.png#clientId=u7bc39c19-43ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=313&id=u0e2403c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92137&status=done&style=none&taskId=u927eb0d4-d5e2-468d-8556-18104e0bc5a&title=&width=668.5714285714286" alt="image.png"><br><strong>题解</strong><br>大流程<br>矩形必须包含第0行数据, 且只包含第0行的情况下, 最大累加和是多少?<br>矩形必须包含0,1两行数据, 且只包含0,1两行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2三行数据, 且只包含0,1,2三行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2,3四行数据, 且只包含0,1,2,3四行的情况下, 最大累加和是多少?<br>….<br>然后<br>1行<del>1行<br>1行</del>2行<br>1行<del>3行<br>1行</del>4行<br>…<br>然后<br>2行<del>2行<br>2行</del>3行<br>2行<del>4行<br>…<br>然后<br>3行</del>3行<br>…<br>然后<br>4行~4行<br>如果我们能够每一个都求出来，答案一定在其中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884708-799a0b20-7c1c-47b3-977e-90592414790a.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u0156074e&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7b53efdb-4fdf-4833-8ad0-bd3bc9bb71d&title=&width=432"><br>如果我们能够每一个都求出来答案一定在其中</p><p>压缩数组技巧<br>0行<br>必须包含第0行数据，且只有第0行情况下画框, 最大累加和多少?<br>就是子数组的最大累加和问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884722-2be04454-65aa-4ab1-bf9a-f9b97da2206c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4164a828&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1f9b8e9-8a11-4a1f-9e61-14d37d138b3&title=&width=554"><br>下面<br>矩形必须包含0, 1两行数据, 且只包含0, 1两行的情况下, 最大累加和是多少?<br>两行上下数据压在一起,形成一个新数组<br>对这个数组求最大累加和就代表必须包含0, 1两行数据，且只包含01两行数据画框的最好答案是啥。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884649-aa42ef84-bb7a-4136-98bb-9fd3691bc443.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ude7883e6&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2740ec61-35a4-4813-9a55-36c15b2fcb8&title=&width=526"><br>复杂度O(行^2*列)<br>在行上玩了一个O(行^2)的事<br>0<del>0<br>0</del>1<br>…<br>1<del>1<br>1</del>2<br>…<br>但你每次解决一个子任务它就是过一遍数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884664-75b98c0a-3eaa-493f-bfb2-184b1e00835a.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=ue4e4a946&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u95e57951-deb2-47df-983f-7072b817740&title=&width=506"><br>进一步优化: 让行列小的当平方项<br>如果是5行, 100列, 选择让行做平方项<br>如果是100行, 5列, 选择让列做平方项</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884772-ba08c36e-d98b-45f2-8291-2432422e914c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=uf99229ea&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=1061&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a44cb24-c550-46f5-888f-c474dd72d23&title=&width=559"><br><strong>代码</strong></p><p>| **public static int <strong>maxSum</strong>(int[][] <strong>m</strong>) {<br>   if (**m &#x3D;&#x3D; **null **&amp;#124;&amp;#124; m.<strong>length <strong>&#x3D;&#x3D; 0 &amp;#124;&amp;#124; m</strong>[<strong>0</strong>]</strong>.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   **&#x2F;&#x2F; O(N^2 * M)<br>   **int **N &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      **&#x2F;&#x2F; i行~j行<br>      **int[] **s &#x3D; <strong>new int[<strong>M</strong>]</strong>;<br>      <strong>for (int <strong>j &#x3D; i; j &lt; N; j++</strong>) {<br>         for (int <strong>k &#x3D; 0; k &lt; M; k++</strong>) {<br>            <strong>s</strong>[<strong>k</strong>] <strong>+&#x3D; m</strong>[<strong>j</strong>][<strong>k</strong>]</strong>;<br>         <strong>}<br>         <strong>max &#x3D; Math.max</strong>(<strong>max, maxSubArray</strong>(<strong>s</strong>))</strong>;<br>      **}<br>   }<br>   return **max;<br>**}</p><p>public static int <strong>maxSubArray</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   <strong>int <strong>cur &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>cur +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      max &#x3D; Math.max</strong>(<strong>max, cur</strong>)</strong>;<br>      cur &#x3D; cur &lt; 0 ? 0 : cur;<br>   **}<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>LeetCode原题<br>需要返回最大累加和矩形的左上角跟右下角点<br>当你发现了更大的答案， 你把它左上角点跟右下角点抓一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655001837943-7e030c8e-9549-42e0-a28a-31e013cd2d7b.png#clientId=ub6405de6-621a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=530&id=u0049c974&margin=%5Bobject%20Object%5D&name=A19EA1E0AF7663EFCF77985E2517F6F4.png&originHeight=1296&originWidth=1216&originalType=binary&ratio=1&rotation=0&showTitle=false&size=510166&status=done&style=none&taskId=u1f0706bf-c56b-4e69-9411-9025019afa5&title=&width=497.2857360839844" alt="A19EA1E0AF7663EFCF77985E2517F6F4.png"></p><p>| &#x2F;&#x2F;返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。<br>&#x2F;&#x2F; 本题测试链接 : <a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">https://leetcode-cn.com/problems/max-submatrix-lcci/</a><br>**public static int[] <strong>getMaxMatrix</strong>(int[][] <strong>m</strong>) {<br>   int **N &#x3D; m.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; m</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **int **cur &#x3D; 0;<br>   **int **a &#x3D; 0;<br>   **int **b &#x3D; 0;<br>   **int **c &#x3D; 0;<br>   **int **d &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      int[] **s &#x3D; <strong>new int[<strong>M</strong>]</strong>;<br>      **for (int <strong>j &#x3D; i; j &lt; N; j++</strong>) {<br>         **cur &#x3D; 0;<br>         &#x2F;&#x2F;记录左上角的列<br>         <em>*int <strong>begin &#x3D; 0;<br>         &#x2F;</strong><br>          * [1 1 1 1]<br>          * [0 1 1 2]<br>          * [2 1 0 1]<br>          *&#x2F;<br>         <strong>for (int <strong>k &#x3D; 0; k &lt; M; k++</strong>) {<br>            <strong>s</strong>[<strong>k</strong>] <strong>+&#x3D; m</strong>[<strong>j</strong>][<strong>k</strong>]</strong>;<br>            cur +&#x3D; s**[<strong>k</strong>]</em>*;<br>            **if (<strong>max &lt; cur</strong>) {<br>               **max &#x3D; cur;<br>               a &#x3D; i;<br>               &#x2F;&#x2F;主要这一句<br>               b &#x3D; begin;<br>               &#x2F;&#x2F;<br>               c &#x3D; j;<br>               d &#x3D; k;<br>            **}<br>            **&#x2F;&#x2F;只有一开始就为负数的情况下，0列<br>            **if (<strong>cur &lt; 0</strong>) {<br>               **cur &#x3D; 0;<br>               begin &#x3D; k + 1;<br>            **}<br>         }<br>      }<br>   }<br>   return new int[] { **a, b, c, d <strong>}</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-135-分糖果问题-H"><a href="#·-135-分糖果问题-H" class="headerlink" title="· 135.分糖果问题 [H]"></a>· 135.分糖果问题 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757640476-f9879a7a-09ff-4b7e-9894-dcc5fb7a88f1.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=294&id=uefc12a68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26786&status=done&style=none&taskId=u1a5c1fb5-6fbe-4e76-9b2f-86a45e8de44&title=&width=573.6" alt="image.png"><br><strong>原问题</strong><br>一个数组是所有孩子的得分, 规则是，每个孩子至少一颗糖。相等不管, 只管严格大小关系<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486177-e5f2c5b1-bff0-4a8a-b27f-80ba3eac2b1c.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=u249a86d3&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8840862e-eeb8-4455-87ff-fdf3aa4e161&title=&width=504"><br><strong>题解</strong><br><strong>预处理数组+贪心</strong><br>左边没东西1块糖, 比左边大, 数字就++, 不再大了就返回1, left代表每一个点左边的坡度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486316-27402c6e-a9dd-4a3a-b72e-c09cae8103ee.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u59a65f06&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=1093&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u999c1aa3-b272-4cb8-9003-279e9af6e87&title=&width=499"><br>右边没东西1块糖, 比右边打了就++, 不再大了就回1<br>每个位置的max就是分糖数量，因为左坡跟右坡以较大坡为准<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486225-aba65e85-23b1-4233-a76e-2e967ed35bc0.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ud59977cd&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf3423d64-9cb4-4a2c-9e49-352f333674a&title=&width=652"><br><strong>复杂度</strong><br>时间复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757488676-248c8add-ee09-4fe4-9157-ff396f83324e.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ued7c1b61&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=913&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u552fabd9-cd94-48a3-bc14-1d1ab0ac4fe&title=&width=479"><br><strong>最优解</strong><br>我遍历的过程中，我先认为进入到上坡阶段和下坡阶段，我如果能找出一个坡来<br>就是上坡跟下坡共同构成这么一个坡度的话，该怎么分糖我就知道了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489305-1d4f8a25-b3af-43b7-9067-6174a5c50d95.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=180&id=ucfc19315&margin=%5Bobject%20Object%5D&originHeight=329&originWidth=1101&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8812c98d-eef3-4d11-8bbc-cbd7af31d8c&title=&width=603"><br>对coding要求比较高<br>Coding技巧可以让我找到一组上坡下坡, 等找到的时候, 再回过去给糖</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489355-8a08973f-476c-46d2-8817-37ea96dc2203.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ua20e6791&margin=%5Bobject%20Object%5D&originHeight=412&originWidth=942&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9aab8328-aca0-4baa-acf8-3a67fc6e1b5&title=&width=646"><br>没有重复值的例子<br>先遍历一遍找到坡, 然后再回去给糖, 两个坡度较大的那个+1<br>然后处理下个坡<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489655-913e2252-71e6-43df-9f0f-e11e4963f752.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u9023b751&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u293717ff-dce2-472f-a9bc-18f6b77868d&title=&width=525"><br>要保证两个坡中间同样的那个1不要重复给<br>相当于遍历两遍这个事儿就出来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489683-68970db3-f71e-47f9-a62e-43d3352f2041.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ud4227d7e&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u373ac26e-6280-4b9b-9741-d0f405fca4a&title=&width=567"><br>有相等值就更考验coding<br>相等是无非就是你认为上坡停止下会停止, 更考研Coding技巧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490765-ec269bd1-cd03-4caf-a292-1556e258aaed.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=uf2363b7e&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=751&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1aa1af8b-180e-44d1-adbd-6f02d306b85&title=&width=498"><br>补充问题<br>相邻孩子分数一样, 糖的数量必须一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490609-1e02392c-0c28-4911-aabe-a0e441adc3b2.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u9114b783&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1041&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u74edf940-9fec-4510-bf50-509068979ff&title=&width=441"><br><strong>例子</strong><br>生成辅助数组<br>三个原则，第一比左边大就++，<br>第二，跟左边相等就继承, 就是不变，<br>第三比左边小就归1<br>同样方法生成right<br>还是每个位置的值求max</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490724-1661c665-c1f5-4df8-8d39-1a84b646d746.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ubc071e71&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubd737b23-0203-49bd-9d92-6f6dddc3625&title=&width=492"><br>可以Coding省掉辅助数组, 更难（idea上有代码）<br>相等认为坡没变<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757491157-d5860f2a-c415-4dba-a996-a2ef506de57f.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=u5b8b35db&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=971&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8911ce37-03e3-4967-8e7d-037c74c385c&title=&width=426"></p><p>| &#x2F;&#x2F; 这是原问题的优良解<br>&#x2F;&#x2F; 时间复杂度O(N)，额外空间复杂度O(N)<br>**public static int <strong>candy1</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   **int[] **left &#x3D; <strong>new int[<strong>N</strong>]</strong>;<br>   **for (int <strong>i &#x3D; 1; i &lt; N; i++**) {<br>      if (**arr**[**i - 1**] **&lt; arr**[**i**]) {<br>         **left**[**i**] **&#x3D; left**[**i - 1**] **+ 1;<br>      **}<br>   }<br>   int[] **right &#x3D; **new int[**N**]**;<br>   **for (int **i &#x3D; N - 2; i &gt;&#x3D; 0; i–</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; arr</strong>[<strong>i + 1</strong>]) {<br>         <strong>right</strong>[<strong>i</strong>] <strong>&#x3D; right</strong>[<strong>i + 1</strong>] **+ 1;<br>      <strong>}<br>   }<br>   int <strong>ans &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      <strong>ans +&#x3D; Math.max</strong>(<strong>left</strong>[<strong>i</strong>]</strong>, right</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   return **ans + N;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-小人过有鳄鱼的河-博弈论"><a href="#·-小人过有鳄鱼的河-博弈论" class="headerlink" title="· 小人过有鳄鱼的河(博弈论)"></a>· 小人过有鳄鱼的河(博弈论)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757912442-ad573f17-7f4a-489a-ad67-3e78f85412e8.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=76&id=uacedcc1b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17519&status=done&style=none&taskId=u60591a67-ac3f-4cdc-b743-12dc5bc1e43&title=&width=669.6" alt="image.png"><br><strong>题解</strong><br>思路: 从小推到大<br>这个人在一只鳄鱼的时候就过不了河了，<br>两只鳄鱼的时候就可以过河<br>三只鳄鱼等同于一个人两条鳄鱼的时候, 也不能过河, 因为任何一个鳄鱼吃掉人是没风险的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885276-012e6b97-e501-4f4e-be4b-fa012f482633.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u9ca7460a&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=937&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1dff254-e3ae-49c7-94e2-2f88822fd1d&title=&width=530"><br>奇数能过河, 偶数不能过河<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885221-16ccb180-9d2a-48a8-bd80-9148fde82953.png#clientId=u126c1856-ca70-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u2548e3b4&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u299d4d20-2cf8-471b-8a64-0863faf084d&title=&width=457"></p><h2 id="·-Nim博弈问题"><a href="#·-Nim博弈问题" class="headerlink" title="· Nim博弈问题"></a>· Nim博弈问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800477496-814bb547-f09d-498f-abe5-e2c0e47bb5df.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=79&id=u4fd49066&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22068&status=done&style=none&taskId=uc93319c5-ad21-4523-9ae1-dc89387a500&title=&width=674.4" alt="image.png"><br><strong>题意</strong><br>所有的数&gt;&#x3D;0, 每一轮不管谁都不能拿0<br>谁最先把最后一点数拿完谁赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457877-281d0894-d81e-47d0-987e-47ebb159a8b0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u3d1eed1b&margin=%5Bobject%20Object%5D&originHeight=607&originWidth=1273&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7304e460-0286-465e-aee9-75c63e9b7ec&title=&width=478"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457894-773ef509-f81a-4726-b0ee-d9cf10ef31bd.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=uf044b29a&margin=%5Bobject%20Object%5D&originHeight=468&originWidth=672&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue799c9d7-94cb-4cac-8596-1d6808cdfa8&title=&width=342"><br>先手跟后手，绝顶聪明，每一个人都充分为所有为自己打算，<br>而且绝对理智，问你，给你一个数组状况返回谁会赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800467223-97b4ba95-223a-4115-827b-edf542fc7b0c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=ud3a77b39&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=734&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue582679d-eb0a-4430-ac2a-50f530a132f&title=&width=410"><br>先手第一回拿把它拿成两个数都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458021-1b935de2-12bb-47d3-8f26-530ef46b89a0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=udc3de2b1&margin=%5Bobject%20Object%5D&originHeight=515&originWidth=693&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u18bf42a8-f831-4160-8833-13cff2b33f1&title=&width=378"><br>后手接下来不管拿多少, 先手都让它两个数一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457964-b74ab48f-bb7e-453a-beb0-160600a24846.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=u85f511af&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u107afaec-9b34-4b96-8fe4-32cb147b4a3&title=&width=418"><br>这样先手一定会赢<br>这是两个数的规律<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458667-6220c51c-3dd2-47e9-bde9-b5b33c5a54a4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=u163724fc&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=862&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufbf57780-7d21-4ca3-8ca3-77502419af6&title=&width=391"><br><strong>题解</strong><br>由1900年数学家尼姆搞出来一个非常牛逼的解，<br>结论:<br>所有的数异或起来，如果异或和不等于零先手赢，如果异或和等于0后手赢</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458782-28023103-8346-46b2-a8dc-de62f52c13ac.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=u8660b253&margin=%5Bobject%20Object%5D&originHeight=563&originWidth=987&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua5dfad24-d8cf-4843-9bf3-a66fb04062c&title=&width=442"><br>先手的大目标:<br>让后手最先面对所有数组中都是 0 的状态。<br>大目标不知道怎么实现, 转换一下目标</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458900-733597fd-a958-4f2d-bd91-7dee949c8ffa.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u50188994&margin=%5Bobject%20Object%5D&originHeight=459&originWidth=1066&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud4ecb940-750d-4418-b3c3-e54b7d7592a&title=&width=446"></p><p>所有数都异或起来的异或和, 我如果先手能够做到我面对这坨数的异或和它不等于零，<br>但是我拿完之后每一次都让后手面对的异或和等于0，那么最后胜利是先手<br>我们知道最后全 0 的时候异或和是0。所以就这么玩下去，它总有一个时刻全 0 的时候，<br>而我是遇不到的，只会让后手遇到，所以我必胜的大目标被我们变成一个看似更难的目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458936-68a35d98-dbb4-4fbc-8eb7-a1dd85180307.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=uda72b545&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u505fe591-a3c8-41b2-ab41-bd6884a1f14&title=&width=500"><br><strong>例子</strong><br>把二进制写出来, 数组7,5,3 整体异或和001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459312-eddefebf-42c9-45db-9b8e-ddbd313e4e16.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=ua7fccb0e&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud2f98016-c6b9-4d1d-a11e-a52172c1446&title=&width=560"><br>先手在1这拿一个, 变成6, 更后面的5,3异或和为6的合起来异或和为0<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459424-4f4051be-b558-49e1-90b9-860f4b9f0660.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u72048edf&margin=%5Bobject%20Object%5D&originHeight=617&originWidth=1318&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e0608f9-d441-45c1-80f0-19fbc6e06d1&title=&width=491"><br>后手再拿的时候，他不管在哪个位置上拿哪个数都一定会让异或和从 0 变成不是零，<br>因为他必然会改变某一个位置上一的数量, 改变了它的异或和就不是0，然后先手继续让<br>它异或和变0, 先手必胜.<br>但是这样做的前提是什么?初始的时候异或和得是非零的先手才能这么干，如果先手面<br>对一个一上来就是异或和等于0的状态，后手赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459439-1138e3cb-d17b-4fe9-810b-e54a6fc1742f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u2905cd61&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1307&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf2bff4b1-484e-4ee0-9b03-d077dffc405&title=&width=510"><br>先手不一定在最大值上拿</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459509-11aaa21d-d569-4be6-9afa-9d6e11b76fa1.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u5f1b26a9&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1179&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3841b959-e751-45bc-9027-7d4efd1ad33&title=&width=507"><br>就是先手一定能做到一个不是0 异或和的东西变成全零，但不一定是在最大值上拿的，但是他一定能做到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800460027-d4c6583e-9e89-43ce-92f4-10ed5c3be356.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=uc64a46f9&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1331&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8bef9a58-5ca7-415c-85d2-26b3416a918&title=&width=566"></p><p>| &#x2F;&#x2F; 保证arr是正数数组<br>**public static void <strong>printWinner</strong>(int[] <strong>arr</strong>) {<br>   int **eor &#x3D; 0;<br>   **for (int <strong>num : arr</strong>) {<br>      **eor ^&#x3D; num;<br>   <strong>}<br>   if (<strong>eor &#x3D;&#x3D; 0</strong>) {<br>      <strong>System.<strong>out</strong>.println</strong>(“后手赢”)</strong>;<br>   <strong>} else {<br>      <strong>System.<strong>out</strong>.println</strong>(“先手赢”)</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><h2 id="·-非负数组中两个数相与的最大结果"><a href="#·-非负数组中两个数相与的最大结果" class="headerlink" title="· 非负数组中两个数相与的最大结果"></a>· 非负数组中两个数相与的最大结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650113590488-8110c2b9-7a47-41d5-a42b-f0a7399ead91.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=u485e8bbb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15539&status=done&style=none&taskId=u122a7d6b-ae77-4da4-8b41-ac244820e50&title=&width=315.2" alt="image.png"><br><strong>题解</strong><br>可以用前缀树, 额外空间比较大, 存在更好的解法<br>思路: 高位尽量变1<br>因为我如果选一些数让30位变成0，它就不如30位变成1的值大</p><p>先遍历一遍所有的数字, 只考察30位是1的有几个, 分情况</p><ol><li>小于两个<br>这说明最终的结果30位上肯定不是1，因为你小于两个就不存在任何两个数，两个两个数与玩之后第30位是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800811891-1b46d42a-fe12-4196-af17-9775c90ea3a4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u164ba3a7&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf326dddf-1871-4357-abfd-fc5d79a368e&title=&width=518"></li><li>正好有两个数， 就是这两个数与完的结果最大， 直接返回就行<br>3） 大于两个数<br>那我就把这100个数淘汰掉，剩下的我只留这23个数，我再去看第29位</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812084-94f090b2-a658-437e-8dc0-a7931e7bc517.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u2d559d95&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub142840c-3848-4aa9-ae7d-5317a77cf57&title=&width=549"><br>假设目前这一批数还剩20个， 来到第i位<br>第i位上有1的数：<br>1） &lt;2个<br>2） &#x3D;2个<br>3） &gt; 2个</p><p>我们遍历一遍整个数组，如果有第i位上有1的数，<br>第1种情况小于两个，那么这20个数一个也不淘汰，你接下来去看a减，<br>第2种情况如果这20个数中第i位上1的只有两个数，你不用再看，就这两个是结果<br>第3种情况如果大约在在地在第i位上有1的数是大于两个的，比如说他有7个，那么删掉剩余的13个，只留这7个数去搞安检一位不就玩儿去了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812139-21391412-9c69-4642-866d-d3f960d20bc7.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=ucefcac7f&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=1083&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54468d3d-1d2f-4ae3-b207-9d23095f3ba&title=&width=504"><br><strong>时间复杂度</strong><br>30位遍历一遍数组， 29位遍历一遍数组…<br>一共遍历32遍数组, O(32N)</p><p><strong>空间复杂度怎么计算</strong><br>如果删到只剩下6个数, 17位的时候<br>保留数字这件事情, 在原数组上操作, 原数组末尾做垃圾区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812121-214352ae-98c3-4159-91d0-39878e511b6c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u73578c17&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=833&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue4361ff8-1204-42b3-9953-9cab2cc1866&title="><br><strong>代码</strong><br>垃圾区<br>&lt;2个, 一个数也不淘汰, 让M跳回去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812117-fb4a8866-f4ce-4796-9d6f-e723dcabb358.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u3dfa6e88&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=895&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud964a6ce-61a5-49cc-bd8b-f81d3549e57&title=&width=483"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812536-2890f02a-970d-48af-90d3-2e5b41d3edb8.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0869c0ec&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=575&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u146e66a2-ea4d-4abe-92ce-6d990b399e2&title="></p><p>| **public static int <strong>maxAndValue2</strong>(int[] <strong>arr</strong>) {<br>   **&#x2F;&#x2F; arr[0…M-1]  arr[M….]<br>   **int **M &#x3D; arr.<strong>length</strong>;<br>   **int **ans &#x3D; 0;<br>   **for (int <strong>bit &#x3D; 30; bit &gt;&#x3D; 0; bit–</strong>) {<br>      **&#x2F;&#x2F; arr[0…M-1] arr[M…]<br>      **int **i &#x3D; 0;<br>      **int **tmp &#x3D; M;&#x2F;&#x2F;有可能跳回去<br>      **while (**i &lt; M**) { **&#x2F;&#x2F; arr[0…M-1]<br>         **if ((**arr**[**i**] **&amp; **(**1 &lt;&lt; bit**)) **&#x3D;&#x3D; 0**) {<br>            **swap**(**arr, i, –M**)**;<br>         **} else {<br>            **i++;<br>         **}<br>      }<br>      if (**M &#x3D;&#x3D; 2**) { **&#x2F;&#x2F; arr[0,1]<br>         **return **arr**[**0**] **&amp; arr**[**1**]**;<br>      **}<br>      **&#x2F;&#x2F;&#x3D;&#x3D;<br>      **if (**M &lt; 2**) {**&#x2F;&#x2F;当前bit为无法得到1，M跳回原来位置，一个数也不删****         **M &#x3D; tmp;<br>      **} else { **&#x2F;&#x2F; &gt; 2个数  bit位上有1<br>         ans &amp;#124;&#x3D; <strong>(<strong>1 &lt;&lt; bit</strong>)</strong>;<br>      **}<br>   }<br>   return **ans;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊括号嵌套系列问题"><a href="#·-✊括号嵌套系列问题" class="headerlink" title="· ✊括号嵌套系列问题"></a>· ✊括号嵌套系列问题</h2><h3 id="①计算str表达式结果"><a href="#①计算str表达式结果" class="headerlink" title="①计算str表达式结果"></a>①计算str表达式结果</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650098950782-2396606a-0bbb-4b55-9cb6-f263b9578ad9.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=uaeee7735&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49751&status=done&style=none&taskId=u4b5b7ea1-393b-431b-8ac2-e4790d56699&title=&width=679.2" alt="image.png"><br><strong>题意</strong><br>负数作为公式的开头 或括号部分的开头，可以没有括号<br><strong>题解</strong><br>先处理没有小括号的情况</p><p>指针从零开始就有两种情况:</p><ol><li>当前压中的是数字</li><li>当前压中的是符号<br>准备一个栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569314-732407d5-15f9-4a7e-955b-af2e37ff100f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u1a923818&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=1096&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc508edf6-c054-45e5-b769-4791d54b022&title=&width=505"><br>压中运算符号, 当初过数字阶段结束了, 找到了34<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569315-adc8cd07-34b4-4302-9e41-3b97c55765fb.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=uce5b21e3&margin=%5Bobject%20Object%5D&originHeight=493&originWidth=1115&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua15fcfcf-0634-4317-b4a3-83765138bda&title=&width=536"><br>**1, * **入栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569327-d3093cd3-afae-4027-a13c-21a795ed98e4.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u8b5cb035&margin=%5Bobject%20Object%5D&originHeight=477&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0f70762-e91b-40e6-ad16-29f364c33ce&title=&width=567"><br>栈顶乘除, 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569326-10c63ce7-1bb7-4088-b202-5669ddcfa1ce.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0ca380b&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=1116&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u19d8bda1-3868-4505-8ef6-06decfae122&title="><br>栈顶 &#x2F; 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569330-71ccfd20-9804-4216-a208-53f5b5d350c1.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=uaea7846f&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69bde130-2897-4078-9dfd-67844659fef&title=&width=570"><br>最后位置， 7 入栈， 栈里只有+-符号了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802570274-71211b4b-b360-454e-af84-04dd0cae9fc3.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=ub7bce47c&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1112&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8191caa6-71ac-442a-8cc3-02e1fd3d0ff&title=&width=558"><br>定义递归函数f<br>int[] f(int i)<br>从i位置出发, 遇到右括号或者整个字符串终止位置停止， 返回两个值</li></ol><ul><li><ol><li>answer</li></ol></li><li><ol start="2"><li>F函数算到哪个位置了</li></ol></li></ul><p>条件情况：<br>①遇到数字</p><ul><li>设置cur</li></ul><p>②遇到运算符，结合cur加入到队列中<br>③遇到左括号就交给递归去搞，递归返回两个值</p><ul><li><ol><li>answer</li></ol></li><li><ol start="2"><li>F函数算到哪个位置了</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127597996-d7be7b6e-c490-4bea-bd31-166716737d7e.png#clientId=u7251bedd-719d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=504&id=u8c22e28e&margin=%5Bobject%20Object%5D&name=B03D96AEEDFC16F1164F383A3C4FA837.png&originHeight=1081&originWidth=1739&originalType=binary&ratio=1&rotation=0&showTitle=false&size=456166&status=done&style=none&taskId=u8a1e2898-b1b8-4344-a8d0-08c331b7bf2&title=&width=811.0000610351562" alt="B03D96AEEDFC16F1164F383A3C4FA837.png"></p><p><strong>例子2</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802571970-a1640f24-2c37-483d-b77a-efbb1b989559.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=ua50d068b&margin=%5Bobject%20Object%5D&originHeight=445&originWidth=1107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u99525ff6-64ba-48bf-b068-cce57175db3&title=&width=506"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572172-4a4912ea-4cde-4445-8205-a79369f2c4ca.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=187&id=u81b31c60&margin=%5Bobject%20Object%5D&originHeight=416&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf9fcaa9a-38b5-4adf-97e8-c0b34eab9cd&title=&width=498"><br>遇到左括号了就调递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572369-f6d4f508-2cf3-4096-944a-dd73f55c5d87.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u0ecc431b&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1103&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub543cc02-862d-4386-ac2e-09562639620&title=&width=546"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572690-1f71ba4c-d5a1-4bca-b4b9-84e14c4ec028.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u1ef6c4e6&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=1112&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u81b410fe-4bce-4b03-ae45-37ae4dc0511&title=&width=543"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572941-2ab03421-1f4d-4d27-89e2-904c73ddb9d8.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u5a645239&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1105&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u43dfc911-4281-454a-8e5d-0e49de897e6&title=&width=515"><br>压缩数组例子<br>只要是括号嵌套的都这玩意儿。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573019-d4ab5767-707d-4c9e-b387-12602d4bcdc0.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=206&id=u794d34bb&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=940&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u011e5f47-e7bf-4aeb-9bb3-746df83d1bb&title=&width=498"><br>开头为负怎么计算<br>一上来碰到-号, 0, -, 压栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573351-066ab599-0ef9-4c1a-9f56-c63f6a74181f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u36ef568b&margin=%5Bobject%20Object%5D&originHeight=464&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud82d0514-6263-41c7-b9d5-faaef151f10&title=&width=485"><br><strong>代码</strong><br>最后一个数字还没入栈， 放进去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573451-a23baef1-630a-43f3-89a6-cd2766a53edd.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=312&id=u878bd00f&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0b6eb0c-a03c-4a1a-8d42-f425afa6344&title=&width=582"><br>这种方法一定要牢牢掌握，因为任何括号嵌套的题都可以这么改</p><p>| **public static int[] <strong>f</strong>(char[] **str, **int <strong>i</strong>) {<br>   <strong>LinkedList</strong>&lt;**String**&gt; **que &#x3D; <strong>new <strong>LinkedList</strong>&lt;**String**&gt;()</strong>;<br>   **int **cur &#x3D; 0;<br>   **int[] **bra &#x3D; <strong>null</strong>;<br>   &#x2F;&#x2F; 从i出发，开始撸串<br>   **while (**i &lt; str.**length **&amp;&amp; str**[**i**] **!&#x3D; **’)’) {<br>      if (**str**[**i**] **&gt;&#x3D; **’0’ <strong>&amp;&amp; str</strong>[<strong>i</strong>] <strong>&lt;&#x3D; <strong>‘9’) {<br>         <strong>cur &#x3D; cur * 10 + str</strong>[<strong>i++</strong>] <strong>- <strong>‘0’</strong>;<br>      <strong>} else if (<strong>str</strong>[<strong>i</strong>] <strong>!&#x3D; <strong>‘(‘) { <strong>&#x2F;&#x2F; 遇到的是运算符号<br>         addNum</strong>(<strong>que, cur</strong>)</strong>;&#x2F;&#x2F;比如队列中此时有 1 +   cur &#x3D; 2  来到+ 放入 2 +<br>         que.addLast</strong>(<strong>String.valueOf</strong>(<strong>str</strong>[<strong>i++</strong>]))</strong>;<br>         cur &#x3D; 0;<br>      <strong>} else { <strong>&#x2F;&#x2F; 遇到左括号了<br>         bra &#x3D; f</strong>(<strong>str, i + 1</strong>)</strong>;<br>         cur &#x3D; bra</strong>[<strong>0</strong>]</strong>;<br>         i &#x3D; bra</strong>[<strong>1</strong>] **+ 1;<br>      <strong>}<br>   }<br>   <strong>&#x2F;&#x2F;注意！要结束了，把最后一个数字放进去<br>   addNum</strong>(<strong>que, cur</strong>)</strong>;<br>   <strong>return new int[] { <strong>getNum</strong>(<strong>que</strong>)</strong>, i <strong>}</strong>;<br>**}</p><p>public static void <strong>addNum</strong>(<strong>LinkedList</strong>&lt;<strong>String**&gt; <strong>que, <strong>int <strong>num</strong>) {<br>   if (</strong>!que.isEmpty</strong>()) {<br>      int <strong>cur &#x3D; 0;<br>      String top &#x3D; que.pollLast</strong>()</strong>;<br>      <strong>if (<strong>top.equals</strong>(“+”) <strong>&amp;#124;&amp;#124; top.equals</strong>(“-“)) {<br>         <strong>que.addLast</strong>(<strong>top</strong>)</strong>;<br>      <strong>} else {<br>         <strong>cur &#x3D; Integer.valueOf</strong>(<strong>que.pollLast</strong>())</strong>;<br>         num &#x3D; top.equals**(“*”) **? **(<strong>cur * num</strong>) **: <strong>(<strong>cur &#x2F; num</strong>)</strong>;<br>      <strong>}<br>   }<br>   <strong>que.addLast</strong>(<strong>String.valueOf</strong>(<strong>num</strong>))</strong>;<br><strong>}</strong><br>**public static int <strong>getNum</strong>(<strong>LinkedList</strong>&lt;**String**&gt; <strong>que</strong>) {<br>   int **res &#x3D; 0;<br>   **boolean **add &#x3D; <strong>true</strong>;<br>   String cur &#x3D; <strong>null</strong>;<br>   <strong>int <strong>num &#x3D; 0;<br>   <strong>while (</strong>!que.isEmpty</strong>()) {<br>      <strong>cur &#x3D; que.pollFirst</strong>()</strong>;<br>      **if (<strong>cur.equals</strong>(“+”)) {<br>         **add &#x3D; <strong>true</strong>;<br>      <strong>} else if (<strong>cur.equals</strong>(“-“)) {<br>         <strong>add &#x3D; <strong>false</strong>;<br>      <strong>} else {<br>         <strong>num &#x3D; Integer.valueOf</strong>(<strong>cur</strong>)</strong>;<br>         res +&#x3D; add ? num : <strong>(</strong>-num</strong>)</strong>;<br>      **}<br>   }<br>   return **res;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h3 id="②字符串解码"><a href="#②字符串解码" class="headerlink" title="②字符串解码"></a>②字符串解码</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127913238-063d6a0a-b032-4ca8-89e2-5dc17f30d0be.png#clientId=u7251bedd-719d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u2e367064&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22499&status=done&style=none&taskId=u6402f452-c01d-4576-b24d-7d027b199f9&title=&width=440.57142857142856" alt="image.png"></p><p>| **public static **String calculate(String str) {<br>        **return **f(str.toCharArray(), 0)[0];<br>    }</p><pre><code>**public static **String[] f(**char**[] str, **int **i) &#123;    String ans = **&quot;&quot;**;    **int **cur = 0;    // 从i出发，开始撸串    **while **(i &lt; str.**length **&amp;&amp; str[i] != **&#39;]&#39;**) &#123;        //遇到数字        **if **(str[i] &gt;= **&#39;0&#39; **&amp;&amp; str[i] &lt;= **&#39;9&#39;**) &#123;            cur = cur * 10 + str[i++] - **&#39;0&#39;**;        &#125; **else if **(str[i] &gt;= **&#39;a&#39; **&amp;&amp; str[i] &lt;= **&#39;z&#39;**) &#123; //            ans += str[i++];        &#125; **else **&#123; // 遇到左括号了            String[] f = f(str, i + 1);            **for **(**int **j = 0; j &lt; cur; j++) &#123;                ans += f[0];            &#125;            cur = 0;            i = Integer.valueOf(f[1]);            i++;        &#125;    &#125;    **return new **String[] &#123; ans, String.valueOf(i) &#125;;&#125; |</code></pre><p>| — |</p><h3 id="③❓原子的数量"><a href="#③❓原子的数量" class="headerlink" title="③❓原子的数量"></a>③❓原子的数量</h3><p><strong>扩展：计算括号字符串的分数</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650109458205-b1b14786-40bd-4f1c-bfa1-9a055b24847d.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=uabd6313c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=711&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36399&status=done&style=none&taskId=u2890ec75-3800-40a2-aabe-f170319bf19&title=&width=568.8" alt="image.png"><br>记住代码，比较难理解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650110035627-385b43a8-6afc-437b-bb16-74508df9d7f8.png#clientId=u0ec617b1-5e20-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u52f0ac7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111603&status=done&style=none&taskId=uc24e086b-659c-49f0-b945-4a1fb06b24d&title=&width=304" alt="image.png"></p><h2 id="·-盛最多水的容器"><a href="#·-盛最多水的容器" class="headerlink" title="· 盛最多水的容器"></a>· 盛最多水的容器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652803229358-74a054ba-5506-4cb4-888f-08fb6bd8faed.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=uab3100b9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=609&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40053&status=done&style=none&taskId=u5e22d377-cb6c-42c5-a11e-f25dd5bf093&title=&width=514.7999877929688" alt="image.png"><br><strong>题解</strong><br>先假设无重复值, 左右两个指针<br>左边跟右边比大小， 谁小结算谁的水量<br>两个左右两个指针依次划的过程中算出所有水量的最大值就是答案</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603322-564cdac1-d9b0-46b5-ae4f-e90597069858.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=ue0abe2ca&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u56957f64-7d7b-4946-9167-ea72d58d406&title=&width=462"><br>而事实上3可以继续往右扩大，那我为什么不求出唯一的正确答案，<br>只求3~8这一段的答案呢，这是因为a的答案包含这一段，所以我只关注会不会有把答案推高的可能性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603354-4d6989ad-b2b5-4a05-8c69-6f7008972fd5.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=uf256ec8f&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uba4cb029-1101-4abf-a81a-be756f71cbe&title=&width=496"><br>它不是严格要求每一个数都能够准确的算出来它的答案, 它只关心有没有推高答案的可能性<br>为啥你不知道这道题怎么做?<br>但是你看数据量，你就知道自己一定会憋出一个O(N)的解，<br>那势必可能会想到双指针，谁大移动谁跟谁小移动谁都试一遍这题就出来了，不用知道为什么有可能都能猜出来<br>复杂度O(N)<br>我不去严格纠结到底这个值他真实的最优解是什么，我只纠结会不会让答案变大<br>ref： 数组三连第三连<br><strong>例子</strong><br>只关注它推高答案的可能性，但是我们不去严格纠结每一个位置的值，它具体答案是多少<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603343-312db809-99e8-414c-a228-7fc6ae108e0c.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=200&id=u90840346&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=928&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u82dc8d2e-0c79-4da0-9b9b-729957c3535&title=&width=419"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603345-91268f80-07fa-46fd-9be0-2ac568756483.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u9a46939d&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=1092&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2229fb65-1462-44d2-a2f2-ad111e6093d&title=&width=475"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603340-dff504be-50d9-4110-bde8-60d0eaa86e2f.png#clientId=u11627af4-eb4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u5153fc20&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1094&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54178eed-544a-423b-9a03-b4e0b59ea95&title=&width=488"></p><p>| **public static int <strong>maxArea1</strong>(int[] <strong>h</strong>) {<br>   int **max &#x3D; 0;<br>   **int **N &#x3D; h.<strong>length</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) { <strong>&#x2F;&#x2F; h[i]<br>      <strong>for (int <strong>j &#x3D; i + 1; j &lt; N; j++</strong>) { <strong>&#x2F;&#x2F; h[j]<br>         max &#x3D; Math.max</strong>(<strong>max, Math.min</strong>(<strong>h</strong>[<strong>i</strong>]</strong>, h</strong>[<strong>j</strong>]) *** <strong>(<strong>j - i</strong>))</strong>;<br>      **}<br>   }<br>   return **max;<br>**}</p><p>public static int <strong>maxArea2</strong>(int[] <strong>h</strong>) {<br>   int **max &#x3D; 0;<br>   **int **l &#x3D; 0;<br>   **int **r &#x3D; h.**length **- 1;<br>   **while (<strong>l &lt; r**) {<br>      **max &#x3D; Math.max**(**max, Math.min**(**h**[**l**]**, h**[**r**]) *** **(**r - l**))**;<br>      **if (**h**[**l**] **&gt; h</strong>[<strong>r</strong>]) {<br>         **r–;<br>      **} else {<br>         **l++;<br>      **}<br>   }<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-多个有序list中的top-100-大"><a href="#·-多个有序list中的top-100-大" class="headerlink" title="· 多个有序list中的top 100 大"></a>· 多个有序list中的top 100 大</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882236750-67c0af3e-05fa-4bed-98b7-fcf80e36b74c.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=30&id=ufd509bb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=38&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7392&status=done&style=none&taskId=uef743611-362e-49ac-b624-c0c7dc58095&title=&width=509.6" alt="image.png"><br>大根堆<br>先把链表逆序<br>所有头部拿出来组成一个大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882248310-fbb2aa87-caa0-422c-a083-a8713a7d4694.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u5395c82a&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1291&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u437d1bae-2ae6-40d8-a1af-96d46908e56&title=&width=624"></p><h2 id="·-跳跃游戏Ⅱ"><a href="#·-跳跃游戏Ⅱ" class="headerlink" title="· 跳跃游戏Ⅱ"></a>· 跳跃游戏Ⅱ</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650029478423-12a50e13-5642-45ad-9e9e-04f762f5b727.png#clientId=u98aeb21b-e583-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u7efc409b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37693&status=done&style=none&taskId=u765ebde4-b464-4164-bf78-e8a292676f9&title=&width=532.8" alt="image.png"><br><strong>题意</strong><br>存在一个选择<br>如果尽着最大步数跳他可能得不到最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305648-957d0562-d157-4d3d-ae6c-fc146f1a4502.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u7daad865&margin=%5Bobject%20Object%5D&originHeight=510&originWidth=1237&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3f318203-80a6-4650-85bf-4d1f226ff95&title=&width=609"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305602-7f9f8032-223f-476c-b74f-d76bef9d32ac.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=210&id=u21788ad8&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1216&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufb841da7-04af-4c5b-907e-0212ae690a1&title=&width=524"><br>用贪心, 老紧着最大步数跳是不对的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305681-d01ab949-c241-4243-bac5-4c66c124efae.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=uc2a1cfe5&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1252&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u926d9fc0-6e2a-4122-a843-128c9c2436c&title=&width=521"><br><strong>题解</strong><br>流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655211162287-fd0710b0-b985-4a90-bfed-0abe223715f1.png#clientId=u83bd60c9-5fa5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=812&id=u6a026509&margin=%5Bobject%20Object%5D&name=41D4CCD93F04922A9F2D17AA467437A5.png&originHeight=1421&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&size=417915&status=done&style=none&taskId=u26adf01b-d2c7-4f51-8d3d-1813a4c2bf8&title=&width=704" alt="41D4CCD93F04922A9F2D17AA467437A5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882306957-1850e9b7-de8b-4a4a-adea-eb2cfffcc9eb.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ufbe8fdc9&margin=%5Bobject%20Object%5D&originHeight=579&originWidth=1043&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc564cc66-4380-40a6-a766-66d63c6b832&title=&width=509"><br>反例<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307533-6f1f96c5-ad80-4f9e-9ab2-54da1412c258.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=uc54b612f&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=1132&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3debd364-ff69-4b03-b637-3746408f53d&title=&width=507"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307672-7a9a40e1-5757-4e56-8392-55c6b983411e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u9fe696a3&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=797&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u381a4f25-cc9a-4da0-94f2-80b9ae28f16&title=&width=428"><br><strong>代码</strong></p><p>| **public static int <strong>jump</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **step &#x3D; 0;&#x2F;&#x2F;目前位置跳了几步<br>   **int **cur &#x3D; 0;&#x2F;&#x2F;如果你不增加步数，step以内，你最远能到哪儿<br>   <strong>int <strong>next &#x3D; 0;&#x2F;&#x2F;如果允许我多跳一步，请问我最远的到哪儿<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882687455-34de4ef7-d45e-4515-8847-2cdd7261f16a.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=141&id=u998e7fdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=219&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15857&status=done&style=none&taskId=uf377eb45-a694-43de-80a6-f4277e28737&title=&width=292.8000183105469" alt="image.png"></strong></strong>      if (<strong>cur &lt; i</strong>) {<br>         **step++;<br>         cur &#x3D; next;<br>      <strong>}<br>      <strong>next &#x3D; Math.max</strong>(<strong>next, i + arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   return **step;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·✊在两个都有序的数组找整体第k小的数"><a href="#·✊在两个都有序的数组找整体第k小的数" class="headerlink" title="·✊在两个都有序的数组找整体第k小的数"></a><strong>·✊在两个都有序的数组找整体第k小的数</strong></h2><h3 id="①算法模型：在两个都有序的数组中找上中位数"><a href="#①算法模型：在两个都有序的数组中找上中位数" class="headerlink" title="①算法模型：在两个都有序的数组中找上中位数"></a>①算法模型：在两个都有序的数组中找上中位数</h3><p><strong>题意</strong><br>O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884443226-1de0ecb3-1471-4e81-899c-0e32b5ca4a66.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ub50901c6&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua642aa49-06f2-439b-a489-64f4f71a01d&title=&width=426"><br><strong>题解</strong><br>分情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655299291411-6ecd16bb-340f-4d93-9539-e4bb4a986a8a.png#clientId=u02685321-15d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1841&id=uf949730e&margin=%5Bobject%20Object%5D&name=7A99CC63E8320AA8102F6ACA846A0A14.png&originHeight=3222&originWidth=1849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1850552&status=done&style=none&taskId=ucde9adac-f3e4-459e-a56d-0b19154fa4c&title=&width=1056.5714285714287" alt="7A99CC63E8320AA8102F6ACA846A0A14.png"><br><strong>代码</strong></p><p>| **public static int <strong>getUpMedian</strong>(int[] **A, **int **s1, **int **e1, **int[] **B, **int **s2, **int <strong>e2</strong>) {<br>   int **mid1 &#x3D; 0;<br>   **int **mid2 &#x3D; 0;<br>   **while (**s1 &lt; e1**) {<br>      **&#x2F;&#x2F; mid1 &#x3D; s1 + (e1 - s1) &gt;&gt; 1<br>      mid1 &#x3D; **(<strong>s1 + e1</strong>) **&#x2F; 2;<br>      mid2 &#x3D; **(<strong>s2 + e2</strong>) **&#x2F; 2;<br>      <strong>if (<strong>A</strong>[<strong>mid1</strong>] <strong>&#x3D;&#x3D; B</strong>[<strong>mid2</strong>]) {<br>         return <strong>A</strong>[<strong>mid1</strong>]</strong>;<br>      **}<br>      **&#x2F;&#x2F; 两个中点一定不等！<br>      &#x2F;&#x2F;e1 - s1 + 1就是个数 奇数&amp;1 &#x3D;&#x3D; 1<br>      **if (((<strong>e1 - s1 + 1</strong>) <strong>&amp; 1</strong>) <strong>&#x3D;&#x3D; 1</strong>) { **&#x2F;&#x2F; 奇数长度<br>         &#x2F;&#x2F;一定要对着例子<br>         <strong>if (<strong>A</strong>[<strong>mid1</strong>] <strong>&gt; B</strong>[<strong>mid2</strong>]) {<br>            if (<strong>B</strong>[<strong>mid2</strong>] <strong>&gt;&#x3D; A</strong>[<strong>mid1 - 1</strong>]) {<br>               return <strong>B</strong>[<strong>mid2</strong>]</strong>;<br>            **}<br>            **e1 &#x3D; mid1 - 1;<br>            s2 &#x3D; mid2 + 1;<br>         <strong>} else { <strong>&#x2F;&#x2F; A[mid1] &lt; B[mid2]<br>            **if (**A**[**mid1**] **&gt;&#x3D; B</strong>[<strong>mid2 - 1</strong>]) {<br>               return <strong>A</strong>[<strong>mid1</strong>]</strong>;<br>            **}<br>            **e2 &#x3D; mid2 - 1;<br>            s1 &#x3D; mid1 + 1;<br>         **}<br>      } else { **&#x2F;&#x2F; 偶数长度<br>         **if (<strong>A</strong>[<strong>mid1</strong>] <strong>&gt; B</strong>[<strong>mid2</strong>]) {<br>            **e1 &#x3D; mid1;<br>            s2 &#x3D; mid2 + 1;<br>         <strong>} else {<br>            <strong>e2 &#x3D; mid2;<br>            s1 &#x3D; mid1 + 1;<br>         <strong>}<br>      }<br>   }<br>   return <strong>Math.min</strong>(<strong>A</strong>[<strong>s1</strong>]</strong>, B</strong>[<strong>s2</strong>])</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>复杂度</strong><br>每一次比价砍一半, 二分, O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884449524-c998a42f-d576-4006-9cf1-9c30739af9d7.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=342&id=Dep6S&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=945&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25c8aeb9-2c09-4667-9058-e9474a70a88&title=&width=517"></p><h3 id="②进阶：在两个都有序的数组找整体第k小的数"><a href="#②进阶：在两个都有序的数组找整体第k小的数" class="headerlink" title="②进阶：在两个都有序的数组找整体第k小的数"></a><strong>②进阶：在两个都有序的数组找整体第k小的数</strong></h3><p><strong>例子：arr1 17个 arr2 10个</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655300515983-61e193b4-7e6a-4b2e-8067-4cd547c49684.png#clientId=u02685321-15d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1109&id=uc06c0ab8&margin=%5Bobject%20Object%5D&name=ACE1391B1036C5CD896CD36C7A4E1AF8.png&originHeight=1941&originWidth=2212&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1248551&status=done&style=none&taskId=u7e89ae7d-1de4-45b4-a7ae-d3b2e6a1f95&title=&width=1264" alt="ACE1391B1036C5CD896CD36C7A4E1AF8.png"></p><p>| &#x2F;&#x2F; 进阶问题 : 在两个都有序的数组中，找整体第K小的数<br>&#x2F;&#x2F; 可以做到O(log(Min(M,N)))<br>**public static int <strong>findKthNum</strong>(int[] **arr1, **int[] **arr2, **int <strong>kth</strong>) {<br>   int[] **longs &#x3D; arr1.**length **&gt;&#x3D; arr2.**length **? arr1 : arr2;<br>   **int[] **shorts &#x3D; arr1.**length <strong>&lt; arr2.**length **? arr1 : arr2;<br>   **int **l &#x3D; longs.**length**;<br>   **int **s &#x3D; shorts.**length**;<br>   **if (**kth &lt;&#x3D; s**) { **&#x2F;&#x2F; 1)<br>      **return **getUpMedian**(**shorts, 0, kth - 1, longs, 0, kth - 1**)**;<br>   **}<br>   if (**kth &gt; l</strong>) { <strong>&#x2F;&#x2F; 3)  对着例子【例子太重要了，具象化的代码改为抽象化就可以了】看代码就懂了  贴图过来非常简单！<br>      <strong>if (<strong>shorts</strong>[<strong>kth - l - 1</strong>] <strong>&gt;&#x3D; longs</strong>[<strong>l - 1</strong>]) {<br>         return <strong>shorts</strong>[<strong>kth - l - 1</strong>]</strong>;<br>      <strong>}<br>      if (<strong>longs</strong>[<strong>kth - s - 1</strong>] <strong>&gt;&#x3D; shorts</strong>[<strong>s - 1</strong>]) {<br>         return <strong>longs</strong>[<strong>kth - s - 1</strong>]</strong>;<br>      <strong>}<br>      return <strong>getUpMedian</strong>(<strong>shorts, kth - l, s - 1, longs, kth - s, l - 1</strong>)</strong>;<br>   <strong>}</strong><br>****   <strong>&#x2F;&#x2F; 2)  s &lt; k &lt;&#x3D; l<br>   **if (**longs**[**kth - s - 1**] **&gt;&#x3D; shorts</strong>[<strong>s - 1</strong>]) {<br>      return <strong>longs</strong>[<strong>kth - s - 1</strong>]</strong>;<br>   <strong>}<br>   return <strong>getUpMedian</strong>(<strong>shorts, 0, s - 1, longs, kth - s, kth - 1</strong>)</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h3 id="·-394-字符串解码-M"><a href="#·-394-字符串解码-M" class="headerlink" title="· 394. 字符串解码 [M]"></a>· 394. 字符串解码 [M]</h3><p><strong>题意</strong><br>字符串还原成全是小写字母<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500821-75a18c69-29c4-4b24-b7e5-887be3cb6749.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=ucd62da43&margin=%5Bobject%20Object%5D&originHeight=596&originWidth=1175&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u468d9297-5ca7-472c-88dc-6d62e3ef096&title=&width=488"><br>原始串只有a~z<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500842-3195e513-118a-4630-af49-7b8ed4406f4d.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=uf17c79f4&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u987e1af2-77b6-46ca-b800-4512ab05154&title=&width=364"><br><strong>题解</strong><br>定义递归函数:</p><ol><li>返回结果字符串</li><li>处理到的位置</li></ol><p>从压缩串str i位置往后转换, 遇到]或者压缩串结尾停止, 停的时候, 从i…停这段返回, 并返回计算到的位置</p><p>所有的嵌套结构可以用这个递归结构求解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500729-ad1aeada-e94d-4f7f-9263-31b5031971c8.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=ua4899735&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1306&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a9acdf8-1639-498c-b25c-8532d5b9013&title=&width=451"><br>比如表达式计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500774-5f55cb4a-375e-4628-8a25-c5886f9b8ecf.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=ub4b51deb&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6130fe28-6f0f-4e73-8f26-03514873989&title=&width=505"><br>例子<br>一个字符串的总结果， ans<br>一个收集数字的 cur</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500812-577e8e62-310b-441d-b5fc-70f6264da78d.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ueb3f028b&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=1249&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e762acf-74d3-4f32-a96c-9b00be09246&title=&width=643"><br>2位置遇到左括号, 调子过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504551-ef54c717-a12c-4ef7-a8e6-1dea07860e9f.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u174ad8d4&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=1290&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb7240e5-7fd4-4f17-9d0c-dc13026baee&title=&width=530"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504525-6706a8a2-0c1d-4b36-941c-b9c59ded0d45.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u689b0aea&margin=%5Bobject%20Object%5D&originHeight=668&originWidth=1371&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7f4f3313-621b-4ad6-a317-6341b366355&title=&width=513"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504536-785698a9-0b58-4ea5-bb85-e5870cbed403.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u107f1f9b&margin=%5Bobject%20Object%5D&originHeight=665&originWidth=1262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8359b1d3-cd55-4872-a3b1-24b10aa2d4d&title=&width=468"><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504635-339d1550-5bd7-4f34-8eca-7de606f92831.png#clientId=ub068ef40-dae1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3a36b325&margin=%5Bobject%20Object%5D&originHeight=795&originWidth=747&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5993c173-de94-4eac-806d-e4d0ee9a8b5&title="></p><p>| <strong>public static <strong>String decodeString</strong>(<strong>String s</strong>) {<br>   char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>   <strong>return <strong>process</strong>(<strong>str, 0</strong>)</strong>.<strong>ans</strong>;<br>**}</p><p>public static class **Info **{<br>   public **String <strong>ans</strong>;<br>   <strong>public int stop</strong>;</p><p>   **public <strong>Info</strong>(**String a, **int <strong>e</strong>) {<br>      ans **&#x3D; a;<br>      **stop **&#x3D; e;<br>   **}<br>}</p><p>**&#x2F;&#x2F; s[i….]  何时停？遇到   ‘]’  或者遇到 s的终止位置，停止<br>&#x2F;&#x2F; 返回Info<br>&#x2F;&#x2F; 0) 串<br>&#x2F;&#x2F; 1) 算到了哪<br>**public static <strong>Info process</strong>(char[] **s, **int <strong>i</strong>) {<br>   **StringBuilder ans &#x3D; <strong>new <strong>StringBuilder</strong>()</strong>;<br>   **int **count &#x3D; 0;<br>   **while (**i &lt; s.**length **&amp;&amp; s**[**i**] **!&#x3D; **’]’) {<br>      if ((**s**[**i**] **&gt;&#x3D; **’a’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’z’) **&amp;#124;&amp;#124; **(**s**[**i**] **&gt;&#x3D; **’A’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’Z’)) {<br>         **ans.append**(**s**[**i++**])**;<br>      **} else if (**s**[**i**] **&gt;&#x3D; **’0’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] **&lt;&#x3D; **’9’) {<br>         <strong>count &#x3D; count * 10 + s</strong>[<strong>i++</strong>] <strong>- <strong>‘0’</strong>;<br>      <strong>} else { <strong>&#x2F;&#x2F; str[index] &#x3D; ‘[‘<br>         Info next &#x3D; process</strong>(<strong>s, i + 1</strong>)</strong>;<br>         ans.append</strong>(<strong>timesString</strong>(**count, next.<strong>ans))</strong>;<br>         &#x2F;&#x2F;<br>         count &#x3D; 0;<br>         i &#x3D; next.<strong>stop <strong>+ 1;<br>      <strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>ans.toString</strong>()</strong>, i</strong>)</strong>;<br>**}</p><p>public static <strong>String timesString</strong>(int <strong>times, String str</strong>) {<br>   **StringBuilder ans &#x3D; <strong>new <strong>StringBuilder</strong>()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; times; i++</strong>) {<br>      <strong>ans.append</strong>(<strong>str</strong>)</strong>;<br>   <strong>}<br>   return <strong>ans.toString</strong>()</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-最长连续序列"><a href="#·-最长连续序列" class="headerlink" title="· 最长连续序列"></a>· 最长连续序列</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650027587467-9c71453c-132e-4e65-92ea-5e95c4838e80.png#clientId=u98aeb21b-e583-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=341&id=uc6150b29&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35602&status=done&style=none&taskId=u165c0c4b-a7e3-4fba-bdad-65d2fc46eed&title=&width=666.4" alt="image.png"><br><strong>题解</strong><br>连续区间头表+连续区间尾表<br>100来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450085-90058467-9331-4e7f-afc9-abfc89b72c9e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u25beeefc&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=1139&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e7bb74f-ea0e-4c9a-93a4-d29beffe1e0&title=&width=530"><br>3来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450084-3d961eca-d28d-4f43-b7fe-e707f3e47a19.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=uac2eb7d7&margin=%5Bobject%20Object%5D&originHeight=461&originWidth=1141&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u17d37d9c-915a-46fd-ab24-ef6eb833409&title=&width=498"><br>4来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450169-15fadec0-cbd9-4797-82c9-51f4aa1f8295.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u4eee0f77&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9de3535e-8e32-4ff8-bc47-4d00a37927c&title=&width=480"><br>合并<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450083-6829ff9b-d260-46f0-b4f6-170148bd867e.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ud0fd55ea&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1511e11d-3175-4713-8409-9f9a8863080&title=&width=457"><br>6来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450067-4a7f66f8-a015-411b-a4cc-095f219446d4.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u00347243&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90b8fbaa-d0f1-43c4-8845-9a8afae0a7f&title=&width=480"><br>7来了<br>5<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450782-178be574-6064-458a-9275-a8f116757def.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u9c05a450&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u85da3f43-5abc-4192-bdfc-dccfad0d0ca&title=&width=472"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450958-39fc9099-3c15-44d8-bc54-5f2a4a86304a.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=uaca38d01&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udcfcab17-b0c7-49d5-b493-4931f6a3233&title=&width=448"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450977-0bb7308a-fa05-40a5-9dcf-9540516264b5.png#clientId=u27775d2f-c52a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=217&id=uedf3ad85&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=1091&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u863f4790-bc00-4d11-b7ac-4d41a2ecfc5&title=&width=428"><br>总结<br>每个数来的时候都自己建出自己的区间，看看跟之前都不能合，看看后面能不能合,<br>你每次都严严格格的合完之后，你问我最后有多长的连续区间，你随便找一张表，把value最大值拿出来<br>每一个数来到的时候, 对于哈希表的操作都是O(1)<br><strong>代码</strong><br>难点在于它怎么只用一张哈表搞出来。</p><p>| **public static int <strong>longestConsecutive</strong>(int[] <strong>nums</strong>) {<br>   <strong>HashMap</strong>&lt;**Integer, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>len &#x3D; 0;<br>   <strong>for (int <strong>num : nums</strong>) {<br>      if (</strong>!map.containsKey</strong>(<strong>num</strong>)) {<br>         <strong>map.put</strong>(<strong>num, 1</strong>)</strong>;<br>         <strong>int <strong>preLen &#x3D; map.containsKey</strong>(<strong>num - 1</strong>) <strong>? map.get</strong>(<strong>num - 1</strong>) <strong>: 0;<br>         <strong>int <strong>posLen &#x3D; map.containsKey</strong>(<strong>num + 1</strong>) <strong>? map.get</strong>(<strong>num + 1</strong>) <strong>: 0;<br>         <strong>int <strong>all &#x3D; preLen + posLen + 1;<br>         map.put</strong>(<strong>num - preLen, all</strong>)</strong>;<br>         map.put</strong>(<strong>num + posLen, all</strong>)</strong>;<br>         len &#x3D; Math.max</strong>(<strong>len, all</strong>)</strong>;<br>      **}<br>   }<br>   return **len;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-超级洗衣机（硬记）"><a href="#·-超级洗衣机（硬记）" class="headerlink" title="· 超级洗衣机（硬记）"></a><strong>· 超级洗衣机（硬记）</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932367995-bbe4de73-2904-4594-916c-9533bbc0f67e.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=uea6a2d41&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39680&status=done&style=none&taskId=u8f0f91ee-9a43-4785-a206-f20939def19&title=&width=668" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403145-b876e20d-8562-4eff-b4f8-d442cf06b0f4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=u3a840e1e&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0ffadcba-008c-4d96-b91e-d0ebf518fa5&title=&width=482"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403138-c0c32760-5291-473e-8c7b-ed2d0d17ab3d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=u2bc83435&margin=%5Bobject%20Object%5D&originHeight=569&originWidth=1275&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udf474620-5c39-4ccf-9947-d5377322ff9&title=&width=432"><br><strong>题解</strong><br>大过滤器<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403158-39eaeb21-beea-423a-9a81-ab1b3e4f0c8a.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u5dbce6c0&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=889&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b72d3a9-8d80-444f-a2a7-71510f9fd37&title=&width=381"><br>思想传统: 算单点的瓶颈, 最后看总答案跟单点瓶颈之间的关系</p><p>假设来到某一台(i号)洗衣机, 衣服数量?<br>假设每台机器该有的平均数我们知道<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403159-bc4570ef-622d-4f66-b7b2-806dd142a67c.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=uaf6e2a70&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1229&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc26ff0ff-3a4e-4e24-ae5a-aa0f7723c5f&title=&width=589"><br><strong>第一种情况</strong><br>左右两侧有一个为正数有一个为负数<br>左侧整体欠15件。而它右侧整体多10件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403191-6e7e37d7-0bf5-4987-a6ce-5be5b43a0741.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u95da6da5&margin=%5Bobject%20Object%5D&originHeight=622&originWidth=837&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u070d6067-1b7d-42c5-b8ff-3bc599784ca&title=&width=386"><br>左侧整体欠15件。而它右侧整体多20件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932412835-bcbf1abd-1049-4490-a288-38569f24b131.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u491fbc95&margin=%5Bobject%20Object%5D&originHeight=604&originWidth=899&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua656072e-d9c0-41e4-8e4c-954b2598c76&title=&width=402"><br><strong>总结</strong><br>左右两侧有一个为正数有一个为负数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932414115-732d2fca-785a-4f8e-a095-b8ca0fbe23b4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=ucc357489&margin=%5Bobject%20Object%5D&originHeight=546&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5290c3aa-c695-47a0-9411-e0238a73417&title=&width=394"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932417841-5e9e3984-a2c9-4e68-9694-6b85c58bafd0.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u6fe2d0e8&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=971&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ac861c9-058d-4e4e-8e96-d5996a3c43d&title=&width=365"><br><strong>第二种情况</strong><br>左右两侧都为正数<br>i如果衣服特别少就可能左右两侧都要给它衣服<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932420558-7c95096e-d93b-4f93-b6f3-4eb0b7ca8c5c.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=ud8e9e4fd&margin=%5Bobject%20Object%5D&originHeight=638&originWidth=857&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6165a81f-c605-4f9c-a6aa-8fe99ad651f&title=&width=296"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421080-d8bf23ca-28a5-4431-aa0e-425b360ae4bd.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u2fc15dd2&margin=%5Bobject%20Object%5D&originHeight=561&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u720e32f9-1f9c-4cd3-bec7-e5cff31ee20&title=&width=394"><br><strong>最后一种情况</strong><br>左右两侧都为负数<br>如果左侧欠15件。右侧欠7件，我问你是要搬多少轮, 两侧都指望着i出力, 它一次只能扔一件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421484-2e38c5da-e2b5-44fc-b02a-0f6932eb9510.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=udc41672d&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=745&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6afbd492-5e3d-4243-ae8d-d15ddd0797d&title=&width=408"><br>先算一个总衣服的数量，你再算一个左侧部分的累加和, i位置自己有值。<br>左侧部分欠几件还多几件, 右侧部分欠几件还是多几件。都能算出来<br>有一个衣服的总数量，有一个i左侧的累加和, 接下来你到任何一个i位置。<br>你左侧, 右侧到底是多还是少？你都能算出来</p><p>根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,<br>2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。<br>因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了<br>因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421558-5fddfdda-a71d-4671-aece-dc0b34e07408.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u75e1afcf&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=1024&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u550aae88-3e80-416e-bdc1-1f855da6fc1&title=&width=445"><br><strong>单点思维传统</strong><br>接雨水的问题, 左侧最大值最小值问题，这些东西都是以单点算出来一个答案，然后去决策等。<br>洗衣机问题它属于我把整个问题，我不去想它整体我就想它单点的答案是啥，你给我整出一个答案，<br>然后我去决策出来什么东西，以后单点去求然后再得到整体答案的办法，将会成为我们的一个思想传统。<br>类似子串子数组问题, 每个位置结尾时候啥答案。其实这也是<strong>单点思维。</strong><br><strong>代码</strong></p><p>| **public static int <strong>findMinMoves</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **size &#x3D; arr.<strong>length</strong>;<br>   **int **sum &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; size; i++</strong>) {<br>      <strong>sum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   **}<br>   if (<strong>sum % size !&#x3D; 0</strong>) {<br>      return **-1;<br>   **}<br>   int **avg &#x3D; sum &#x2F; size;<br>   &#x2F;&#x2F;左侧部分累加和<br>   **int **leftSum &#x3D; 0;<br>   **int **ans &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      **&#x2F;&#x2F;左侧部分剩余<br>      **int **leftRest &#x3D; leftSum - i * avg;<br>      &#x2F;&#x2F;右侧部分剩余<br>      **int **rightRest &#x3D; **(<strong>sum - leftSum - arr</strong>[<strong>i</strong>]) <strong>- <strong>(<strong>size - i - 1</strong>) *** avg;<br>      <strong>if (<strong>leftRest &lt; 0 &amp;&amp; rightRest &lt; 0</strong>) {<br>         <strong>ans &#x3D; Math.max</strong>(<strong>ans, Math.abs</strong>(<strong>leftRest</strong>) <strong>+ Math.abs</strong>(<strong>rightRest</strong>))</strong>;<br>      <strong>} else {<br>         <strong>ans &#x3D; Math.max</strong>(<strong>ans, Math.max</strong>(<strong>Math.abs</strong>(<strong>leftRest</strong>)</strong>, Math.abs</strong>(<strong>rightRest</strong>)))</strong>;<br>      <strong>}<br>      <strong>leftSum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   **}<br>   return **ans;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-缺失的第一个正数"><a href="#·-缺失的第一个正数" class="headerlink" title="· 缺失的第一个正数"></a><strong>· 缺失的第一个正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922711623-5f275d70-6ad9-4a85-b908-b754c4c08188.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=377&id=u10e943fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31833&status=done&style=none&taskId=u01469d94-35f3-4ad3-8669-3edd28f7319&title=&width=536.8" alt="image.png"><br>核心就是<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922917933-411751da-967b-4a5a-bba8-08ca6afba789.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u1d4d9e20&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81409&status=done&style=none&taskId=uea4d21e0-d3fc-4dc9-be76-12aa8351e2e&title=&width=503.2" alt="image.png"><br>分为有效区和垃圾区<br>核心</p><ul><li>如果L位置上的数 &lt;&#x3D;L跟垃圾区交换</li><li><blockquote><p>R位置的数 跟垃圾区交换</p></blockquote></li><li>等于 arr[arr[L]-1]的数也交换<br>| **public static int <strong>firstMissingPositive</strong>(int[] <strong>arr</strong>) {<br> **&#x2F;&#x2F; l是盯着的位置<br> &#x2F;&#x2F; 0 ~ L-1有效区<br> **int **L &#x3D; 0;<br> **int **R &#x3D; arr.<strong>length</strong>;<br> **while (<strong>L !&#x3D; R</strong>) {<br>**&#x2F;&#x2F;有效区向右扩<br>**if (<strong>arr</strong>[<strong>L</strong>] <strong>&#x3D;&#x3D; L + 1</strong>) {<br>   **L++;<br><strong>} else if (<strong>arr</strong>[<strong>L</strong>] <strong>&lt;&#x3D; L &amp;#124;&amp;#124; arr**[**L**] **&gt; R &amp;#124;&amp;#124; arr</strong>[<strong>arr</strong>[<strong>L</strong>] <strong>- 1</strong>] <strong>&#x3D;&#x3D; arr</strong>[<strong>L</strong>]) { <strong>&#x2F;&#x2F; 垃圾的情况<br>   swap</strong>(<strong>arr, L, –R</strong>)</strong>;<br><strong>} else {<br>   <strong>swap</strong>(<strong>arr, L, arr</strong>[<strong>L</strong>] <strong>- 1</strong>)</strong>;<br>**}<br> }<br> return **L + 1;<br>**}</li></ul><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-数组的自己不能累加和出的最小正数"><a href="#·-数组的自己不能累加和出的最小正数" class="headerlink" title="· 数组的自己不能累加和出的最小正数"></a><strong>· 数组的自己不能累加和出的最小正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649908121718-8953c38b-c4f7-47ac-ae29-35e9ffd72e37.png#clientId=u66160ce2-b06d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=99&id=u1ea6fc03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=366&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12897&status=done&style=none&taskId=u8559eaa1-8292-41bd-a5cc-ca091503438&title=&width=292.8" alt="image.png"><br><strong>第一问</strong><br>同上问<br>arr所有值的累加和从一个负数到一个整数做出一张表, 然后看最后一行<br>arr 0~N-1宿友的值能不能搞定1, 2, 3…, 哪一个最早不行的, 返回就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274512-42b3c5d7-4c34-41d1-90af-b01987c4bcf7.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=ub0253dce&margin=%5Bobject%20Object%5D&originHeight=664&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4c3059f8-c8ca-4e0e-8def-f24e2bb3715&title=&width=434"></p><p>| **public static int <strong>unformedSum2</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **1;<br>   **}<br>   int **sum &#x3D; 0;<br>   <strong>int <strong>min &#x3D; Integer.<strong>MAX_VALUE</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>sum +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      min &#x3D; Math.min</strong>(<strong>min, arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   **&#x2F;&#x2F; boolean[][] dp …<br>   **int **N &#x3D; arr.<strong>length</strong>;<br>   **boolean[][] **dp &#x3D; <strong>new boolean[<strong>N</strong>][<strong>sum + 1</strong>]</strong>;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++**) {**&#x2F;&#x2F; arr[0..i] 0<br>      dp**[**i**][**0**] **&#x3D; **true**;<br>   **}<br>   **dp**[**0**][**arr**[**0**]] **&#x3D; **true**;<br>   **for (int **i &#x3D; 1; i &lt; N; i++**) {<br>      for (int **j &#x3D; 1; j &lt;&#x3D; sum; j++**) {<br>         **dp**[**i**][**j**] **&#x3D; dp**[**i - 1**][**j**] **&amp;#124;&amp;#124; **((**j - arr**[**i**] **&gt;&#x3D; 0</strong>) <strong>? dp</strong>[<strong>i - 1</strong>][<strong>j - arr</strong>[<strong>i</strong>]] <strong>: <strong>false)</strong>;<br>      <strong>}<br>   }<br>   for (int <strong>j &#x3D; min; j &lt;&#x3D; sum; j++</strong>) {<br>      if (</strong>!dp</strong>[<strong>N - 1</strong>][<strong>j</strong>]) {<br>         return **j;<br>      **}<br>   }<br>   return **sum + 1;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>第二问</strong><br>先把array排序, 正数数组排完序, 左边0位置肯定是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274407-d5bb7112-75b6-4c1a-8c5a-636c29d2da74.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=u7c7998e0&margin=%5Bobject%20Object%5D&originHeight=598&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6d443944-221f-4578-af40-df6b9538517&title=&width=428"><br>定义变量range &#x3D;1, 表示从1<del>1范围上的正数都能累加出来<br>range&#x3D;k, 代表1</del>k上的所有正数都能搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-064d2ceb-c903-444a-8b3b-def179bd1054.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=udb091615&margin=%5Bobject%20Object%5D&originHeight=627&originWidth=1208&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87640a35-779d-455c-92d7-3d66170c5b2&title=&width=451"><br>当arr 0位置是1的情况下, range&#x3D;1, 代表1<del>1范围的正数都可以搞出来<br>如果1位置也是1, range变成2, 代表1</del>2范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-3a9c1b06-df19-4cbf-a1a0-8890c1df2d33.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u4a638e7d&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uacb8b2ee-8e40-476b-b0e6-d3dd0902597&title=&width=546"><br>如果2位置也是2, range变成4, 代表1<del>4范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274433-c44f8de2-ab64-4735-a4ae-0d303eaeb2be.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=u36d33f1c&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=1218&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75c49504-7235-4203-9e18-e0efd1c066a&title=&width=500"><br>如果0</del>i-1是0~100, range&#x3D;100<br>i位置17, 可以让range扩充到117</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276639-76ea18e4-1553-4416-b729-602f169e4256.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=ud24b4420&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf800b3ae-b828-40f4-9f35-e53b5b30e59&title=&width=540"><br>注意一点<br>如果0<del>i-1能搞定的数是1</del>100, 此时i位置是102, 那么101不可以搞定<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276627-25522d30-aa31-47f1-a2c0-70754b005b35.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=ub8d18f54&margin=%5Bobject%20Object%5D&originHeight=641&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c78c50f-b4c4-4174-aeb2-65532acedc1&title=&width=484"><br><strong>抽象化</strong><br>如果0<del>i-1搞定1</del>a, 如果i位置上是b:<br>1)如果b&lt;&#x3D; a+1, 能扩充, 范围到1~a+b<br>2)如果b&gt; a+1, a+1就是搞定不了的最小正整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276617-5b986e34-cf33-4d56-a953-8b54313b7cb9.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=309&id=u561892aa&margin=%5Bobject%20Object%5D&originHeight=661&originWidth=1101&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8618d200-7b25-4c41-89a5-14bb0c7e026&title=&width=515"><br><strong>代码</strong></p><p>| **&#x2F;&#x2F; 已知arr中肯定有1这个数<br>**public static int <strong>unformedSum3</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   <strong>}<br>   <strong>Arrays.sort</strong>(<strong>arr</strong>)</strong>; &#x2F;&#x2F; O (N * logN)<br>   **int **range &#x3D; 1;<br>   &#x2F;&#x2F; arr[0] &#x3D;&#x3D; 1<br>   **for (int <strong>i &#x3D; 1; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; range + 1</strong>) {<br>         return **range + 1;<br>      <strong>} else {<br>         <strong>range +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      **}<br>   }<br>   return **range + 1;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>原题<br>arr是正数, 要求子集不能是空集, 最小子集累加和到最大子集累加和的范围中哪个数是最小不可组成的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927277249-0071ad5e-e13b-4370-bfe9-c4e82ef62414.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=202&id=u10a4ace4&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1230&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6504140f-42f0-4cdd-ab09-4e8752f37b5&title=&width=385"></p><h2 id="·-按要求补齐数组"><a href="#·-按要求补齐数组" class="headerlink" title="· 按要求补齐数组"></a>· 按要求补齐数组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649917704725-47286ee2-4581-440e-87d2-40217bdc6892.png#clientId=uddadb385-d350-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=401&id=uafa838b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=501&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36432&status=done&style=none&taskId=u650b2498-cf20-4fe1-bdde-0a59049f6aa&title=&width=656.8" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555620-061a554b-82b5-41e0-9e92-a690ce40510d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=ud98747b1&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=1248&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc3bcf646-19ce-4700-8f4a-bd401665f44&title=&width=389"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555641-e30d7e5e-1c75-4f52-a033-af5aee074d54.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u7ba03d88&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=1240&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a3bc28c-d3a2-4b58-ba9a-de9d7ca6744&title=&width=477"><br>到达数字+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555680-c1d3ccf6-3771-4e93-96b8-39c885a5a4bf.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=211&id=ub2e23613&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc2cbb657-a0c0-4d31-afee-d802e35c8fe&title=&width=417"><br><strong>题解</strong><br>先把数组排序<br>数组中每个数最经济的使用<br>只能是 1<del>3 范围，你先都搞定之后，你舒舒服服，使用这个4，就能扩到1</del>7了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555600-28054282-00a3-4ada-b588-8c83daa1343d.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u36009711&margin=%5Bobject%20Object%5D&originHeight=414&originWidth=1355&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c1ace8f-dc3d-4e30-aa37-c80e0af525c&title=&width=540"><br>给自己提了小目标，这个小目标是搞定1<del>3 范围上，你缺几个数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555576-2c52f0c4-a3ee-4fe0-99fd-d5ad4194db98.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=u2bb70482&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1326&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u30cd7616-6530-4109-9843-187a632bcd8&title=&width=539"><br>对于5, 小目标1</del>4范围上都可以搞定, 已经满足了<br>可以直接使用这个5，让它变成12，不用添任何数字</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559417-d4b87abf-d387-42d2-8d80-4a0a8ec4f0c4.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u32d93753&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=1317&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u127e139e-6b60-4227-ad19-1e323514d0d&title=&width=521"><br>想使用17, 要求目标1<del>16必须具备<br>目前有1</del>12, 缺13, 补13之后范围扩到1~25<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559808-215561a1-ff63-415f-bf78-fad7b73a64ba.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=uea5b1f49&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1322&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2cc09c61-ee32-4302-b314-4ba0be0fea5&title=&width=507"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927560402-d3d539ae-2061-402e-8409-47fe164264a2.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=227&id=u09c809c8&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1338&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7877baab-db60-4c74-96b5-33a014c76fd&title=&width=491"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561057-82a9fd44-9823-4f41-858c-acdcdc07147b.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u1757f08b&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1340&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucad0fd2b-6999-4754-89cb-2a2fdc5f0e0&title=&width=468"><br><strong>例子</strong><br>如果n特别大, 整个数组都使用完以后范围是1~3050, 先补3051<br>整个数组都使完之后，如果你还没到，接下来的过程就等同于给了你一个范围，你一个数也没有了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561285-f47b7093-d077-49ef-9d8a-40af2438e4b0.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u48355d80&margin=%5Bobject%20Object%5D&originHeight=587&originWidth=1165&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25fd03f5-cf32-4ea9-b5a2-10523fc59b6&title=&width=399"><br>注意点<br>只要范围扩充了，我就盯着总目标有没有实现，我不一定要使用完所有数字，我可能已经提前搞定考了，<br>我缺了多少数字，如果发现我range已经到它了，直接返回就可以了，不用看后面的数字<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927562331-6d5e0b3b-b786-468c-a940-7c5b9ed70aa2.png#clientId=u25bf4cf1-53e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=u84594179&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1341&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d649c1a-e5d8-43f0-87e0-47de55d83b7&title=&width=510"></p><p>| &#x2F;&#x2F; arr请保证有序，且正数  1~aim<br>**public static int <strong>minPatches</strong>(int[] **arr, **int <strong>aim</strong>) {<br>   int **patches &#x3D; 0; &#x2F;&#x2F; 缺多少个数字<br>   <strong>long <strong>range &#x3D; 0; &#x2F;&#x2F; 已经完成了1 ~ range的目标<br>   Arrays.sort</strong>(<strong>arr</strong>)</strong>;<br>   **for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      **&#x2F;&#x2F; arr[i]<br>      &#x2F;&#x2F; 要求：1 ~ arr[i]-1 范围被搞定！<br>      **while (<strong>arr</strong>[<strong>i</strong>] <strong>- 1 &gt; range</strong>) { **&#x2F;&#x2F; arr[i] 1 ~ arr[i]-1<br>         range +&#x3D; (range + 1); &#x2F;&#x2F; range + 1 是缺的数字<br>         patches++;<br>         &#x2F;&#x2F;只要范围一变化就盯着目标<br>         **if (<strong>range &gt;&#x3D; aim</strong>) {<br>            return **patches;<br>         <strong>}<br>      }<br>      <strong>&#x2F;&#x2F; 要求被满足了！<br>      range +&#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      **if (<strong>range &gt;&#x3D; aim</strong>) {<br>         return **patches;<br>      **}<br>   }<br>   while (<strong>aim &gt;&#x3D; range + 1</strong>) {<br>      **range +&#x3D; range + 1;<br>      patches++;<br>   **}<br>   return **patches;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="x2F-x2F-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x2F-x2F-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><h2 id="·-240-行列递增矩阵的查找-搜索二维矩阵-II-M"><a href="#·-240-行列递增矩阵的查找-搜索二维矩阵-II-M" class="headerlink" title="· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]"></a>· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538431656-6b591c24-62b5-4f4d-a992-0e2ee6455b85.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=ucaa40dd5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11740&status=done&style=none&taskId=u76050ce0-5216-4663-83e4-b58fdd5ced0&title=&width=439.2" alt="image.png"><br><strong>题意</strong><br>让你找某一个数字在其中是否存在<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537626124-5e69971c-798a-4382-a6c0-56062f07a154.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u825d9625&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=642&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u938e2c19-6aff-4589-84b0-79641bb03ae&title=&width=348"><br><strong>题解</strong><br>经典解法:<br>从右上角开始找<br>复杂度O(N+M)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624515-057e50f5-c481-4b0a-8091-003f019142d4.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u86a3eab4&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1257&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufda2a2e9-c766-4bc5-9780-98846953c45&title=&width=553"><br>从左下角走</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624507-9f4bca2b-fa51-4bd1-ae0a-cc127e634a97.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=ubf5cba53&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0f5c24b9-5e75-475b-96da-fcd5f286991&title=&width=515"></p><p>| **public static boolean <strong>isContains</strong>(int[][] **matrix, **int <strong>K</strong>) {<br>   int **row &#x3D; 0;<br>   <strong>int <strong>col &#x3D; matrix</strong>[<strong>0</strong>]</strong>.**length **- 1;<br>   <strong>while (<strong>row &lt; matrix.**length **&amp;&amp; col &gt; -1</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&#x3D;&#x3D; K</strong>) {<br>         return true</strong>;<br>      **} else if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&gt; K</strong>) {<br>         **col–;<br>      **} else {<br>         **row++;<br>      <strong>}<br>   }<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊378-行列递增矩阵中的第K小-M"><a href="#·-✊378-行列递增矩阵中的第K小-M" class="headerlink" title="· ✊378.行列递增矩阵中的第K小 [M]"></a>· ✊378.行列递增矩阵中的第K小 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538447469-55d93518-20af-4ac9-bb0d-cc650b505a39.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=75&id=ue2220b92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=94&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12027&status=done&style=none&taskId=u7642227d-241c-4306-8adb-3d21d1474a6&title=&width=434.4" alt="image.png"><br><strong>最优解</strong><br>给定一个目标, 想知道&lt;&#x3D;100的数有几个, 怎么快能求出来?<br>往左走, 获得0个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464907-2dead8bf-8612-4941-8c80-3b22ba09131b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u2e5cfef4&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=1302&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua5722571-1037-41c0-a18e-d6fb6cb934b&title=&width=427"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464900-3f1bafb2-1bae-4cdb-8c53-cc846c69f134.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u4704966e&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1269&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4d022a33-b6ba-45b1-8229-acd68f70a81&title=&width=500"><br>就这样一直卡到结束，你正确的获得整个数组中有多少个数&lt;&#x3D;100<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464925-50973775-2761-4ed9-8cd5-5337041bf338.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=ua11d3edf&margin=%5Bobject%20Object%5D&originHeight=636&originWidth=1279&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueff346fb-ab57-4bd5-9a3e-3880b1e4b7b&title=&width=534"><br>**例子**<br>&lt;&#x3D;100的有几个, 同时也可以知道最接近100的是啥数?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464932-49c9b5d2-a01d-4a5c-8975-50303fa6a936.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u56983f42&margin=%5Bobject%20Object%5D&originHeight=588&originWidth=1296&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u67098799-26c6-4f3c-8175-19f94ecb673&title=&width=521"><br>120&gt;100获得0个</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464930-de301eda-d2b0-440b-b938-1bc52130534e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=u2cdb7407&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1311&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b4b31cf-26dc-496f-8390-87189a86c68&title=&width=411"><br>100&gt;90 假设90所在的列是col<br>获得的个数是rol+1<br>同时更新接近100的数字为90</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465650-44206736-0a80-4be1-b524-3e42d7c92086.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u653e1491&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=1304&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uefd5909b-1438-4e68-8c39-07bb5605a84&title=&width=549"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465710-67505b3a-0cc8-4c66-b908-40ff88ecab43.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u66d628df&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufefde839-ee65-4893-88e1-ff39a92a975&title=&width=431"><br>解决原问题<br><strong>二分</strong><br>整个数组中最小的是谁？左上角的数<br>那整个数组中，最大的数是谁？右下角的数<br>第一百小的数一定在一到1000之间, 看看&lt;&#x3D;500的数有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465810-e8be4f70-42f7-4fa5-b7a0-c81514b2ff5d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=256&id=u9bcf7146&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1219&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u479e614c-408d-4eb6-9c84-94373d1aa27&title=&width=521"><br>如果&lt;&#x3D;500有200个, 目标大了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465999-a6e86772-a3ac-4585-a06c-2081f5cdd43e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=284&id=uddbef8b1&margin=%5Bobject%20Object%5D&originHeight=650&originWidth=1265&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u361c54da-f6cb-48a8-9aaf-db96a0a03c1&title=&width=553"><br>有可能最后得到&lt;&#x3D;785的数有100个, 但是数组中没有这个数, 应该是&lt;&#x3D;785并离它最近<br>的数<br>我每次让你过的时候求俩信息，</p><ul><li>第一小于等于某一个值个数有几个</li><li>第二，最接近它的是谁？</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466133-869c69d6-fbbd-4e08-b85f-e7affbbdba50.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=u32fd171a&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1263&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf7b5a0ae-78a1-4110-90ef-898624a9d91&title=&width=560"><br><strong>复杂度</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466525-0b2fee08-0f44-4e91-b063-3992ab4853f0.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=268&id=ucbc9934f&margin=%5Bobject%20Object%5D&originHeight=659&originWidth=1263&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua58a75d8-03db-4569-b937-1af685bff8d&title=&width=513"><br><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466467-9e5f348e-c41d-4268-9b00-b0c0e20be6de.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u762a2f31&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1285&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8fa0287d-25c4-48b9-a7cf-aa1e3e128a1&title=&width=516"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466606-1c01a2b3-8288-4f63-a32f-5ef20107ec9d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=ua6082d71&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=912&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1827838a-ed61-4d55-b0e4-80808063065&title=&width=564"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466819-f599b5d1-bfaf-409d-9a8b-05f51b31ee1a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u7c9fce28&margin=%5Bobject%20Object%5D&originHeight=671&originWidth=1356&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u150b1272-8545-4d16-8622-d69dad22697&title=&width=544"><br><strong>代码</strong></p><p>| &#x2F;&#x2F; 二分的方法<br>**public static int <strong>kthSmallest2</strong>(int[][] **matrix, **int <strong>k</strong>) {<br>   int **N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   <strong>int <strong>left &#x3D; matrix</strong>[<strong>0</strong>][<strong>0</strong>]</strong>;<br>   <strong>int <strong>right &#x3D; matrix</strong>[<strong>N - 1</strong>][<strong>M - 1</strong>]</strong>;<br>   <strong>int <strong>ans &#x3D; 0;<br>   <strong>while (<strong>left &lt;&#x3D; right**) {<br>      int **mid &#x3D; left + **((**right - left**) **&gt;&gt; 1</strong>)</strong>;<br>      &#x2F;&#x2F; &lt;&#x3D;mid 有几个 &lt;&#x3D; mid 在矩阵中真实出现的数，谁最接近mid<br>      Info info &#x3D; noMoreNum</strong>(<strong>matrix, mid</strong>)</strong>;<br>      **if (**info.**num <strong>&lt; k</strong>) {<br>         **left &#x3D; mid + 1;<br>      **} else {<br>         **&#x2F;&#x2F;这里就是有可能&lt;&#x3D;785的数有100个，但是数组中没有这个数，所以要记录与他最接近的<br>         ans &#x3D; info.<strong>near</strong>;<br>         right &#x3D; mid - 1;<br>      **}<br>   }<br>   return **ans;<br>**}</p><p>public static class **Info <strong>{<br>   public int near</strong>;<br>   <strong>public int num</strong>;</p><p>   **public <strong>Info</strong>(int **n1, **int <strong>n2</strong>) {<br>      near **&#x3D; n1;<br>      **num **&#x3D; n2;<br>   **}<br>}</p><p>public static <strong>Info noMoreNum</strong>(int[][] **matrix, **int <strong>value</strong>) {<br>   int **near &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   **int **num &#x3D; 0;<br>   **int **N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   **int **row &#x3D; 0;<br>   **int **col &#x3D; M - 1;<br>   <strong>while (<strong>row &lt; N &amp;&amp; col &gt;&#x3D; 0</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&lt;&#x3D; value</strong>) {<br>         <strong>near &#x3D; Math.max</strong>(<strong>near, matrix</strong>[<strong>row</strong>][<strong>col</strong>])</strong>;<br>         num +&#x3D; col + 1;<br>         row++;<br>      **} else {<br>         **col–;<br>      <strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>near, num</strong>)</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>| &#x2F;&#x2F; 堆的方法<br><strong>public static int <strong>kthSmallest1</strong>(int[][] <strong>matrix, <strong>int <strong>k</strong>) {<br>   int <strong>N &#x3D; matrix.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; matrix</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   PriorityQueue</strong>&lt;**Node**&gt; <strong>heap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;(new <strong>NodeComparator</strong>())</strong>;<br>   <strong>boolean[][] <strong>set &#x3D; <strong>new boolean[<strong>N</strong>][<strong>M</strong>]</strong>;<br>   heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>0</strong>][<strong>0</strong>]</strong>, 0, 0</strong>))</strong>;<br>   set</strong>[<strong>0</strong>][<strong>0</strong>] <strong>&#x3D; <strong>true</strong>;<br>   <strong>int <strong>count &#x3D; 0;<br>   Node ans &#x3D; <strong>null</strong>;<br>   <strong>while (</strong>!heap.isEmpty</strong>()) {<br>      <strong>ans &#x3D; heap.poll</strong>()</strong>;<br>      <strong>if (</strong>++count &#x3D;&#x3D; k</strong>) {<br>         break</strong>;<br>      <strong>}<br>      int <strong>row &#x3D; ans.<strong>row</strong>;<br>      <strong>int <strong>col &#x3D; ans.<strong>col</strong>;<br>      <strong>if (<strong>row + 1 &lt; N &amp;&amp; !set</strong>[<strong>row + 1</strong>][<strong>col</strong>]) {<br>         <strong>heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>row + 1</strong>][<strong>col</strong>]</strong>, row + 1, col</strong>))</strong>;<br>         set</strong>[<strong>row + 1</strong>][<strong>col</strong>] <strong>&#x3D; <strong>true</strong>;<br>      <strong>}<br>      if (<strong>col + 1 &lt; M &amp;&amp; !set</strong>[<strong>row</strong>][<strong>col + 1</strong>]) {<br>         <strong>heap.add</strong>(new <strong>Node</strong>(<strong>matrix</strong>[<strong>row</strong>][<strong>col + 1</strong>]</strong>, row, col + 1</strong>))</strong>;<br>         set**[<strong>row</strong>][<strong>col + 1</strong>] **&#x3D; <strong>true</strong>;<br>      **}<br>   }<br>   return **ans.<strong>value</strong>;<br>**}</p><p>public static class **Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   **public <strong>Node</strong>(int **v, **int **r, **int <strong>c</strong>) {<br>      value **&#x3D; v;<br>      **row **&#x3D; r;<br>      **col **&#x3D; c;<br>   **}</p><p>}</p><p>public static class **NodeComparator **implements <strong>Comparator</strong>&lt;**Node**&gt; {</p><p>   **@Override<br>   **public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return **o1.**value **- o2.<strong>value</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><h2 id="·-940-不同的子序列-II-H"><a href="#·-940-不同的子序列-II-H" class="headerlink" title="· 940.不同的子序列 II [H]"></a>· 940.不同的子序列 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538612708-fda8d9fb-bb27-4677-8080-a6c88db86f79.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=u64377b4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=412&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24324&status=done&style=none&taskId=ub9741443-896e-42ce-8c56-8a848253493&title=&width=529.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-ffb30de6-f89e-4cc2-97f9-f689fa201501.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=u1fea0879&margin=%5Bobject%20Object%5D&originHeight=587&originWidth=1215&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u55df378d-a803-40de-a808-0dedf0ccfe0&title=&width=458"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-f0b61739-d00f-48b6-998c-26a3711ea3bf.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u1df3788a&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1042&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4f9cf5bd-ef8b-440e-8b26-ba037940ecf&title=&width=429"><br><strong>题解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655384932788-bf089bd0-c6f2-473c-a397-a313422b8837.png#clientId=u782dedcd-cafb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1810&id=ua0fa29c9&margin=%5Bobject%20Object%5D&name=779E39B64BA9EC69E5A1C515E4200530.png&originHeight=3168&originWidth=1424&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1164522&status=done&style=none&taskId=udfa184cd-8bbd-4169-93f5-29e4850f4c6&title=&width=813.7142857142857" alt="779E39B64BA9EC69E5A1C515E4200530.png"><br>模操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538826795-e3410ba0-a512-485d-951d-69bb5cb981a6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9b1dd3e0&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=755&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u811d823a-3961-4f75-b8f3-4b6d6da427b&title="></p><p>| **public static int <strong>zuo1</strong>(<strong>String s</strong>) {<br>      if (**s &#x3D;&#x3D; **null <strong>&amp;#124;&amp;#124; s.length</strong>() <strong>&#x3D;&#x3D; 0</strong>) {<br>         return **0;<br>      **}<br>      int <strong>m &#x3D; 1000000007;<br>      <strong>char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>      HashMap</strong>&lt;**Character, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>      **int **all &#x3D; 1; &#x2F;&#x2F; 一个字符也没遍历的时候，有空集<br>      **for (char <strong>x : str</strong>) {<br>         **&#x2F;&#x2F;新加出来的玩意儿就是以什么结尾的数量<br>         **int **newAdd &#x3D; all;<br>         <strong>int <strong>curAll &#x3D; all + newAdd - <strong>(<strong>map.containsKey</strong>(<strong>x</strong>) <strong>? map.get</strong>(<strong>x</strong>) <strong>: 0</strong>)</strong>;<br>         all &#x3D; curAll;<br>         map.put</strong>(<strong>x, newAdd</strong>)</strong>;<br>      **}<br>      return **all;<br>   **}<br>   public static int <strong>zuo</strong>(<strong>String s</strong>) {<br>      if (**s &#x3D;&#x3D; **null <strong>&amp;#124;&amp;#124; s.length</strong>() <strong>&#x3D;&#x3D; 0</strong>) {<br>         return **0;<br>      **}<br>      int <strong>m &#x3D; 1000000007;<br>      <strong>char[] <strong>str &#x3D; s.toCharArray</strong>()</strong>;<br>      HashMap</strong>&lt;**Character, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;&gt;()</strong>;<br>      **int **all &#x3D; 1; &#x2F;&#x2F; 一个字符也没遍历的时候，有空集<br>      **for (char <strong>x : str</strong>) {<br>         int **newAdd &#x3D; all;<br>&#x2F;&#x2F;       int curAll &#x3D; all + newAdd - (map.containsKey(x) ? map.get(x) : 0);<br>         **int **curAll &#x3D; all;<br>         curAll &#x3D; **(<strong>curAll + newAdd</strong>) **% m;<br>         &#x2F;&#x2F;减完可能为负数，所以要先加<br>         curAll &#x3D; **(**curAll - <strong>(<strong>map.containsKey</strong>(<strong>x</strong>) <strong>? map.get</strong>(<strong>x</strong>) <strong>: 0</strong>) <strong>+ m</strong>) <strong>% m;<br>         all &#x3D; curAll;<br>         map.put</strong>(<strong>x, newAdd</strong>)</strong>;<br>      **}<br>      return **all;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-汉诺塔游戏中的最优状态"><a href="#·-汉诺塔游戏中的最优状态" class="headerlink" title="· 汉诺塔游戏中的最优状态"></a>· 汉诺塔游戏中的最优状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539211568-a1dd0839-322f-4a09-8fbb-4427209b059d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=u5e9bcd3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40554&status=done&style=none&taskId=u75553f41-4211-4e03-b1c3-af09e2d344e&title=&width=489.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187846-f70f3d8f-0157-43bd-b853-e65f7208f8ce.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=ua14962a4&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1280&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u50a5c929-49c5-44bd-bc95-307b8dadc4c&title=&width=585"><br>7层汉诺塔问题的一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187621-d66d9436-5fa6-4b96-8665-50fa8b081a64.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=uc20ed9ff&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1260&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1831e6fb-2ea6-4897-b345-95c2d0e887b&title=&width=559"><br>最优解的第一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187608-84fce00e-ce50-476f-8097-9a88be815ab3.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=188&id=u606020c1&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=1323&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udc765580-8b82-4da7-9d75-d59459d93e9&title=&width=666"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187793-ebb720d3-d2df-44dd-b600-10e2915349d5.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=ue283094b&margin=%5Bobject%20Object%5D&originHeight=633&originWidth=1368&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub9dc08a9-ad4f-48c3-9036-b1723d5d890&title=&width=595"><br><strong>题解</strong><br>复杂度 O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187754-902ce282-eb4d-4ffa-b9f2-08d5bb24a1ca.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=ueee15b1a&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5fe3be44-3808-4c07-a651-80f9cb66498&title=&width=523"><br>先忘掉左中右, 目标是逐渐分解的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281818-8f55bc3d-600b-4fe1-9a28-194a2e14b313.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=uc72a3d6d&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1309&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9972a330-30f9-4bb4-b8c7-08fe6f74d00&title=&width=560"><br><strong>抽象</strong><br>i: 1<del>i的圆盘需要移动<br>F: 1</del>i的圆盘现在处在什么圆盘上, 可能是左, 中, 右<br>t: 需要去的位置, 可能是左, 中, 右<br>other: 除了from, to的另外一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281875-9d349353-6eed-4b5a-9c10-e6e7433d67c4.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=ua78ed761&margin=%5Bobject%20Object%5D&originHeight=633&originWidth=1251&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued654e3c-92fc-4ef3-a314-9c63cc17362&title=&width=574"><br><strong>代码</strong><br>i层的圆盘没有任何道理是在other上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358889-bf247fdd-e580-4abd-8d24-c40995fab0f6.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=316&id=u5e1ef882&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1171&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d288535-fb85-41b3-98d3-2cf5fb5d4b2&title=&width=591"><br>如果index还在From上, 说明第一大步没走完<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358848-516f2145-a3f9-46ba-81c9-e9ce28edee97.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=293&id=u07d3b69a&margin=%5Bobject%20Object%5D&originHeight=651&originWidth=1255&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u48e1996c-d742-490a-96d7-66c6462a3a3&title=&width=565"><br><strong>n层汉诺塔最优解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358910-0c4cbbd5-0292-44fe-b9d6-b53981389b71.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=ua0d8af67&margin=%5Bobject%20Object%5D&originHeight=654&originWidth=879&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d18edcc-fa98-42fc-8d83-170aa0206d6&title=&width=386"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028378401-1aa4cb61-81e0-4606-934e-dbf7cd028030.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u5785399a&margin=%5Bobject%20Object%5D&originHeight=612&originWidth=1203&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uea4922b0-8da4-4a95-abb3-8986b68ee4c&title=&width=491"><br>后续有任何一点点无效，你整体就无效</p><p>| **public static int <strong>kth</strong>(int[] <strong>arr</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>return <strong>step</strong>(<strong>arr, N - 1, 1, 3, 2</strong>)</strong>;<br>**}</p><p>**&#x2F;&#x2F; 0…index这些圆盘，arr[0..index] index+1层塔<br>&#x2F;&#x2F; 在哪？from 去哪？to 另一个是啥？other<br>&#x2F;&#x2F; arr[0..index]这些状态，是index+1层汉诺塔问题的，最优解第几步<br>**public static int <strong>step</strong>(int[] **arr, **int **index, **int **from, **int **to, **int <strong>other</strong>) {<br>   if (<strong>index &#x3D;&#x3D; -1</strong>) {<br>      return **0;<br>   **}<br>   if (<strong>arr</strong>[<strong>index</strong>] <strong>&#x3D;&#x3D; other</strong>) {<br>      return **-1;<br>   **}<br>   **&#x2F;**多想想就明白了<br>    * 比如 arr[3,2,1] 三层汉诺塔问题<br>    *<br>    * 第一个在to区<br>    * 第二个在<br>    *<br>    *&#x2F;<br>   &#x2F;&#x2F; arr[index] &#x3D;&#x3D; from arr[index] &#x3D;&#x3D; to;<br>   <strong>if (<strong>arr</strong>[<strong>index</strong>] <strong>&#x3D;&#x3D; from</strong>) {<br>      return <strong>step</strong>(<strong>arr, index - 1, from, other, to</strong>)</strong>;<br>   **} else {<br>      int **p1 &#x3D; **(<strong>1 &lt;&lt; index</strong>) **- 1;<br>      **int **p2 &#x3D; 1;<br>      <strong>int <strong>p3 &#x3D; step</strong>(<strong>arr, index - 1, other, to, from</strong>)</strong>;<br>      **if (<strong>p3 &#x3D;&#x3D; -1</strong>) {<br>         return **-1;<br>      **}<br>      return **p1 + p2 + p3;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><p><strong>复杂度</strong><br>单决策递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028426636-08060a50-74cc-4c62-8e62-424f512cf88c.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=338&id=u443ec777&margin=%5Bobject%20Object%5D&originHeight=634&originWidth=943&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u203f3cdf-b1ab-456b-b0c3-d0034313049&title=&width=502"></p><h2 id="·-两个有序数组间相加和的Topk问题"><a href="#·-两个有序数组间相加和的Topk问题" class="headerlink" title="· 两个有序数组间相加和的Topk问题"></a>· 两个有序数组间相加和的Topk问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539251891-3de0d850-c8d0-4239-a81d-fa1a2210426c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=ue5640a4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43271&status=done&style=none&taskId=u6feb9167-120c-415a-b74d-95ac0e48b98&title=&width=664" alt="image.png"><br>用大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031978240-dce8b855-e997-478e-933a-aab5c7268225.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=u92e50c4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82696&status=done&style=none&taskId=ue0cf5ae5-f712-4140-aac0-9aa695e0286&title=&width=456.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031989072-10c19f0a-4015-407a-8fb7-176cef820206.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u9583c67c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90083&status=done&style=none&taskId=ufffa987b-c980-44a0-89a3-38926c6b62d&title=&width=478.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032000117-c9d348c8-6b94-4a91-a50e-1a47217c9b57.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u80c59775&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119662&status=done&style=none&taskId=udb562210-be25-49bb-981b-b2ccf26efe2&title=&width=516.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032013255-95030714-b09e-4f25-a865-2758167fb7b1.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u49edc7c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=649&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146468&status=done&style=none&taskId=u5745c217-4dbe-4db4-b967-7cfbd0548ac&title=&width=519.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032038337-4b6eddac-52e2-40b0-ac4f-694be2af4927.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u7efe8179&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145293&status=done&style=none&taskId=uc4397788-c306-4e30-b954-1c34575127e&title=&width=510.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032058547-5ce5c648-4d2f-4c69-a0ca-51424b5f5c83.png#clientId=uf4c6500d-8e60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=uec145c06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=317&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38852&status=done&style=none&taskId=uee16e7db-0793-4ade-bcf7-ae43094fe60&title=&width=420" alt="image.png"></p><p>| &#x2F;&#x2F; 放入大根堆中的结构<br>**public static class **Node <strong>{<br>   public int index1</strong>;&#x2F;&#x2F; arr1中的位置<br>   <strong>public int index2</strong>;&#x2F;&#x2F; arr2中的位置<br>   <strong>public int sum</strong>;&#x2F;&#x2F; arr1[index1] + arr2[index2]的值</p><p>   **public <strong>Node</strong>(int **i1, **int **i2, **int <strong>s</strong>) {<br>      index1 **&#x3D; i1;<br>      **index2 **&#x3D; i2;<br>      **sum **&#x3D; s;<br>   **}<br>}</p><p>**&#x2F;&#x2F; 生成大根堆的比较器<br>**public static class **MaxHeapComp **implements <strong>Comparator</strong>&lt;**Node**&gt; {<br>   **@Override<br>   **public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return **o2.**sum **- o1.<strong>sum</strong>;<br>   **}<br>}</p><p>public static int[] <strong>topKSum</strong>(int[] **arr1, **int[] **arr2, **int <strong>topK</strong>) {<br>   if (**arr1 &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr2 &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; topK &lt; 1</strong>) {<br>      return null</strong>;<br>   **}<br>   int **N &#x3D; arr1.<strong>length</strong>;<br>   **int **M &#x3D; arr2.<strong>length</strong>;</p><p>   topK &#x3D; Math.min**(<strong>topK, N * M</strong>)**;</p><p>   **int[] **res &#x3D; <strong>new int[<strong>topK</strong>]</strong>;<br>   **int **resIndex &#x3D; 0;</p><p>   PriorityQueue**&lt;<strong>Node**&gt; <strong>maxHeap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;(new <strong>MaxHeapComp</strong>())</strong>;<br>   HashSet</strong>&lt;**Long**&gt; <strong>set &#x3D; <strong>new <strong>HashSet</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>i1 &#x3D; N - 1;<br>   <strong>int <strong>i2 &#x3D; M - 1;<br>   maxHeap.add</strong>(new <strong>Node</strong>(<strong>i1, i2, arr1</strong>[<strong>i1</strong>] <strong>+ arr2</strong>[<strong>i2</strong>]))</strong>;<br>   set.add</strong>(<strong>x</strong>(<strong>i1, i2, M</strong>))</strong>;&#x2F;&#x2F;二维变一维<br>   <strong>while (<strong>resIndex !&#x3D; topK</strong>) {<br>      <strong>Node curNode &#x3D; maxHeap.poll</strong>()</strong>;<br>      res</strong>[<strong>resIndex++</strong>] <strong>&#x3D; curNode.<strong>sum</strong>;<br>      i1 &#x3D; curNode.<strong>index1</strong>;<br>      i2 &#x3D; curNode.<strong>index2</strong>;<br>      set.remove</strong>(<strong>x</strong>(<strong>i1, i2, M</strong>))</strong>;<br>      <strong>if (<strong>i1 - 1 &gt;&#x3D; 0 &amp;&amp; !set.contains</strong>(<strong>x</strong>(<strong>i1 - 1, i2, M</strong>))) {<br>         <strong>set.add</strong>(<strong>x</strong>(<strong>i1 - 1, i2, M</strong>))</strong>;<br>         maxHeap.add**(new <strong>Node</strong>(<strong>i1 - 1, i2, arr1</strong>[<strong>i1 - 1</strong>] <strong>+ arr2</strong>[<strong>i2</strong>]))<strong>;<br>      <strong>}<br>      if (<strong>i2 - 1 &gt;&#x3D; 0 &amp;&amp; !set.contains</strong>(<strong>x</strong>(<strong>i1, i2 - 1, M</strong>))) {<br>         <strong>set.add</strong>(<strong>x</strong>(<strong>i1, i2 - 1, M</strong>))</strong>;<br>         maxHeap.add</strong>(new <strong>Node</strong>(<strong>i1, i2 - 1, arr1</strong>[<strong>i1</strong>] <strong>+ arr2</strong>[<strong>i2 - 1</strong>]))**;<br>      **}<br>   }<br>   return **res;<br>**}</p><p>public static long <strong>x</strong>(int **i1, **int **i2, **int <strong>M</strong>) {<br>   return (long) **i1 * **(long) **M + **(long) **i2;<br>**}</p><table><thead><tr><th>**</th></tr></thead></table><h2 id="·-42-接雨水-H"><a href="#·-42-接雨水-H" class="headerlink" title="· 42. 接雨水 [H]"></a>· 42. 接雨水 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267273178-987b1982-ef81-4324-8306-8f79b8e3d6ff.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=353&id=u9a387aaa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33271&status=done&style=none&taskId=u7e5d0662-374f-45a2-926d-fe2e07cee61&title=&width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653183809624-bfe54faa-fc8e-4c66-a37c-99bf00c7ccb2.png#clientId=u9486b31d-676a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=uc43d2755&margin=%5Bobject%20Object%5D&name=image.png&originHeight=359&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17507&status=done&style=none&taskId=u90fb9776-20c1-498f-95f0-ab5a02da7b7&title=&width=724" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323108-3482efdf-9617-4893-953d-ccef84395862.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uf94fe60c&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=855&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue2587b40-59ad-4b39-8b70-6184ba23117&title=&width=490"><br><strong>题解</strong><br>跟踪坡峰坡谷的Coding解法不正确<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323100-9d08de8c-b1e3-4f1d-9d28-813b0490efef.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=u98c83e06&margin=%5Bobject%20Object%5D&originHeight=366&originWidth=986&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c3e4756-b5a8-4817-8a39-e247925cb50&title=&width=578"><br>i位置自己整个位置上方有几格水?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323023-37d28c90-8cf6-460d-96e9-9cf07801d95d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=298&id=u691728f9&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=984&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5e997542-0ba1-4e3b-9bf7-b430884218a&title=&width=614"><br>边界情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323022-bf49b7ca-7a22-499d-89e4-9ba96be952dc.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u185b9d89&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=681&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1a037bb2-07a4-406b-b36a-a860e287ed7&title=&width=545"><br>i位置的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268325675-aeb3f9d1-c2fd-4218-89f5-368d9ac0bf4f.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ua64db485&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4474289a-e974-4f64-822b-7bed7e7cc27&title=&width=506"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326254-52267b69-79ad-4bf9-9fa8-cd8d26a94a8d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=292&id=u4434b4f8&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=962&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5338f041-b732-47d3-b061-8a59c39d9b4&title=&width=587"><br><strong>辅助数组</strong><br>需要0<del>i范围上的最大值max<br>i</del>N-1范围上的最大值max<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326340-b8cc0df3-73c2-4d4e-a267-dbe509ac09a4.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=u3182ff51&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=710&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e3ff214-4949-458e-a458-e98f1d2275a&title=&width=540"><br><strong>最优解</strong><br>不需要辅助数组<br>0位置最左 20位置最右是不可能留下水的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326487-100d9b8f-7d1c-416f-9c3f-d57fed517bdc.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue35ef49f&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f3ada90-3915-4cab-ae55-b2018430e01&title="><br>19位置的最大高度假设6, 要结算算水量<br>需要求6的左边, 右边部分的max, 以13做瓶颈,<br>因为6它的左边这么多最大值还没看过，但它的最大值是17，恐怕它真实的左边最大值是大于17的。<br>而我右边的最大值，这可是个真实最大值, 所以6位置的水量就是13-6 &#x3D; 7 格子水<br>左边跟右边max谁小就先结算那边的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326627-e696ef0d-bcf9-4c31-b14d-f8340253c3b2.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=278&id=uac262f4d&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=1063&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uecb45efd-f557-48a5-b00f-d7bd73562f1&title=&width=635"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327142-fa9a9589-71a6-4d59-aa66-b7c33cee30c5.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4c693001&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2adf84f1-1a9b-4fe1-b0a8-886ae13e2cf&title=&width=564"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327723-c5a819e2-e219-4a73-a4fb-5d3e37bc01c7.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u59b410f0&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1074&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u401cfdd3-d2fd-4b7e-9f90-aa11bcb92b4&title=&width=568"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327914-13401c07-43a7-45f0-b9fb-be52bf672963.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u0fcb1059&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u33092d65-5421-468c-961f-251f018357f&title=&width=562"><br>相等怎么办<br>可以一起结算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328197-0ef67c95-b205-4b96-bb3b-4861e493c575.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=197&id=u58c81a8a&margin=%5Bobject%20Object%5D&originHeight=340&originWidth=1038&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d5765fc-e857-484a-bb9b-b63c2ef9a07&title=&width=602"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328220-048d534c-040c-4157-851b-81ffab6e636e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ub7259426&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=1024&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud895d562-3d89-4df9-973d-e6e4a3153f3&title=&width=557"><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328354-f6461e69-c9fc-464e-b55d-98e8f7a989f6.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2f50eac9&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=433&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufd62e68c-e8d6-4953-ae67-65811a0750c&title="></p><h2 id="·-✊407-接雨水-II-H"><a href="#·-✊407-接雨水-II-H" class="headerlink" title="· ✊407. 接雨水 II [H]"></a>· ✊407. 接雨水 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267310891-9ae51e62-eb36-4c3d-aecf-42757c8bc9da.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=424&id=u4348eeb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=921&originalType=binary&ratio=1&rotation=0&showTitle=false&size=167029&status=done&style=none&taskId=u12c089cc-f48c-4fe5-b32a-f49a6ad36f5&title=&width=616.7999877929688" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567058-f79a7202-de25-40fb-a9e7-36ee14452e6c.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uf198170f&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=835&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc30f9554-6db3-457f-b0f2-32d091524b1&title=&width=489"><br><strong>题解</strong><br>这一圈的值放到小根堆去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566883-18c6b4b4-30c6-4a82-a82a-59b43835a5db.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=u3d5807f8&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=806&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u427cc3c0-49d7-4081-aa59-7229fad2c68&title=&width=542"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566896-0282f120-5392-4308-9d6e-ecdfee83e80e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=u9d229db5&margin=%5Bobject%20Object%5D&originHeight=449&originWidth=1004&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u218c752a-31e6-48f8-919c-307b08a911f&title=&width=595"><br>都会以max做为瓶颈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567083-2497db05-4afd-4681-82b4-112847d15636.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=316&id=u799526e3&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=957&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc83a1690-d0de-4210-95ad-eb1fbc9439e&title=&width=608"><br>只要max不更新, 都是max的内湖区域<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566876-7b3a2096-ce22-4ac5-90e4-10ffa818dc49.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u8728c50f&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=916&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae7d39ad-2aa8-4dd3-922b-4deb1c5a810&title=&width=608"><br><strong>例子</strong><br>一个数进去的时候结算水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568452-8d0329f2-01e6-457a-af5e-535b96a0aa9e.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=324&id=u2d7d0a44&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=962&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2363d263-1b25-4389-b468-1c17f534e8d&title=&width=642"><br><strong>代码</strong><br>max不更新就说明出海口就没有变</p><p>| **public static class **Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   **public <strong>Node</strong>(int **v, **int **r, **int <strong>c</strong>) {<br>      value **&#x3D; v;<br>      **row **&#x3D; r;<br>      **col **&#x3D; c;<br>   **}</p><p>}</p><p>public static int <strong>trapRainWater</strong>(int[][] <strong>heightMap</strong>) {<br>   if (**heightMap &#x3D;&#x3D; **null **&amp;#124;&amp;#124; heightMap.**length <strong>&#x3D;&#x3D; 0 &amp;#124;&amp;#124; heightMap</strong>[<strong>0</strong>] **&#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; heightMap</strong>[<strong>0</strong>]</strong>.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   **}<br>   int **N &#x3D; heightMap.<strong>length</strong>;<br>   <strong>int <strong>M &#x3D; heightMap</strong>[<strong>0</strong>]</strong>.<strong>length</strong>;<br>   <strong>boolean[][] <strong>isEnter &#x3D; <strong>new boolean[<strong>N</strong>][<strong>M</strong>]</strong>;<br>   PriorityQueue</strong>&lt;**Node**&gt; <strong>heap &#x3D; <strong>new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) <strong>-&gt; a.<strong>value <strong>- b.<strong>value)</strong>;<br>   <strong>for (int <strong>col &#x3D; 0; col &lt; M - 1; col++**) {<br>      **isEnter**[**0**][**col**] **&#x3D; **true**;<br>      heap.add**(new **Node**(**heightMap**[**0**][**col**]**, 0, col**))**;<br>   **}<br>   for (int **row &#x3D; 0; row &lt; N - 1; row++**) {<br>      **isEnter**[**row**][**M - 1**] **&#x3D; **true**;<br>      heap.add**(new **Node**(**heightMap**[**row**][**M - 1**]**, row, M - 1**))**;<br>   **}<br>   for (int **col &#x3D; M - 1; col &gt; 0; col–</strong>) {<br>      <strong>isEnter</strong>[<strong>N - 1</strong>][<strong>col</strong>] <strong>&#x3D; <strong>true</strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>N - 1</strong>][<strong>col</strong>]</strong>, N - 1, col</strong>))</strong>;<br>   <strong>}<br>   for (int <strong>row &#x3D; N - 1; row &gt; 0; row–</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>0</strong>] <strong>&#x3D; <strong>true</strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>0</strong>]</strong>, row, 0</strong>))</strong>;<br>   <strong>}<br>   int <strong>water &#x3D; 0;<br>   <strong>int <strong>max &#x3D; 0;<br>   <strong>while (</strong>!heap.isEmpty</strong>()) {<br>      <strong>Node cur &#x3D; heap.poll</strong>()</strong>;<br>      max &#x3D; Math.max</strong>(<strong>max, cur.<strong>value)</strong>;<br>      <strong>int <strong>r &#x3D; cur.<strong>row</strong>;<br>      <strong>int <strong>c &#x3D; cur.<strong>col</strong>;<br>      &#x2F;&#x2F;上下左右去放<br>      &#x2F;&#x2F;有上面<br>      <strong>if (<strong>r &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>])</strong>;<br>         isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>]</strong>, r - 1, c</strong>))</strong>;<br>      <strong>}<br>      <strong>&#x2F;&#x2F;有下<br>      <strong>if (<strong>r &lt; N - 1 &amp;&amp; !isEnter**[**r + 1**][**c**]) {<br>         **water +&#x3D; Math.max**(**0, max - heightMap**[**r + 1**][**c**])**;<br>         isEnter**[**r + 1**][**c**] **&#x3D; **true**;<br>         heap.add**(new **Node**(**heightMap**[**r + 1**][**c**]**, r + 1, c**))**;<br>      **}<br>      **&#x2F;&#x2F;有左<br>      **if (**c &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>])</strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>]</strong>, r, c - 1</strong>))</strong>;<br>      <strong>}<br>      <strong>&#x2F;&#x2F;有右<br>      <strong>if (<strong>c &lt; M - 1 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>]) {<br>         <strong>water +&#x3D; Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>])</strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>] <strong>&#x3D; <strong>true</strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>]</strong>, r, c + 1</strong>))</strong>;<br>      **}<br>   }<br>   return **water;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568940-16d91986-3ce5-4170-995b-25e5eb327a2d.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=ua197f36f&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=560&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5856214b-6641-45ba-838e-b397b8823c9&title=&width=378"></p><h2 id="·-找出最大的左部分最大值减去右部分最大值的绝对值"><a href="#·-找出最大的左部分最大值减去右部分最大值的绝对值" class="headerlink" title="· 找出最大的左部分最大值减去右部分最大值的绝对值"></a>· 找出最大的左部分最大值减去右部分最大值的绝对值</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652270318016-0e37cdc1-b8e3-47ba-bf01-6f42eb4e6247.png#clientId=u8f57a630-644c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=ua69a96f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17778&status=done&style=none&taskId=u26260abf-215f-42d6-9e95-5f6eace034c&title=&width=652.8" alt="image.png"><br><strong>题意</strong><br>所以你每切一刀都会有一个左部分的最大值，减去右部分的最大值的绝对值<br>一共有N-1种切法。那么哪一种切法下，这个值能最大, 把这个最大的结果返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009637-2441118c-f8dd-47dd-afef-1bf81668b74a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=pClpf&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=1223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f94afae-e9f4-41ae-8f51-6fb3c2947e8&title=&width=485"><br><strong>题解</strong><br>暴力: 遍历<br>当我来到i位置的时候, 0<del>i是左部分, i+1</del>N-1是右部分, 枚举i, 遍历一下找左右部分的最大值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009601-259b07db-0b03-422c-aa80-7360e0e29474.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=zBUSt&margin=%5Bobject%20Object%5D&originHeight=525&originWidth=1171&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u68d556cd-13fd-4bfa-b226-e655edba474&title=&width=605"><br><strong>辅助数组</strong><br>left数组: 记录0~i范围上的最大值<br>当前数跟前一个位置的数, 谁大拷贝谁</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009616-8360c1b6-bd21-47cf-b05a-4894b6301470.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=w2PrR&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=1020&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3dd0bbc-0eb9-4eda-8708-0ac0d2dcf67&title=&width=656"><br>right数组:从右往左生成,i+1<del>N-1范围上的最大值<br>有了两个辅助数组, 再去枚举i的时候<br>0</del>i范围上的最大值直接从left数组里取, i+1~N-1范围上的最大值直接从right数组里拿<br>把O(N^2)的暴力解优化成O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009605-dbca0f91-6ad8-4748-9f10-8885d7311c83.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=337&id=qF9iP&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1035&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8518c4be-731f-43bd-910f-44af73685c7&title=&width=690"></p><p>| **public static int <strong>maxABS2</strong>(int[] <strong>arr</strong>) {<br>   int[] **lArr &#x3D; **new int[**arr.<strong>length]</strong>;<br>   **int[] <strong>rArr &#x3D; <strong>new int[<strong>arr.<strong>length]</strong>;<br>   lArr</strong>[<strong>0</strong>] <strong>&#x3D; arr</strong>[<strong>0</strong>]</strong>;<br>   rArr</strong>[**arr.<strong>length <strong>- 1</strong>] <strong>&#x3D; arr</strong>[<strong>arr.<strong>length <strong>- 1</strong>]</strong>;<br>   <strong>for (int <strong>i &#x3D; 1; i &lt; arr.**length**; i++**) {<br>      **lArr**[**i**] **&#x3D; Math.max**(**lArr**[**i - 1**]**, arr**[**i**])**;<br>   **}<br>   for (int **i &#x3D; arr.**length **- 2; i &gt; -1; i–</strong>) {<br>      <strong>rArr</strong>[<strong>i</strong>] <strong>&#x3D; Math.max</strong>(<strong>rArr</strong>[<strong>i + 1</strong>]</strong>, arr</strong>[<strong>i</strong>])</strong>;<br>   **}<br>   int **max &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.<strong>length <strong>- 1; i++</strong>) {<br>      <strong>max &#x3D; Math.max</strong>(<strong>max, Math.abs</strong>(<strong>lArr</strong>[<strong>i</strong>] <strong>- rArr</strong>[<strong>i + 1</strong>]))</strong>;<br>   **}<br>   return **max;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>最优解</strong><br>arr 遍历一遍找到全局最大值, 然后0位置数跟N-1位置数, 谁小减谁就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009794-49174c11-7c15-4f33-86e2-e55388ed91d5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=cLoHI&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=885&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c009e6b-c545-4de7-913a-67aee64f8ad&title=&width=519"><br>可能性罗列</p><ol><li><p>全局max被划分到了左边</p></li><li><p>全局max被划分到了右边</p></li><li><p>max - 右边的最大值就是答案<br>让右max尽量小<br>右部分一定要有数, 一定会包含N-1位置的数<br>右部分只包含最右边一个数是右边max最小的时候<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010132-31eed44f-ffcb-4639-bc25-e746726c22ef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=D4cKJ&margin=%5Bobject%20Object%5D&originHeight=453&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d6af354-eb1a-467a-8e6e-9faad6833e9&title="></p></li><li><p>左max尽量小, 左部分一定会包含0位置的数<br>就让左部分只包含0位置的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010235-2ac3a3a2-5e64-4573-90c1-1ce1513e4177.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=dhLOT&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=1030&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue7dd0c92-9bcb-4ee3-ae1f-c25a9700fb7&title="><br><strong>代码</strong></p></li></ol><p>| &#x2F;&#x2F;amazing！<br><strong>public static int <strong>maxABS3</strong>(int[] <strong>arr</strong>) {<br>   int <strong>max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; arr.<strong>length</strong>; i++</strong>) {<br>      <strong>max &#x3D; Math.max</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, max</strong>)</strong>;<br>   <strong>}<br>   return <strong>max - Math.min</strong>(<strong>arr</strong>[<strong>0</strong>]</strong>, arr**[**arr.<strong>length <strong>- 1</strong>])</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊最大可整合子数组的长度"><a href="#·-✊最大可整合子数组的长度" class="headerlink" title="· ✊最大可整合子数组的长度"></a>· ✊最大可整合子数组的长度</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532365836-3c8093cf-782d-4f0e-854a-8c3427e0a834.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=u867734bf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=305&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61875&status=done&style=none&taskId=u53f84319-b0b7-4cfb-9d4d-beafbf2b477&title=&width=669.6" alt="image.png"><br><strong>题意</strong><br>排完序之后依次加1得到就是可整合<br>只要有重复值，它就没办法做可整合数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386766-8b1f7bae-ec0c-4109-bd44-011cacc7d351.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=ua84eeb28&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=581&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u015f7cff-9f62-4bfc-954d-9440e8dd640&title=&width=396"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386782-0ba22845-7afc-4f9e-a81b-9283c470caba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u3850d3b2&margin=%5Bobject%20Object%5D&originHeight=438&originWidth=728&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb9990b4-f7ff-479c-94d4-943e8d57ac3&title=&width=449"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386975-f5f84998-bdcd-4f75-8fb4-702dc86cb261.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=udf385003&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=782&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d425bbc-9f7b-4f84-bf26-d91fcd501fa&title=&width=462"><br>哪一个子数组是可整合的而且最长, 返回最长长度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386935-72cadf66-19f6-4562-b619-f95e67f91c55.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=u6cceb4e0&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=694&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4089eb32-f3bb-4b90-9c15-e35b315eb17&title=&width=491"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386866-d20c76bd-4969-4bce-ad9b-c784eb6a76a2.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=224&id=u7df7ee5c&margin=%5Bobject%20Object%5D&originHeight=387&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua502ac2b-174e-47d6-b4d4-4187fa647f2&title=&width=521"><br>不能排序<br>因为他问的就是你原始arr的数据状况，最长可整合子数组是啥？<br>排完序0,1,2原数组没有这个子数组<br>原数据状况是不能够动的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387154-7c295c6a-1838-45a2-ae75-508ced86774f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=320&id=u735cfd92&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=882&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0882a71c-1ed1-4ec5-bce0-e4fbd3b9685&title=&width=625"><br><strong>题解</strong><br>不能用滑动窗口, 没有单调性<br>因为如果一个窗口是可整合的, 它扩大或缩小不一定可整合<br>子数组范围这件事和可整合这件事建立不起单调性。<br>能用滑动窗口的最重要的性质就是某种范围上的单调性<br>子数组范围扩大了，或者子数组范围缩小了，对于可整合的东西，<br>它是有一定的单调性的，我菜可以去利用，而本题是没有的。<br>所以滑动窗口也用不了。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387319-f3df4fef-b417-4636-bfc4-b098e97ad628.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=u07077d33&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6d45fb4c-a596-4283-a50a-b3b83d3dd28&title=&width=496"><br><strong>暴力解:</strong><br>枚举所有子数组<br>比如说我验证从L到R这一段是不是可整合的,<br>可以把它拷贝出来, 拍完序再验证是不是可整合的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387425-c3b5c57f-08b3-4119-a9d3-65813f51fc17.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=307&id=uf7a760b5&margin=%5Bobject%20Object%5D&originHeight=435&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u83b81b1d-d7d6-49c7-ac07-77c4d2696e1&title=&width=636"><br><strong>复杂度</strong><br>子数组数量O(N^2), 子数组平均长度N<br>把子数组拷贝一下O(N), 子数组排序O(N<em>logN), 排序后的验证O(N)<br>取最高阶O(N</em>logN), 最终复杂度O(N^3*logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387470-931d4e55-faee-4d65-aaf2-82ec28e91d09.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=u9026a328&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89e7ad6f-b03b-4734-b328-39d568514d8&title=&width=625"><br><strong>重新定义可整合数组标准！！！</strong></p><ol><li>没有重复值</li><li>数组最大值-最小值&#x3D;个数-1<br>满足这两个条件就是可整合数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387491-c2cc6771-68b6-4a63-a0ab-83e7c4f0ed43.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u4220dfc8&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=965&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23575989-4df0-4efb-a468-212b66ddbef&title=&width=532"><br>简化的过程</li></ol><p>| **public static int <strong>maxLen</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length <strong>&#x3D;&#x3D; 0</strong>) {<br>      return **0;<br>   <strong>}<br>   int <strong>N &#x3D; arr.<strong>length</strong>;<br>   HashSet</strong>&lt;**Integer**&gt; <strong>set &#x3D; <strong>new <strong>HashSet</strong>&lt;&gt;()</strong>;<br>   <strong>int <strong>ans &#x3D; 1;&#x2F;&#x2F;答案至少是1<br>   <strong>for (int <strong>L &#x3D; 0; L &lt; N; L++</strong>) {<br>      <strong>set.clear</strong>()</strong>;&#x2F;&#x2F;因为r要归为<br>      <strong>int <strong>min &#x3D; arr</strong>[<strong>L</strong>]</strong>;<br>      <strong>int <strong>max &#x3D; arr</strong>[<strong>L</strong>]</strong>;<br>      set.add</strong>(<strong>arr</strong>[<strong>L</strong>])</strong>;<br>      &#x2F;&#x2F; L..R<br>      <strong>for (int <strong>R &#x3D; L + 1; R &lt; N; R++</strong>) {<br>         <strong>&#x2F;&#x2F; L….R<br>         <strong>if(<strong>set.contains</strong>(<strong>arr</strong>[<strong>R</strong>])) {<br>            break</strong>;<br>         <strong>}<br>         <strong>set.add</strong>(<strong>arr</strong>[<strong>R</strong>])</strong>;<br>         min &#x3D; Math.min</strong>(<strong>min, arr</strong>[<strong>R</strong>])</strong>;&#x2F;&#x2F;可能r的值更小<br>         max &#x3D; Math.max</strong>(<strong>max, arr</strong>[<strong>R</strong>])</strong>;&#x2F;&#x2F;也可能r的值更大<br>         &#x2F;&#x2F;个数：R-L+1,再减个1<br>         <strong>if(<strong>max - min &#x3D;&#x3D; R - L</strong>) {<br>            <strong>ans &#x3D; Math.max</strong>(<strong>ans, R - L + 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   return **ans;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>总结: 改题目的设定让它变得更简洁</strong><br>就是当你发现，比如说面试场上给了你一道题，它的定义部分让你求解的部分是如此之复杂。<br>你不要硬着头皮，就按照他的说法就硬上了，你要改成你自己的定义。比如说我们把这个就<br>拆分成了系统最大值减两头这样一个问题，把可整合数组重新写了定义之后，能让我们验证<br>可整合这个过程变快，这种就属于在面试场上遇到了一类，它给你来一个设定，但是你要改<br>它的设定让它变得更简洁的。要有这个心眼，你发现这道题目设定的部分写得特别的绕。<br>那说明它可能不够简洁，这时要有一个心眼，就是要改设定。这样改设定的题型很多，<br>我们以后遇到再说。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532543649-53d3de55-8561-4ff0-add7-817357bd81ac.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=u7ad3e556&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ce4aaab-9297-47d3-9ce8-fbaa226b91f&title=&width=474"></p><h2 id="·-✊超级水王问题"><a href="#·-✊超级水王问题" class="headerlink" title="· ✊超级水王问题"></a>· ✊超级水王问题</h2><p><strong>题意</strong><br>我给你个数组，如果有水王数你打印出来，如果无水王数，你告诉用户没有<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564573-18f0aae5-4c48-4583-a5fc-908f05f918aa.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=ub63ef09a&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb3f9d95-2385-4717-ab8a-502c4ce9c0f&title=&width=489"><br>要求时间复杂度O(N)<br>空间复杂度O(1)<br>把用hash表的路堵死了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564812-7f6017f2-4972-4dde-b65e-5065ad21c9b5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=ua3b9fe6a&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=963&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u345c305d-94e0-4908-a782-ea6311d8772&title=&width=533"><br><strong>题解</strong><br>一次删掉两个不同值的数, 如果arr中真的有水王的话, 这个水王数一定会剩下来<br>因为水王数是大于一半的次数的。哪怕其它所有的数字都跟水王数为敌<br>水王数也会活下来, 更不用说其它数字之间还会有内战的情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564621-4c4d07c4-1905-4d22-8161-ba7827127276.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=ud9c14c93&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uac5cb9f7-4ed2-4d56-99bd-234e14ca061&title=&width=470"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564724-40df89be-6e7c-479d-b755-0479f9168ce6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1df2e5b3&margin=%5Bobject%20Object%5D&originHeight=144&originWidth=382&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94cefb0a-39fc-4749-88dc-a340c7f447b&title="><br>arr一次删掉两个不同的数, 最后剩下的数一定是水王吗?<br>不一定是水王<br>如果有水王的话, 一定会剩下来<br>如果没有水王的话, 如果剩下来的数都不是水王，那就没有数是了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564674-454bc6b4-a8ff-479c-938b-e6e9a24a390d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua49eec8c&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=421&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1cb3b4b7-b9f8-4379-a900-ef09a62f703&title="><br><strong>思路</strong></p><ol><li>arr 一次删除两个不同值的数, 看最终谁会剩下来</li></ol><p>可能性<br>1: 没有数字剩下来: 无水王数<br>2: 有数剩下来<br>x剩下来, 再遍历看x真实出现的次数跟N&#x2F;2对比</p><p><strong>怎么一次删除两个不同的数?</strong><br>时间复杂度O(N)<br>空间复杂度O(1)<br>两个变量</p><ol><li>候选cand</li><li>血量hp<br>当血量&#x3D;0, 认为没有候选人<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565245-13d042e9-15ce-451f-9d00-22fb6b8c37eb.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u22eda463&margin=%5Bobject%20Object%5D&originHeight=431&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua04fdaf1-7f3e-4a6d-9286-dad2914a968&title=&width=542"><br><strong>流程</strong><br>一个一个数遍历, 三条规则:</li><li>如果没有候选, 当前数立为候选, 血量+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565228-0cb5c6f0-77d1-4a27-9618-82f95127135e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u3e918b1a&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=1021&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8d87f13b-7fc7-4e50-aa59-77782c0c05d&title=&width=585"></li><li>如果有候选<br> 1)当前数跟候选不一样,血量–<br> 2)当前数是候选,血量++<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565221-c7dde5a0-148c-4fc2-9ce8-9c33a38b526a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u9c9600a3&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=1032&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c27cf79-9f62-4684-95ac-0cb1bb50623&title=&width=571"><br>解释</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565427-1f53495a-7f90-4a2e-b08b-43af2f9f0147.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u1cb7e569&margin=%5Bobject%20Object%5D&originHeight=506&originWidth=1011&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf9fba9e6-c81e-4f75-a1bc-54ac7326b4d&title=&width=592"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565702-b20446ee-a34b-4303-85dc-18bfb790a1ab.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=u81618e25&margin=%5Bobject%20Object%5D&originHeight=497&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua102ae15-5ac8-4490-a8d4-6d41c0048d7&title=&width=623"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565738-f2a9bd97-215c-4362-9d4d-23af8dc985b1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u9538e7a3&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=1009&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72d5eca0-0819-455a-bb9a-c4de485e2ab&title=&width=634"><br>遍历完成后,如果血量&#x3D;0,表示什么数也没有剩下来,如果血量不等于零，候选就是剩下来的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565794-847db360-2964-4094-8ffe-a086883180e7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u676fec88&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e114edf-2d28-4477-a82d-92b2a494048&title=&width=634"><br><strong>代码</strong></p><p>| **public static void <strong>printHalfMajor</strong>(int[] <strong>arr</strong>) {<br>   int **cand &#x3D; 0;<br>   **int **HP &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.**length**; i++**) {<br>      if (**HP &#x3D;&#x3D; 0**) {<br>         **cand &#x3D; arr**[**i**]**;<br>         HP &#x3D; 1;<br>      **} else if (**arr**[**i**] **&#x3D;&#x3D; cand**) {<br>         **HP++;<br>      **} else {<br>         **HP–;<br>      **}<br>   }<br>   if(**HP &#x3D;&#x3D; 0**) {<br>      **System.**out**.println**(“no such number.”)**;<br>      **return**;<br>   **}<br>   **HP &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; arr.**length**; i++**) {<br>      if (**arr**[**i**] **&#x3D;&#x3D; cand**) {<br>         **HP++;<br>      **}<br>   }<br>   if (**HP &gt; arr.<strong>length <strong>&#x2F; 2</strong>) {<br>      <strong>System.<strong>out</strong>.println</strong>(<strong>cand</strong>)</strong>;<br>   <strong>} else {<br>      <strong>System.<strong>out</strong>.println</strong>(“no such number.”)</strong>;<br>   **}</p><table><thead><tr><th>}**</th></tr></thead></table><p><strong>扩展</strong><br>给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N&#x2F;K，打印这些数，如果没有不打印</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692268-ec19fdb8-d919-4ff4-989b-a9441d09217c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u794e348d&margin=%5Bobject%20Object%5D&originHeight=467&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c744658-4ae3-453a-95bc-6b4354a53a7&title=&width=532"><br>至多K-1个出现N&#x2F;K次的数（假设k &#x3D; 2，至多只有一个数字）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692364-02aa48c0-9e3a-4054-aaa4-0a8176783fbc.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u7c355bf8&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=820&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u22b99e23-11f2-4517-ad75-24ab4f0e7ac&title=&width=477"><br><strong>例子</strong><br>K&#x3D;4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692393-908c6f08-2bfa-4465-812d-6007cce170df.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=udfebc94e&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=919&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c9dd817-5300-40b5-818b-31b809878ad&title=&width=563"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692292-a6252411-18f3-4e51-a21c-65ab7d2fe782.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=uc29f6c64&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=907&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udfc00b4d-da71-4486-92cc-4c1ec0d3bb6&title=&width=521"><br>4来了, 所有人-1点血量<br>血量是0不要, 删掉, 一次删掉了4个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692349-175242d0-ebac-4c64-8c62-f814f64470dd.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59831a71&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=603&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub7fa5c34-2c6b-4a84-8c3a-dac5f6647df&title="><br><strong>代码</strong><br>必须验证真实次数<br>候选有什么，也不代表它就代表唯一考虑的集合<br>但它是不是, 不收集真实次数没人知道</p><p>| **public static void <strong>printKMajor</strong>(int[] **arr, <strong>int <strong>K</strong>) {<br>   if (<strong>K &lt; 2**) {<br>      **System.**out**.println**(“the value of K is invalid.”)**;<br>      **return**;<br>   **}<br>   **&#x2F;&#x2F; 攒候选，cands，候选表，最多K-1条记录！ &gt; N &#x2F; K次的数字，最多有K-1个<br>   HashMap</strong>&lt;**Integer, Integer**&gt; <strong>cands &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      if (<strong>cands.containsKey</strong>(<strong>arr</strong>[<strong>i</strong>])) {<br>         <strong>cands.put</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, cands.get</strong>(<strong>arr</strong>[<strong>i</strong>]) <strong>+ 1</strong>)</strong>;<br>      <strong>} else { <strong>&#x2F;&#x2F; arr[i] 不是候选<br>         <strong>if (<strong>cands.size</strong>() <strong>&#x3D;&#x3D; K - 1</strong>) { <strong>&#x2F;&#x2F; 当前数肯定不要！，每一个候选付出1点血量，血量变成0的候选，要删掉！<br>            allCandsMinusOne</strong>(<strong>cands</strong>)</strong>;<br>         <strong>} else {<br>            <strong>cands.put</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   **&#x2F;&#x2F; 所有可能的候选，都在cands表中！遍历一遍arr，每个候选收集真实次数</p><p>   HashMap**&lt;<strong>Integer, Integer**&gt; <strong>reals &#x3D; getReals</strong>(<strong>arr, cands</strong>)</strong>;<br>   **boolean **hasPrint &#x3D; <strong>false</strong>;<br>   <strong>for (<strong>Entry</strong>&lt;**Integer, Integer**&gt; <strong>set : cands.entrySet</strong>()) {<br>      <strong>Integer key &#x3D; set.getKey</strong>()</strong>;<br>      **if (<strong>reals.get</strong>(<strong>key</strong>) **&gt; arr.**length <strong>&#x2F; K</strong>) {<br>         <strong>hasPrint &#x3D; <strong>true</strong>;<br>         System.<strong>out</strong>.print</strong>(**key + <strong>“ “)</strong>;<br>      **}<br>   }<br>   <strong>System.<strong>out</strong>.println</strong>(**hasPrint ? **”” **: <strong>“no such number.”)</strong>;<br>**}</p><p>public static void <strong>allCandsMinusOne</strong>(<strong>HashMap</strong>&lt;<strong>Integer, Integer**&gt; <strong>map</strong>) {<br>   <strong>List</strong>&lt;**Integer**&gt; <strong>removeList &#x3D; <strong>new <strong>LinkedList</strong>&lt;**Integer**&gt;()</strong>;<br>   <strong>for (<strong>Entry</strong>&lt;**Integer, Integer**&gt; <strong>set : map.entrySet</strong>()) {<br>      <strong>Integer key &#x3D; set.getKey</strong>()</strong>;<br>      Integer value &#x3D; set.getValue</strong>()</strong>;<br>      <strong>if (<strong>value &#x3D;&#x3D; 1</strong>) {<br>         <strong>removeList.add</strong>(<strong>key</strong>)</strong>;<br>      <strong>}<br>      <strong>map.put</strong>(<strong>key, value - 1</strong>)</strong>;<br>   <strong>}<br>   for (<strong>Integer removeKey : removeList</strong>) {<br>      <strong>map.remove</strong>(<strong>removeKey</strong>)</strong>;<br>   **}<br>}</p><p>public static <strong>HashMap</strong>&lt;**Integer, Integer**&gt; <strong>getReals</strong>(int[] <strong>arr,<br>      HashMap</strong>&lt;**Integer, Integer**&gt; <strong>cands</strong>) {<br>   <strong>HashMap</strong>&lt;**Integer, Integer**&gt; **reals &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>for (int <strong>i &#x3D; 0; i !&#x3D; arr.<strong>length</strong>; i++</strong>) {<br>      int <strong>curNum &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>      <strong>if (<strong>cands.containsKey</strong>(<strong>curNum</strong>)) {<br>         if (<strong>reals.containsKey</strong>(<strong>curNum</strong>)) {<br>            <strong>reals.put</strong>(<strong>curNum, reals.get</strong>(<strong>curNum</strong>) <strong>+ 1</strong>)</strong>;<br>         <strong>} else {<br>            <strong>reals.put</strong>(<strong>curNum, 1</strong>)</strong>;<br>         **}<br>      }<br>   }<br>   return **reals;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊第k小的数值对"><a href="#·-✊第k小的数值对" class="headerlink" title="· ✊第k小的数值对"></a>· ✊第k小的数值对</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533451839-1dcc4f86-8175-4b98-bb2d-33fab076095b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ucc6bd1e8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43310&status=done&style=none&taskId=udbf48c7b-c5c2-41b0-807a-c792b021443&title=&width=669.6" alt="image.png"><br><strong>题解</strong><br><strong>暴力解</strong><br>两个for循环生成所有数值对, 放到数组里用比较器排序, 取出第K位的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574288-932f369b-6665-4975-870e-8d798fe5b12a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ue3aaa206&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1081&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1fb1f388-552d-4f2a-a109-a817c3ba4b9&title=&width=604"><br>复杂度 O(N^2*logN^2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574337-82315d0f-95c8-492b-9c77-3fc02ea2091e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=u7073562e&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1147&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6c9f817e-0dab-474c-857c-d4fef6c040a&title=&width=655"><br><strong>最优解</strong><br>最优解复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574399-0f80a80f-e29a-446a-91ed-6eb65d947887.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ud6983707&margin=%5Bobject%20Object%5D&originHeight=323&originWidth=806&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u84b6d280-143f-4d10-abd7-57f845288b9&title=&width=626"><br><strong>过程</strong><br>根据第一维数据进行分组<br>第一维的数字是1的叫第1组里的数值对<br>第一维的数字是2的叫第2组里的数值对<br>第一维的数字是3的叫第3组里的数值对<br>第一维的数字是5的叫第4组里的数值对<br>大体上分块就这么多块<br>想知道第70个数是哪个数值对里的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574353-1821c432-0685-4133-b7b9-be12b0b00a2f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaf4e4a03&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=1148&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2ded78e1-5092-4773-9c69-8dd1d9d867c&title="><br>假设第70个数是(a,b)这两维数据, 先定位a是谁, 数组长度是11<br>必须以0位置的1做为第一维数据的一共有11个<br>必须以1位置的1做为第一维数据的一共有11个<br>必须以2位置的1做为第一维数据的一共有11个<br>必须以3位置的2做为第一维数据的一共有11个<br>所以你想求第 70 个怎么定位这个a？你就看看它是哪一组里的, 说明它第一维就是那个位置的数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574305-dac448dc-7170-485a-a101-f723d251e819.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueab68af7&margin=%5Bobject%20Object%5D&originHeight=407&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u052e5313-afe0-43a7-8a72-428388a3bf1&title="><br>定位70是哪一组里的,<br>第70个数来自于3的组, 第一维数据是3<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575227-31b8ed61-55a5-4dfe-9627-7c7149d896d6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1a4f9244&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=1133&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucf6b52e7-70e5-4015-a29f-6c52f65ea6e&title="><br>怎么得到b<br>b肯定是3组里的数值对,<br>3之前一共搞定了55个, 所以你要第 70 个，它应该是三大组中的第 15 个。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575288-74bcd08a-9b14-434a-8bff-c504f8dabde3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=ufa15bced&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2db97466-6de6-4213-9d9d-840e2b29949&title=&width=635"><br>3大组中再细分,<br>必须以0位置的1做二维数据的有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575449-630237a5-8e4c-44e5-8adf-02ebd9c41cf7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u2e30a4fd&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1129&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uca568bff-376a-4bb3-812f-4b3fa039d94&title=&width=527"><br>相求3大组中的第15个, 一共有4个3, 所以<br>必须0位置的1做第二维数据的, 4个<br>必须1位置的1做第二维数据的,4个<br>必须2位置的1做第二维数据的,4个<br>必须3位置的2做第二维数据的,4个<br>看看这第15个来自那一组, 就可以定位第二维的数字来自哪儿了</p><p><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575700-2e9c1dc6-1c5a-434e-8f4a-34e244c6162e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=ue603987f&margin=%5Bobject%20Object%5D&originHeight=390&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u494d13cd-e862-4e22-a402-187828b9bf6&title=&width=689"><br>第一维的数字是4<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575882-6c7e9e5d-1b94-4951-841f-d623a6840864.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udeef2653&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u06579f25-1baa-49c4-81f0-bda6a471bfc&title=&width=667"><br>1,2,3开头的一共有70个<br>第一维是4的情况下,<br>4里的12<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576014-43be7fca-337b-4cbf-9dd6-ac93d054933f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6ae98023&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1126&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufe456ad6-a016-4ec4-9226-9d0d844b402&title="><br>4的组细分<br>第二维数字是1,2,3,4的那些<br>第一维数字是 4 的情况下再往下细分组是啥?<br>第二维数据是 1 的那些<br>第二维数据是 2 的那些<br>第二维数据是 3 的那些<br>第二维数据是 4 的那些</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576961-4018a1d4-8795-402b-ad61-9094ebaf856f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=uc4ab67a7&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=1135&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub026b4b3-619a-4a77-a4a5-ae1fc99b04f&title=&width=629"><br>第一维的数字已经确实是4了<br>第二维数据是 1 的那些分为<br>0位置的1做第二维的数据, 3个, 7,8,9位置的4都是<br>1位置的1做第二维的数据, 3个, 7,8,9位置的4都是</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577008-8175b831-2b92-4719-bc9c-ea5b8bf3434e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=372&id=u8e3187a1&margin=%5Bobject%20Object%5D&originHeight=547&originWidth=873&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf2f6ca15-0d35-46b9-be0d-6928f79b21f&title=&width=594"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576966-c18e528a-b6b0-4d36-b9ad-54ce913287a5.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=u2b5ae72a&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=1121&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uee646ef9-bab2-4946-9ef3-cdd53fb4f48&title=&width=627"><br><strong>抽象化</strong><br>假设一共有N个数,求第K小数值对<br>怎么定位第一维数据?<br>K&#x2F;N的下标对应的值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577141-db303288-f81d-47eb-a691-3490f7349eeb.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u855fa134&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8076f660-ae44-4486-a8c9-004532ef1a2&title=&width=563"><br>边界考虑<br>第一维数字的下标<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577309-cb5440cc-ec6c-42d0-a207-c3f531c35f16.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u3731a3d1&margin=%5Bobject%20Object%5D&originHeight=530&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue81e3ddb-626b-4ef0-b035-e2b5239cb4e&title=&width=508"><br>无序数组中找到第k小, bfprt<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577557-ad44f93d-e7d0-4003-ba23-3ae7897ccd42.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ud35ec140&margin=%5Bobject%20Object%5D&originHeight=557&originWidth=1120&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u38e4bc18-5977-4562-9d02-123c3e64abe&title=&width=545"><br><strong>怎么定义第二维数字</strong><br>你必须数一下小于 7 的数字有几个你才能知道前面做的一位数字的组帮你搞定了几个，<br>然后拿k减去它才是属于7的组，在第一位数字是 7 的情况下，在这个内部组里面我是第几个呢？<br>这事怎么求?<br>你必须数一下前面小于 7 的数字有几个</p><p>**代码 **<br>必须搞清楚的第一维数字小于 5 的，之前的数字有几个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577715-e66d1dd1-8985-476f-a263-11335040c1ba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u9c8a0bcd&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uedae6774-6831-4395-9c5d-11ba2520332&title=&width=551"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577892-e34c0223-de0d-4c47-88cc-c15cd07653ef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=uc48d9a27&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=1134&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u939b5448-34f1-459a-a8cb-f98e841f015&title=&width=631"></p><p>| **public static class **Pair <strong>{<br>   public int x</strong>;<br>   <strong>public int y</strong>;</p><p>   Pair**(int **a, **int <strong>b</strong>) {<br>      x **&#x3D; a;<br>      **y **&#x3D; b;<br>   **}<br>}</p><p>public static class **PairComparator **implements <strong>Comparator</strong>&lt;**Pair**&gt; {</p><p>   **@Override<br>   **public int <strong>compare</strong>(<strong>Pair arg0, Pair arg1</strong>) {<br>      return **arg0.**x **!&#x3D; arg1.**x **? arg0.**x **- arg1.**x **: arg0.**y **- arg1.<strong>y</strong>;<br>   **}</p><p>}</p><p>**&#x2F;&#x2F; O(N^2 * log (N^2))的复杂度，你肯定过不了<br>&#x2F;&#x2F; 返回的int[] 长度是2，{3,1} int[2] &#x3D; [3,1]<br>**public static int[] <strong>kthMinPair1</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   **}<br>   <strong>Pair</strong>[] **pairs &#x3D; <strong>new <strong>Pair</strong>[<strong>N * N</strong>]</strong>;<br>   **int **index &#x3D; 0;<br>   <strong>for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      for (int <strong>j &#x3D; 0; j &lt; N; j++</strong>) {<br>         <strong>pairs</strong>[<strong>index++</strong>] <strong>&#x3D; <strong>new <strong>Pair</strong>(<strong>arr</strong>[<strong>i</strong>]</strong>, arr</strong>[<strong>j</strong>])</strong>;<br>      <strong>}<br>   }<br>   <strong>Arrays.sort</strong>(<strong>pairs, <strong>new <strong>PairComparator</strong>())</strong>;<br>   <strong>return new int[] { <strong>pairs</strong>[<strong>k - 1</strong>]</strong>.<strong>x</strong>, pairs</strong>[<strong>k - 1</strong>]</strong>.<strong>y }</strong>;<br>**}</p><table><thead><tr><th>**</th></tr></thead></table><p>| &#x2F;&#x2F; O(N*logN)的复杂度，你肯定过了<br>**public static int[] <strong>kthMinPair2</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   <strong>}<br>   <strong>&#x2F;&#x2F; O(N*logN)<br>   Arrays.sort</strong>(<strong>arr</strong>)</strong>;<br>   &#x2F;&#x2F; 第K小的数值对，第一维数字，是什么 是arr中<br>   <strong>int <strong>fristNum &#x3D; arr</strong>[(<strong>k - 1</strong>) <strong>&#x2F; N</strong>]</strong>;<br>   **int **lessFristNumSize &#x3D; 0;&#x2F;&#x2F; 数出比fristNum小的数有几个<br>   **int **fristNumSize &#x3D; 0; &#x2F;&#x2F; 数出&#x3D;&#x3D;fristNum的数有几个<br>   &#x2F;&#x2F; &lt;&#x3D; fristNum<br>   **for (int <strong>i &#x3D; 0; i &lt; N &amp;&amp; arr</strong>[<strong>i</strong>] <strong>&lt;&#x3D; fristNum; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&lt; fristNum</strong>) {<br>         **lessFristNumSize++;<br>      **} else {<br>         **fristNumSize++;<br>      **}<br>   }<br>   int **rest &#x3D; k - <strong>(<strong>lessFristNumSize * N</strong>)</strong>;<br>   <strong>return new int[] { <strong>fristNum, arr</strong>[(<strong>rest - 1</strong>) <strong>&#x2F; fristNumSize</strong>] }</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p>| &#x2F;&#x2F; O(N)的复杂度，你肯定蒙了<br>**public static int[] <strong>kthMinPair3</strong>(int[] **arr, **int <strong>k</strong>) {<br>   int **N &#x3D; arr.<strong>length</strong>;<br>   <strong>if (<strong>k &gt; N * N</strong>) {<br>      return null</strong>;<br>   **}<br>   **&#x2F;&#x2F; 在无序数组中，找到第K小的数（k表示下标），返回值<br>   &#x2F;&#x2F; 第K小，以1作为开始<br>   **int <strong>fristNum &#x3D; getMinKth</strong>(**arr, <strong>(<strong>k - 1</strong>) <strong>&#x2F; N</strong>)</strong>;<br>   &#x2F;&#x2F; 第1维数字<br>   **int **lessFristNumSize &#x3D; 0;<br>   **int **fristNumSize &#x3D; 0;<br>   **for (int <strong>i &#x3D; 0; i &lt; N; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&lt; fristNum</strong>) {<br>         **lessFristNumSize++;<br>      **}<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&#x3D;&#x3D; fristNum</strong>) {<br>         **fristNumSize++;<br>      **}<br>   }<br>   <strong>&#x2F;&#x2F;切记不能死记硬背<br>   &#x2F;</strong><br>    *  2 1 5 3 6 5 4 7 2 长度为9 求K &#x3D; 58<br>    *  1 2 2 3 4 5 5 6 7   firstNum &#x3D; 5(第6小的数)<br>    *  rest &#x3D; 58 - 45 &#x3D; 13<br>    *&#x2F;<br>   <strong>int <strong>rest &#x3D; k - <strong>(<strong>lessFristNumSize * N</strong>)</strong>;<br>   System.<strong>out</strong>.println</strong>(“rest &#x3D; “ <strong>+ rest</strong>)</strong>;<br>   **return new int[] { <strong>fristNum, getMinKth</strong>(**arr, <strong>(<strong>rest - 1</strong>) <strong>&#x2F; fristNumSize</strong>) }</strong>;<br>**}</p><p>**&#x2F;&#x2F; 改写快排，时间复杂度O(N)<br>&#x2F;&#x2F; 在无序数组arr中，找到，如果排序的话，arr[index]的数是什么？<br>**public static int <strong>getMinKth</strong>(int[] **arr, **int <strong>index</strong>) {<br>   int **L &#x3D; 0;<br>   **int **R &#x3D; arr.**length **- 1;<br>   **int **pivot &#x3D; 0;<br>   **int[] **range &#x3D; <strong>null</strong>;<br>   **while (<strong>L &lt; R**) {<br>      **pivot &#x3D; arr**[**L + **(int) (**Math.random**() *** **(**R - L + 1**))]**;<br>      range &#x3D; partition**(**arr, L, R, pivot**)**;<br>      **if (**index &lt; range**[**0**]) {<br>         **R &#x3D; range**[**0**] **- 1;<br>      **} else if (**index &gt; range</strong>[<strong>1</strong>]) {<br>         <strong>L &#x3D; range</strong>[<strong>1</strong>] **+ 1;<br>      **} else {<br>         return **pivot;<br>      <strong>}<br>   }<br>   return <strong>arr</strong>[<strong>L</strong>]</strong>;<br>**}</p><p>public static int[] <strong>partition</strong>(int[] **arr, **int **L, **int **R, **int <strong>pivot</strong>) {<br>   int **less &#x3D; L - 1;<br>   **int **more &#x3D; R + 1;<br>   **int **cur &#x3D; L;<br>   <strong>while (<strong>cur &lt; more**) {<br>      if (**arr**[**cur**] **&lt; pivot**) {<br>         **swap**(**arr, ++less, cur++**)**;<br>      **} else if (**arr**[**cur**] **&gt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, cur, –more</strong>)</strong>;<br>      **} else {<br>         **cur++;<br>      **}<br>   }<br>   return new int[] { **less + 1, more - 1 <strong>}</strong>;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, <strong>int <strong>i, <strong>int <strong>j</strong>) {<br>   int <strong>tmp &#x3D; arr</strong>[<strong>i</strong>]</strong>;<br>   arr</strong>[<strong>i</strong>] <strong>&#x3D; arr</strong>[<strong>j</strong>]</strong>;<br>   arr</strong>[<strong>j</strong>] **&#x3D; tmp;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-数组能不能分成4个相等的部分"><a href="#·-数组能不能分成4个相等的部分" class="headerlink" title="· 数组能不能分成4个相等的部分"></a>· 数组能不能分成4个相等的部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533468062-870ee3db-9ba1-438d-bfba-f1f0eaca5b6e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=139&id=u21da3700&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31102&status=done&style=none&taskId=u552b24ea-96ee-414d-8b28-0f5ce24cea0&title=&width=456.8" alt="image.png"><br><strong>题意</strong><br>N&gt;&#x3D;7, 正数数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471540-fc6df3a7-1744-4cd5-abf5-c52f0a31e14f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u3c662ee6&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u91f5bb87-ba17-433f-954d-94343906014&title=&width=508"><br>你能不能切出四个部分，让四个部分累加和一样。但是切掉的数字是不算的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471734-ee7c3286-54dc-49c0-9841-5a6297def955.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=ucc6800d7&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u02fc3a3e-8ed3-4c74-9bd3-99e837f2411&title=&width=578"><br><strong>题解</strong><br>做出前缀和数组, 假设来到i位置, 想问<br>i位置做第一刀的情况下有没有可能切出4个部分累加和一样<br><strong>例子</strong><br>找209的前缀和<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471524-5d3a4faa-2313-4e57-b4a0-f8c9f5f4cd8b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=u24736741&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=651&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8b0e8c1c-ddc2-4fac-829c-3118343a3af&title=&width=483"><br>14位置是第二刀<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471485-660cacba-56bd-4b13-a478-cf66a91eec8a.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=uf0101aab&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae1dd84f-46f8-46f8-af79-6a3c3d93766&title=&width=541"><br>验证7位置能不能第一刀, O(1), 然后验证每一个位置做为第一刀, 就可以了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471488-436b2399-5728-40d0-8da9-e1a64ed33a89.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u97f20565&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f84d7de-0496-43f3-a6c5-e1cb29a148d&title="></p><p><strong>代码</strong></p><p>| **public static boolean <strong>canSplits2</strong>(int[] <strong>arr</strong>) {<br>   if (**arr &#x3D;&#x3D; **null **&amp;#124;&amp;#124; arr.**length **&lt; 7**) {<br>      return false**;<br>   **}<br>   **&#x2F;&#x2F; key 某一个累加和， value出现的位置<br>   HashMap**&lt;**Integer, Integer**&gt; **map &#x3D; <strong>new <strong>HashMap</strong>&lt;**Integer, Integer**&gt;()</strong>;<br>   <strong>int <strong>sum &#x3D; arr</strong>[<strong>0</strong>]</strong>;<br>   <strong>for (int <strong>i &#x3D; 1; i &lt; arr.**length**; i++**) {<br>      **map.put**(**sum, i**)**;<br>      sum +&#x3D; arr**[**i**]**;<br>   **}<br>   int **lsum &#x3D; arr**[**0**]**; &#x2F;&#x2F; 第一刀左侧的累加和<br>   **for (int **s1 &#x3D; 1; s1 &lt; arr.**length **- 5; s1++**) { **&#x2F;&#x2F; s1是第一刀的位置<br>      **int **checkSum &#x3D; lsum * 2 + arr**[**s1**]**; &#x2F;&#x2F; 100 x 100   100*2 + x<br>      **if (**map.containsKey**(**checkSum**)) {<br>         int **s2 &#x3D; map.get**(**checkSum**)**; &#x2F;&#x2F; j -&gt; y<br>         checkSum +&#x3D; (lsum + arr</strong>[<strong>s2</strong>])</strong>;<br>         **if (<strong>map.containsKey</strong>(<strong>checkSum</strong>)) { **&#x2F;&#x2F; 100 * 3 + x + y<br>            <strong>int <strong>s3 &#x3D; map.get</strong>(<strong>checkSum</strong>)</strong>; &#x2F;&#x2F; k -&gt; z<br>            <strong>if (<strong>checkSum + (arr</strong>[<strong>s3</strong>] <strong>+ lsum) &#x3D;&#x3D; sum</strong>) {<br>               return true</strong>;<br>            <strong>}<br>         }<br>      }<br>      <strong>lsum +&#x3D; arr</strong>[<strong>s1</strong>]</strong>;<br>   <strong>}<br>   return false</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-✊316-去除重复字母-M"><a href="#·-✊316-去除重复字母-M" class="headerlink" title="· ✊316. 去除重复字母  [M]"></a>· ✊316. 去除重复字母  [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533504865-a0411f35-f468-4fe7-ba62-98a6ffb066a1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udc341fe0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32042&status=done&style=none&taskId=u83a362da-6605-45be-b799-61f01d3e0bb&title=&width=662.4" alt="image.png"><br><strong>题意</strong><br>每种字符只保留一个, 请你返回字典序最小的结果<br>相对次序不能乱<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940519-92d4b450-75f4-4738-b2fc-d448dabee78d.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=uc3a5dde1&margin=%5Bobject%20Object%5D&originHeight=393&originWidth=973&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7ea7df2e-ecc2-4679-8640-20a95c7d97c&title=&width=502"><br><strong>题解</strong><br>先建立词频统计表, 从左往右划线, 划线的词从词频表里删除</p><p>我如果在这线里面，这条线代表啥意思，我如果要选保留的第一个字符的话，我只能在这条线里选，<br>不能够再把右侧的字符考虑进来了。<br>当我决定保留一个字符的时候，我保留这个字符的同时，左侧字符全不要, 右侧字符可以继续选，<br>我在后面的字符里再选一个字符Y，那么 Y 左边的字符就不能再选了，在后面继续选，这是我的主流程。<br>选ascii码最小的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940426-5bd3de48-60bb-4186-b3f0-dafc220489fd.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=uec914f16&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=931&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d28ade0-97a0-4e57-8028-5f5f382ea6d&title=&width=598"><br>因为如果我这个 C 作为我保留第一个字符的话，后面就没 A 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940449-8ead876f-9228-42c5-9a3a-9e1da7419ba8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u7b220aee&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=918&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb18526a-30cb-44be-9a19-beabfa28a43&title=&width=586"><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940483-a32ca227-5889-422a-a8a6-b692068da001.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u476f8fde&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=861&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua441ad0d-c491-4083-8559-fa70fc38f5b&title=&width=550"><br><strong>代码</strong></p><p>| &#x2F;&#x2F;递归版本： 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回<br>**public static <strong>String removeDuplicateLetters1</strong>(<strong>String str</strong>) {<br>   if (**str &#x3D;&#x3D; <strong>null <strong>&amp;#124;&amp;#124; str.length</strong>() <strong>&lt; 2**) {<br>      return **str;<br>   **}<br>   int[] **map &#x3D; **new int[**256**]**;<br>   **for (int **i &#x3D; 0; i &lt; str.length**()**; i++**) {<br>      **map**[**str.charAt**(**i**)]**++;<br>   **}<br>   int **minACSIndex &#x3D; 0;<br>   **for (int **i &#x3D; 0; i &lt; str.length**()**; i++**) {<br>      **minACSIndex &#x3D; str.charAt**(**minACSIndex**) **&gt; str.charAt</strong>(<strong>i</strong>) <strong>? i : minACSIndex;<br>      <strong>if (</strong>–map</strong>[<strong>str.charAt</strong>(<strong>i</strong>)] <strong>&#x3D;&#x3D; 0</strong>) {<br>         break</strong>;<br>      <strong>}<br>   }<br>   <strong>&#x2F;&#x2F; 0…break(之前) minACSIndex<br>   &#x2F;&#x2F; str[minACSIndex] 剩下的字符串str[minACSIndex+1…] -&gt; 去掉str[minACSIndex]字符 -&gt; s’<br>   &#x2F;&#x2F; s’…<br>   <strong>return <strong>String.valueOf</strong>(<strong>str.charAt</strong>(<strong>minACSIndex</strong>)) <strong>+ removeDuplicateLetters1</strong>(<br>         <strong>str.substring</strong>(<strong>minACSIndex + 1</strong>)</strong>.replaceAll</strong>(<strong>String.valueOf</strong>(<strong>str.charAt</strong>(<strong>minACSIndex</strong>))</strong>, <strong>“”))</strong>;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><p><strong>复杂度</strong><br>遍历一遍总会保留一个字符, 而且以后的字符串中是不含有这个字符的。<br>所以你str中如果含有 K 种字符，复杂度就是O(K*N)。这个 K 大写加小写也不就是 52 种字符, 所以O(N)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940987-5cb7a264-d11d-41c0-b9e1-8e61798e55c6.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u7ac43425&margin=%5Bobject%20Object%5D&originHeight=458&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69a4ec90-04ea-41f8-acde-5152dda5a2b&title=&width=586"></p><h2 id="·-15-三数之和-M"><a href="#·-15-三数之和-M" class="headerlink" title="· 15.三数之和 [M]"></a>· 15.三数之和 [M]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168720-6b744df4-7946-45c9-a331-a2bea7ca808b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u91a5461c&margin=%5Bobject%20Object%5D&originHeight=418&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47aed55e-205d-42c8-b687-db174d78dfa&title=&width=466"><br>字面值都不一样，就算不同的，有几个三元组全返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168713-93b17778-7f67-446e-90c9-05862b57e449.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ubaf6ddac&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=964&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u18986bf3-72d6-45ce-9a40-801113f1696&title=&width=440"><br><strong>题解</strong><br>2sum<br>双指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168718-d3daae68-041e-4709-83d2-24ed9706dcf1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=u3abbd115&margin=%5Bobject%20Object%5D&originHeight=244&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u13162b89-c8f0-4a19-a91b-a82270cb67d&title=&width=665"><br><strong>去重复:</strong></p><ol><li>收集所有二元组, 过滤</li><li>通过好的流程设计规避重复<br>L移动到下一个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168760-f5557fad-41a1-4981-9a4a-e7b1be9554d8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=ue9ce0c40&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=1076&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1155980f-554e-48b9-9513-a53e4dfc988&title=&width=574"><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168722-ed693ec3-17f3-40db-875b-40df7a3e3bc2.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc9bb16c8&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=604&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3cc0675-8fd4-41a6-82ad-5ab956d174d&title="><br><strong>题解</strong><br>你只要保证第1个数字不一样后面就是二元组的问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169245-eb3b0c0f-0f36-4691-9b6d-a4d24f65c0f9.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=ubddc1e46&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9cfee96b-8401-44c4-8bfc-7cbfccc2aa1&title=&width=623"><br>避免arrayList插到开头的代价有点高, 所以从右往左生成所有的三元组, 把一个数塞在最后<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169284-19a38708-e6da-4a5e-bb4a-20a29232ee3c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=u9d26ce66&margin=%5Bobject%20Object%5D&originHeight=520&originWidth=1064&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f65a980-7862-4577-af50-86a27112905&title=&width=614"><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169425-e3392844-3840-45f1-9ab5-46624ba97638.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue27c0fc3&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=689&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc8ba67a7-38d3-4a72-af12-8e3c795c18e&title="></li></ol><p>| **public static **List&lt;List<Integer>&gt; threeSum(<strong>int</strong>[] nums) {<br>   Arrays.<em>sort</em>(nums);<br>   **int **N &#x3D; nums.<strong>length</strong>;<br>   List&lt;List<Integer>&gt; ans &#x3D; **new **ArrayList&lt;&gt;();<br>   **for **(**int **i &#x3D; N - 1; i &gt; 1; i–) { _&#x2F;&#x2F; 三元组最后一个数，是arr[i]   之前….二元组 + arr[i]<br>      _**if **(i &#x3D;&#x3D; N - 1 &amp;#124;&amp;#124; nums[i] !&#x3D; nums[i + 1]) {<br>         List&lt;List<Integer>&gt; nexts &#x3D; <em>twoSum</em>(nums, i - 1, -nums[i]);<br>         **for **(List<Integer> cur : nexts) {<br>            cur.add(nums[i]);<br>            ans.add(cur);<br>         }<br>      }<br>   }<br>   **return **ans;<br>}</p><p>_&#x2F;&#x2F; nums[0…end]这个范围上，有多少个不同二元组，相加&#x3D;&#x3D;target，全返回<br>&#x2F;&#x2F; {-1,5}     K &#x3D; 4<br>&#x2F;&#x2F; {1, 3}<br>_**public static **List&lt;List<Integer>&gt; twoSum(<strong>int</strong>[] nums, **int **end, **int **target) {<br>   **int **L &#x3D; 0;<br>   **int **R &#x3D; end;<br>   List&lt;List<Integer>&gt; ans &#x3D; **new **ArrayList&lt;&gt;();<br>   **while **(L &lt; R) {<br>      **if **(nums[L] + nums[R] &gt; target) {<br>         R–;<br>      } **else if **(nums[L] + nums[R] &lt; target) {<br>         L++;<br>      } **else **{ _&#x2F;&#x2F; nums[L] + nums[R] &#x3D;&#x3D; target<br>         _**if **(L &#x3D;&#x3D; 0 &amp;#124;&amp;#124; nums[L - 1] !&#x3D; nums[L]) {<br>            List<Integer> cur &#x3D; **new **ArrayList&lt;&gt;();<br>            cur.add(nums[L]);<br>            cur.add(nums[R]);<br>            ans.add(cur);<br>         }<br>         L++;<br>      }<br>   }<br>   **return **ans;</p><table><thead><tr><th>}</th></tr></thead></table><h2 id="·-小朋友排队的最高分数"><a href="#·-小朋友排队的最高分数" class="headerlink" title="· 小朋友排队的最高分数"></a>· 小朋友排队的最高分数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652536502099-7223e529-c2d9-4f8f-a4a9-a6ab1fcd7ad3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=91&id=u6ea2c2e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22491&status=done&style=none&taskId=u67386263-86db-4666-a03d-34b0bd10782&title=&width=665.6" alt="image.png"><br>暴力递归，把所有的全排列(N!)搞出来, 分数最大的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537096712-968d9c3d-2f9f-44bc-b6e9-a801cf34a8ba.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=ue4cc4511&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub1f9f15f-045e-4823-bf05-f159007dd6a&title=&width=597"></p><p>| **public static int <strong>process</strong>(int[][] **matrix,**int **index,**int <strong>score</strong>) {<br>    int **max &#x3D; Integer.<strong>MIN_VALUE</strong>;<br>    **int **ans &#x3D; 0;<br>    **if (**index &#x3D;&#x3D; matrix.**length) {<br>        return **score;<br>    <strong>} else {<br>        for (int <strong>i &#x3D; index; i &lt; matrix.<strong>length</strong>; i++</strong>) {<br>            int <strong>num &#x3D; 0;<br>            swap</strong>(<strong>matrix,index,i</strong>)</strong>;</p><pre><code>        **if (**i-1&gt;0 &amp;&amp; matrix**[**i**][**0**] **&gt; matrix**[**i-1**][**0**]) &#123;            **num += 1;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**]) &#123;            **num += 2;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**] **&amp;&amp; matrix**[**i+1**][**0**] **&gt; matrix**[**i**][**0**]) &#123;            **num += 5;        **&#125;        **ans = process**(**matrix,index+1,score+num**)**;        max = Math.max**(**max,ans**)**;        swap**(**matrix,index,i**)**;    **&#125;    return **max;**&#125;</code></pre><p>}<br>public static void <strong>swap</strong>(int[][] <strong>matrix,<strong>int <strong>i,<strong>int <strong>j</strong>) {<br>    int[] <strong>temp &#x3D; matrix</strong>[<strong>i</strong>]</strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>0</strong>] <strong>&#x3D; matrix</strong>[<strong>j</strong>][<strong>0</strong>]</strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>1</strong>] <strong>&#x3D; matrix</strong>[<strong>j</strong>][<strong>1</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>0</strong>] <strong>&#x3D; temp</strong>[<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>1</strong>] <strong>&#x3D; temp</strong>[<strong>1</strong>]**;</p><table><thead><tr><th><strong>}</strong></th></tr></thead></table><h2 id="·-❓乐队演出的最少花费"><a href="#·-❓乐队演出的最少花费" class="headerlink" title="· ❓乐队演出的最少花费"></a>· ❓乐队演出的最少花费</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537423682-efe033ec-3f72-424f-bde7-e5014b897bef.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u4f042f4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43808&status=done&style=none&taskId=u0e6f551b-d211-4ea1-b57c-7c37cc19b72&title=&width=676" alt="image.png"><br>题意<br>乐队数量编号跟numbers*2是严格绑定的<br>nums&#x3D;5, 乐队数量下标一定是0~9<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448658-3dab8950-a21f-43a1-b17b-7ed848f64840.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=u7d539c9d&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uacdc5ae2-9463-4236-b703-588b8875dfa&title=&width=592"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448639-8358f990-06dd-4df5-92ae-7f64d89c5234.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=u8052bab1&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1124&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u76a2c942-9cfb-413c-87b0-e6c87ef102c&title=&width=585"><br>nums&#x3D;1, 一定有0,1两支乐队<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448741-b140f77d-7e96-44c8-84b8-5fc2a709c6d8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=285&id=u403bc2c5&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucb4940ea-7279-443e-9b7d-0ae124ea889&title=&width=583"><br>nums&#x3D;2, 一定有0,1, 2, 3 四支乐队<br>一个乐队只能在一个项目里被挑到，它不能同时为两个项目挑到, 把所有乐队都挑全, 返回最低报价</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448667-377bf58a-896b-4092-92b2-f8b2a5e09815.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=286&id=u32fa3de3&margin=%5Bobject%20Object%5D&originHeight=531&originWidth=1106&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u65c2b037-7834-4cf3-ab10-f0b6e2bf05e&title=&width=596"><br>题解<br>乐队数量16只, 任何两个乐队的组合为C_16^2, 共120种情况, 现在题目中有500组,<br>有大量冗余项目, 只选报价低的, 剩余的删掉<br>如果某个乐队不在报价中返回-1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448679-f9b98e3e-d745-4b02-bdae-869c77c67a26.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u6948a087&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=1137&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucaf4f2e9-9d3d-4a61-975f-3175ffd7c66&title=&width=589"><br>洗数据<br>调整乐队编号, 两个乐队最小值放第一位, 最大值放第二位, 最后是花费<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449231-9d45d470-a1c6-43c9-9588-469ca0f1e264.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u46433d67&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=1033&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8f5bb06b-f43c-4077-8a14-5d13c732d90&title=&width=647"><br>排序: 第一维小的排前面，第一维数据相等的，根据第二维数据小的排前面，前两维数据都相同的，<br>根据报价小的排前面<br>前两项一样的这一组，我只要第一个, 剩下的都删掉<br>把价格大的都删掉。两个乐队之间最低报价的留下来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449453-bf550b3c-8f14-4478-83d9-7deee2932b11.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=ud0a23bf4&margin=%5Bobject%20Object%5D&originHeight=491&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ee4650d-6457-4fb0-9ab1-c041cd0877a&title=&width=541"><br>暴力递归<br>通过size控制<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449574-6cc51376-eedc-4492-9837-2b7fe7a5137b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=441&id=u19699120&margin=%5Bobject%20Object%5D&originHeight=586&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue22b83d6-55e4-4b95-829f-40f960b64cd&title=&width=586"><br>可以用一个整数的二进制状态，表示哪个乐队挑了哪个没挑<br>一共就8组, 16个乐队<br>最低位就代表0号乐队挑没有挑, 上面如果是1代表挑了, 上面如果是 0 , 代表没挑</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449591-6da74ef6-513b-4524-9b3a-b672e0db5668.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=u2fe508db&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1006&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94eb5d67-dd4e-4672-9456-0ae104e69b9&title=&width=554"><br>乐队全挑是啥样？<br>应该是某一个整数，后面 16 位全是1，前面 16 位全是0。这个状态就表示你所有的都挑到了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449813-4c4d0188-00e0-4d90-94b2-91dde3d4e2ee.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=291&id=u2abab5d3&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7278723a-a0c2-4568-a86d-a0851da4baf&title=&width=555"><br>之前 5 位置的 5 乐队已经考虑过了，此时的项目无论如何不能考虑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449921-dabce459-c444-48ca-9b0d-38842a88bea8.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=276&id=u91c52048&margin=%5Bobject%20Object%5D&originHeight=543&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u69d7ed52-13ce-44af-b614-77ad78833ad&title=&width=534"><br>不能改动态规划, 可变参数太多了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450094-53b89c36-d138-4950-9855-9eb41da56b81.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaefbf1e8&margin=%5Bobject%20Object%5D&originHeight=1189&originWidth=980&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f03743c-eabf-4d20-b806-7572874a0d2&title="><br>优化<br>可以省掉done参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450158-14d02b8e-1908-4948-8d94-927946c3838e.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4a13716a&margin=%5Bobject%20Object%5D&originHeight=369&originWidth=825&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1a8774c-e654-4e8e-80e7-5bbedb5bdff&title="><br>复杂度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450320-12c34c5a-b718-43e3-b910-ce5cd6be6e48.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5fa9848d&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0d5c8479-84af-4bde-b87e-fdc85878b0a&title="><br><br>分治<br>复杂度<br>一共 120 个项目挑 8 个项目就停。<br>C_{120}^8_C_1208 超过 10^8了, 这个方法不行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450494-e0629605-12c2-45c0-ba4d-8981a6fc2e84.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue97cf8a0&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=1057&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u40393ab8-0e3f-4b26-ae96-d80c6c2c4d1&title="><br>特殊情况, num&#x3D;7<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450801-bf9dd979-4d42-4c30-9acd-45c6b4e7f866.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u628d5bce&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u16e23e4a-120c-4887-adee-11b29cab4e1&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450938-6f42c655-5387-4db9-b9db-d38ddc55848f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7ea57ad3&margin=%5Bobject%20Object%5D&originHeight=767&originWidth=713&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u340a0fea-3523-4622-b767-bc6d89db7eb&title="></p><h2 id="·-❓题目2-企鹅的最少数量-781-森林中的兔子-M"><a href="#·-❓题目2-企鹅的最少数量-781-森林中的兔子-M" class="headerlink" title="· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]"></a>· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537527351-44459aaf-41e1-458d-bae2-5ce71a0191b1.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=176&id=u67946780&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40177&status=done&style=none&taskId=u47ce9f2e-8b46-4f21-a705-0ea9eefe640&title=&width=637.6" alt="image.png"><br>题意</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-b877c03c-a285-4712-9615-258c243e8ed7.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u5b0b2b90&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufafc36af-a0b5-4e28-9db2-89eb9b6b178&title=&width=570"><br>a,b必然不同<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512800-25772203-c346-4bbe-8237-30518dbdb60b.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9a8e07f0&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=228&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0c66b2ce-92ce-46a9-b14b-4a3751310b8&title="><br><br>题解<br><br>排序, 让说的一样数量的人在一起<br>自我消化<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-cf987f51-87b0-448b-ac46-e9d5faf98eb3.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=uaaa8f52f&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=1092&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud38b542a-cec3-4e17-b52e-70e2f50bd8f&title=&width=570"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512924-12bacc17-7f26-4686-85f0-7f71db1bfa89.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=uf697393a&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7604ddcd-7966-4e3a-b5d3-8f4cabf5c5a&title=&width=573"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512826-891ffc75-377e-4fc5-9d7a-da4028ceae6f.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u2a3485d2&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6df243e7-fbc7-4a92-ab5c-bae5a440dbc&title=&width=559"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513286-e4853f30-976d-4afb-a9c2-1c0843765303.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=uc338299f&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf7ddc6e6-1972-40c5-8878-9a5754d7b21&title=&width=553"><br>规律, 如果当前数是x, 有c个, 有几组?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513383-501045f8-319a-4179-b47c-9c0c02e0badf.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=u5d11b8c0&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=869&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4c2f6b9e-c173-4c10-9c13-75c4fbdd5e3&title=&width=503"><br>a&#x2F;b怎么向上取整<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513552-6e8d37f3-9848-4900-8eda-b864d1d22c3c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u20f90519&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=1146&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u396d7a21-be1d-44e9-877e-02a28b7fadc&title=&width=525"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513704-ac750a4e-7f0b-4700-8c7d-443c6aff347c.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=ucf35688f&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=1125&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u103b599a-2ac9-4946-ae00-a479d0b8f24&title=&width=560"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513881-861b81c5-c61d-4e5d-92f4-e7f56b5dc042.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=150&id=u74b861b9&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75cc545e-f180-4c5d-90b8-b2e36446e6f&title=&width=544"><br>代码<br>不能约<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514082-45e66cf1-cbdf-48bd-80ce-7343743b8fca.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=250&id=u32d23b83&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1010&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1f8888e6-27db-45fb-867a-dc516aff8af&title=&width=503"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514370-fba438f5-6e52-45a9-b7ff-ffe1427d7e10.png#clientId=u1970c3f5-190b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udbfd29aa&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=447&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u877d5405-cfd1-4b2e-b825-ffe2521430e&title="></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
