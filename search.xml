<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>翻唱</title>
      <link href="/2022/11/12/1/"/>
      <url>/2022/11/12/1/</url>
      
        <content type="html"><![CDATA[<!-- <div align=center class="aspect-ratio">    <iframe src="https://www.bilibili.com/video/BV1Gr4y1a7cX/?spm_id_from=333.999.0.0"     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     high_quality=1    danmaku=1     allowfullscreen="true">     </iframe></div> --><div class="aplayer no-destroy" data-id="7427714271" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/08/09/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/09/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>多练的代码也就是不容易写出来的：✊<br>困难的代码：😡<br>了解：👌</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>heap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;((</strong>a, b<strong>) </strong>-&gt; a.<strong>value </strong>- b.<strong>value)</strong>;<br>要练熟的代码：</p><p>排序：Arrays.sort()<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650254542022-b29c6afb-07da-458f-aad0-d9195e2cbb60.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=37&amp;id=BvypH&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=46&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29461&amp;status=done&amp;style=none&amp;taskId=ue1e9cf3b-75fb-4abc-a0d2-566f55d0aec&amp;title=&amp;width=466.4" alt="image.png"></p><p>子串子数组想到以i结尾往左推 class3例子</p><h2 id="·-返回离非负整数num最近的2的某次方"><a href="#·-返回离非负整数num最近的2的某次方" class="headerlink" title="· 返回离非负整数num最近的2的某次方"></a>· 返回离非负整数num最近的2的某次方</h2><p><strong>题意</strong><br>num=7, 返回8   num=8，返回8   num=13，返回6<br><strong>题解</strong><br>二进制第一个1后面全部填充完1后加1返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606374038-5dc3bdff-f8db-4cea-b539-13bc0f241519.png#clientId=u24411928-8d24-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=u6f518ae8&amp;margin=%5Bobject%20Object%5D&amp;name=DEF082573F9BE5D1BD2D58935BF11CDD.png&amp;originHeight=1166&amp;originWidth=1502&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=328379&amp;status=done&amp;style=none&amp;taskId=uc329201a-a346-4a48-9408-2ab96b91a62&amp;title=&amp;width=448.2857666015625" alt="DEF082573F9BE5D1BD2D58935BF11CDD.png"></p><p>| // 已知n是正数<br>// 返回大于等于，且最接近n的，2的某次方的值<br>public static final int tableSizeFor(int n) {<br>   //这个是为了如果正好是2的某次方，打散！！<br>   n—;<br>   //&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补0。<br>   n &#124;= n &gt;&gt;&gt; 1;<br>   n &#124;= n &gt;&gt;&gt; 2;<br>   n &#124;= n &gt;&gt;&gt; 4;<br>   n &#124;= n &gt;&gt;&gt; 8;<br>   //整型最多32位<br>   n &#124;= n &gt;&gt;&gt; 16;<br>   return (n &lt; 0) ? 1 : n + 1;//负数最高位是1，填满32个1，返回1<br>} |<br>| —- |</p><h2 id="·-相邻字符的交换次数"><a href="#·-相邻字符的交换次数" class="headerlink" title="· 相邻字符的交换次数"></a>· 相邻字符的交换次数</h2><p><strong>题意</strong><br>刻意的说两个标准, 搞你一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704873615-836bf286-fab2-47cb-8817-a817f740da5d.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=70&amp;id=u73201307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=88&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19948&amp;status=done&amp;style=none&amp;taskId=ub30207ba-f24d-4b60-884e-75662524657&amp;title=&amp;width=660.8" alt="image.png"><br><strong>题解</strong><br>贪心:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704850684-0c6b231e-483f-4ad1-99fb-9b7d76b6ffc9.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u5d3653f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=398&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u976907e3-3bde-438a-891c-5605344be3c&amp;title=&amp;width=556" alt=""><br><strong>两个指针</strong><br>index: 往右扫, 不是G就往右飘<br>L: 如果发现了放到哪儿的位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606588940-7b194664-6549-49a7-bec8-3209b6c93f08.png#clientId=u24411928-8d24-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=uab987630&amp;margin=%5Bobject%20Object%5D&amp;name=39A8E84629C793605662823ED198A9D4.png&amp;originHeight=718&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=126502&amp;status=done&amp;style=none&amp;taskId=uc016d720-79cd-42d8-8978-bf6dafda160&amp;title=&amp;width=390.2857666015625" alt="39A8E84629C793605662823ED198A9D4.png"><br>如何确定这是最优解?<br>这个过程, L, index都不回退, 复杂度O(N)<br>原题: 你可以选择让 G 在左边B 在右边或者你可以选择让 B 在左边G在右边哪种更省。<br>哪种更剩你用哪种, 问你最小的用代价</p><p>| <em>// 可以让G在左，或者在右</em><strong>public static int </strong>minSteps2(String s) {<br>   <strong>if </strong>(s == <strong>null </strong>&#124;&#124; s.equals(<strong>“”</strong>)) {<br>      <strong>return </strong>0;<br>   }<br>   <strong>char</strong>[] str = s.toCharArray();<br>   <strong>int </strong>step1 = 0;<br>   <strong>int </strong>step2 = 0;<br>   <strong>int </strong>gi = 0;<br>   <strong>int </strong>bi = 0;<br>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; str.<strong>length</strong>; i++) {<br>      <strong>if </strong>(str[i] == <strong>‘G’</strong>) { <em>// 当前的G，去左边   方案1<br>         _step1 += i - (gi++);<br>      } <strong>else </strong>{</em>// 当前的B，去左边   方案2<br>         <em>step2 += i - (bi++);<br>      }<br>   }<br>   <strong>return </strong>Math._min</em>(step1, step2);<br>} |<br>| —- |</p><h2 id="·-无序数组需要排序的最短子数组长度"><a href="#·-无序数组需要排序的最短子数组长度" class="headerlink" title="· 无序数组需要排序的最短子数组长度"></a>· 无序数组需要排序的最短子数组长度</h2><p><strong>题意</strong><br>想让整体有序<br>时间复杂度 O(N)额外空间复杂度O(1)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710897296-aa25c260-3795-403f-a63d-abcb51e33ff8.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u907fe5bc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=593&amp;originWidth=1216&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8e7d06d1-a6cb-4207-a123-ea9ca887b8c&amp;title=&amp;width=477" alt=""><br><strong>题解</strong><br>最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654696304737-51815bbc-5fb1-4258-8122-5b4218ecc06f.png#clientId=uaf1c0b48-9cd0-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=2891&amp;id=u37b19965&amp;margin=%5Bobject%20Object%5D&amp;name=63E3A64272C54C218FDD9192B70053CB.png&amp;originHeight=5059&amp;originWidth=1612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=673473&amp;status=done&amp;style=none&amp;taskId=u1c723737-203b-4864-b838-1417ede3aeb&amp;title=&amp;width=921.1428571428571" alt="63E3A64272C54C218FDD9192B70053CB.png"><br>需要排序范围2~5<br>你第一回从左往右遍历最右的违规，然后从右往左遍历最左的违规这之间需要排序。</p><p>左面max&lt;=当前数, 比如左max=6, 最后8,9是对号, 说明如果真要排序的话, 8不必给前面的最大值让位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898543-234a31d2-30e8-43f4-8676-33e52a7b9d25.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u2443991c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90eff19c-58f3-47d7-a63a-a785a4fd9f9&amp;title=&amp;width=572" alt=""><br>9不必给前面的最大值让位置<br>10也不必给前面的最大值让位置<br>你后面连续的对号说明如果真的排序的话，它们动都不需要动<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898593-d8fbbadb-d557-419e-867b-23549142645e.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u9fabbcb7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1258&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud6eca0a4-35e4-44ff-9ecc-aeb906a1b14&amp;title=&amp;width=631" alt=""><br>从右往左滑同理, 最左的对号说明在往左一直到开头全是对号,<br>说明如果真的排序的话，这些数据也不用给右边部分的最小值让位置。<br>你确定了一个右边不需要排的部分, 确定了一个左边不需要排的部分，那中间就是需要排序的部分, 搞定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898762-58901f0c-bbed-431c-a9f4-1bbd7fea4661.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u670e797a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=609&amp;originWidth=1212&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4471b33b-6b3d-4372-8a6b-4a2b4749e8c&amp;title=&amp;width=484" alt=""><br>第一个X到最后一个X中间直接排序不行吗?<br>不行, 因为你只关注了最大值, 例子中8没有人处理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710899406-b03a72c2-596b-40b2-b0a1-9d726f5d16a4.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u033c7053&amp;margin=%5Bobject%20Object%5D&amp;originHeight=275&amp;originWidth=1204&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u59606f10-dbf2-4450-924e-ed0813e7169&amp;title=" alt=""></p><p>| <strong>public static int </strong>findUnsortedSubarray2(<strong>int</strong>[] nums) {</p><p>   <strong>if </strong>(nums == <strong>null </strong>&#124;&#124; nums.<strong>length </strong>&lt; 2) {<br>      <strong>return </strong>0;<br>   }<br>   <strong>int </strong>N = nums.<strong>length</strong>;<br>   <strong>int </strong>right = -1;<br>   <strong>int </strong>max = Integer.<strong><em>MIN_VALUE</em></strong>;</p><p>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; nums.<strong>length</strong>; i++) {<br>      <strong>if </strong>(nums[i] &gt;= max) {<br>         max = nums[i];<br>      } <strong>else </strong>{<br>         right = i;<br>      }</p><p>   }<br>   <strong>int </strong>left = N;<br>   <strong>int </strong>min = Integer.<strong><em>MAX_VALUE</em></strong>;</p><p>   <strong>for </strong>(<strong>int </strong>i = N - 1; i &gt;= 0; i—) {<br>      <strong>if </strong>(nums[i] &lt; min) {<br>         min = nums[i];<br>      } <strong>else </strong>{<br>         left = i;<br>      }<br>   }<br>   <strong>return </strong>Math.<em>max</em>(0,right-left+1);<br>} |<br>| —- |</p><h2 id="·-字符串种类"><a href="#·-字符串种类" class="headerlink" title="· 字符串种类"></a>· 字符串种类</h2><p>你只有26种字符，一个整数是不是有32位了，<br>你就拿这个整数的第0位表示a从没出现过，它是1是出现过，它是0就没出现过，<br>你拿这个整数第1位表示b拿这个整数，第2位表示c拿一个整数，第25位表示z，<br>你还结余了这么多倍不用了，那你的摘要是不是就不用是str类型了，变成一个<br>整数就可以表示一个摘要了<br>最后看这个set中留下了多少不同的整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351350-dc64aa66-e5f5-44a0-a5d7-96736ca8680d.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=207&amp;id=u5fa830fc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=582&amp;originWidth=1183&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue6d9144b-3a7b-4eca-8c40-f73d1b2aa6d&amp;title=&amp;width=420" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351667-30911ef7-b885-449e-ab70-5c2e626b1445.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u6191cdd4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=257&amp;originWidth=422&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uece8ee91-b5ee-4851-a947-dd631519c75&amp;title=&amp;width=358" alt=""></p><h2 id="·-最大的以-1-为边界的正方形-M"><a href="#·-最大的以-1-为边界的正方形-M" class="headerlink" title="· 最大的以 1 为边界的正方形 [M]"></a>· 最大的以 1 为边界的正方形 [M]</h2><p><strong>题意</strong><br>边框全是1就达标，它不要求内部也有1, 内部有1, 也可以没有1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-9c36b203-d37d-46a9-9483-0348e3180719.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=ub37f09bb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=578&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a91b9c9-d45e-406e-9103-c6290e2fc15&amp;title=&amp;width=427" alt=""><br><strong>题解</strong><br>预处理数组技巧</p><p><strong>前置</strong><br>N<em>N区域中长方形正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399168-04bf1552-399a-4c84-9e06-1ba7badf959e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=151&amp;id=ud0e60c23&amp;margin=%5Bobject%20Object%5D&amp;originHeight=566&amp;originWidth=1167&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1bf94e4e-6018-42e3-bfac-44286cc6e9a&amp;title=&amp;width=311.0000305175781" alt=""><br>N</em>N区域中正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399176-f2349f13-30c8-4f6b-8779-a086f36cb16e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=163&amp;id=u2f2a5857&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1160&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a4e536e-ea47-4b8f-acd2-17bb7283331&amp;title=&amp;width=359" alt=""><br><strong>代码</strong><br>所以边长的枚举一定是哪个少，就到那个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-09736a59-aa8a-4393-b496-335dd697275c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u3d7bd96a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=501&amp;originWidth=738&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u924c016e-b4a5-492d-890b-d66b64c878a&amp;title=&amp;width=403" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399153-31e8e2ec-e0f7-4ab7-a328-8b2e74742a8f.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u6d60a1cb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0b2a46c-d586-4bff-99d6-7555284bbb0&amp;title=&amp;width=414" alt=""><br>当我们点一个点的时候，我们只要那个长方形，它往右下方向拉, 然后看你能拉多远<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401624-62771dcc-0e46-4e02-95be-f03c4a11dd8d.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=181&amp;id=u20bd98fa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=275&amp;originWidth=741&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9ee39ed7-94fc-449b-ba80-16d2550e136&amp;title=&amp;width=487" alt=""><br>验证过程能不能快一点 O(1)内<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401970-88428577-d5a9-4b70-8787-83d3001063ea.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uada68211&amp;margin=%5Bobject%20Object%5D&amp;originHeight=304&amp;originWidth=692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua0608d42-bb77-46f4-b982-6c6e649dd36&amp;title=" alt=""><br>假设我知道任何一个(i,j)位置右边有多少个连续的1, 下方有多少个连续的1(包括自己在内)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402673-739ba559-43f0-4cfc-9907-3a8c7357f9aa.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=359&amp;id=uda259ca9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=603&amp;originWidth=670&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uef3ee539-2f80-47f9-813c-47d085e71b8&amp;title=&amp;width=399" alt=""><br>17,29的左上顶点, 边长是7的这么一个正方形。<br>怎么验证?<br>你先看看(7,29)右方连续的1够不够 7 个，你再看看(7,29)这个点下方连续的1够不够 7个<br>…<br>只需要调出这 3 个点的信息, O(1)的过程<br>接下来就是求任何一个(i,j)点，让它右方和下方有这个信息</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402900-dc768550-cd1a-4853-a5d8-f871f5fcabfc.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=uc6970c91&amp;margin=%5Bobject%20Object%5D&amp;originHeight=547&amp;originWidth=995&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08ef4750-7959-4b40-969e-e9a6bda8fc0&amp;title=&amp;width=572" alt=""><br>怎么求这个信息呢?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781186419-16a3698d-6e4e-4407-9643-68dfc9156b32.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=810&amp;id=u0773d943&amp;margin=%5Bobject%20Object%5D&amp;name=8594CD1133E89D6E5D0DE8C781C7E60E.png&amp;originHeight=1418&amp;originWidth=1034&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=457290&amp;status=done&amp;style=none&amp;taskId=ub2bac3a4-0128-47f0-b5ea-c0907f659e3&amp;title=&amp;width=590.8571428571429" alt="8594CD1133E89D6E5D0DE8C781C7E60E.png"><br>咋知道这个O(N^3)的解需不需要继续优化?<br>矩阵规模告诉你, 最多100*100, 你拿N^3一套没到10^8这个级别,<br>你知道O(N^3)的这个解不需要再优化了, 这个题目必过.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403570-4bf72a85-3dce-4515-959c-f1866430fbbd.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u8da21f2c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=63&amp;originWidth=246&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc724a96e-b8cd-4797-97b5-7198d88597b&amp;title=" alt=""></p><p>怎么想到是预处理数组呢?<br>当写完3个for循环之后, 底层一个正方形再验的时候不想再遍历了,<br>势必会设计一种查询的结构来支持它, 不让它遍历来保证O(1)<br>这就是思想的开端,<br>预处理数组怎么用?<br>就是当你最后卡在最后一步，一个小的元件需要遍历搞定，这样的时候特别的多，<br>你就想着我怎么样做出一个能够提前查询的结构，到这一步的时候把遍历省掉, 比如前缀数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403652-75a89599-d8f8-43a3-a1e1-5d2643008a8c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=ub5033baf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=884&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1f7af3b0-f56a-4be7-b7cc-baeebc9e05a&amp;title=&amp;width=492" alt=""></p><p>| <strong>public static int </strong>largest1BorderedSquare<strong>(int[][] </strong>m<strong>) {<br>   int[][] </strong>right = <strong>new int[</strong>m.<strong>length][</strong>m<strong>[</strong>0<strong>]</strong>.<strong>length]</strong>;<br>   <strong>int[][] </strong>down = <strong>new int[</strong>m.<strong>length][</strong>m<strong>[</strong>0<strong>]</strong>.<strong>length]</strong>;<br>   //==生成右信息 下信息<br>   setBorderMap<strong>(</strong>m, right, down<strong>)</strong>;<br>   <strong>for (int </strong>size = Math.min<strong>(</strong>m.<strong>length</strong>, m<strong>[</strong>0<strong>]</strong>.<strong>length)</strong>; size != 0; size—<strong>) {<br>      if (</strong>hasSizeOfBorder<strong>(</strong>size, right, down<strong>)) {<br>         return </strong>size <em> size;<br>      <strong>}<br>   }<br>   return </strong>0;<br><strong>}</strong><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781251250-6c80220e-fc56-430a-b4c9-377e6c3fa002.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=455&amp;id=uadd39646&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=797&amp;originWidth=995&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=221761&amp;status=done&amp;style=none&amp;taskId=udef49ab0-cccf-4360-9f48-ec0dcec606e&amp;title=&amp;width=568.5714285714286" alt="image.png"><strong>**public static void </strong>setBorderMap<strong>(int[][] </strong>m, <strong>int[][] </strong>right, <strong>int[][] </strong>down<strong>) {<br>   int </strong>r = m.<strong>length</strong>;<br>   <strong>int </strong>c = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   //右下角<br>   <strong>if (</strong>m<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>== 1<strong>) {      </strong>right<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>= 1;<br>      down<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>= 1;<br>   <strong>}   </strong>//最右侧的数据<br>   <strong>for (int </strong>i = r - 2; i != -1; i—<strong>) {<br>      if (</strong>m<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>== 1<strong>) {         </strong>right<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>= 1;<br>         //等于1的话九四下一行加1<br>         down<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>= down<strong>[</strong>i + 1<strong>][</strong>c - 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }   </strong>//最后一行的数据<br>   <strong>for (int </strong>i = c - 2; i != -1; i—<strong>) {<br>      if (</strong>m<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>== 1<strong>) {         </strong>right<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>= right<strong>[</strong>r - 1<strong>][</strong>i + 1<strong>] </strong>+ 1;<br>         down<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>= 1;<br>      <strong>}<br>   }   </strong>//然后从倒数第二行开始，从倒数第二列往前一行一行的推 &lt;—  ^<br>   <strong>for (int </strong>i = r - 2; i != -1; i—<strong>) {<br>      for (int </strong>j = c - 2; j != -1; j—<strong>) {<br>         if (</strong>m<strong>[</strong>i<strong>][</strong>j<strong>] </strong>== 1<strong>) {            </strong>right<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= right<strong>[</strong>i<strong>][</strong>j + 1<strong>] </strong>+ 1;<br>            down<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= down<strong>[</strong>i + 1<strong>][</strong>j<strong>] </strong>+ 1;<br>         *</em>}<br>      }<br>   }<br>}</p><p>** |<br>| —- |</p><p>| <strong>public static boolean </strong>hasSizeOfBorder<strong>(int </strong>size, <strong>int[][] </strong>right, <strong>int[][] </strong>down<strong>) {<br>   for (int </strong>i = 0; i != right.<strong>length </strong>- size + 1; i++<strong>) {<br>      for (int </strong>j = 0; j != right<strong>[</strong>0<strong>]</strong>.<strong>length </strong>- size + 1; j++<strong>) {         </strong>//找那三个点！！  左上的那个点              下方的那个点<br>         <strong>if (</strong>right<strong>[</strong>i<strong>][</strong>j<strong>] </strong>&gt;= size &amp;&amp; down<strong>[</strong>i<strong>][</strong>j<strong>] </strong>&gt;= size &amp;&amp; right<strong>[</strong>i + size - 1<strong>][</strong>j<strong>] </strong>&gt;= size<br>               //右边的那个点<br>               &amp;&amp; down<strong>[</strong>i<strong>][</strong>j + size - 1<strong>] </strong>&gt;= size<strong>) {<br>            return true</strong>;<br>         <strong>}<br>      }<br>   }<br>   return false</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-乘客坐船使用的最少船数"><a href="#·-乘客坐船使用的最少船数" class="headerlink" title="· 乘客坐船使用的最少船数"></a>· 乘客坐船使用的最少船数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266540654-bc52c017-346b-4c9c-ba85-2f8363a2f43d.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=123&amp;id=u90d68d8f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20339&amp;status=done&amp;style=none&amp;taskId=ua7a2c8fd-24f1-479b-b9e4-4bb22b8c84a&amp;title=&amp;width=412.8" alt="image.png"><br><strong>题意</strong><br>每艘船最多坐两人，且不能超过载重。问你让所有人同时过河，并且用最好的分配方法，<br>使船尽量少返回最少的船数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754920033-d23a14f3-997f-4f13-a9f0-7b561f79d2f2.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=u96abc735&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1151&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25fc0b67-d916-4e77-8078-1029b98c178&amp;title=&amp;width=428" alt=""><br><strong>题解</strong><br>你先遍历一遍数组，如果有单独一个人的体重已经超过了limit返回无穷大。<br>多少条船都搞不定的<br><strong>流程</strong><br>先排序<br>从中间分界点开始往左右两边滑</p><p>找&lt;=limit/2最右的位置, 做为L指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919993-2fc7575c-c414-4b7e-a832-5bf0bcb40ff6.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=ufb0881ef&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75a44641-53ce-4de8-8f74-8ac55b102d0&amp;title=&amp;width=446" alt=""><br>R指针: 第一个超过limit/2的位置<br>看L位置和R位置能否凑一个船, 不能, 超了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919953-4a90aa2e-3033-4477-8930-018ff980a464.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u95912d5e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=1102&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue7bf048f-aaa8-4400-803d-9d57b976d24&amp;title=&amp;width=538" alt=""><br>L往左飘, L来到3, 可以<br>先不忙分配船, R往右滑, 一直划到R再往下进一个就没有办法跟 3凑一船为止<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919952-f9d1b099-1792-43c3-931a-0e97bdbaec96.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u65f47ec7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1076&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u854235fa-c1f2-44a8-9746-bc7d404a688&amp;title=&amp;width=522" alt=""><br>贪心的核心点:<br>从3出发往左数6个的这6个，去消化这6个，一定是最省的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919986-6ed6fbd8-2c1a-41ba-9150-e1e3bb4a60e3.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u93e568a4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=1162&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u91791187-7421-4fec-b6c7-edf0f6db13c&amp;title=&amp;width=445" alt=""><br><strong>例子1: 右侧先耗尽</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921589-39ec9db9-b791-4250-84a0-959f28c10384.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u89cdb406&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1019&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5babd024-fc3f-4e18-897a-c9982047463&amp;title=&amp;width=475" alt=""><br>俩对号装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921991-8f261b8f-5962-4c73-85b3-f6a17ed90471.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=u2d0e63b4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=558&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08d96e78-dff0-43b7-a5d1-52d57f628ed&amp;title=&amp;width=503" alt=""><br>X号两两可以装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922406-6a35f17e-24ef-4b59-92c8-c94d60e2eeaa.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u608ae23c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=548&amp;originWidth=1040&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud57e21a5-c48a-4d3e-a609-646cb20f153&amp;title=&amp;width=439" alt=""><br><strong>例子2: 左侧先耗尽</strong><br>最后对号的数量除2，加上×号的数量除2(向上取整)，加上右侧剩几个数它们一定单独一艘船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922475-c578911c-83dd-4b73-a887-e8c5088bf359.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=198&amp;id=u2c8f3183&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=1191&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua593a755-3782-413c-ab6c-595e375b6c0&amp;title=&amp;width=456" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654782938733-ff5ae0ad-f593-4836-8ee2-b595c618751a.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=867&amp;id=u98f15db6&amp;margin=%5Bobject%20Object%5D&amp;name=2B163C063CD4521C4323347FAFB38F50.png&amp;originHeight=1518&amp;originWidth=1036&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=511608&amp;status=done&amp;style=none&amp;taskId=uee0c2454-79c7-4464-a51a-0459a5ae855&amp;title=&amp;width=592" alt="2B163C063CD4521C4323347FAFB38F50.png"></p><p>| public static int numRescueBoats(int[] arr, int limit) {<br>   if (arr == null &#124;&#124; arr.length == 0) {<br>      return 0;<br>   }<br>   int N = arr.length;<br>   Arrays.sort(arr);<br>   if (arr[N - 1] &gt; limit) {<br>      return -1;<br>   }<br>   int lessR = -1;<br>   //找到 最左侧里 limit/2最接近的数<br>   for (int i = N - 1; i &gt;= 0; i—) {<br>      if (arr[i] &lt;= (limit / 2)) {<br>         lessR = i;<br>         break;<br>      }<br>   }<br>   if (lessR == -1) {<br>      return N;<br>   }<br>   int L = lessR;<br>   int R = lessR + 1;<br>   int noUsed = 0;<br>   while (L &gt;= 0) {<br>      int solved = 0;//用来更新L下标的<br>      while (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) {<br>         R++;<br>         solved++;<br>      }<br>      //表示上述结束了右边没有一个能和当前的L乘坐<br>      if (solved == 0) {<br>         noUsed++;//左侧未使用的<br>         L—;<br>      } else {<br>         L = Math.max(-1, L - solved);<br>      }<br>   }<br>  //下面的要用具体的例子来换算下标<br>   int leftAll = lessR + 1;//理解的好方法：因为数组是下标0开始的 +1就表示左侧的全部数量<br>   int leftUsed = leftAll - noUsed;//左侧的全部数量-未使用的就是使用的<br>   //右侧还剩下未使用的<br>   int rightUnsolved = (N - all) - used;<br>   return used + ((noUsed + 1) &gt;&gt; 1) + moreUnsolved;<br>} |<br>| —- |</p><h2 id="·-子数组最大累加和"><a href="#·-子数组最大累加和" class="headerlink" title="· 子数组最大累加和"></a>· 子数组最大累加和</h2><p><strong>题解</strong><br>看到子数组子串想想每个位置结尾是答案是什么<br>如果子数组必须以0结尾, 它往左扩到什么程度，能让累加和最大<br>如果子数组必须以1位置结尾, 它往左扩到什么程度，能让累加和最大</p><p><strong>大流程</strong><br><strong>可能性划分</strong><br>必须以i位置结尾答案可能来自什么?<br>1) 完全不向左扩, 只有自己<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677717-e5aafff1-1b52-4e5e-80db-0a14e490e373.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=uea3b3eb0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=389&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u498816dd-5c0d-429b-81ef-e611245e7c0&amp;title=&amp;width=489" alt=""><br>2) 要向左扩， i-1结尾的时候扩出来的最好决定了当前能扩出来的最好<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677743-cc8cf0a5-a0c2-459a-abbe-6d083b658117.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=315&amp;id=ue16cd42f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=863&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89741c3c-0ea1-41a0-8082-0ac2dd610c1&amp;title=&amp;width=559" alt=""><br><strong>例子</strong><br>dp[i]: 必须以i位置的数结尾的时候最好累加和多少<br>dp中的max就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677733-ba8e98b6-b4cd-4ab5-8570-929835020c5b.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u3525b401&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1029&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udbb81fdc-2585-4a4b-9adb-f55a90e2193&amp;title=&amp;width=470" alt=""><br><strong>代码</strong><br>没有必要准备一整个 BP 有几个变量滚动更新下去就完了<br>因为它只依赖左边的一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756678781-859e8520-7df4-4d2f-887d-9be3467f97b0.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubf36503d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=355&amp;originWidth=788&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u515da530-1d5b-46cd-8343-4404bd2aed8&amp;title=" alt=""></p><h2 id="·-😡子矩阵最大累加和-H"><a href="#·-😡子矩阵最大累加和-H" class="headerlink" title="· 😡子矩阵最大累加和 [H]"></a>· 😡子矩阵最大累加和 [H]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655000610147-a7d3a92b-d3ae-4465-94ce-a8a8d694215c.png#clientId=u7bc39c19-43ea-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=313&amp;id=u0e2403c7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=547&amp;originWidth=1170&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=92137&amp;status=done&amp;style=none&amp;taskId=u927eb0d4-d5e2-468d-8556-18104e0bc5a&amp;title=&amp;width=668.5714285714286" alt="image.png"><br><strong>题解</strong><br>大流程<br>矩形必须包含第0行数据, 且只包含第0行的情况下, 最大累加和是多少?<br>矩形必须包含0,1两行数据, 且只包含0,1两行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2三行数据, 且只包含0,1,2三行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2,3四行数据, 且只包含0,1,2,3四行的情况下, 最大累加和是多少?<br>….<br>然后<br>1行~1行<br>1行~2行<br>1行~3行<br>1行~4行<br>…<br>然后<br>2行~2行<br>2行~3行<br>2行~4行<br>…<br>然后<br>3行~3行<br>…<br>然后<br>4行~4行<br>如果我们能够每一个都求出来，答案一定在其中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884708-799a0b20-7c1c-47b3-977e-90592414790a.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u0156074e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1078&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7b53efdb-4fdf-4833-8ad0-bd3bc9bb71d&amp;title=&amp;width=432" alt=""><br>如果我们能够每一个都求出来答案一定在其中</p><p>压缩数组技巧<br>0行<br>必须包含第0行数据，且只有第0行情况下画框, 最大累加和多少?<br>就是子数组的最大累加和问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884722-2be04454-65aa-4ab1-bf9a-f9b97da2206c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u4164a828&amp;margin=%5Bobject%20Object%5D&amp;originHeight=429&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud1f9b8e9-8a11-4a1f-9e61-14d37d138b3&amp;title=&amp;width=554" alt=""><br>下面<br>矩形必须包含0, 1两行数据, 且只包含0, 1两行的情况下, 最大累加和是多少?<br>两行上下数据压在一起,形成一个新数组<br>对这个数组求最大累加和就代表必须包含0, 1两行数据，且只包含01两行数据画框的最好答案是啥。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884649-aa42ef84-bb7a-4136-98bb-9fd3691bc443.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ude7883e6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=1075&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2740ec61-35a4-4813-9a55-36c15b2fcb8&amp;title=&amp;width=526" alt=""><br>复杂度O(行^2*列)<br>在行上玩了一个O(行^2)的事<br>0~0<br>0~1<br>…<br>1~1<br>1~2<br>…<br>但你每次解决一个子任务它就是过一遍数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884664-75b98c0a-3eaa-493f-bfb2-184b1e00835a.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=ue4e4a946&amp;margin=%5Bobject%20Object%5D&amp;originHeight=507&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u95e57951-deb2-47df-983f-7072b817740&amp;title=&amp;width=506" alt=""><br>进一步优化: 让行列小的当平方项<br>如果是5行, 100列, 选择让行做平方项<br>如果是100行, 5列, 选择让列做平方项</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884772-ba08c36e-d98b-45f2-8291-2432422e914c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=uf99229ea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=496&amp;originWidth=1061&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6a44cb24-c550-46f5-888f-c474dd72d23&amp;title=&amp;width=559" alt=""><br><strong>代码</strong></p><p>| <strong>public static int </strong>maxSum<strong>(int[][] </strong>m<strong>) {<br>   if (</strong>m == <strong>null </strong>&#124;&#124; m.<strong>length </strong>== 0 &#124;&#124; m<strong>[</strong>0<strong>]</strong>.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}   </strong>// O(N^2 <em> M)<br>   <strong>int </strong>N = m.<strong>length</strong>;<br>   <strong>int </strong>M = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {      </strong>// i行~j行<br>      <strong>int[] </strong>s = <strong>new int[</strong>M<strong>]</strong>;<br>      <strong>for (int </strong>j = i; j &lt; N; j++<strong>) {<br>         for (int </strong>k = 0; k &lt; M; k++<strong>) {            </strong>s<strong>[</strong>k<strong>] </strong>+= m<strong>[</strong>j<strong>][</strong>k<strong>]</strong>;<br>         <strong>}         </strong>max = Math.max<strong>(</strong>max, maxSubArray<strong>(</strong>s<strong>))</strong>;<br>      <strong>}<br>   }<br>   return </strong>max;<br>*</em>}</p><p>public static int <strong>maxSubArray</strong>(int[] <strong>arr</strong>) {<br>   if (<strong>arr == </strong>null <strong>&#124;&#124; arr.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   int <strong>max = Integer.</strong>MIN_VALUE<strong>;   </strong>int <strong>cur = 0;   </strong>for (int <strong>i = 0; i &lt; arr.</strong>length<strong>; i++</strong>) {<br>      <strong>cur += arr</strong>[<strong>i</strong>]<strong>;<br>      max = Math.max</strong>(<strong>max, cur</strong>)<strong>;<br>      cur = cur &lt; 0 ? 0 : cur;   </strong>}<br>   return <strong>max;</strong>}** |<br>| —- |</p><p>LeetCode原题<br>需要返回最大累加和矩形的左上角跟右下角点<br>当你发现了更大的答案， 你把它左上角点跟右下角点抓一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655001837943-7e030c8e-9549-42e0-a28a-31e013cd2d7b.png#clientId=ub6405de6-621a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=530&amp;id=u0049c974&amp;margin=%5Bobject%20Object%5D&amp;name=A19EA1E0AF7663EFCF77985E2517F6F4.png&amp;originHeight=1296&amp;originWidth=1216&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=510166&amp;status=done&amp;style=none&amp;taskId=u1f0706bf-c56b-4e69-9411-9025019afa5&amp;title=&amp;width=497.2857360839844" alt="A19EA1E0AF7663EFCF77985E2517F6F4.png"></p><p>| //返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。<br>// 本题测试链接 : <a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">https://leetcode-cn.com/problems/max-submatrix-lcci/</a><br><strong>public static int[] </strong>getMaxMatrix<strong>(int[][] </strong>m<strong>) {<br>   int </strong>N = m.<strong>length</strong>;<br>   <strong>int </strong>M = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>int </strong>cur = 0;<br>   <strong>int </strong>a = 0;<br>   <strong>int </strong>b = 0;<br>   <strong>int </strong>c = 0;<br>   <strong>int </strong>d = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {<br>      int[] </strong>s = <strong>new int[</strong>M<strong>]</strong>;<br>      <strong>for (int </strong>j = i; j &lt; N; j++<strong>) {         </strong>cur = 0;<br>         //记录左上角的列<br>         <strong>int </strong>begin = 0;<br>         /**</p><pre><code>      * [1 1 1 1]      * [0 1 1 2]      * [2 1 0 1]      */     **for (int **k = 0; k &lt; M; k++**) &#123;        **s**[**k**] **+= m**[**j**][**k**]**;        cur += s**[**k**]**;        **if (**max &lt; cur**) &#123;           **max = cur;           a = i;           //主要这一句           b = begin;           //           c = j;           d = k;        **&#125;        **//只有一开始就为负数的情况下，0列        **if (**cur &lt; 0**) &#123;           **cur = 0;           begin = k + 1;        **&#125;     &#125;  &#125;</code></pre><p>   }<br>   return new int[] { <strong>a, b, c, d </strong>}<strong>;</strong>}** |<br>| —- |</p><h2 id="·-135-分糖果问题-H"><a href="#·-135-分糖果问题-H" class="headerlink" title="· 135.分糖果问题 [H]"></a>· 135.分糖果问题 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757640476-f9879a7a-09ff-4b7e-9894-dcc5fb7a88f1.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=294&amp;id=uefc12a68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=368&amp;originWidth=717&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26786&amp;status=done&amp;style=none&amp;taskId=u1a5c1fb5-6fbe-4e76-9b2f-86a45e8de44&amp;title=&amp;width=573.6" alt="image.png"><br><strong>原问题</strong><br>一个数组是所有孩子的得分, 规则是，每个孩子至少一颗糖。相等不管, 只管严格大小关系<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486177-e5f2c5b1-bff0-4a8a-b27f-80ba3eac2b1c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=u249a86d3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8840862e-eeb8-4455-87ff-fdf3aa4e161&amp;title=&amp;width=504" alt=""><br><strong>题解</strong><br><strong>预处理数组+贪心</strong><br>左边没东西1块糖, 比左边大, 数字就++, 不再大了就返回1, left代表每一个点左边的坡度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486316-27402c6e-a9dd-4a3a-b72e-c09cae8103ee.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u59a65f06&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=1093&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u999c1aa3-b272-4cb8-9003-279e9af6e87&amp;title=&amp;width=499" alt=""><br>右边没东西1块糖, 比右边打了就++, 不再大了就回1<br>每个位置的max就是分糖数量，因为左坡跟右坡以较大坡为准<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486225-aba65e85-23b1-4233-a76e-2e967ed35bc0.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=ud59977cd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf3423d64-9cb4-4a2c-9e49-352f333674a&amp;title=&amp;width=652" alt=""><br><strong>复杂度</strong><br>时间复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757488676-248c8add-ee09-4fe4-9157-ff396f83324e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=ued7c1b61&amp;margin=%5Bobject%20Object%5D&amp;originHeight=508&amp;originWidth=913&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u552fabd9-cd94-48a3-bc14-1d1ab0ac4fe&amp;title=&amp;width=479" alt=""><br><strong>最优解</strong><br>我遍历的过程中，我先认为进入到上坡阶段和下坡阶段，我如果能找出一个坡来<br>就是上坡跟下坡共同构成这么一个坡度的话，该怎么分糖我就知道了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489305-1d4f8a25-b3af-43b7-9067-6174a5c50d95.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=180&amp;id=ucfc19315&amp;margin=%5Bobject%20Object%5D&amp;originHeight=329&amp;originWidth=1101&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8812c98d-eef3-4d11-8bbc-cbd7af31d8c&amp;title=&amp;width=603" alt=""><br>对coding要求比较高<br>Coding技巧可以让我找到一组上坡下坡, 等找到的时候, 再回过去给糖</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489355-8a08973f-476c-46d2-8817-37ea96dc2203.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=ua20e6791&amp;margin=%5Bobject%20Object%5D&amp;originHeight=412&amp;originWidth=942&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9aab8328-aca0-4baa-acf8-3a67fc6e1b5&amp;title=&amp;width=646" alt=""><br>没有重复值的例子<br>先遍历一遍找到坡, 然后再回去给糖, 两个坡度较大的那个+1<br>然后处理下个坡<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489655-913e2252-71e6-43df-9f0f-e11e4963f752.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u9023b751&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u293717ff-dce2-472f-a9bc-18f6b77868d&amp;title=&amp;width=525" alt=""><br>要保证两个坡中间同样的那个1不要重复给<br>相当于遍历两遍这个事儿就出来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489683-68970db3-f71e-47f9-a62e-43d3352f2041.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ud4227d7e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=1016&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u373ac26e-6280-4b9b-9741-d0f405fca4a&amp;title=&amp;width=567" alt=""><br>有相等值就更考验coding<br>相等是无非就是你认为上坡停止下会停止, 更考研Coding技巧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490765-ec269bd1-cd03-4caf-a292-1556e258aaed.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=uf2363b7e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=420&amp;originWidth=751&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1aa1af8b-180e-44d1-adbd-6f02d306b85&amp;title=&amp;width=498" alt=""><br>补充问题<br>相邻孩子分数一样, 糖的数量必须一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490609-1e02392c-0c28-4911-aabe-a0e441adc3b2.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u9114b783&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1041&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u74edf940-9fec-4510-bf50-509068979ff&amp;title=&amp;width=441" alt=""><br><strong>例子</strong><br>生成辅助数组<br>三个原则，第一比左边大就++，<br>第二，跟左边相等就继承, 就是不变，<br>第三比左边小就归1<br>同样方法生成right<br>还是每个位置的值求max</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490724-1661c665-c1f5-4df8-8d39-1a84b646d746.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ubc071e71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=533&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubd737b23-0203-49bd-9d92-6f6dddc3625&amp;title=&amp;width=492" alt=""><br>可以Coding省掉辅助数组, 更难（idea上有代码）<br>相等认为坡没变<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757491157-d5860f2a-c415-4dba-a996-a2ef506de57f.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=u5b8b35db&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=971&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8911ce37-03e3-4967-8e7d-037c74c385c&amp;title=&amp;width=426" alt=""></p><p>| // 这是原问题的优良解<br>// 时间复杂度O(N)，额外空间复杂度O(N)<br><strong>public static int </strong>candy1<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>int[] </strong>left = <strong>new int[</strong>N<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; N; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i - 1<strong>] </strong>&lt; arr<strong>[</strong>i<strong>]) {         </strong>left<strong>[</strong>i<strong>] </strong>= left<strong>[</strong>i - 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }<br>   int[] </strong>right = <strong>new int[</strong>N<strong>]</strong>;<br>   <strong>for (int </strong>i = N - 2; i &gt;= 0; i—<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&gt; arr<strong>[</strong>i + 1<strong>]) {         </strong>right<strong>[</strong>i<strong>] </strong>= right<strong>[</strong>i + 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }<br>   int </strong>ans = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {      </strong>ans += Math.max<strong>(</strong>left<strong>[</strong>i<strong>]</strong>, right<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   return </strong>ans + N;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-小人过有鳄鱼的河-博弈论"><a href="#·-小人过有鳄鱼的河-博弈论" class="headerlink" title="· 小人过有鳄鱼的河(博弈论)"></a>· 小人过有鳄鱼的河(博弈论)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757912442-ad573f17-7f4a-489a-ad67-3e78f85412e8.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=76&amp;id=uacedcc1b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=95&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17519&amp;status=done&amp;style=none&amp;taskId=u60591a67-ac3f-4cdc-b743-12dc5bc1e43&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题解</strong><br>思路: 从小推到大<br>这个人在一只鳄鱼的时候就过不了河了，<br>两只鳄鱼的时候就可以过河<br>三只鳄鱼等同于一个人两条鳄鱼的时候, 也不能过河, 因为任何一个鳄鱼吃掉人是没风险的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885276-012e6b97-e501-4f4e-be4b-fa012f482633.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=u9ca7460a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=444&amp;originWidth=937&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud1dff254-e3ae-49c7-94e2-2f88822fd1d&amp;title=&amp;width=530" alt=""><br>奇数能过河, 偶数不能过河<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885221-16ccb180-9d2a-48a8-bd80-9148fde82953.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=u2548e3b4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=925&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u299d4d20-2cf8-471b-8a64-0863faf084d&amp;title=&amp;width=457" alt=""></p><h2 id="·-Nim博弈问题"><a href="#·-Nim博弈问题" class="headerlink" title="· Nim博弈问题"></a>· Nim博弈问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800477496-814bb547-f09d-498f-abe5-e2c0e47bb5df.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=79&amp;id=u4fd49066&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=99&amp;originWidth=843&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22068&amp;status=done&amp;style=none&amp;taskId=uc93319c5-ad21-4523-9ae1-dc89387a500&amp;title=&amp;width=674.4" alt="image.png"><br><strong>题意</strong><br>所有的数&gt;=0, 每一轮不管谁都不能拿0<br>谁最先把最后一点数拿完谁赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457877-281d0894-d81e-47d0-987e-47ebb159a8b0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u3d1eed1b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=607&amp;originWidth=1273&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7304e460-0286-465e-aee9-75c63e9b7ec&amp;title=&amp;width=478" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457894-773ef509-f81a-4726-b0ee-d9cf10ef31bd.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=uf044b29a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=468&amp;originWidth=672&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue799c9d7-94cb-4cac-8596-1d6808cdfa8&amp;title=&amp;width=342" alt=""><br>先手跟后手，绝顶聪明，每一个人都充分为所有为自己打算，<br>而且绝对理智，问你，给你一个数组状况返回谁会赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800467223-97b4ba95-223a-4115-827b-edf542fc7b0c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=ud3a77b39&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=734&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue582679d-eb0a-4430-ac2a-50f530a132f&amp;title=&amp;width=410" alt=""><br>先手第一回拿把它拿成两个数都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458021-1b935de2-12bb-47d3-8f26-530ef46b89a0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=281&amp;id=udc3de2b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=515&amp;originWidth=693&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u18bf42a8-f831-4160-8833-13cff2b33f1&amp;title=&amp;width=378" alt=""><br>后手接下来不管拿多少, 先手都让它两个数一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457964-b74ab48f-bb7e-453a-beb0-160600a24846.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=u85f511af&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u107afaec-9b34-4b96-8fe4-32cb147b4a3&amp;title=&amp;width=418" alt=""><br>这样先手一定会赢<br>这是两个数的规律<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458667-6220c51c-3dd2-47e9-bde9-b5b33c5a54a4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=u163724fc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=862&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufbf57780-7d21-4ca3-8ca3-77502419af6&amp;title=&amp;width=391" alt=""><br><strong>题解</strong><br>由1900年数学家尼姆搞出来一个非常牛逼的解，<br>结论:<br>所有的数异或起来，如果异或和不等于零先手赢，如果异或和等于0后手赢</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458782-28023103-8346-46b2-a8dc-de62f52c13ac.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=u8660b253&amp;margin=%5Bobject%20Object%5D&amp;originHeight=563&amp;originWidth=987&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5dfad24-d8cf-4843-9bf3-a66fb04062c&amp;title=&amp;width=442" alt=""><br>先手的大目标:<br>让后手最先面对所有数组中都是 0 的状态。<br>大目标不知道怎么实现, 转换一下目标</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458900-733597fd-a958-4f2d-bd91-7dee949c8ffa.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=192&amp;id=u50188994&amp;margin=%5Bobject%20Object%5D&amp;originHeight=459&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud4ecb940-750d-4418-b3c3-e54b7d7592a&amp;title=&amp;width=446" alt=""></p><p>所有数都异或起来的异或和, 我如果先手能够做到我面对这坨数的异或和它不等于零，<br>但是我拿完之后每一次都让后手面对的异或和等于0，那么最后胜利是先手<br>我们知道最后全 0 的时候异或和是0。所以就这么玩下去，它总有一个时刻全 0 的时候，<br>而我是遇不到的，只会让后手遇到，所以我必胜的大目标被我们变成一个看似更难的目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458936-68a35d98-dbb4-4fbc-8eb7-a1dd85180307.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=uda72b545&amp;margin=%5Bobject%20Object%5D&amp;originHeight=629&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u505fe591-a3c8-41b2-ab41-bd6884a1f14&amp;title=&amp;width=500" alt=""><br><strong>例子</strong><br>把二进制写出来, 数组7,5,3 整体异或和001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459312-eddefebf-42c9-45db-9b8e-ddbd313e4e16.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=ua7fccb0e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=1310&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud2f98016-c6b9-4d1d-a11e-a52172c1446&amp;title=&amp;width=560" alt=""><br>先手在1这拿一个, 变成6, 更后面的5,3异或和为6的合起来异或和为0<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459424-4f4051be-b558-49e1-90b9-860f4b9f0660.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=230&amp;id=u72048edf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=617&amp;originWidth=1318&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e0608f9-d441-45c1-80f0-19fbc6e06d1&amp;title=&amp;width=491" alt=""><br>后手再拿的时候，他不管在哪个位置上拿哪个数都一定会让异或和从 0 变成不是零，<br>因为他必然会改变某一个位置上一的数量, 改变了它的异或和就不是0，然后先手继续让<br>它异或和变0, 先手必胜.<br>但是这样做的前提是什么?初始的时候异或和得是非零的先手才能这么干，如果先手面<br>对一个一上来就是异或和等于0的状态，后手赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459439-1138e3cb-d17b-4fe9-810b-e54a6fc1742f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u2905cd61&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=1307&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2bff4b1-484e-4ee0-9b03-d077dffc405&amp;title=&amp;width=510" alt=""><br>先手不一定在最大值上拿</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459509-11aaa21d-d569-4be6-9afa-9d6e11b76fa1.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u5f1b26a9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1179&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3841b959-e751-45bc-9027-7d4efd1ad33&amp;title=&amp;width=507" alt=""><br>就是先手一定能做到一个不是0 异或和的东西变成全零，但不一定是在最大值上拿的，但是他一定能做到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800460027-d4c6583e-9e89-43ce-92f4-10ed5c3be356.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=uc64a46f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1331&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8bef9a58-5ca7-415c-85d2-26b3416a918&amp;title=&amp;width=566" alt=""></p><p>| // 保证arr是正数数组<br><strong>public static void </strong>printWinner<strong>(int[] </strong>arr<strong>) {<br>   int </strong>eor = 0;<br>   <strong>for (int </strong>num : arr<strong>) {      </strong>eor ^= num;<br>   <strong>}<br>   if (</strong>eor == 0<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“后手赢”)</strong>;<br>   <strong>} else {      </strong>System.<strong>out</strong>.println<strong>(“先手赢”)</strong>;<br>   <strong>}<br>}</strong> |<br>| —- |</p><h2 id="·-非负数组中两个数相与的最大结果"><a href="#·-非负数组中两个数相与的最大结果" class="headerlink" title="· 非负数组中两个数相与的最大结果"></a>· 非负数组中两个数相与的最大结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650113590488-8110c2b9-7a47-41d5-a42b-f0a7399ead91.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=u485e8bbb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=394&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15539&amp;status=done&amp;style=none&amp;taskId=u122a7d6b-ae77-4da4-8b41-ac244820e50&amp;title=&amp;width=315.2" alt="image.png"><br><strong>题解</strong><br>可以用前缀树, 额外空间比较大, 存在更好的解法<br>思路: 高位尽量变1<br>因为我如果选一些数让30位变成0，它就不如30位变成1的值大</p><p>先遍历一遍所有的数字, 只考察30位是1的有几个, 分情况<br>1) 小于两个<br>这说明最终的结果30位上肯定不是1，因为你小于两个就不存在任何两个数，两个两个数与玩之后第30位是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800811891-1b46d42a-fe12-4196-af17-9775c90ea3a4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u164ba3a7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=500&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf326dddf-1871-4357-abfd-fc5d79a368e&amp;title=&amp;width=518" alt=""><br>2) 正好有两个数， 就是这两个数与完的结果最大， 直接返回就行<br>3） 大于两个数<br>那我就把这100个数淘汰掉，剩下的我只留这23个数，我再去看第29位</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812084-94f090b2-a658-437e-8dc0-a7931e7bc517.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u2d559d95&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1108&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub142840c-3848-4aa9-ae7d-5317a77cf57&amp;title=&amp;width=549" alt=""><br>假设目前这一批数还剩20个， 来到第i位<br>第i位上有1的数：<br>1） <2个2） =2个3） > 2个</p><p>我们遍历一遍整个数组，如果有第i位上有1的数，<br>第1种情况小于两个，那么这20个数一个也不淘汰，你接下来去看a减，<br>第2种情况如果这20个数中第i位上1的只有两个数，你不用再看，就这两个是结果<br>第3种情况如果大约在在地在第i位上有1的数是大于两个的，比如说他有7个，那么删掉剩余的13个，只留这7个数去搞安检一位不就玩儿去了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812139-21391412-9c69-4642-866d-d3f960d20bc7.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=ucefcac7f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=554&amp;originWidth=1083&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54468d3d-1d2f-4ae3-b207-9d23095f3ba&amp;title=&amp;width=504" alt=""><br><strong>时间复杂度</strong><br>30位遍历一遍数组， 29位遍历一遍数组…<br>一共遍历32遍数组, O(32N)</p><p><strong>空间复杂度怎么计算</strong><br>如果删到只剩下6个数, 17位的时候<br>保留数字这件事情, 在原数组上操作, 原数组末尾做垃圾区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812121-214352ae-98c3-4159-91d0-39878e511b6c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u73578c17&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=833&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue4361ff8-1204-42b3-9953-9cab2cc1866&amp;title=" alt=""><br><strong>代码</strong><br>垃圾区</p><p>&lt;2个, 一个数也不淘汰, 让M跳回去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812117-fb4a8866-f4ce-4796-9d6f-e723dcabb358.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u3dfa6e88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=895&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud964a6ce-61a5-49cc-bd8b-f81d3549e57&amp;title=&amp;width=483" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812536-2890f02a-970d-48af-90d3-2e5b41d3edb8.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0869c0ec&amp;margin=%5Bobject%20Object%5D&amp;originHeight=516&amp;originWidth=575&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u146e66a2-ea4d-4abe-92ce-6d990b399e2&amp;title=" alt=""></p><p>| <strong>public static int </strong>maxAndValue2<strong>(int[] </strong>arr<strong>) {   </strong>// arr[0…M-1]  arr[M….]<br>   <strong>int </strong>M = arr.<strong>length</strong>;<br>   <strong>int </strong>ans = 0;<br>   <strong>for (int </strong>bit = 30; bit &gt;= 0; bit—<strong>) {      </strong>// arr[0…M-1] arr[M…]<br>      <strong>int </strong>i = 0;<br>      <strong>int </strong>tmp = M;//有可能跳回去<br>      <strong>while (</strong>i &lt; M<strong>) { </strong>// arr[0…M-1]<br>         <strong>if ((</strong>arr<strong>[</strong>i<strong>] </strong>&amp; <strong>(</strong>1 &lt;&lt; bit<strong>)) </strong>== 0<strong>) {            </strong>swap<strong>(</strong>arr, i, —M<strong>)</strong>;<br>         <strong>} else {            </strong>i++;<br>         <strong>}<br>      }<br>      if (</strong>M == 2<strong>) { </strong>// arr[0,1]<br>         <strong>return </strong>arr<strong>[</strong>0<strong>] </strong>&amp; arr<strong>[</strong>1<strong>]</strong>;<br>      <strong>}      </strong>//==<br>      <strong>if (</strong>M &lt; 2<strong>) {</strong>//当前bit为无法得到1，M跳回原来位置，一个数也不删<strong>**         </strong>M = tmp;<br>      <strong>} else { </strong>// &gt; 2个数  bit位上有1<br>         ans &#124;= <strong>(</strong>1 &lt;&lt; bit<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>ans;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-✊括号嵌套系列问题"><a href="#·-✊括号嵌套系列问题" class="headerlink" title="· ✊括号嵌套系列问题"></a>· ✊括号嵌套系列问题</h2><h3 id="①计算str表达式结果"><a href="#①计算str表达式结果" class="headerlink" title="①计算str表达式结果"></a>①计算str表达式结果</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650098950782-2396606a-0bbb-4b55-9cb6-f263b9578ad9.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=uaeee7735&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49751&amp;status=done&amp;style=none&amp;taskId=u4b5b7ea1-393b-431b-8ac2-e4790d56699&amp;title=&amp;width=679.2" alt="image.png"><br><strong>题意</strong><br>负数作为公式的开头 或括号部分的开头，可以没有括号<br><strong>题解</strong><br>先处理没有小括号的情况</p><p>指针从零开始就有两种情况:</p><ol><li>当前压中的是数字</li><li>当前压中的是符号<br>准备一个栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569314-732407d5-15f9-4a7e-955b-af2e37ff100f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u1a923818&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=1096&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc508edf6-c054-45e5-b769-4791d54b022&amp;title=&amp;width=505" alt=""><br>压中运算符号, 当初过数字阶段结束了, 找到了34<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569315-adc8cd07-34b4-4302-9e41-3b97c55765fb.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=uce5b21e3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=493&amp;originWidth=1115&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua15fcfcf-0634-4317-b4a3-83765138bda&amp;title=&amp;width=536" alt=""><br><strong>1, * </strong>入栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569327-d3093cd3-afae-4027-a13c-21a795ed98e4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u8b5cb035&amp;margin=%5Bobject%20Object%5D&amp;originHeight=477&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0f70762-e91b-40e6-ad16-29f364c33ce&amp;title=&amp;width=567" alt=""><br>栈顶乘除, 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569326-10c63ce7-1bb7-4088-b202-5669ddcfa1ce.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud0ca380b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=1116&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u19d8bda1-3868-4505-8ef6-06decfae122&amp;title=" alt=""><br>栈顶 / 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569330-71ccfd20-9804-4216-a208-53f5b5d350c1.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=uaea7846f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=507&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69bde130-2897-4078-9dfd-67844659fef&amp;title=&amp;width=570" alt=""><br>最后位置， 7 入栈， 栈里只有+-符号了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802570274-71211b4b-b360-454e-af84-04dd0cae9fc3.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=ub7bce47c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1112&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8191caa6-71ac-442a-8cc3-02e1fd3d0ff&amp;title=&amp;width=558" alt=""><br>定义递归函数f<br>int[] f(int i)<br>从i位置出发, 遇到右括号或者整个字符串终止位置停止， 返回两个值</li></ol><ul><li><ol><li>answer</li></ol></li><li><ol><li>F函数算到哪个位置了</li></ol></li></ul><p>条件情况：<br>①遇到数字</p><ul><li>设置cur</li></ul><p>②遇到运算符，结合cur加入到队列中<br>③遇到左括号就交给递归去搞，递归返回两个值</p><ul><li><ol><li>answer</li></ol></li><li><ol><li>F函数算到哪个位置了</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127597996-d7be7b6e-c490-4bea-bd31-166716737d7e.png#clientId=u7251bedd-719d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=504&amp;id=u8c22e28e&amp;margin=%5Bobject%20Object%5D&amp;name=B03D96AEEDFC16F1164F383A3C4FA837.png&amp;originHeight=1081&amp;originWidth=1739&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=456166&amp;status=done&amp;style=none&amp;taskId=u8a1e2898-b1b8-4344-a8d0-08c331b7bf2&amp;title=&amp;width=811.0000610351562" alt="B03D96AEEDFC16F1164F383A3C4FA837.png"></p><p><strong>例子2</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802571970-a1640f24-2c37-483d-b77a-efbb1b989559.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=ua50d068b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=445&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u99525ff6-64ba-48bf-b068-cce57175db3&amp;title=&amp;width=506" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572172-4a4912ea-4cde-4445-8205-a79369f2c4ca.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=187&amp;id=u81b31c60&amp;margin=%5Bobject%20Object%5D&amp;originHeight=416&amp;originWidth=1109&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf9fcaa9a-38b5-4adf-97e8-c0b34eab9cd&amp;title=&amp;width=498" alt=""><br>遇到左括号了就调递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572369-f6d4f508-2cf3-4096-944a-dd73f55c5d87.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u0ecc431b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=1103&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub543cc02-862d-4386-ac2e-09562639620&amp;title=&amp;width=546" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572690-1f71ba4c-d5a1-4bca-b4b9-84e14c4ec028.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u1ef6c4e6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=1112&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u81b410fe-4bce-4b03-ae45-37ae4dc0511&amp;title=&amp;width=543" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572941-2ab03421-1f4d-4d27-89e2-904c73ddb9d8.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u5a645239&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=1105&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u43dfc911-4281-454a-8e5d-0e49de897e6&amp;title=&amp;width=515" alt=""><br>压缩数组例子<br>只要是括号嵌套的都这玩意儿。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573019-d4ab5767-707d-4c9e-b387-12602d4bcdc0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=206&amp;id=u794d34bb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=388&amp;originWidth=940&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u011e5f47-e7bf-4aeb-9bb3-746df83d1bb&amp;title=&amp;width=498" alt=""><br>开头为负怎么计算<br>一上来碰到-号, 0, -, 压栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573351-066ab599-0ef9-4c1a-9f56-c63f6a74181f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=u36ef568b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=464&amp;originWidth=1184&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud82d0514-6263-41c7-b9d5-faaef151f10&amp;title=&amp;width=485" alt=""><br><strong>代码</strong><br>最后一个数字还没入栈， 放进去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573451-a23baef1-630a-43f3-89a6-cd2766a53edd.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=312&amp;id=u878bd00f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=483&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0b6eb0c-a03c-4a1a-8d42-f425afa6344&amp;title=&amp;width=582" alt=""><br>这种方法一定要牢牢掌握，因为任何括号嵌套的题都可以这么改</p><p>| <strong>public static int[] </strong>f<strong>(char[] </strong>str, <strong>int </strong>i<strong>) {   </strong>LinkedList<strong>&lt;</strong>String<strong>&gt; </strong>que = <strong>new </strong>LinkedList<strong>&lt;</strong>String<strong>&gt;()</strong>;<br>   <strong>int </strong>cur = 0;<br>   <strong>int[] </strong>bra = <strong>null</strong>;<br>   // 从i出发，开始撸串<br>   <strong>while (</strong>i &lt; str.<strong>length </strong>&amp;&amp; str<strong>[</strong>i<strong>] </strong>!= <strong>‘)’) {<br>      if (</strong>str<strong>[</strong>i<strong>] </strong>&gt;= <strong>‘0’ </strong>&amp;&amp; str<strong>[</strong>i<strong>] </strong>&lt;= <strong>‘9’) {         </strong>cur = cur <em> 10 + str<strong>[</strong>i++<strong>] </strong>- <strong>‘0’</strong>;<br>      <strong>} else if (</strong>str<strong>[</strong>i<strong>] </strong>!= <strong>‘(‘) { </strong>// 遇到的是运算符号<br>         addNum<strong>(</strong>que, cur<strong>)</strong>;//比如队列中此时有 1 +   cur = 2  来到+ 放入 2 +<br>         que.addLast<strong>(</strong>String.valueOf<strong>(</strong>str<strong>[</strong>i++<strong>]))</strong>;<br>         cur = 0;<br>      <strong>} else { </strong>// 遇到左括号了<br>         bra = f<strong>(</strong>str, i + 1<strong>)</strong>;<br>         cur = bra<strong>[</strong>0<strong>]</strong>;<br>         i = bra<strong>[</strong>1<strong>] </strong>+ 1;<br>      <strong>}<br>   }   </strong>//注意！要结束了，把最后一个数字放进去<br>   addNum<strong>(</strong>que, cur<strong>)</strong>;<br>   <strong>return new int[] { </strong>getNum<strong>(</strong>que<strong>)</strong>, i <strong>}</strong>;<br>*</em>}</p><p>public static void <strong>addNum</strong>(<strong>LinkedList</strong>&lt;<strong>String</strong>&gt; <strong>que, </strong>int <strong>num</strong>) {<br>   if (<strong>!que.isEmpty</strong>()) {<br>      int <strong>cur = 0;<br>      String top = que.pollLast</strong>()<strong>;      </strong>if (<strong>top.equals</strong>(“+”) <strong>&#124;&#124; top.equals</strong>(“-“)) {<br>         <strong>que.addLast</strong>(<strong>top</strong>)<strong>;      </strong>} else {<br>         <strong>cur = Integer.valueOf</strong>(<strong>que.pollLast</strong>())<strong>;<br>         num = top.equals</strong>(“<em>“) <strong>? </strong>(**cur </em> num<strong>) </strong>: <strong>(</strong>cur / num<strong>)</strong>;<br>      <strong>}<br>   }   </strong>que.addLast<strong>(</strong>String.valueOf<strong>(</strong>num<strong>))</strong>;<br><strong>}</strong><br><strong>public static int </strong>getNum<strong>(</strong>LinkedList<strong>&lt;</strong>String<strong>&gt; </strong>que<strong>) {<br>   int </strong>res = 0;<br>   <strong>boolean </strong>add = <strong>true</strong>;<br>   String cur = <strong>null</strong>;<br>   <strong>int </strong>num = 0;<br>   <strong>while (</strong>!que.isEmpty<strong>()) {      </strong>cur = que.pollFirst<strong>()</strong>;<br>      <strong>if (</strong>cur.equals<strong>(“+”)) {         </strong>add = <strong>true</strong>;<br>      <strong>} else if (</strong>cur.equals<strong>(“-“)) {         </strong>add = <strong>false</strong>;<br>      <strong>} else {         </strong>num = Integer.valueOf<strong>(</strong>cur<strong>)</strong>;<br>         res += add ? num : <strong>(</strong>-num<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>res;<br><strong>}</strong> |<br>| —- |</p><h3 id="②字符串解码"><a href="#②字符串解码" class="headerlink" title="②字符串解码"></a>②字符串解码</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127913238-063d6a0a-b032-4ca8-89e2-5dc17f30d0be.png#clientId=u7251bedd-719d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u2e367064&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=365&amp;originWidth=771&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22499&amp;status=done&amp;style=none&amp;taskId=u6402f452-c01d-4576-b24d-7d027b199f9&amp;title=&amp;width=440.57142857142856" alt="image.png"></p><p>| <strong>public static </strong>String calculate(String str) {<br>        <strong>return </strong>f(str.toCharArray(), 0)[0];<br>    }</p><pre><code>**public static **String[] f(**char**[] str, **int **i) &#123;    String ans = **&quot;&quot;**;    **int **cur = 0;    // 从i出发，开始撸串    **while **(i &lt; str.**length **&amp;&amp; str[i] != **&#39;]&#39;**) &#123;        //遇到数字        **if **(str[i] &gt;= **&#39;0&#39; **&amp;&amp; str[i] &lt;= **&#39;9&#39;**) &#123;            cur = cur * 10 + str[i++] - **&#39;0&#39;**;        &#125; **else if **(str[i] &gt;= **&#39;a&#39; **&amp;&amp; str[i] &lt;= **&#39;z&#39;**) &#123; //            ans += str[i++];        &#125; **else **&#123; // 遇到左括号了            String[] f = f(str, i + 1);            **for **(**int **j = 0; j &lt; cur; j++) &#123;                ans += f[0];            &#125;            cur = 0;            i = Integer.valueOf(f[1]);            i++;        &#125;    &#125;    **return new **String[] &#123; ans, String.valueOf(i) &#125;;&#125; |</code></pre><p>| —- |</p><h3 id="③❓原子的数量"><a href="#③❓原子的数量" class="headerlink" title="③❓原子的数量"></a>③❓原子的数量</h3><p><strong>扩展：计算括号字符串的分数</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650109458205-b1b14786-40bd-4f1c-bfa1-9a055b24847d.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=uabd6313c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=260&amp;originWidth=711&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36399&amp;status=done&amp;style=none&amp;taskId=u2890ec75-3800-40a2-aabe-f170319bf19&amp;title=&amp;width=568.8" alt="image.png"><br>记住代码，比较难理解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650110035627-385b43a8-6afc-437b-bb16-74508df9d7f8.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u52f0ac7e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=380&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=111603&amp;status=done&amp;style=none&amp;taskId=uc24e086b-659c-49f0-b945-4a1fb06b24d&amp;title=&amp;width=304" alt="image.png"></p><h2 id="·-盛最多水的容器"><a href="#·-盛最多水的容器" class="headerlink" title="· 盛最多水的容器"></a>· 盛最多水的容器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652803229358-74a054ba-5506-4cb4-888f-08fb6bd8faed.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=339&amp;id=uab3100b9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=609&amp;originWidth=926&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40053&amp;status=done&amp;style=none&amp;taskId=u5e22d377-cb6c-42c5-a11e-f25dd5bf093&amp;title=&amp;width=514.7999877929688" alt="image.png"><br><strong>题解</strong><br>先假设无重复值, 左右两个指针<br>左边跟右边比大小， 谁小结算谁的水量<br>两个左右两个指针依次划的过程中算出所有水量的最大值就是答案</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603322-564cdac1-d9b0-46b5-ae4f-e90597069858.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=ue0abe2ca&amp;margin=%5Bobject%20Object%5D&amp;originHeight=526&amp;originWidth=1044&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u56957f64-7d7b-4946-9167-ea72d58d406&amp;title=&amp;width=462" alt=""><br>而事实上3可以继续往右扩大，那我为什么不求出唯一的正确答案，<br>只求3~8这一段的答案呢，这是因为a的答案包含这一段，所以我只关注会不会有把答案推高的可能性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603354-4d6989ad-b2b5-4a05-8c69-6f7008972fd5.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=uf256ec8f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=441&amp;originWidth=1019&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uba4cb029-1101-4abf-a81a-be756f71cbe&amp;title=&amp;width=496" alt=""><br>它不是严格要求每一个数都能够准确的算出来它的答案, 它只关心有没有推高答案的可能性<br>为啥你不知道这道题怎么做?<br>但是你看数据量，你就知道自己一定会憋出一个O(N)的解，<br>那势必可能会想到双指针，谁大移动谁跟谁小移动谁都试一遍这题就出来了，不用知道为什么有可能都能猜出来<br>复杂度O(N)<br>我不去严格纠结到底这个值他真实的最优解是什么，我只纠结会不会让答案变大<br>ref： 数组三连第三连<br><strong>例子</strong><br>只关注它推高答案的可能性，但是我们不去严格纠结每一个位置的值，它具体答案是多少<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603343-312db809-99e8-414c-a228-7fc6ae108e0c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=200&amp;id=u90840346&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=928&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u82dc8d2e-0c79-4da0-9b9b-729957c3535&amp;title=&amp;width=419" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603345-91268f80-07fa-46fd-9be0-2ac568756483.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u9a46939d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2229fb65-1462-44d2-a2f2-ad111e6093d&amp;title=&amp;width=475" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603340-dff504be-50d9-4110-bde8-60d0eaa86e2f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u5153fc20&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1094&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54178eed-544a-423b-9a03-b4e0b59ea95&amp;title=&amp;width=488" alt=""></p><p>| <strong>public static int </strong>maxArea1<strong>(int[] </strong>h<strong>) {<br>   int </strong>max = 0;<br>   <strong>int </strong>N = h.<strong>length</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) { </strong>// h[i]<br>      <strong>for (int </strong>j = i + 1; j &lt; N; j++<strong>) { </strong>// h[j]<br>         max = Math.max<strong>(</strong>max, Math.min<strong>(</strong>h<strong>[</strong>i<strong>]</strong>, h<strong>[</strong>j<strong>]) *</strong> <strong>(</strong>j - i<strong>))</strong>;<br>      <strong>}<br>   }<br>   return </strong>max;<br>**}</p><p>public static int <strong>maxArea2</strong>(int[] <strong>h</strong>) {<br>   int <strong>max = 0;   </strong>int <strong>l = 0;   </strong>int <strong>r = h.</strong>length <strong>- 1;   </strong>while (<strong>l &lt; r</strong>) {<br>      <strong>max = Math.max</strong>(<strong>max, Math.min</strong>(<strong>h</strong>[<strong>l</strong>]<strong>, h</strong>[<strong>r</strong>]) <strong>* </strong>(<strong>r - l</strong>))<strong>;      </strong>if (<strong>h</strong>[<strong>l</strong>] <strong>&gt; h</strong>[<strong>r</strong>]) {<br>         <strong>r—;      </strong>} else {<br>         <strong>l++;      </strong>}<br>   }<br>   return <strong>max;</strong>}** |<br>| —- |</p><h2 id="·-多个有序list中的top-100-大"><a href="#·-多个有序list中的top-100-大" class="headerlink" title="· 多个有序list中的top 100 大"></a>· 多个有序list中的top 100 大</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882236750-67c0af3e-05fa-4bed-98b7-fcf80e36b74c.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=30&amp;id=ufd509bb4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=38&amp;originWidth=637&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7392&amp;status=done&amp;style=none&amp;taskId=uef743611-362e-49ac-b624-c0c7dc58095&amp;title=&amp;width=509.6" alt="image.png"><br>大根堆<br>先把链表逆序<br>所有头部拿出来组成一个大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882248310-fbb2aa87-caa0-422c-a083-a8713a7d4694.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=u5395c82a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=618&amp;originWidth=1291&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u437d1bae-2ae6-40d8-a1af-96d46908e56&amp;title=&amp;width=624" alt=""></p><h2 id="·-跳跃游戏Ⅱ"><a href="#·-跳跃游戏Ⅱ" class="headerlink" title="· 跳跃游戏Ⅱ"></a>· 跳跃游戏Ⅱ</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650029478423-12a50e13-5642-45ad-9e9e-04f762f5b727.png#clientId=u98aeb21b-e583-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=u7efc409b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=666&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=37693&amp;status=done&amp;style=none&amp;taskId=u765ebde4-b464-4164-bf78-e8a292676f9&amp;title=&amp;width=532.8" alt="image.png"><br><strong>题意</strong><br>存在一个选择<br>如果尽着最大步数跳他可能得不到最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305648-957d0562-d157-4d3d-ae6c-fc146f1a4502.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=u7daad865&amp;margin=%5Bobject%20Object%5D&amp;originHeight=510&amp;originWidth=1237&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3f318203-80a6-4650-85bf-4d1f226ff95&amp;title=&amp;width=609" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305602-7f9f8032-223f-476c-b74f-d76bef9d32ac.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=210&amp;id=u21788ad8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1216&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufb841da7-04af-4c5b-907e-0212ae690a1&amp;title=&amp;width=524" alt=""><br>用贪心, 老紧着最大步数跳是不对的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305681-d01ab949-c241-4243-bac5-4c66c124efae.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=uc2a1cfe5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1252&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u926d9fc0-6e2a-4122-a843-128c9c2436c&amp;title=&amp;width=521" alt=""><br><strong>题解</strong><br>流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655211162287-fd0710b0-b985-4a90-bfed-0abe223715f1.png#clientId=u83bd60c9-5fa5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=812&amp;id=u6a026509&amp;margin=%5Bobject%20Object%5D&amp;name=41D4CCD93F04922A9F2D17AA467437A5.png&amp;originHeight=1421&amp;originWidth=1232&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=417915&amp;status=done&amp;style=none&amp;taskId=u26adf01b-d2c7-4f51-8d3d-1813a4c2bf8&amp;title=&amp;width=704" alt="41D4CCD93F04922A9F2D17AA467437A5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882306957-1850e9b7-de8b-4a4a-adea-eb2cfffcc9eb.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=ufbe8fdc9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=579&amp;originWidth=1043&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc564cc66-4380-40a6-a766-66d63c6b832&amp;title=&amp;width=509" alt=""><br>反例<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307533-6f1f96c5-ad80-4f9e-9ab2-54da1412c258.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=uc54b612f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=1132&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3debd364-ff69-4b03-b637-3746408f53d&amp;title=&amp;width=507" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307672-7a9a40e1-5757-4e56-8392-55c6b983411e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u9fe696a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=434&amp;originWidth=797&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u381a4f25-cc9a-4da0-94f2-80b9ae28f16&amp;title=&amp;width=428" alt=""><br><strong>代码</strong></p><p>| <strong>public static int </strong>jump<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>step = 0;//目前位置跳了几步<br>   <strong>int </strong>cur = 0;//如果你不增加步数，step以内，你最远能到哪儿<br>   <strong>int </strong>next = 0;//如果允许我多跳一步，请问我最远的到哪儿<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882687455-34de4ef7-d45e-4515-8847-2cdd7261f16a.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=141&amp;id=u998e7fdc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=219&amp;originWidth=456&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15857&amp;status=done&amp;style=none&amp;taskId=uf377eb45-a694-43de-80a6-f4277e28737&amp;title=&amp;width=292.8000183105469" alt="image.png"><strong>**      if (</strong>cur &lt; i<strong>) {         </strong>step++;<br>         cur = next;<br>      <strong>}      </strong>next = Math.max<strong>(</strong>next, i + arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   return </strong>step;<br><strong>}</strong> |<br>| —- |</p><h2 id="·✊在两个都有序的数组找整体第k小的数"><a href="#·✊在两个都有序的数组找整体第k小的数" class="headerlink" title="·✊在两个都有序的数组找整体第k小的数"></a><strong>·✊在两个都有序的数组找整体第k小的数</strong></h2><h3 id="①算法模型：在两个都有序的数组中找上中位数"><a href="#①算法模型：在两个都有序的数组中找上中位数" class="headerlink" title="①算法模型：在两个都有序的数组中找上中位数"></a>①算法模型：在两个都有序的数组中找上中位数</h3><p><strong>题意</strong><br>O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884443226-1de0ecb3-1471-4e81-899c-0e32b5ca4a66.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ub50901c6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=567&amp;originWidth=891&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua642aa49-06f2-439b-a489-64f4f71a01d&amp;title=&amp;width=426" alt=""><br><strong>题解</strong><br>分情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655299291411-6ecd16bb-340f-4d93-9539-e4bb4a986a8a.png#clientId=u02685321-15d8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1841&amp;id=uf949730e&amp;margin=%5Bobject%20Object%5D&amp;name=7A99CC63E8320AA8102F6ACA846A0A14.png&amp;originHeight=3222&amp;originWidth=1849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1850552&amp;status=done&amp;style=none&amp;taskId=ucde9adac-f3e4-459e-a56d-0b19154fa4c&amp;title=&amp;width=1056.5714285714287" alt="7A99CC63E8320AA8102F6ACA846A0A14.png"><br><strong>代码</strong></p><p>| <strong>public static int </strong>getUpMedian<strong>(int[] </strong>A, <strong>int </strong>s1, <strong>int </strong>e1, <strong>int[] </strong>B, <strong>int </strong>s2, <strong>int </strong>e2<strong>) {<br>   int </strong>mid1 = 0;<br>   <strong>int </strong>mid2 = 0;<br>   <strong>while (</strong>s1 &lt; e1<strong>) {      </strong>// mid1 = s1 + (e1 - s1) &gt;&gt; 1<br>      mid1 = <strong>(</strong>s1 + e1<strong>) </strong>/ 2;<br>      mid2 = <strong>(</strong>s2 + e2<strong>) </strong>/ 2;<br>      <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>== B<strong>[</strong>mid2<strong>]) {<br>         return </strong>A<strong>[</strong>mid1<strong>]</strong>;<br>      <strong>}      </strong>// 两个中点一定不等！<br>      //e1 - s1 + 1就是个数 奇数&amp;1 == 1<br>      <strong>if (((</strong>e1 - s1 + 1<strong>) </strong>&amp; 1<strong>) </strong>== 1<strong>) { </strong>// 奇数长度<br>         //一定要对着例子<br>         <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt; B<strong>[</strong>mid2<strong>]) {<br>            if (</strong>B<strong>[</strong>mid2<strong>] </strong>&gt;= A<strong>[</strong>mid1 - 1<strong>]) {<br>               return </strong>B<strong>[</strong>mid2<strong>]</strong>;<br>            <strong>}            </strong>e1 = mid1 - 1;<br>            s2 = mid2 + 1;<br>         <strong>} else { </strong>// A[mid1] &lt; B[mid2]<br>            <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt;= B<strong>[</strong>mid2 - 1<strong>]) {<br>               return </strong>A<strong>[</strong>mid1<strong>]</strong>;<br>            <strong>}            </strong>e2 = mid2 - 1;<br>            s1 = mid1 + 1;<br>         <strong>}<br>      } else { </strong>// 偶数长度<br>         <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt; B<strong>[</strong>mid2<strong>]) {            </strong>e1 = mid1;<br>            s2 = mid2 + 1;<br>         <strong>} else {            </strong>e2 = mid2;<br>            s1 = mid1 + 1;<br>         <strong>}<br>      }<br>   }<br>   return </strong>Math.min<strong>(</strong>A<strong>[</strong>s1<strong>]</strong>, B<strong>[</strong>s2<strong>])</strong>;<br><strong>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>每一次比价砍一半, 二分, O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884449524-c998a42f-d576-4006-9cf1-9c30739af9d7.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=342&amp;id=Dep6S&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=945&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25c8aeb9-2c09-4667-9058-e9474a70a88&amp;title=&amp;width=517" alt=""></p><h3 id="②进阶：在两个都有序的数组找整体第k小的数"><a href="#②进阶：在两个都有序的数组找整体第k小的数" class="headerlink" title="②进阶：在两个都有序的数组找整体第k小的数"></a><strong>②进阶：在两个都有序的数组找整体第k小的数</strong></h3><p><strong>例子：arr1 17个 arr2 10个</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655300515983-61e193b4-7e6a-4b2e-8067-4cd547c49684.png#clientId=u02685321-15d8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1109&amp;id=uc06c0ab8&amp;margin=%5Bobject%20Object%5D&amp;name=ACE1391B1036C5CD896CD36C7A4E1AF8.png&amp;originHeight=1941&amp;originWidth=2212&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1248551&amp;status=done&amp;style=none&amp;taskId=u7e89ae7d-1de4-45b4-a7ae-d3b2e6a1f95&amp;title=&amp;width=1264" alt="ACE1391B1036C5CD896CD36C7A4E1AF8.png"></p><p>| // 进阶问题 : 在两个都有序的数组中，找整体第K小的数<br>// 可以做到O(log(Min(M,N)))<br><strong>public static int </strong>findKthNum<strong>(int[] </strong>arr1, <strong>int[] </strong>arr2, <strong>int </strong>kth<strong>) {<br>   int[] </strong>longs = arr1.<strong>length </strong>&gt;= arr2.<strong>length </strong>? arr1 : arr2;<br>   <strong>int[] </strong>shorts = arr1.<strong>length </strong>&lt; arr2.<strong>length </strong>? arr1 : arr2;<br>   <strong>int </strong>l = longs.<strong>length</strong>;<br>   <strong>int </strong>s = shorts.<strong>length</strong>;<br>   <strong>if (</strong>kth &lt;= s<strong>) { </strong>// 1)<br>      <strong>return </strong>getUpMedian<strong>(</strong>shorts, 0, kth - 1, longs, 0, kth - 1<strong>)</strong>;<br>   <strong>}<br>   if (</strong>kth &gt; l<strong>) { </strong>// 3)  对着例子【例子太重要了，具象化的代码改为抽象化就可以了】看代码就懂了  贴图过来非常简单！<br>      <strong>if (</strong>shorts<strong>[</strong>kth - l - 1<strong>] </strong>&gt;= longs<strong>[</strong>l - 1<strong>]) {<br>         return </strong>shorts<strong>[</strong>kth - l - 1<strong>]</strong>;<br>      <strong>}<br>      if (</strong>longs<strong>[</strong>kth - s - 1<strong>] </strong>&gt;= shorts<strong>[</strong>s - 1<strong>]) {<br>         return </strong>longs<strong>[</strong>kth - s - 1<strong>]</strong>;<br>      <strong>}<br>      return </strong>getUpMedian<strong>(</strong>shorts, kth - l, s - 1, longs, kth - s, l - 1<strong>)</strong>;<br>   <strong>}</strong><br><strong>**   </strong>// 2)  s &lt; k &lt;= l<br>   <strong>if (</strong>longs<strong>[</strong>kth - s - 1<strong>] </strong>&gt;= shorts<strong>[</strong>s - 1<strong>]) {<br>      return </strong>longs<strong>[</strong>kth - s - 1<strong>]</strong>;<br>   <strong>}<br>   return </strong>getUpMedian<strong>(</strong>shorts, 0, s - 1, longs, kth - s, kth - 1<strong>)</strong>;<br><strong>}</strong> |<br>| —- |</p><h3 id="·-394-字符串解码-M"><a href="#·-394-字符串解码-M" class="headerlink" title="· 394. 字符串解码 [M]"></a>· 394. 字符串解码 [M]</h3><p><strong>题意</strong><br>字符串还原成全是小写字母<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500821-75a18c69-29c4-4b24-b7e5-887be3cb6749.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=ucd62da43&amp;margin=%5Bobject%20Object%5D&amp;originHeight=596&amp;originWidth=1175&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u468d9297-5ca7-472c-88dc-6d62e3ef096&amp;title=&amp;width=488" alt=""><br>原始串只有a~z<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500842-3195e513-118a-4630-af49-7b8ed4406f4d.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=uf17c79f4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u987e1af2-77b6-46ca-b800-4512ab05154&amp;title=&amp;width=364" alt=""><br><strong>题解</strong><br>定义递归函数:</p><ol><li>返回结果字符串</li><li>处理到的位置</li></ol><p>从压缩串str i位置往后转换, 遇到]或者压缩串结尾停止, 停的时候, 从i…停这段返回, 并返回计算到的位置</p><p>所有的嵌套结构可以用这个递归结构求解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500729-ad1aeada-e94d-4f7f-9263-31b5031971c8.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=ua4899735&amp;margin=%5Bobject%20Object%5D&amp;originHeight=660&amp;originWidth=1306&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4a9acdf8-1639-498c-b25c-8532d5b9013&amp;title=&amp;width=451" alt=""><br>比如表达式计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500774-5f55cb4a-375e-4628-8a25-c5886f9b8ecf.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=ub4b51deb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1050&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6130fe28-6f0f-4e73-8f26-03514873989&amp;title=&amp;width=505" alt=""><br>例子<br>一个字符串的总结果， ans<br>一个收集数字的 cur</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500812-577e8e62-310b-441d-b5fc-70f6264da78d.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ueb3f028b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=1249&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2e762acf-74d3-4f32-a96c-9b00be09246&amp;title=&amp;width=643" alt=""><br>2位置遇到左括号, 调子过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504551-ef54c717-a12c-4ef7-a8e6-1dea07860e9f.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u174ad8d4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=1290&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubb7240e5-7fd4-4f17-9d0c-dc13026baee&amp;title=&amp;width=530" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504525-6706a8a2-0c1d-4b36-941c-b9c59ded0d45.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u689b0aea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=668&amp;originWidth=1371&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7f4f3313-621b-4ad6-a317-6341b366355&amp;title=&amp;width=513" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504536-785698a9-0b58-4ea5-bb85-e5870cbed403.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u107f1f9b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=665&amp;originWidth=1262&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8359b1d3-cd55-4872-a3b1-24b10aa2d4d&amp;title=&amp;width=468" alt=""><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504635-339d1550-5bd7-4f34-8eca-7de606f92831.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3a36b325&amp;margin=%5Bobject%20Object%5D&amp;originHeight=795&amp;originWidth=747&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5993c173-de94-4eac-806d-e4d0ee9a8b5&amp;title=" alt=""></p><p>| <strong>public static </strong>String decodeString<strong>(</strong>String s<strong>) {<br>   char[] </strong>str = s.toCharArray<strong>()</strong>;<br>   <strong>return </strong>process<strong>(</strong>str, 0<strong>)</strong>.<strong>ans</strong>;<br>**}</p><p>public static class <strong>Info </strong>{<br>   public <strong>String </strong>ans<strong>;   </strong>public int stop**;</p><p>   <strong>public </strong>Info<strong>(</strong>String a, <strong>int </strong>e<strong>) {<br>      ans </strong>= a;<br>      <strong>stop </strong>= e;<br>   **}<br>}</p><p><strong>// s[i….]  何时停？遇到   ‘]’  或者遇到 s的终止位置，停止<br>// 返回Info<br>// 0) 串<br>// 1) 算到了哪</strong>public static <strong>Info process</strong>(char[] <strong>s, </strong>int <strong>i</strong>) {<br>   <strong>StringBuilder ans = </strong>new <strong>StringBuilder</strong>()<strong>;   </strong>int <strong>count = 0;   </strong>while (<strong>i &lt; s.</strong>length <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>!= </strong>‘]’) {<br>      if ((<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘a’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘z’) <strong>&#124;&#124; </strong>(<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘A’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘Z’)) {<br>         <strong>ans.append</strong>(<strong>s</strong>[<strong>i++</strong>])<strong>;      </strong>} else if (<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘0’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘9’) {<br>         <strong>count = count * 10 + s</strong>[<strong>i++</strong>] <strong>- </strong>‘0’<strong>;      </strong>} else { <strong>// str[index] = ‘[‘<br>         Info next = process</strong>(<strong>s, i + 1</strong>)<strong>;<br>         ans.append</strong>(<strong>timesString</strong>(<strong>count, next.</strong>ans))<strong>;<br>         //<br>         count = 0;<br>         i = next.</strong>stop <strong>+ 1;      </strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>ans.toString</strong>()<strong>, i</strong>)<strong>;</strong>}</p><p>public static <strong>String timesString</strong>(int <strong>times, String str</strong>) {<br>   <strong>StringBuilder ans = </strong>new <strong>StringBuilder</strong>()<strong>;   </strong>for (int <strong>i = 0; i &lt; times; i++</strong>) {<br>      <strong>ans.append</strong>(<strong>str</strong>)<strong>;   </strong>}<br>   return <strong>ans.toString</strong>()<strong>;</strong>}** |<br>| —- |</p><h2 id="·-最长连续序列"><a href="#·-最长连续序列" class="headerlink" title="· 最长连续序列"></a>· 最长连续序列</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650027587467-9c71453c-132e-4e65-92ea-5e95c4838e80.png#clientId=u98aeb21b-e583-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=341&amp;id=uc6150b29&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=833&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35602&amp;status=done&amp;style=none&amp;taskId=u165c0c4b-a7e3-4fba-bdad-65d2fc46eed&amp;title=&amp;width=666.4" alt="image.png"><br><strong>题解</strong><br>连续区间头表+连续区间尾表<br>100来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450085-90058467-9331-4e7f-afc9-abfc89b72c9e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u25beeefc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=397&amp;originWidth=1139&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e7bb74f-ea0e-4c9a-93a4-d29beffe1e0&amp;title=&amp;width=530" alt=""><br>3来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450084-3d961eca-d28d-4f43-b7fe-e707f3e47a19.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=uac2eb7d7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=461&amp;originWidth=1141&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u17d37d9c-915a-46fd-ab24-ef6eb833409&amp;title=&amp;width=498" alt=""><br>4来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450169-15fadec0-cbd9-4797-82c9-51f4aa1f8295.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u4eee0f77&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=1108&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9de3535e-8e32-4ff8-bc47-4d00a37927c&amp;title=&amp;width=480" alt=""><br>合并<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450083-6829ff9b-d260-46f0-b4f6-170148bd867e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ud0fd55ea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=1136&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1511e11d-3175-4713-8409-9f9a8863080&amp;title=&amp;width=457" alt=""><br>6来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450067-4a7f66f8-a015-411b-a4cc-095f219446d4.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u00347243&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90b8fbaa-d0f1-43c4-8845-9a8afae0a7f&amp;title=&amp;width=480" alt=""><br>7来了<br>5<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450782-178be574-6064-458a-9275-a8f116757def.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=230&amp;id=u9c05a450&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u85da3f43-5abc-4192-bdfc-dccfad0d0ca&amp;title=&amp;width=472" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450958-39fc9099-3c15-44d8-bc54-5f2a4a86304a.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=uaca38d01&amp;margin=%5Bobject%20Object%5D&amp;originHeight=567&amp;originWidth=1110&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udcfcab17-b0c7-49d5-b493-4931f6a3233&amp;title=&amp;width=448" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450977-0bb7308a-fa05-40a5-9dcf-9540516264b5.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=uedf3ad85&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=1091&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u863f4790-bc00-4d11-b7ac-4d41a2ecfc5&amp;title=&amp;width=428" alt=""><br>总结<br>每个数来的时候都自己建出自己的区间，看看跟之前都不能合，看看后面能不能合,<br>你每次都严严格格的合完之后，你问我最后有多长的连续区间，你随便找一张表，把value最大值拿出来<br>每一个数来到的时候, 对于哈希表的操作都是O(1)<br><strong>代码</strong><br>难点在于它怎么只用一张哈表搞出来。</p><p>| <strong>public static int </strong>longestConsecutive<strong>(int[] </strong>nums<strong>) {   </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>len = 0;<br>   <strong>for (int </strong>num : nums<strong>) {<br>      if (</strong>!map.containsKey<strong>(</strong>num<strong>)) {         </strong>map.put<strong>(</strong>num, 1<strong>)</strong>;<br>         <strong>int </strong>preLen = map.containsKey<strong>(</strong>num - 1<strong>) </strong>? map.get<strong>(</strong>num - 1<strong>) </strong>: 0;<br>         <strong>int </strong>posLen = map.containsKey<strong>(</strong>num + 1<strong>) </strong>? map.get<strong>(</strong>num + 1<strong>) </strong>: 0;<br>         <strong>int </strong>all = preLen + posLen + 1;<br>         map.put<strong>(</strong>num - preLen, all<strong>)</strong>;<br>         map.put<strong>(</strong>num + posLen, all<strong>)</strong>;<br>         len = Math.max<strong>(</strong>len, all<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>len;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-超级洗衣机（硬记）"><a href="#·-超级洗衣机（硬记）" class="headerlink" title="· 超级洗衣机（硬记）"></a><strong>· 超级洗衣机（硬记）</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932367995-bbe4de73-2904-4594-916c-9533bbc0f67e.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=332&amp;id=uea6a2d41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=415&amp;originWidth=835&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39680&amp;status=done&amp;style=none&amp;taskId=u8f0f91ee-9a43-4785-a206-f20939def19&amp;title=&amp;width=668" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403145-b876e20d-8562-4eff-b4f8-d442cf06b0f4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=u3a840e1e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=554&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0ffadcba-008c-4d96-b91e-d0ebf518fa5&amp;title=&amp;width=482" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403138-c0c32760-5291-473e-8c7b-ed2d0d17ab3d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=193&amp;id=u2bc83435&amp;margin=%5Bobject%20Object%5D&amp;originHeight=569&amp;originWidth=1275&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udf474620-5c39-4ccf-9947-d5377322ff9&amp;title=&amp;width=432" alt=""><br><strong>题解</strong><br>大过滤器<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403158-39eaeb21-beea-423a-9a81-ab1b3e4f0c8a.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u5dbce6c0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=889&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b72d3a9-8d80-444f-a2a7-71510f9fd37&amp;title=&amp;width=381" alt=""><br>思想传统: 算单点的瓶颈, 最后看总答案跟单点瓶颈之间的关系</p><p>假设来到某一台(i号)洗衣机, 衣服数量?<br>假设每台机器该有的平均数我们知道<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403159-bc4570ef-622d-4f66-b7b2-806dd142a67c.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=uaf6e2a70&amp;margin=%5Bobject%20Object%5D&amp;originHeight=526&amp;originWidth=1229&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc26ff0ff-3a4e-4e24-ae5a-aa0f7723c5f&amp;title=&amp;width=589" alt=""><br><strong>第一种情况</strong><br>左右两侧有一个为正数有一个为负数<br>左侧整体欠15件。而它右侧整体多10件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403191-6e7e37d7-0bf5-4987-a6ce-5be5b43a0741.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=u95da6da5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=622&amp;originWidth=837&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u070d6067-1b7d-42c5-b8ff-3bc599784ca&amp;title=&amp;width=386" alt=""><br>左侧整体欠15件。而它右侧整体多20件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932412835-bcbf1abd-1049-4490-a288-38569f24b131.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u491fbc95&amp;margin=%5Bobject%20Object%5D&amp;originHeight=604&amp;originWidth=899&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua656072e-d9c0-41e4-8e4c-954b2598c76&amp;title=&amp;width=402" alt=""><br><strong>总结</strong><br>左右两侧有一个为正数有一个为负数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932414115-732d2fca-785a-4f8e-a095-b8ca0fbe23b4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=ucc357489&amp;margin=%5Bobject%20Object%5D&amp;originHeight=546&amp;originWidth=1002&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5290c3aa-c695-47a0-9411-e0238a73417&amp;title=&amp;width=394" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932417841-5e9e3984-a2c9-4e68-9694-6b85c58bafd0.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u6fe2d0e8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=556&amp;originWidth=971&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ac861c9-058d-4e4e-8e96-d5996a3c43d&amp;title=&amp;width=365" alt=""><br><strong>第二种情况</strong><br>左右两侧都为正数<br>i如果衣服特别少就可能左右两侧都要给它衣服<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932420558-7c95096e-d93b-4f93-b6f3-4eb0b7ca8c5c.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=220&amp;id=ud8e9e4fd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=638&amp;originWidth=857&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6165a81f-c605-4f9c-a6aa-8fe99ad651f&amp;title=&amp;width=296" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421080-d8bf23ca-28a5-4431-aa0e-425b360ae4bd.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u2fc15dd2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=561&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u720e32f9-1f9c-4cd3-bec7-e5cff31ee20&amp;title=&amp;width=394" alt=""><br><strong>最后一种情况</strong><br>左右两侧都为负数<br>如果左侧欠15件。右侧欠7件，我问你是要搬多少轮, 两侧都指望着i出力, 它一次只能扔一件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421484-2e38c5da-e2b5-44fc-b02a-0f6932eb9510.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=udc41672d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=601&amp;originWidth=745&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6afbd492-5e3d-4243-ae8d-d15ddd0797d&amp;title=&amp;width=408" alt=""><br>先算一个总衣服的数量，你再算一个左侧部分的累加和, i位置自己有值。<br>左侧部分欠几件还多几件, 右侧部分欠几件还是多几件。都能算出来<br>有一个衣服的总数量，有一个i左侧的累加和, 接下来你到任何一个i位置。<br>你左侧, 右侧到底是多还是少？你都能算出来</p><p>根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,<br>2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。<br>因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了<br>因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421558-5fddfdda-a71d-4671-aece-dc0b34e07408.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u75e1afcf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u550aae88-3e80-416e-bdc1-1f855da6fc1&amp;title=&amp;width=445" alt=""><br><strong>单点思维传统</strong><br>接雨水的问题, 左侧最大值最小值问题，这些东西都是以单点算出来一个答案，然后去决策等。<br>洗衣机问题它属于我把整个问题，我不去想它整体我就想它单点的答案是啥，你给我整出一个答案，<br>然后我去决策出来什么东西，以后单点去求然后再得到整体答案的办法，将会成为我们的一个思想传统。<br>类似子串子数组问题, 每个位置结尾时候啥答案。其实这也是<strong>单点思维。</strong><br><strong>代码</strong></p><p>| <strong>public static int </strong>findMinMoves<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>size = arr.<strong>length</strong>;<br>   <strong>int </strong>sum = 0;<br>   <strong>for (int </strong>i = 0; i &lt; size; i++<strong>) {      </strong>sum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   if (</strong>sum % size != 0<strong>) {<br>      return </strong>-1;<br>   <strong>}<br>   int </strong>avg = sum / size;<br>   //左侧部分累加和<br>   <strong>int </strong>leftSum = 0;<br>   <strong>int </strong>ans = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>//左侧部分剩余<br>      <strong>int </strong>leftRest = leftSum - i <em> avg;<br>      //右侧部分剩余<br>      <strong>int </strong>rightRest = <strong>(</strong>sum - leftSum - arr<strong>[</strong>i<strong>]) </strong>- <strong>(</strong>size - i - 1<strong>) </strong></em> avg;<br>      <strong>if (</strong>leftRest &lt; 0 &amp;&amp; rightRest &lt; 0<strong>) {         </strong>ans = Math.max<strong>(</strong>ans, Math.abs<strong>(</strong>leftRest<strong>) </strong>+ Math.abs<strong>(</strong>rightRest<strong>))</strong>;<br>      <strong>} else {         </strong>ans = Math.max<strong>(</strong>ans, Math.max<strong>(</strong>Math.abs<strong>(</strong>leftRest<strong>)</strong>, Math.abs<strong>(</strong>rightRest<strong>)))</strong>;<br>      <strong>}      </strong>leftSum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   return </strong>ans;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-缺失的第一个正数"><a href="#·-缺失的第一个正数" class="headerlink" title="· 缺失的第一个正数"></a><strong>· 缺失的第一个正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922711623-5f275d70-6ad9-4a85-b908-b754c4c08188.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=377&amp;id=u10e943fc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=471&amp;originWidth=671&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31833&amp;status=done&amp;style=none&amp;taskId=u01469d94-35f3-4ad3-8669-3edd28f7319&amp;title=&amp;width=536.8" alt="image.png"><br>核心就是<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922917933-411751da-967b-4a5a-bba8-08ca6afba789.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u1d4d9e20&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=629&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=81409&amp;status=done&amp;style=none&amp;taskId=uea4d21e0-d3fc-4dc9-be76-12aa8351e2e&amp;title=&amp;width=503.2" alt="image.png"><br>分为有效区和垃圾区<br>核心</p><ul><li>如果L位置上的数 &lt;=L跟垃圾区交换</li><li><blockquote><p>R位置的数 跟垃圾区交换</p></blockquote></li><li>等于 arr[arr[L]-1]的数也交换<br>| <strong>public static int </strong>firstMissingPositive<strong>(int[] </strong>arr<strong>) { </strong>// l是盯着的位置<br> // 0 ~ L-1有效区<br> <strong>int </strong>L = 0;<br> <strong>int </strong>R = arr.<strong>length</strong>;<br> <strong>while (</strong>L != R**) {<pre><code>**//有效区向右扩**if (**arr**[**L**] **== L + 1**) &#123;   **L++;**&#125; else if (**arr**[**L**] **&lt;= L &amp;#124;&amp;#124; arr**[**L**] **&gt; R &amp;#124;&amp;#124; arr**[**arr**[**L**] **- 1**] **== arr**[**L**]) &#123; **// 垃圾的情况   swap**(**arr, L, --R**)**;**&#125; else &#123;   **swap**(**arr, L, arr**[**L**] **- 1**)**;**&#125;</code></pre> }<br> return <strong>L + 1;</strong>}</li></ul><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-数组的自己不能累加和出的最小正数"><a href="#·-数组的自己不能累加和出的最小正数" class="headerlink" title="· 数组的自己不能累加和出的最小正数"></a><strong>· 数组的自己不能累加和出的最小正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649908121718-8953c38b-c4f7-47ac-ae29-35e9ffd72e37.png#clientId=u66160ce2-b06d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=99&amp;id=u1ea6fc03&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=124&amp;originWidth=366&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12897&amp;status=done&amp;style=none&amp;taskId=u8559eaa1-8292-41bd-a5cc-ca091503438&amp;title=&amp;width=292.8" alt="image.png"><br><strong>第一问</strong><br>同上问<br>arr所有值的累加和从一个负数到一个整数做出一张表, 然后看最后一行<br>arr 0~N-1宿友的值能不能搞定1, 2, 3…, 哪一个最早不行的, 返回就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274512-42b3c5d7-4c34-41d1-90af-b01987c4bcf7.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=ub0253dce&amp;margin=%5Bobject%20Object%5D&amp;originHeight=664&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c3059f8-c8ca-4e0e-8def-f24e2bb3715&amp;title=&amp;width=434" alt=""></p><p>| <strong>public static int </strong>unformedSum2<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>1;<br>   <strong>}<br>   int </strong>sum = 0;<br>   <strong>int </strong>min = Integer.<strong>MAX_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {      </strong>sum += arr<strong>[</strong>i<strong>]</strong>;<br>      min = Math.min<strong>(</strong>min, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}   </strong>// boolean[][] dp …<br>   <strong>int </strong>N = arr.<strong>length</strong>;<br>   <strong>boolean[][] </strong>dp = <strong>new boolean[</strong>N<strong>][</strong>sum + 1<strong>]</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {</strong>// arr[0..i] 0<br>      dp<strong>[</strong>i<strong>][</strong>0<strong>] </strong>= <strong>true</strong>;<br>   <strong>}   </strong>dp<strong>[</strong>0<strong>][</strong>arr<strong>[</strong>0<strong>]] </strong>= <strong>true</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; N; i++<strong>) {<br>      for (int </strong>j = 1; j &lt;= sum; j++<strong>) {         </strong>dp<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= dp<strong>[</strong>i - 1<strong>][</strong>j<strong>] </strong>&#124;&#124; <strong>((</strong>j - arr<strong>[</strong>i<strong>] </strong>&gt;= 0<strong>) </strong>? dp<strong>[</strong>i - 1<strong>][</strong>j - arr<strong>[</strong>i<strong>]] </strong>: <strong>false)</strong>;<br>      <strong>}<br>   }<br>   for (int </strong>j = min; j &lt;= sum; j++<strong>) {<br>      if (</strong>!dp<strong>[</strong>N - 1<strong>][</strong>j<strong>]) {<br>         return </strong>j;<br>      <strong>}<br>   }<br>   return </strong>sum + 1;<br><strong>}</strong> |<br>| —- |</p><p><strong>第二问</strong><br>先把array排序, 正数数组排完序, 左边0位置肯定是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274407-d5bb7112-75b6-4c1a-8c5a-636c29d2da74.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=u7c7998e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=598&amp;originWidth=914&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6d443944-221f-4578-af40-df6b9538517&amp;title=&amp;width=428" alt=""><br>定义变量range =1, 表示从1~1范围上的正数都能累加出来<br>range=k, 代表1~k上的所有正数都能搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-064d2ceb-c903-444a-8b3b-def179bd1054.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=udb091615&amp;margin=%5Bobject%20Object%5D&amp;originHeight=627&amp;originWidth=1208&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u87640a35-779d-455c-92d7-3d66170c5b2&amp;title=&amp;width=451" alt=""><br>当arr 0位置是1的情况下, range=1, 代表1~1范围的正数都可以搞出来<br>如果1位置也是1, range变成2, 代表1~2范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-3a9c1b06-df19-4cbf-a1a0-8890c1df2d33.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=u4a638e7d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1197&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uacb8b2ee-8e40-476b-b0e6-d3dd0902597&amp;title=&amp;width=546" alt=""><br>如果2位置也是2, range变成4, 代表1~4范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274433-c44f8de2-ab64-4735-a4ae-0d303eaeb2be.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=u36d33f1c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=629&amp;originWidth=1218&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75c49504-7235-4203-9e18-e0efd1c066a&amp;title=&amp;width=500" alt=""><br>如果0~i-1是0~100, range=100<br>i位置17, 可以让range扩充到117</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276639-76ea18e4-1553-4416-b729-602f169e4256.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=ud24b4420&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=1188&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf800b3ae-b828-40f4-9f35-e53b5b30e59&amp;title=&amp;width=540" alt=""><br>注意一点<br>如果0~i-1能搞定的数是1~100, 此时i位置是102, 那么101不可以搞定<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276627-25522d30-aa31-47f1-a2c0-70754b005b35.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=ub8d18f54&amp;margin=%5Bobject%20Object%5D&amp;originHeight=641&amp;originWidth=946&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c78c50f-b4c4-4174-aeb2-65532acedc1&amp;title=&amp;width=484" alt=""><br><strong>抽象化</strong><br>如果0~i-1搞定1~a, 如果i位置上是b:<br>1)如果b&lt;= a+1, 能扩充, 范围到1~a+b<br>2)如果b&gt; a+1, a+1就是搞定不了的最小正整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276617-5b986e34-cf33-4d56-a953-8b54313b7cb9.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=309&amp;id=u561892aa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=661&amp;originWidth=1101&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8618d200-7b25-4c41-89a5-14bb0c7e026&amp;title=&amp;width=515" alt=""><br><strong>代码</strong></p><p>| <strong>// 已知arr中肯定有1这个数</strong>public static int <strong>unformedSum3</strong>(int[] <strong>arr</strong>) {<br>   if (<strong>arr == </strong>null <strong>&#124;&#124; arr.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   <strong>Arrays.sort</strong>(<strong>arr</strong>)<strong>; // O (N * logN)   </strong>int <strong>range = 1;<br>   // arr[0] == 1   </strong>for (int <strong>i = 1; i != arr.</strong>length<strong>; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; range + 1</strong>) {<br>         return <strong>range + 1;      </strong>} else {<br>         <strong>range += arr</strong>[<strong>i</strong>]<strong>;      </strong>}<br>   }<br>   return <strong>range + 1;</strong>}** |<br>| —- |</p><p>原题<br>arr是正数, 要求子集不能是空集, 最小子集累加和到最大子集累加和的范围中哪个数是最小不可组成的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927277249-0071ad5e-e13b-4370-bfe9-c4e82ef62414.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=u10a4ace4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=644&amp;originWidth=1230&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6504140f-42f0-4cdd-ab09-4e8752f37b5&amp;title=&amp;width=385" alt=""></p><h2 id="·-按要求补齐数组"><a href="#·-按要求补齐数组" class="headerlink" title="· 按要求补齐数组"></a>· 按要求补齐数组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649917704725-47286ee2-4581-440e-87d2-40217bdc6892.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=401&amp;id=uafa838b3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=501&amp;originWidth=821&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36432&amp;status=done&amp;style=none&amp;taskId=u650b2498-cf20-4fe1-bdde-0a59049f6aa&amp;title=&amp;width=656.8" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555620-061a554b-82b5-41e0-9e92-a690ce40510d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=ud98747b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=559&amp;originWidth=1248&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc3bcf646-19ce-4700-8f4a-bd401665f44&amp;title=&amp;width=389" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555641-e30d7e5e-1c75-4f52-a033-af5aee074d54.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u7ba03d88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=1240&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4a3bc28c-d3a2-4b58-ba9a-de9d7ca6744&amp;title=&amp;width=477" alt=""><br>到达数字+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555680-c1d3ccf6-3771-4e93-96b8-39c885a5a4bf.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=211&amp;id=ub2e23613&amp;margin=%5Bobject%20Object%5D&amp;originHeight=639&amp;originWidth=1262&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc2cbb657-a0c0-4d31-afee-d802e35c8fe&amp;title=&amp;width=417" alt=""><br><strong>题解</strong><br>先把数组排序<br>数组中每个数最经济的使用<br>只能是 1~3 范围，你先都搞定之后，你舒舒服服，使用这个4，就能扩到1~7了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555600-28054282-00a3-4ada-b588-8c83daa1343d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=165&amp;id=u36009711&amp;margin=%5Bobject%20Object%5D&amp;originHeight=414&amp;originWidth=1355&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c1ace8f-dc3d-4e30-aa37-c80e0af525c&amp;title=&amp;width=540" alt=""><br>给自己提了小目标，这个小目标是搞定1~3 范围上，你缺几个数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555576-2c52f0c4-a3ee-4fe0-99fd-d5ad4194db98.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=u2bb70482&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=1326&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u30cd7616-6530-4109-9843-187a632bcd8&amp;title=&amp;width=539" alt=""><br>对于5, 小目标1~4范围上都可以搞定, 已经满足了<br>可以直接使用这个5，让它变成12，不用添任何数字</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559417-d4b87abf-d387-42d2-8d80-4a0a8ec4f0c4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u32d93753&amp;margin=%5Bobject%20Object%5D&amp;originHeight=584&amp;originWidth=1317&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u127e139e-6b60-4227-ad19-1e323514d0d&amp;title=&amp;width=521" alt=""><br>想使用17, 要求目标1~16必须具备<br>目前有1~12, 缺13, 补13之后范围扩到1~25<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559808-215561a1-ff63-415f-bf78-fad7b73a64ba.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=uea5b1f49&amp;margin=%5Bobject%20Object%5D&amp;originHeight=611&amp;originWidth=1322&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2cc09c61-ee32-4302-b314-4ba0be0fea5&amp;title=&amp;width=507" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927560402-d3d539ae-2061-402e-8409-47fe164264a2.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=227&amp;id=u09c809c8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=618&amp;originWidth=1338&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7877baab-db60-4c74-96b5-33a014c76fd&amp;title=&amp;width=491" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561057-82a9fd44-9823-4f41-858c-acdcdc07147b.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u1757f08b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=660&amp;originWidth=1340&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucad0fd2b-6999-4754-89cb-2a2fdc5f0e0&amp;title=&amp;width=468" alt=""><br><strong>例子</strong><br>如果n特别大, 整个数组都使用完以后范围是1~3050, 先补3051<br>整个数组都使完之后，如果你还没到，接下来的过程就等同于给了你一个范围，你一个数也没有了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561285-f47b7093-d077-49ef-9d8a-40af2438e4b0.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=u48355d80&amp;margin=%5Bobject%20Object%5D&amp;originHeight=587&amp;originWidth=1165&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25fd03f5-cf32-4ea9-b5a2-10523fc59b6&amp;title=&amp;width=399" alt=""><br>注意点<br>只要范围扩充了，我就盯着总目标有没有实现，我不一定要使用完所有数字，我可能已经提前搞定考了，<br>我缺了多少数字，如果发现我range已经到它了，直接返回就可以了，不用看后面的数字<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927562331-6d5e0b3b-b786-468c-a940-7c5b9ed70aa2.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=u84594179&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1341&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3d649c1a-e5d8-43f0-87e0-47de55d83b7&amp;title=&amp;width=510" alt=""></p><p>| // arr请保证有序，且正数  1~aim<br><strong>public static int </strong>minPatches<strong>(int[] </strong>arr, <strong>int </strong>aim<strong>) {<br>   int </strong>patches = 0; // 缺多少个数字<br>   <strong>long </strong>range = 0; // 已经完成了1 ~ range的目标<br>   Arrays.sort<strong>(</strong>arr<strong>)</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {      </strong>// arr[i]<br>      // 要求：1 ~ arr[i]-1 范围被搞定！<br>      <strong>while (</strong>arr<strong>[</strong>i<strong>] </strong>- 1 &gt; range<strong>) { </strong>// arr[i] 1 ~ arr[i]-1<br>         range += (range + 1); // range + 1 是缺的数字<br>         patches++;<br>         //只要范围一变化就盯着目标<br>         <strong>if (</strong>range &gt;= aim<strong>) {<br>            return </strong>patches;<br>         <strong>}<br>      }      </strong>// 要求被满足了！<br>      range += arr<strong>[</strong>i<strong>]</strong>;<br>      <strong>if (</strong>range &gt;= aim<strong>) {<br>         return </strong>patches;<br>      <strong>}<br>   }<br>   while (</strong>aim &gt;= range + 1<strong>) {      </strong>range += range + 1;<br>      patches++;<br>   <strong>}<br>   return </strong>patches;<br><strong>}</strong> |<br>| —- |</p><h2 id=""><a href="#" class="headerlink" title="//======================"></a>//======================</h2><h2 id="·-240-行列递增矩阵的查找-搜索二维矩阵-II-M"><a href="#·-240-行列递增矩阵的查找-搜索二维矩阵-II-M" class="headerlink" title="· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]"></a>· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538431656-6b591c24-62b5-4f4d-a992-0e2ee6455b85.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=78&amp;id=ucaa40dd5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=549&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11740&amp;status=done&amp;style=none&amp;taskId=u76050ce0-5216-4663-83e4-b58fdd5ced0&amp;title=&amp;width=439.2" alt="image.png"><br><strong>题意</strong><br>让你找某一个数字在其中是否存在<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537626124-5e69971c-798a-4382-a6c0-56062f07a154.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u825d9625&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=642&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u938e2c19-6aff-4589-84b0-79641bb03ae&amp;title=&amp;width=348" alt=""><br><strong>题解</strong><br>经典解法:<br>从右上角开始找<br>复杂度O(N+M)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624515-057e50f5-c481-4b0a-8091-003f019142d4.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u86a3eab4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=611&amp;originWidth=1257&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufda2a2e9-c766-4bc5-9780-98846953c45&amp;title=&amp;width=553" alt=""><br>从左下角走</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624507-9f4bca2b-fa51-4bd1-ae0a-cc127e634a97.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ubf5cba53&amp;margin=%5Bobject%20Object%5D&amp;originHeight=601&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0f5c24b9-5e75-475b-96da-fcd5f286991&amp;title=&amp;width=515" alt=""></p><p>| <strong>public static boolean </strong>isContains<strong>(int[][] </strong>matrix, <strong>int </strong>K<strong>) {<br>   int </strong>row = 0;<br>   <strong>int </strong>col = matrix<strong>[</strong>0<strong>]</strong>.<strong>length </strong>- 1;<br>   <strong>while (</strong>row &lt; matrix.<strong>length </strong>&amp;&amp; col &gt; -1<strong>) {<br>      if (</strong>matrix<strong>[</strong>row<strong>][</strong>col<strong>] </strong>== K<strong>) {<br>         return true</strong>;<br>      <strong>} else if (</strong>matrix<strong>[</strong>row<strong>][</strong>col<strong>] </strong>&gt; K<strong>) {         </strong>col—;<br>      <strong>} else {         </strong>row++;<br>      <strong>}<br>   }<br>   return false</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-✊378-行列递增矩阵中的第K小-M"><a href="#·-✊378-行列递增矩阵中的第K小-M" class="headerlink" title="· ✊378.行列递增矩阵中的第K小 [M]"></a>· ✊378.行列递增矩阵中的第K小 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538447469-55d93518-20af-4ac9-bb0d-cc650b505a39.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=75&amp;id=ue2220b92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=94&amp;originWidth=543&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12027&amp;status=done&amp;style=none&amp;taskId=u7642227d-241c-4306-8adb-3d21d1474a6&amp;title=&amp;width=434.4" alt="image.png"><br><strong>最优解</strong><br>给定一个目标, 想知道&lt;=100的数有几个, 怎么快能求出来?<br>往左走, 获得0个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464907-2dead8bf-8612-4941-8c80-3b22ba09131b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=192&amp;id=u2e5cfef4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=584&amp;originWidth=1302&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5722571-1037-41c0-a18e-d6fb6cb934b&amp;title=&amp;width=427" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464900-3f1bafb2-1bae-4cdb-8c53-cc846c69f134.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u4704966e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=599&amp;originWidth=1269&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4d022a33-b6ba-45b1-8229-acd68f70a81&amp;title=&amp;width=500" alt=""><br>就这样一直卡到结束，你正确的获得整个数组中有多少个数&lt;=100<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464925-50973775-2761-4ed9-8cd5-5337041bf338.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=ua11d3edf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=636&amp;originWidth=1279&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueff346fb-ab57-4bd5-9a3e-3880b1e4b7b&amp;title=&amp;width=534" alt=""><br><strong>例子</strong><br>&lt;=100的有几个, 同时也可以知道最接近100的是啥数?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464932-49c9b5d2-a01d-4a5c-8975-50303fa6a936.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u56983f42&amp;margin=%5Bobject%20Object%5D&amp;originHeight=588&amp;originWidth=1296&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u67098799-26c6-4f3c-8175-19f94ecb673&amp;title=&amp;width=521" alt=""><br>120&gt;100获得0个</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464930-de301eda-d2b0-440b-b938-1bc52130534e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=u2cdb7407&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=1311&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b4b31cf-26dc-496f-8390-87189a86c68&amp;title=&amp;width=411" alt=""><br>100&gt;90 假设90所在的列是col<br>获得的个数是rol+1<br>同时更新接近100的数字为90</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465650-44206736-0a80-4be1-b524-3e42d7c92086.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=u653e1491&amp;margin=%5Bobject%20Object%5D&amp;originHeight=566&amp;originWidth=1304&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uefd5909b-1438-4e68-8c39-07bb5605a84&amp;title=&amp;width=549" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465710-67505b3a-0cc8-4c66-b908-40ff88ecab43.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=181&amp;id=u66d628df&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1310&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufefde839-ee65-4893-88e1-ff39a92a975&amp;title=&amp;width=431" alt=""><br>解决原问题<br><strong>二分</strong><br>整个数组中最小的是谁？左上角的数<br>那整个数组中，最大的数是谁？右下角的数<br>第一百小的数一定在一到1000之间, 看看&lt;=500的数有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465810-e8be4f70-42f7-4fa5-b7a0-c81514b2ff5d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=256&amp;id=u9bcf7146&amp;margin=%5Bobject%20Object%5D&amp;originHeight=599&amp;originWidth=1219&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u479e614c-408d-4eb6-9c84-94373d1aa27&amp;title=&amp;width=521" alt=""><br>如果&lt;=500有200个, 目标大了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465999-a6e86772-a3ac-4585-a06c-2081f5cdd43e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=284&amp;id=uddbef8b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=650&amp;originWidth=1265&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u361c54da-f6cb-48a8-9aaf-db96a0a03c1&amp;title=&amp;width=553" alt=""><br>有可能最后得到&lt;=785的数有100个, 但是数组中没有这个数, 应该是&lt;=785并离它最近<br>的数<br>我每次让你过的时候求俩信息，</p><ul><li>第一小于等于某一个值个数有几个</li><li>第二，最接近它的是谁？</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466133-869c69d6-fbbd-4e08-b85f-e7affbbdba50.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=u32fd171a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=632&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf7b5a0ae-78a1-4110-90ef-898624a9d91&amp;title=&amp;width=560" alt=""><br><strong>复杂度</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466525-0b2fee08-0f44-4e91-b063-3992ab4853f0.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=268&amp;id=ucbc9934f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=659&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua58a75d8-03db-4569-b937-1af685bff8d&amp;title=&amp;width=513" alt=""><br><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466467-9e5f348e-c41d-4268-9b00-b0c0e20be6de.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u762a2f31&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1285&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8fa0287d-25c4-48b9-a7cf-aa1e3e128a1&amp;title=&amp;width=516" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466606-1c01a2b3-8288-4f63-a32f-5ef20107ec9d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=ua6082d71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=912&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1827838a-ed61-4d55-b0e4-80808063065&amp;title=&amp;width=564" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466819-f599b5d1-bfaf-409d-9a8b-05f51b31ee1a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u7c9fce28&amp;margin=%5Bobject%20Object%5D&amp;originHeight=671&amp;originWidth=1356&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u150b1272-8545-4d16-8622-d69dad22697&amp;title=&amp;width=544" alt=""><br><strong>代码</strong></p><p>| // 二分的方法<br><strong>public static int </strong>kthSmallest2<strong>(int[][] </strong>matrix, <strong>int </strong>k<strong>) {<br>   int </strong>N = matrix.<strong>length</strong>;<br>   <strong>int </strong>M = matrix<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>left = matrix<strong>[</strong>0<strong>][</strong>0<strong>]</strong>;<br>   <strong>int </strong>right = matrix<strong>[</strong>N - 1<strong>][</strong>M - 1<strong>]</strong>;<br>   <strong>int </strong>ans = 0;<br>   <strong>while (</strong>left &lt;= right<strong>) {<br>      int </strong>mid = left + <strong>((</strong>right - left<strong>) </strong>&gt;&gt; 1<strong>)</strong>;<br>      // &lt;=mid 有几个 &lt;= mid 在矩阵中真实出现的数，谁最接近mid<br>      Info info = noMoreNum<strong>(</strong>matrix, mid<strong>)</strong>;<br>      <strong>if (</strong>info.<strong>num </strong>&lt; k<strong>) {         </strong>left = mid + 1;<br>      <strong>} else {         </strong>//这里就是有可能&lt;=785的数有100个，但是数组中没有这个数，所以要记录与他最接近的<br>         ans = info.<strong>near</strong>;<br>         right = mid - 1;<br>      <strong>}<br>   }<br>   return </strong>ans;<br>**}</p><p>public static class <strong>Info </strong>{<br>   public int near<strong>;   </strong>public int num**;</p><p>   <strong>public </strong>Info<strong>(int </strong>n1, <strong>int </strong>n2<strong>) {<br>      near </strong>= n1;<br>      <strong>num </strong>= n2;<br>   **}<br>}</p><p>public static <strong>Info noMoreNum</strong>(int[][] <strong>matrix, </strong>int <strong>value</strong>) {<br>   int <strong>near = Integer.</strong>MIN_VALUE<strong>;   </strong>int <strong>num = 0;   </strong>int <strong>N = matrix.</strong>length<strong>;   </strong>int <strong>M = matrix</strong>[<strong>0</strong>]<strong>.</strong>length<strong>;   </strong>int <strong>row = 0;   </strong>int <strong>col = M - 1;   </strong>while (<strong>row &lt; N &amp;&amp; col &gt;= 0</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&lt;= value</strong>) {<br>         <strong>near = Math.max</strong>(<strong>near, matrix</strong>[<strong>row</strong>][<strong>col</strong>])<strong>;<br>         num += col + 1;<br>         row++;      </strong>} else {<br>         <strong>col—;      </strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>near, num</strong>)<strong>;</strong>}** |<br>| —- |</p><p>| // 堆的方法<br><strong>public static int </strong>kthSmallest1<strong>(int[][] </strong>matrix, <strong>int </strong>k<strong>) {<br>   int </strong>N = matrix.<strong>length</strong>;<br>   <strong>int </strong>M = matrix<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>heap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;(new </strong>NodeComparator<strong>())</strong>;<br>   <strong>boolean[][] </strong>set = <strong>new boolean[</strong>N<strong>][</strong>M<strong>]</strong>;<br>   heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>0<strong>][</strong>0<strong>]</strong>, 0, 0<strong>))</strong>;<br>   set<strong>[</strong>0<strong>][</strong>0<strong>] </strong>= <strong>true</strong>;<br>   <strong>int </strong>count = 0;<br>   Node ans = <strong>null</strong>;<br>   <strong>while (</strong>!heap.isEmpty<strong>()) {      </strong>ans = heap.poll<strong>()</strong>;<br>      <strong>if (</strong>++count == k<strong>) {<br>         break</strong>;<br>      <strong>}<br>      int </strong>row = ans.<strong>row</strong>;<br>      <strong>int </strong>col = ans.<strong>col</strong>;<br>      <strong>if (</strong>row + 1 &lt; N &amp;&amp; !set<strong>[</strong>row + 1<strong>][</strong>col<strong>]) {         </strong>heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>row + 1<strong>][</strong>col<strong>]</strong>, row + 1, col<strong>))</strong>;<br>         set<strong>[</strong>row + 1<strong>][</strong>col<strong>] </strong>= <strong>true</strong>;<br>      <strong>}<br>      if (</strong>col + 1 &lt; M &amp;&amp; !set<strong>[</strong>row<strong>][</strong>col + 1<strong>]) {         </strong>heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>row<strong>][</strong>col + 1<strong>]</strong>, row, col + 1<strong>))</strong>;<br>         set<strong>[</strong>row<strong>][</strong>col + 1<strong>] </strong>= <strong>true</strong>;<br>      <strong>}<br>   }<br>   return </strong>ans.<strong>value</strong>;<br>**}</p><p>public static class <strong>Node </strong>{<br>   public int value<strong>;   </strong>public int row<strong>;   </strong>public int col**;</p><p>   <strong>public </strong>Node<strong>(int </strong>v, <strong>int </strong>r, <strong>int </strong>c<strong>) {<br>      value </strong>= v;<br>      <strong>row </strong>= r;<br>      <strong>col </strong>= c;<br>   **}</p><p>}</p><p>public static class <strong>NodeComparator </strong>implements <strong>Comparator</strong>&lt;<strong>Node</strong>&gt; {</p><p>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return <strong>o1.</strong>value <strong>- o2.</strong>value<strong>;   </strong>}</p><p>}** |<br>| —- |</p><h2 id="·-940-不同的子序列-II-H"><a href="#·-940-不同的子序列-II-H" class="headerlink" title="· 940.不同的子序列 II [H]"></a>· 940.不同的子序列 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538612708-fda8d9fb-bb27-4677-8080-a6c88db86f79.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=330&amp;id=u64377b4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=412&amp;originWidth=662&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24324&amp;status=done&amp;style=none&amp;taskId=ub9741443-896e-42ce-8c56-8a848253493&amp;title=&amp;width=529.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-ffb30de6-f89e-4cc2-97f9-f689fa201501.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=u1fea0879&amp;margin=%5Bobject%20Object%5D&amp;originHeight=587&amp;originWidth=1215&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u55df378d-a803-40de-a808-0dedf0ccfe0&amp;title=&amp;width=458" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-f0b61739-d00f-48b6-998c-26a3711ea3bf.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u1df3788a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1042&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4f9cf5bd-ef8b-440e-8b26-ba037940ecf&amp;title=&amp;width=429" alt=""><br><strong>题解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655384932788-bf089bd0-c6f2-473c-a397-a313422b8837.png#clientId=u782dedcd-cafb-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1810&amp;id=ua0fa29c9&amp;margin=%5Bobject%20Object%5D&amp;name=779E39B64BA9EC69E5A1C515E4200530.png&amp;originHeight=3168&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1164522&amp;status=done&amp;style=none&amp;taskId=udfa184cd-8bbd-4169-93f5-29e4850f4c6&amp;title=&amp;width=813.7142857142857" alt="779E39B64BA9EC69E5A1C515E4200530.png"><br>模操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538826795-e3410ba0-a512-485d-951d-69bb5cb981a6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9b1dd3e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=755&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u811d823a-3961-4f75-b8f3-4b6d6da427b&amp;title=" alt=""></p><p>| <strong>public static int </strong>zuo1<strong>(</strong>String s<strong>) {<br>      if (</strong>s == <strong>null </strong>&#124;&#124; s.length<strong>() </strong>== 0<strong>) {<br>         return </strong>0;<br>      <strong>}<br>      int </strong>m = 1000000007;<br>      <strong>char[] </strong>str = s.toCharArray<strong>()</strong>;<br>      HashMap<strong>&lt;</strong>Character, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>      <strong>int </strong>all = 1; // 一个字符也没遍历的时候，有空集<br>      <strong>for (char </strong>x : str<strong>) {         </strong>//新加出来的玩意儿就是以什么结尾的数量<br>         <strong>int </strong>newAdd = all;<br>         <strong>int </strong>curAll = all + newAdd - <strong>(</strong>map.containsKey<strong>(</strong>x<strong>) </strong>? map.get<strong>(</strong>x<strong>) </strong>: 0<strong>)</strong>;<br>         all = curAll;<br>         map.put<strong>(</strong>x, newAdd<strong>)</strong>;<br>      <strong>}<br>      return </strong>all;<br>   <strong>}<br>   public static int </strong>zuo<strong>(</strong>String s<strong>) {<br>      if (</strong>s == <strong>null </strong>&#124;&#124; s.length<strong>() </strong>== 0<strong>) {<br>         return </strong>0;<br>      <strong>}<br>      int </strong>m = 1000000007;<br>      <strong>char[] </strong>str = s.toCharArray<strong>()</strong>;<br>      HashMap<strong>&lt;</strong>Character, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>      <strong>int </strong>all = 1; // 一个字符也没遍历的时候，有空集<br>      <strong>for (char </strong>x : str<strong>) {<br>         int </strong>newAdd = all;<br>//       int curAll = all + newAdd - (map.containsKey(x) ? map.get(x) : 0);<br>         <strong>int </strong>curAll = all;<br>         curAll = <strong>(</strong>curAll + newAdd<strong>) </strong>% m;<br>         //减完可能为负数，所以要先加<br>         curAll = <strong>(</strong>curAll - <strong>(</strong>map.containsKey<strong>(</strong>x<strong>) </strong>? map.get<strong>(</strong>x<strong>) </strong>: 0<strong>) </strong>+ m<strong>) </strong>% m;<br>         all = curAll;<br>         map.put<strong>(</strong>x, newAdd<strong>)</strong>;<br>      <strong>}<br>      return </strong>all;<br>   <strong>}</strong> |<br>| —- |</p><h2 id="·-汉诺塔游戏中的最优状态"><a href="#·-汉诺塔游戏中的最优状态" class="headerlink" title="· 汉诺塔游戏中的最优状态"></a>· 汉诺塔游戏中的最优状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539211568-a1dd0839-322f-4a09-8fbb-4427209b059d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=156&amp;id=u5e9bcd3b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=195&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40554&amp;status=done&amp;style=none&amp;taskId=u75553f41-4211-4e03-b1c3-af09e2d344e&amp;title=&amp;width=489.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187846-f70f3d8f-0157-43bd-b853-e65f7208f8ce.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=ua14962a4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=1280&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u50a5c929-49c5-44bd-bc95-307b8dadc4c&amp;title=&amp;width=585" alt=""><br>7层汉诺塔问题的一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187621-d66d9436-5fa6-4b96-8665-50fa8b081a64.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=uc20ed9ff&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1260&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1831e6fb-2ea6-4897-b345-95c2d0e887b&amp;title=&amp;width=559" alt=""><br>最优解的第一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187608-84fce00e-ce50-476f-8097-9a88be815ab3.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=188&amp;id=u606020c1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=373&amp;originWidth=1323&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udc765580-8b82-4da7-9d75-d59459d93e9&amp;title=&amp;width=666" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187793-ebb720d3-d2df-44dd-b600-10e2915349d5.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ue283094b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=633&amp;originWidth=1368&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub9dc08a9-ad4f-48c3-9036-b1723d5d890&amp;title=&amp;width=595" alt=""><br><strong>题解</strong><br>复杂度 O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187754-902ce282-eb4d-4ffa-b9f2-08d5bb24a1ca.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=265&amp;id=ueee15b1a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=594&amp;originWidth=1173&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5fe3be44-3808-4c07-a651-80f9cb66498&amp;title=&amp;width=523" alt=""><br>先忘掉左中右, 目标是逐渐分解的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281818-8f55bc3d-600b-4fe1-9a28-194a2e14b313.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=uc72a3d6d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=632&amp;originWidth=1309&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9972a330-30f9-4bb4-b8c7-08fe6f74d00&amp;title=&amp;width=560" alt=""><br><strong>抽象</strong><br>i: 1~i的圆盘需要移动<br>F: 1~i的圆盘现在处在什么圆盘上, 可能是左, 中, 右<br>t: 需要去的位置, 可能是左, 中, 右<br>other: 除了from, to的另外一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281875-9d349353-6eed-4b5a-9c10-e6e7433d67c4.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=ua78ed761&amp;margin=%5Bobject%20Object%5D&amp;originHeight=633&amp;originWidth=1251&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ued654e3c-92fc-4ef3-a314-9c63cc17362&amp;title=&amp;width=574" alt=""><br><strong>代码</strong><br>i层的圆盘没有任何道理是在other上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358889-bf247fdd-e580-4abd-8d24-c40995fab0f6.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=316&amp;id=u5e1ef882&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=1171&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d288535-fb85-41b3-98d3-2cf5fb5d4b2&amp;title=&amp;width=591" alt=""><br>如果index还在From上, 说明第一大步没走完<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358848-516f2145-a3f9-46ba-81c9-e9ce28edee97.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=293&amp;id=u07d3b69a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=651&amp;originWidth=1255&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u48e1996c-d742-490a-96d7-66c6462a3a3&amp;title=&amp;width=565" alt=""><br><strong>n层汉诺塔最优解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358910-0c4cbbd5-0292-44fe-b9d6-b53981389b71.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=ua0d8af67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=654&amp;originWidth=879&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d18edcc-fa98-42fc-8d83-170aa0206d6&amp;title=&amp;width=386" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028378401-1aa4cb61-81e0-4606-934e-dbf7cd028030.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u5785399a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=612&amp;originWidth=1203&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uea4922b0-8da4-4a95-abb3-8986b68ee4c&amp;title=&amp;width=491" alt=""><br>后续有任何一点点无效，你整体就无效</p><p>| <strong>public static int </strong>kth<strong>(int[] </strong>arr<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>return </strong>step<strong>(</strong>arr, N - 1, 1, 3, 2<strong>)</strong>;<br>**}</p><p><strong>// 0…index这些圆盘，arr[0..index] index+1层塔<br>// 在哪？from 去哪？to 另一个是啥？other<br>// arr[0..index]这些状态，是index+1层汉诺塔问题的，最优解第几步</strong>public static int <strong>step</strong>(int[] <strong>arr, </strong>int <strong>index, </strong>int <strong>from, </strong>int <strong>to, </strong>int <strong>other</strong>) {<br>   if (<strong>index == -1</strong>) {<br>      return <strong>0;   </strong>}<br>   if (<strong>arr</strong>[<strong>index</strong>] <strong>== other</strong>) {<br>      return <strong>-1;   </strong>}<br>   <strong>/</strong>多想想就明白了</p><pre><code>* 比如 arr[3,2,1] 三层汉诺塔问题** 第一个在to区* 第二个在**/</code></pre><p>   // arr[index] == from arr[index] == to;<br>   <strong>if (</strong>arr<strong>[</strong>index<strong>] </strong>== from<strong>) {<br>      return </strong>step<strong>(</strong>arr, index - 1, from, other, to<strong>)</strong>;<br>   <strong>} else {<br>      int </strong>p1 = <strong>(</strong>1 &lt;&lt; index<strong>) </strong>- 1;<br>      <strong>int </strong>p2 = 1;<br>      <strong>int </strong>p3 = step<strong>(</strong>arr, index - 1, other, to, from<strong>)</strong>;<br>      <strong>if (</strong>p3 == -1<strong>) {<br>         return </strong>-1;<br>      <strong>}<br>      return </strong>p1 + p2 + p3;<br>   <strong>}<br>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>单决策递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028426636-08060a50-74cc-4c62-8e62-424f512cf88c.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=338&amp;id=u443ec777&amp;margin=%5Bobject%20Object%5D&amp;originHeight=634&amp;originWidth=943&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u203f3cdf-b1ab-456b-b0c3-d0034313049&amp;title=&amp;width=502" alt=""></p><h2 id="·-两个有序数组间相加和的Topk问题"><a href="#·-两个有序数组间相加和的Topk问题" class="headerlink" title="· 两个有序数组间相加和的Topk问题"></a>· 两个有序数组间相加和的Topk问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539251891-3de0d850-c8d0-4239-a81d-fa1a2210426c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=414&amp;id=ue5640a4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=830&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43271&amp;status=done&amp;style=none&amp;taskId=u6feb9167-120c-415a-b74d-95ac0e48b98&amp;title=&amp;width=664" alt="image.png"><br>用大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031978240-dce8b855-e997-478e-933a-aab5c7268225.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=u92e50c4d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82696&amp;status=done&amp;style=none&amp;taskId=ue0cf5ae5-f712-4140-aac0-9aa695e0286&amp;title=&amp;width=456.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031989072-10c19f0a-4015-407a-8fb7-176cef820206.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=u9583c67c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=90083&amp;status=done&amp;style=none&amp;taskId=ufffa987b-c980-44a0-89a3-38926c6b62d&amp;title=&amp;width=478.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032000117-c9d348c8-6b94-4a91-a50e-1a47217c9b57.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u80c59775&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=646&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119662&amp;status=done&amp;style=none&amp;taskId=udb562210-be25-49bb-981b-b2ccf26efe2&amp;title=&amp;width=516.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032013255-95030714-b09e-4f25-a865-2758167fb7b1.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u49edc7c2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=649&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=146468&amp;status=done&amp;style=none&amp;taskId=u5745c217-4dbe-4db4-b967-7cfbd0548ac&amp;title=&amp;width=519.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032038337-4b6eddac-52e2-40b0-ac4f-694be2af4927.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u7efe8179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=638&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145293&amp;status=done&amp;style=none&amp;taskId=uc4397788-c306-4e30-b954-1c34575127e&amp;title=&amp;width=510.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032058547-5ce5c648-4d2f-4c69-a0ca-51424b5f5c83.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=uec145c06&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=317&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=38852&amp;status=done&amp;style=none&amp;taskId=uee16e7db-0793-4ade-bcf7-ae43094fe60&amp;title=&amp;width=420" alt="image.png"></p><p>| // 放入大根堆中的结构<br><strong>public static class </strong>Node <strong>{<br>   public int index1</strong>;// arr1中的位置<br>   <strong>public int index2</strong>;// arr2中的位置<br>   <strong>public int sum</strong>;// arr1[index1] + arr2[index2]的值</p><p>   <strong>public </strong>Node<strong>(int </strong>i1, <strong>int </strong>i2, <strong>int </strong>s<strong>) {<br>      index1 </strong>= i1;<br>      <strong>index2 </strong>= i2;<br>      <strong>sum </strong>= s;<br>   **}<br>}</p><p><strong>// 生成大根堆的比较器</strong>public static class <strong>MaxHeapComp </strong>implements <strong>Comparator</strong>&lt;<strong>Node</strong>&gt; {<br>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return <strong>o2.</strong>sum <strong>- o1.</strong>sum<strong>;   </strong>}<br>}</p><p>public static int[] <strong>topKSum</strong>(int[] <strong>arr1, </strong>int[] <strong>arr2, </strong>int <strong>topK</strong>) {<br>   if (<strong>arr1 == </strong>null <strong>&#124;&#124; arr2 == </strong>null <strong>&#124;&#124; topK &lt; 1</strong>) {<br>      return null<strong>;   </strong>}<br>   int <strong>N = arr1.</strong>length<strong>;   </strong>int <strong>M = arr2.</strong>length**;</p><p>   topK = Math.min<strong>(</strong>topK, N <em> M<em>*)</em></em>;</p><p>   <strong>int[] </strong>res = <strong>new int[</strong>topK<strong>]</strong>;<br>   <strong>int </strong>resIndex = 0;</p><p>   PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>maxHeap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;(new </strong>MaxHeapComp<strong>())</strong>;<br>   HashSet<strong>&lt;</strong>Long<strong>&gt; </strong>set = <strong>new </strong>HashSet<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>i1 = N - 1;<br>   <strong>int </strong>i2 = M - 1;<br>   maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1, i2, arr1<strong>[</strong>i1<strong>] </strong>+ arr2<strong>[</strong>i2<strong>]))</strong>;<br>   set.add<strong>(</strong>x<strong>(</strong>i1, i2, M<strong>))</strong>;//二维变一维<br>   <strong>while (</strong>resIndex != topK<strong>) {      </strong>Node curNode = maxHeap.poll<strong>()</strong>;<br>      res<strong>[</strong>resIndex++<strong>] </strong>= curNode.<strong>sum</strong>;<br>      i1 = curNode.<strong>index1</strong>;<br>      i2 = curNode.<strong>index2</strong>;<br>      set.remove<strong>(</strong>x<strong>(</strong>i1, i2, M<strong>))</strong>;<br>      <strong>if (</strong>i1 - 1 &gt;= 0 &amp;&amp; !set.contains<strong>(</strong>x<strong>(</strong>i1 - 1, i2, M<strong>))) {         </strong>set.add<strong>(</strong>x<strong>(</strong>i1 - 1, i2, M<strong>))</strong>;<br>         maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1 - 1, i2, arr1<strong>[</strong>i1 - 1<strong>] </strong>+ arr2<strong>[</strong>i2<strong>]))</strong>;<br>      <strong>}<br>      if (</strong>i2 - 1 &gt;= 0 &amp;&amp; !set.contains<strong>(</strong>x<strong>(</strong>i1, i2 - 1, M<strong>))) {         </strong>set.add<strong>(</strong>x<strong>(</strong>i1, i2 - 1, M<strong>))</strong>;<br>         maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1, i2 - 1, arr1<strong>[</strong>i1<strong>] </strong>+ arr2<strong>[</strong>i2 - 1<strong>]))</strong>;<br>      <strong>}<br>   }<br>   return </strong>res;<br>**}</p><p>public static long <strong>x</strong>(int <strong>i1, </strong>int <strong>i2, </strong>int <strong>M</strong>) {<br>   return (long) <strong>i1 * </strong>(long) <strong>M + </strong>(long) <strong>i2;</strong>}</p><p>** |<br>| —- |</p><h2 id="·-42-接雨水-H"><a href="#·-42-接雨水-H" class="headerlink" title="· 42. 接雨水 [H]"></a>· 42. 接雨水 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267273178-987b1982-ef81-4324-8306-8f79b8e3d6ff.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=353&amp;id=u9a387aaa&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=441&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33271&amp;status=done&amp;style=none&amp;taskId=u7e5d0662-374f-45a2-926d-fe2e07cee61&amp;title=&amp;width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653183809624-bfe54faa-fc8e-4c66-a37c-99bf00c7ccb2.png#clientId=u9486b31d-676a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=uc43d2755&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=359&amp;originWidth=905&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17507&amp;status=done&amp;style=none&amp;taskId=u90fb9776-20c1-498f-95f0-ab5a02da7b7&amp;title=&amp;width=724" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323108-3482efdf-9617-4893-953d-ccef84395862.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uf94fe60c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=484&amp;originWidth=855&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue2587b40-59ad-4b39-8b70-6184ba23117&amp;title=&amp;width=490" alt=""><br><strong>题解</strong><br>跟踪坡峰坡谷的Coding解法不正确<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323100-9d08de8c-b1e3-4f1d-9d28-813b0490efef.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=u98c83e06&amp;margin=%5Bobject%20Object%5D&amp;originHeight=366&amp;originWidth=986&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c3e4756-b5a8-4817-8a39-e247925cb50&amp;title=&amp;width=578" alt=""><br>i位置自己整个位置上方有几格水?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323023-37d28c90-8cf6-460d-96e9-9cf07801d95d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=298&amp;id=u691728f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=984&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5e997542-0ba1-4e3b-9bf7-b430884218a&amp;title=&amp;width=614" alt=""><br>边界情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323022-bf49b7ca-7a22-499d-89e4-9ba96be952dc.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=319&amp;id=u185b9d89&amp;margin=%5Bobject%20Object%5D&amp;originHeight=399&amp;originWidth=681&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1a037bb2-07a4-406b-b36a-a860e287ed7&amp;title=&amp;width=545" alt=""><br>i位置的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268325675-aeb3f9d1-c2fd-4218-89f5-368d9ac0bf4f.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ua64db485&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=960&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4474289a-e974-4f64-822b-7bed7e7cc27&amp;title=&amp;width=506" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326254-52267b69-79ad-4bf9-9fa8-cd8d26a94a8d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=292&amp;id=u4434b4f8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5338f041-b732-47d3-b061-8a59c39d9b4&amp;title=&amp;width=587" alt=""><br><strong>辅助数组</strong><br>需要0~i范围上的最大值max<br>i~N-1范围上的最大值max<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326340-b8cc0df3-73c2-4d4e-a267-dbe509ac09a4.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=358&amp;id=u3182ff51&amp;margin=%5Bobject%20Object%5D&amp;originHeight=471&amp;originWidth=710&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e3ff214-4949-458e-a458-e98f1d2275a&amp;title=&amp;width=540" alt=""><br><strong>最优解</strong><br>不需要辅助数组<br>0位置最左 20位置最右是不可能留下水的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326487-100d9b8f-7d1c-416f-9c3f-d57fed517bdc.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue35ef49f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=1065&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5f3ada90-3915-4cab-ae55-b2018430e01&amp;title=" alt=""><br>19位置的最大高度假设6, 要结算算水量<br>需要求6的左边, 右边部分的max, 以13做瓶颈,<br>因为6它的左边这么多最大值还没看过，但它的最大值是17，恐怕它真实的左边最大值是大于17的。<br>而我右边的最大值，这可是个真实最大值, 所以6位置的水量就是13-6 = 7 格子水<br>左边跟右边max谁小就先结算那边的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326627-e696ef0d-bcf9-4c31-b14d-f8340253c3b2.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=278&amp;id=uac262f4d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=1063&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uecb45efd-f557-48a5-b00f-d7bd73562f1&amp;title=&amp;width=635" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327142-fa9a9589-71a6-4d59-aa66-b7c33cee30c5.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u4c693001&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=1067&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2adf84f1-1a9b-4fe1-b0a8-886ae13e2cf&amp;title=&amp;width=564" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327723-c5a819e2-e219-4a73-a4fb-5d3e37bc01c7.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u59b410f0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1074&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u401cfdd3-d2fd-4b7e-9f90-aa11bcb92b4&amp;title=&amp;width=568" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327914-13401c07-43a7-45f0-b9fb-be52bf672963.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u0fcb1059&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=1075&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u33092d65-5421-468c-961f-251f018357f&amp;title=&amp;width=562" alt=""><br>相等怎么办<br>可以一起结算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328197-0ef67c95-b205-4b96-bb3b-4861e493c575.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=197&amp;id=u58c81a8a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=340&amp;originWidth=1038&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d5765fc-e857-484a-bb9b-b63c2ef9a07&amp;title=&amp;width=602" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328220-048d534c-040c-4157-851b-81ffab6e636e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=ub7259426&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud895d562-3d89-4df9-973d-e6e4a3153f3&amp;title=&amp;width=557" alt=""><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328354-f6461e69-c9fc-464e-b55d-98e8f7a989f6.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2f50eac9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=381&amp;originWidth=433&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufd62e68c-e8d6-4953-ae67-65811a0750c&amp;title=" alt=""></p><h2 id="·-✊407-接雨水-II-H"><a href="#·-✊407-接雨水-II-H" class="headerlink" title="· ✊407. 接雨水 II [H]"></a>· ✊407. 接雨水 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267310891-9ae51e62-eb36-4c3d-aecf-42757c8bc9da.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=424&amp;id=u4348eeb0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=633&amp;originWidth=921&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=167029&amp;status=done&amp;style=none&amp;taskId=u12c089cc-f48c-4fe5-b32a-f49a6ad36f5&amp;title=&amp;width=616.7999877929688" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567058-f79a7202-de25-40fb-a9e7-36ee14452e6c.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uf198170f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=835&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc30f9554-6db3-457f-b0f2-32d091524b1&amp;title=&amp;width=489" alt=""><br><strong>题解</strong><br>这一圈的值放到小根堆去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566883-18c6b4b4-30c6-4a82-a82a-59b43835a5db.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=u3d5807f8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=806&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u427cc3c0-49d7-4081-aa59-7229fad2c68&amp;title=&amp;width=542" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566896-0282f120-5392-4308-9d6e-ecdfee83e80e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=u9d229db5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=1004&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u218c752a-31e6-48f8-919c-307b08a911f&amp;title=&amp;width=595" alt=""><br>都会以max做为瓶颈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567083-2497db05-4afd-4681-82b4-112847d15636.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=316&amp;id=u799526e3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=498&amp;originWidth=957&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc83a1690-d0de-4210-95ad-eb1fbc9439e&amp;title=&amp;width=608" alt=""><br>只要max不更新, 都是max的内湖区域<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566876-7b3a2096-ce22-4ac5-90e4-10ffa818dc49.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=319&amp;id=u8728c50f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=480&amp;originWidth=916&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae7d39ad-2aa8-4dd3-922b-4deb1c5a810&amp;title=&amp;width=608" alt=""><br><strong>例子</strong><br>一个数进去的时候结算水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568452-8d0329f2-01e6-457a-af5e-535b96a0aa9e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=324&amp;id=u2d7d0a44&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2363d263-1b25-4389-b468-1c17f534e8d&amp;title=&amp;width=642" alt=""><br><strong>代码</strong><br>max不更新就说明出海口就没有变</p><p>| <strong>public static class </strong>Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   <strong>public </strong>Node<strong>(int </strong>v, <strong>int </strong>r, <strong>int </strong>c<strong>) {<br>      value </strong>= v;<br>      <strong>row </strong>= r;<br>      <strong>col </strong>= c;<br>   **}</p><p>}</p><p>public static int <strong>trapRainWater</strong>(int[][] <strong>heightMap</strong>) {<br>   if (<strong>heightMap == </strong>null <strong>&#124;&#124; heightMap.</strong>length <strong>== 0 &#124;&#124; heightMap</strong>[<strong>0</strong>] <strong>== </strong>null <strong>&#124;&#124; heightMap</strong>[<strong>0</strong>]<strong>.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   int <strong>N = heightMap.</strong>length<strong>;   </strong>int <strong>M = heightMap</strong>[<strong>0</strong>]<strong>.</strong>length<strong>;   </strong>boolean[][] <strong>isEnter = </strong>new boolean[<strong>N</strong>][<strong>M</strong>]<strong>;<br>   PriorityQueue</strong>&lt;<strong>Node</strong>&gt; <strong>heap = </strong>new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) <strong>-&gt; a.</strong>value <strong>- b.</strong>value)<strong>;   </strong>for (int <strong>col = 0; col &lt; M - 1; col++</strong>) {<br>      <strong>isEnter</strong>[<strong>0</strong>][<strong>col</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>0</strong>][<strong>col</strong>]<strong>, 0, col</strong>))<strong>;   </strong>}<br>   for (int <strong>row = 0; row &lt; N - 1; row++</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>M - 1</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>M - 1</strong>]<strong>, row, M - 1</strong>))<strong>;   </strong>}<br>   for (int <strong>col = M - 1; col &gt; 0; col—</strong>) {<br>      <strong>isEnter</strong>[<strong>N - 1</strong>][<strong>col</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>N - 1</strong>][<strong>col</strong>]<strong>, N - 1, col</strong>))<strong>;   </strong>}<br>   for (int <strong>row = N - 1; row &gt; 0; row—</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>0</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>0</strong>]<strong>, row, 0</strong>))<strong>;   </strong>}<br>   int <strong>water = 0;   </strong>int <strong>max = 0;   </strong>while (<strong>!heap.isEmpty</strong>()) {<br>      <strong>Node cur = heap.poll</strong>()<strong>;<br>      max = Math.max</strong>(<strong>max, cur.</strong>value)<strong>;      </strong>int <strong>r = cur.</strong>row<strong>;      </strong>int <strong>c = cur.</strong>col<strong>;<br>      //上下左右去放<br>      //有上面      </strong>if (<strong>r &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>])<strong>;<br>         isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>]<strong>, r - 1, c</strong>))<strong>;      </strong>}<br>      <strong>//有下      </strong>if (<strong>r &lt; N - 1 &amp;&amp; !isEnter</strong>[<strong>r + 1</strong>][<strong>c</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r + 1</strong>][<strong>c</strong>])<strong>;<br>         isEnter</strong>[<strong>r + 1</strong>][<strong>c</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r + 1</strong>][<strong>c</strong>]<strong>, r + 1, c</strong>))<strong>;      </strong>}<br>      <strong>//有左      </strong>if (<strong>c &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>])<strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>]<strong>, r, c - 1</strong>))<strong>;      </strong>}<br>      <strong>//有右      </strong>if (<strong>c &lt; M - 1 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>])<strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>]<strong>, r, c + 1</strong>))<strong>;      </strong>}<br>   }<br>   return <strong>water;</strong>}** |<br>| —- |</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568940-16d91986-3ce5-4170-995b-25e5eb327a2d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=333&amp;id=ua197f36f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=560&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5856214b-6641-45ba-838e-b397b8823c9&amp;title=&amp;width=378" alt=""></p><h2 id="·-找出最大的左部分最大值减去右部分最大值的绝对值"><a href="#·-找出最大的左部分最大值减去右部分最大值的绝对值" class="headerlink" title="· 找出最大的左部分最大值减去右部分最大值的绝对值"></a>· 找出最大的左部分最大值减去右部分最大值的绝对值</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652270318016-0e37cdc1-b8e3-47ba-bf01-6f42eb4e6247.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=ua69a96f6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=816&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17778&amp;status=done&amp;style=none&amp;taskId=u26260abf-215f-42d6-9e95-5f6eace034c&amp;title=&amp;width=652.8" alt="image.png"><br><strong>题意</strong><br>所以你每切一刀都会有一个左部分的最大值，减去右部分的最大值的绝对值<br>一共有N-1种切法。那么哪一种切法下，这个值能最大, 把这个最大的结果返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009637-2441118c-f8dd-47dd-afef-1bf81668b74a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=pClpf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1223&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5f94afae-e9f4-41ae-8f51-6fb3c2947e8&amp;title=&amp;width=485" alt=""><br><strong>题解</strong><br>暴力: 遍历<br>当我来到i位置的时候, 0~i是左部分, i+1~N-1是右部分, 枚举i, 遍历一下找左右部分的最大值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009601-259b07db-0b03-422c-aa80-7360e0e29474.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=zBUSt&amp;margin=%5Bobject%20Object%5D&amp;originHeight=525&amp;originWidth=1171&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u68d556cd-13fd-4bfa-b226-e655edba474&amp;title=&amp;width=605" alt=""><br><strong>辅助数组</strong><br>left数组: 记录0~i范围上的最大值<br>当前数跟前一个位置的数, 谁大拷贝谁</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009616-8360c1b6-bd21-47cf-b05a-4894b6301470.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=w2PrR&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=1020&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue3dd0bbc-0eb9-4eda-8708-0ac0d2dcf67&amp;title=&amp;width=656" alt=""><br>right数组:从右往左生成,i+1~N-1范围上的最大值<br>有了两个辅助数组, 再去枚举i的时候<br>0~i范围上的最大值直接从left数组里取, i+1~N-1范围上的最大值直接从right数组里拿<br>把O(N^2)的暴力解优化成O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009605-dbca0f91-6ad8-4748-9f10-8885d7311c83.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=337&amp;id=qF9iP&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1035&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8518c4be-731f-43bd-910f-44af73685c7&amp;title=&amp;width=690" alt=""></p><p>| <strong>public static int </strong>maxABS2<strong>(int[] </strong>arr<strong>) {<br>   int[] </strong>lArr = <strong>new int[</strong>arr.<strong>length]</strong>;<br>   <strong>int[] </strong>rArr = <strong>new int[</strong>arr.<strong>length]</strong>;<br>   lArr<strong>[</strong>0<strong>] </strong>= arr<strong>[</strong>0<strong>]</strong>;<br>   rArr<strong>[</strong>arr.<strong>length </strong>- 1<strong>] </strong>= arr<strong>[</strong>arr.<strong>length </strong>- 1<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>lArr<strong>[</strong>i<strong>] </strong>= Math.max<strong>(</strong>lArr<strong>[</strong>i - 1<strong>]</strong>, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   for (int </strong>i = arr.<strong>length </strong>- 2; i &gt; -1; i—<strong>) {      </strong>rArr<strong>[</strong>i<strong>] </strong>= Math.max<strong>(</strong>rArr<strong>[</strong>i + 1<strong>]</strong>, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   int </strong>max = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length </strong>- 1; i++<strong>) {      </strong>max = Math.max<strong>(</strong>max, Math.abs<strong>(</strong>lArr<strong>[</strong>i<strong>] </strong>- rArr<strong>[</strong>i + 1<strong>]))</strong>;<br>   <strong>}<br>   return </strong>max;<br><strong>}</strong> |<br>| —- |</p><p><strong>最优解</strong><br>arr 遍历一遍找到全局最大值, 然后0位置数跟N-1位置数, 谁小减谁就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009794-49174c11-7c15-4f33-86e2-e55388ed91d5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=cLoHI&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=885&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c009e6b-c545-4de7-913a-67aee64f8ad&amp;title=&amp;width=519" alt=""><br>可能性罗列<br>1) 全局max被划分到了左边<br>2) 全局max被划分到了右边</p><p>1) max - 右边的最大值就是答案<br>让右max尽量小<br>右部分一定要有数, 一定会包含N-1位置的数<br>右部分只包含最右边一个数是右边max最小的时候<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010132-31eed44f-ffcb-4639-bc25-e746726c22ef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=D4cKJ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=453&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3d6af354-eb1a-467a-8e6e-9faad6833e9&amp;title=" alt=""><br>2)<br>左max尽量小, 左部分一定会包含0位置的数<br>就让左部分只包含0位置的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010235-2ac3a3a2-5e64-4573-90c1-1ce1513e4177.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=dhLOT&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1030&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue7dd0c92-9bcb-4ee3-ae1f-c25a9700fb7&amp;title=" alt=""><br><strong>代码</strong></p><p>| //amazing！<br><strong>public static int </strong>maxABS3<strong>(int[] </strong>arr<strong>) {<br>   int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>max = Math.max<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, max<strong>)</strong>;<br>   <strong>}<br>   return </strong>max - Math.min<strong>(</strong>arr<strong>[</strong>0<strong>]</strong>, arr<strong>[</strong>arr.<strong>length </strong>- 1<strong>])</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-✊最大可整合子数组的长度"><a href="#·-✊最大可整合子数组的长度" class="headerlink" title="· ✊最大可整合子数组的长度"></a>· ✊最大可整合子数组的长度</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532365836-3c8093cf-782d-4f0e-854a-8c3427e0a834.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=244&amp;id=u867734bf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61875&amp;status=done&amp;style=none&amp;taskId=u53f84319-b0b7-4cfb-9d4d-beafbf2b477&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题意</strong><br>排完序之后依次加1得到就是可整合<br>只要有重复值，它就没办法做可整合数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386766-8b1f7bae-ec0c-4109-bd44-011cacc7d351.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=ua84eeb28&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=581&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u015f7cff-9f62-4bfc-954d-9440e8dd640&amp;title=&amp;width=396" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386782-0ba22845-7afc-4f9e-a81b-9283c470caba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u3850d3b2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=438&amp;originWidth=728&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubb9990b4-f7ff-479c-94d4-943e8d57ac3&amp;title=&amp;width=449" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386975-f5f84998-bdcd-4f75-8fb4-702dc86cb261.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=udf385003&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d425bbc-9f7b-4f84-bf26-d91fcd501fa&amp;title=&amp;width=462" alt=""><br>哪一个子数组是可整合的而且最长, 返回最长长度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386935-72cadf66-19f6-4562-b619-f95e67f91c55.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=212&amp;id=u6cceb4e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=694&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4089eb32-f3bb-4b90-9c15-e35b315eb17&amp;title=&amp;width=491" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386866-d20c76bd-4969-4bce-ad9b-c784eb6a76a2.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=224&amp;id=u7df7ee5c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=387&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua502ac2b-174e-47d6-b4d4-4187fa647f2&amp;title=&amp;width=521" alt=""><br>不能排序<br>因为他问的就是你原始arr的数据状况，最长可整合子数组是啥？<br>排完序0,1,2原数组没有这个子数组<br>原数据状况是不能够动的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387154-7c295c6a-1838-45a2-ae75-508ced86774f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=320&amp;id=u735cfd92&amp;margin=%5Bobject%20Object%5D&amp;originHeight=451&amp;originWidth=882&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0882a71c-1ed1-4ec5-bce0-e4fbd3b9685&amp;title=&amp;width=625" alt=""><br><strong>题解</strong><br>不能用滑动窗口, 没有单调性<br>因为如果一个窗口是可整合的, 它扩大或缩小不一定可整合<br>子数组范围这件事和可整合这件事建立不起单调性。<br>能用滑动窗口的最重要的性质就是某种范围上的单调性<br>子数组范围扩大了，或者子数组范围缩小了，对于可整合的东西，<br>它是有一定的单调性的，我菜可以去利用，而本题是没有的。<br>所以滑动窗口也用不了。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387319-f3df4fef-b417-4636-bfc4-b098e97ad628.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=325&amp;id=u07077d33&amp;margin=%5Bobject%20Object%5D&amp;originHeight=483&amp;originWidth=738&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6d45fb4c-a596-4283-a50a-b3b83d3dd28&amp;title=&amp;width=496" alt=""><br><strong>暴力解:</strong><br>枚举所有子数组<br>比如说我验证从L到R这一段是不是可整合的,<br>可以把它拷贝出来, 拍完序再验证是不是可整合的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387425-c3b5c57f-08b3-4119-a9d3-65813f51fc17.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=307&amp;id=uf7a760b5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=435&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u83b81b1d-d7d6-49c7-ac07-77c4d2696e1&amp;title=&amp;width=636" alt=""><br><strong>复杂度</strong><br>子数组数量O(N^2), 子数组平均长度N<br>把子数组拷贝一下O(N), 子数组排序O(N<em>logN), 排序后的验证O(N)<br>取最高阶O(N</em>logN), 最终复杂度O(N^3<em>logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387470-931d4e55-faee-4d65-aaf2-82ec28e91d09.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=332&amp;id=u9026a328&amp;margin=%5Bobject%20Object%5D&amp;originHeight=496&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89e7ad6f-b03b-4734-b328-39d568514d8&amp;title=&amp;width=625" alt=""><br><em>*重新定义可整合数组标准！！！</em></em><br>1) 没有重复值<br>2) 数组最大值-最小值=个数-1<br>满足这两个条件就是可整合数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387491-c2cc6771-68b6-4a63-a0ab-83e7c4f0ed43.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u4220dfc8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=965&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u23575989-4df0-4efb-a468-212b66ddbef&amp;title=&amp;width=532" alt=""><br>简化的过程</p><p>| <strong>public static int </strong>maxLen<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>N = arr.<strong>length</strong>;<br>   HashSet<strong>&lt;</strong>Integer<strong>&gt; </strong>set = <strong>new </strong>HashSet<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>ans = 1;//答案至少是1<br>   <strong>for (int </strong>L = 0; L &lt; N; L++<strong>) {      </strong>set.clear<strong>()</strong>;//因为r要归为<br>      <strong>int </strong>min = arr<strong>[</strong>L<strong>]</strong>;<br>      <strong>int </strong>max = arr<strong>[</strong>L<strong>]</strong>;<br>      set.add<strong>(</strong>arr<strong>[</strong>L<strong>])</strong>;<br>      // L..R<br>      <strong>for (int </strong>R = L + 1; R &lt; N; R++<strong>) {         </strong>// L….R<br>         <strong>if(</strong>set.contains<strong>(</strong>arr<strong>[</strong>R<strong>])) {<br>            break</strong>;<br>         <strong>}         </strong>set.add<strong>(</strong>arr<strong>[</strong>R<strong>])</strong>;<br>         min = Math.min<strong>(</strong>min, arr<strong>[</strong>R<strong>])</strong>;//可能r的值更小<br>         max = Math.max<strong>(</strong>max, arr<strong>[</strong>R<strong>])</strong>;//也可能r的值更大<br>         //个数：R-L+1,再减个1<br>         <strong>if(</strong>max - min == R - L<strong>) {            </strong>ans = Math.max<strong>(</strong>ans, R - L + 1<strong>)</strong>;<br>         <strong>}<br>      }<br>   }<br>   return </strong>ans;</p><p><strong>}</strong> |<br>| —- |</p><p><strong>总结: 改题目的设定让它变得更简洁</strong><br>就是当你发现，比如说面试场上给了你一道题，它的定义部分让你求解的部分是如此之复杂。<br>你不要硬着头皮，就按照他的说法就硬上了，你要改成你自己的定义。比如说我们把这个就<br>拆分成了系统最大值减两头这样一个问题，把可整合数组重新写了定义之后，能让我们验证<br>可整合这个过程变快，这种就属于在面试场上遇到了一类，它给你来一个设定，但是你要改<br>它的设定让它变得更简洁的。要有这个心眼，你发现这道题目设定的部分写得特别的绕。<br>那说明它可能不够简洁，这时要有一个心眼，就是要改设定。这样改设定的题型很多，<br>我们以后遇到再说。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532543649-53d3de55-8561-4ff0-add7-817357bd81ac.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=u7ad3e556&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=1002&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ce4aaab-9297-47d3-9ce8-fbaa226b91f&amp;title=&amp;width=474" alt=""></p><h2 id="·-✊超级水王问题"><a href="#·-✊超级水王问题" class="headerlink" title="· ✊超级水王问题"></a>· ✊超级水王问题</h2><p><strong>题意</strong><br>我给你个数组，如果有水王数你打印出来，如果无水王数，你告诉用户没有<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564573-18f0aae5-4c48-4583-a5fc-908f05f918aa.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ub63ef09a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=475&amp;originWidth=946&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueb3f9d95-2385-4717-ab8a-502c4ce9c0f&amp;title=&amp;width=489" alt=""><br>要求时间复杂度O(N)<br>空间复杂度O(1)<br>把用hash表的路堵死了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564812-7f6017f2-4972-4dde-b65e-5065ad21c9b5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=ua3b9fe6a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=455&amp;originWidth=963&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u345c305d-94e0-4908-a782-ea6311d8772&amp;title=&amp;width=533" alt=""><br><strong>题解</strong><br>一次删掉两个不同值的数, 如果arr中真的有水王的话, 这个水王数一定会剩下来<br>因为水王数是大于一半的次数的。哪怕其它所有的数字都跟水王数为敌<br>水王数也会活下来, 更不用说其它数字之间还会有内战的情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564621-4c4d07c4-1905-4d22-8161-ba7827127276.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=220&amp;id=ud9c14c93&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uac5cb9f7-4ed2-4d56-99bd-234e14ca061&amp;title=&amp;width=470" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564724-40df89be-6e7c-479d-b755-0479f9168ce6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1df2e5b3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=144&amp;originWidth=382&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u94cefb0a-39fc-4749-88dc-a340c7f447b&amp;title=" alt=""><br>arr一次删掉两个不同的数, 最后剩下的数一定是水王吗?<br>不一定是水王<br>如果有水王的话, 一定会剩下来<br>如果没有水王的话, 如果剩下来的数都不是水王，那就没有数是了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564674-454bc6b4-a8ff-479c-938b-e6e9a24a390d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua49eec8c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=143&amp;originWidth=421&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1cb3b4b7-b9f8-4379-a900-ef09a62f703&amp;title=" alt=""><br><strong>思路</strong><br>1) arr 一次删除两个不同值的数, 看最终谁会剩下来</p><p>可能性<br>1: 没有数字剩下来: 无水王数<br>2: 有数剩下来<br>x剩下来, 再遍历看x真实出现的次数跟N/2对比</p><p><strong>怎么一次删除两个不同的数?</strong><br>时间复杂度O(N)<br>空间复杂度O(1)<br>两个变量<br>1) 候选cand<br>2) 血量hp<br>当血量=0, 认为没有候选人<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565245-13d042e9-15ce-451f-9d00-22fb6b8c37eb.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u22eda463&amp;margin=%5Bobject%20Object%5D&amp;originHeight=431&amp;originWidth=1026&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua04fdaf1-7f3e-4a6d-9286-dad2914a968&amp;title=&amp;width=542" alt=""><br><strong>流程</strong><br>一个一个数遍历, 三条规则:<br>1) 如果没有候选, 当前数立为候选, 血量+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565228-0cb5c6f0-77d1-4a27-9618-82f95127135e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=u3e918b1a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=399&amp;originWidth=1021&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8d87f13b-7fc7-4e50-aa59-77782c0c05d&amp;title=&amp;width=585" alt=""><br>2) 如果有候选<br>    1)当前数跟候选不一样,血量—<br>    2)当前数是候选,血量++<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565221-c7dde5a0-148c-4fc2-9ce8-9c33a38b526a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u9c9600a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=1032&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c27cf79-9f62-4684-95ac-0cb1bb50623&amp;title=&amp;width=571" alt=""><br>解释</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565427-1f53495a-7f90-4a2e-b08b-43af2f9f0147.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=296&amp;id=u1cb7e569&amp;margin=%5Bobject%20Object%5D&amp;originHeight=506&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf9fba9e6-c81e-4f75-a1bc-54ac7326b4d&amp;title=&amp;width=592" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565702-b20446ee-a34b-4303-85dc-18bfb790a1ab.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=u81618e25&amp;margin=%5Bobject%20Object%5D&amp;originHeight=497&amp;originWidth=1022&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua102ae15-5ac8-4490-a8d4-6d41c0048d7&amp;title=&amp;width=623" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565738-f2a9bd97-215c-4362-9d4d-23af8dc985b1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=305&amp;id=u9538e7a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=1009&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u72d5eca0-0819-455a-bb9a-c4de485e2ab&amp;title=&amp;width=634" alt=""><br>遍历完成后,如果血量=0,表示什么数也没有剩下来,如果血量不等于零，候选就是剩下来的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565794-847db360-2964-4094-8ffe-a086883180e7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=u676fec88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=904&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e114edf-2d28-4477-a82d-92b2a494048&amp;title=&amp;width=634" alt=""><br><strong>代码</strong></p><p>| <strong>public static void </strong>printHalfMajor<strong>(int[] </strong>arr<strong>) {<br>   int </strong>cand = 0;<br>   <strong>int </strong>HP = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>HP == 0<strong>) {         </strong>cand = arr<strong>[</strong>i<strong>]</strong>;<br>         HP = 1;<br>      <strong>} else if (</strong>arr<strong>[</strong>i<strong>] </strong>== cand<strong>) {         </strong>HP++;<br>      <strong>} else {         </strong>HP—;<br>      <strong>}<br>   }<br>   if(</strong>HP == 0<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“no such number.”)</strong>;<br>      <strong>return</strong>;<br>   <strong>}   </strong>HP = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>== cand<strong>) {         </strong>HP++;<br>      <strong>}<br>   }<br>   if (</strong>HP &gt; arr.<strong>length </strong>/ 2<strong>) {      </strong>System.<strong>out</strong>.println<strong>(</strong>cand<strong>)</strong>;<br>   <strong>} else {      </strong>System.<strong>out</strong>.println<strong>(“no such number.”)</strong>;<br>   <strong>}<br>}</strong> |<br>| —- |</p><p><strong>扩展</strong><br>给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N/K，打印这些数，如果没有不打印</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692268-ec19fdb8-d919-4ff4-989b-a9441d09217c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u794e348d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=467&amp;originWidth=904&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c744658-4ae3-453a-95bc-6b4354a53a7&amp;title=&amp;width=532" alt=""><br>至多K-1个出现N/K次的数（假设k = 2，至多只有一个数字）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692364-02aa48c0-9e3a-4054-aaa4-0a8176783fbc.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=u7c355bf8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=480&amp;originWidth=820&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u22b99e23-11f2-4517-ad75-24ab4f0e7ac&amp;title=&amp;width=477" alt=""><br><strong>例子</strong><br>K=4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692393-908c6f08-2bfa-4465-812d-6007cce170df.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=udfebc94e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=919&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c9dd817-5300-40b5-818b-31b809878ad&amp;title=&amp;width=563" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692292-a6252411-18f3-4e51-a21c-65ab7d2fe782.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=281&amp;id=uc29f6c64&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=907&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udfc00b4d-da71-4486-92cc-4c1ec0d3bb6&amp;title=&amp;width=521" alt=""><br>4来了, 所有人-1点血量<br>血量是0不要, 删掉, 一次删掉了4个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692349-175242d0-ebac-4c64-8c62-f814f64470dd.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u59831a71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=603&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub7fa5c34-2c6b-4a84-8c3a-dac5f6647df&amp;title=" alt=""><br><strong>代码</strong><br>必须验证真实次数<br>候选有什么，也不代表它就代表唯一考虑的集合<br>但它是不是, 不收集真实次数没人知道</p><p>| <strong>public static void </strong>printKMajor<strong>(int[] </strong>arr, <strong>int </strong>K<strong>) {<br>   if (</strong>K &lt; 2<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“the value of K is invalid.”)</strong>;<br>      <strong>return</strong>;<br>   <strong>}   </strong>// 攒候选，cands，候选表，最多K-1条记录！ &gt; N / K次的数字，最多有K-1个<br>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>cands = <strong>new </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt;()</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>cands.containsKey<strong>(</strong>arr<strong>[</strong>i<strong>])) {         </strong>cands.put<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, cands.get<strong>(</strong>arr<strong>[</strong>i<strong>]) </strong>+ 1<strong>)</strong>;<br>      <strong>} else { </strong>// arr[i] 不是候选<br>         <strong>if (</strong>cands.size<strong>() </strong>== K - 1<strong>) { </strong>// 当前数肯定不要！，每一个候选付出1点血量，血量变成0的候选，要删掉！<br>            allCandsMinusOne<strong>(</strong>cands<strong>)</strong>;<br>         <strong>} else {            </strong>cands.put<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, 1<strong>)</strong>;<br>         <strong>}<br>      }<br>   }   </strong>// 所有可能的候选，都在cands表中！遍历一遍arr，每个候选收集真实次数</p><p>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>reals = getReals<strong>(</strong>arr, cands<strong>)</strong>;<br>   <strong>boolean </strong>hasPrint = <strong>false</strong>;<br>   <strong>for (</strong>Entry<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>set : cands.entrySet<strong>()) {      </strong>Integer key = set.getKey<strong>()</strong>;<br>      <strong>if (</strong>reals.get<strong>(</strong>key<strong>) </strong>&gt; arr.<strong>length </strong>/ K<strong>) {         </strong>hasPrint = <strong>true</strong>;<br>         System.<strong>out</strong>.print<strong>(</strong>key + <strong>“ “)</strong>;<br>      <strong>}<br>   }   </strong>System.<strong>out</strong>.println<strong>(</strong>hasPrint ? <strong>“” </strong>: <strong>“no such number.”)</strong>;<br>**}</p><p>public static void <strong>allCandsMinusOne</strong>(<strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>map</strong>) {<br>   <strong>List</strong>&lt;<strong>Integer</strong>&gt; <strong>removeList = </strong>new <strong>LinkedList</strong>&lt;<strong>Integer</strong>&gt;()<strong>;   </strong>for (<strong>Entry</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>set : map.entrySet</strong>()) {<br>      <strong>Integer key = set.getKey</strong>()<strong>;<br>      Integer value = set.getValue</strong>()<strong>;      </strong>if (<strong>value == 1</strong>) {<br>         <strong>removeList.add</strong>(<strong>key</strong>)<strong>;      </strong>}<br>      <strong>map.put</strong>(<strong>key, value - 1</strong>)<strong>;   </strong>}<br>   for (<strong>Integer removeKey : removeList</strong>) {<br>      <strong>map.remove</strong>(<strong>removeKey</strong>)<strong>;   </strong>}<br>}</p><p>public static <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>getReals</strong>(int[] <strong>arr,<br>      HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>cands</strong>) {<br>   <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>reals = </strong>new <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt;()<strong>;   </strong>for (int <strong>i = 0; i != arr.</strong>length<strong>; i++</strong>) {<br>      int <strong>curNum = arr</strong>[<strong>i</strong>]<strong>;      </strong>if (<strong>cands.containsKey</strong>(<strong>curNum</strong>)) {<br>         if (<strong>reals.containsKey</strong>(<strong>curNum</strong>)) {<br>            <strong>reals.put</strong>(<strong>curNum, reals.get</strong>(<strong>curNum</strong>) <strong>+ 1</strong>)<strong>;         </strong>} else {<br>            <strong>reals.put</strong>(<strong>curNum, 1</strong>)<strong>;         </strong>}<br>      }<br>   }<br>   return <strong>reals;</strong>}** |<br>| —- |</p><h2 id="·-✊第k小的数值对"><a href="#·-✊第k小的数值对" class="headerlink" title="· ✊第k小的数值对"></a>· ✊第k小的数值对</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533451839-1dcc4f86-8175-4b98-bb2d-33fab076095b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=ucc6bd1e8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=231&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43310&amp;status=done&amp;style=none&amp;taskId=udbf48c7b-c5c2-41b0-807a-c792b021443&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题解</strong><br><strong>暴力解</strong><br>两个for循环生成所有数值对, 放到数组里用比较器排序, 取出第K位的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574288-932f369b-6665-4975-870e-8d798fe5b12a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=ue3aaa206&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1081&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1fb1f388-552d-4f2a-a109-a817c3ba4b9&amp;title=&amp;width=604" alt=""><br>复杂度 O(N^2<em>logN^2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574337-82315d0f-95c8-492b-9c77-3fc02ea2091e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=u7073562e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1147&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6c9f817e-0dab-474c-857c-d4fef6c040a&amp;title=&amp;width=655" alt=""><br><strong>最优解</strong><br>最优解复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574399-0f80a80f-e29a-446a-91ed-6eb65d947887.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ud6983707&amp;margin=%5Bobject%20Object%5D&amp;originHeight=323&amp;originWidth=806&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u84b6d280-143f-4d10-abd7-57f845288b9&amp;title=&amp;width=626" alt=""><br><em>*过程</em></em><br>根据第一维数据进行分组<br>第一维的数字是1的叫第1组里的数值对<br>第一维的数字是2的叫第2组里的数值对<br>第一维的数字是3的叫第3组里的数值对<br>第一维的数字是5的叫第4组里的数值对<br>大体上分块就这么多块<br>想知道第70个数是哪个数值对里的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574353-1821c432-0685-4133-b7b9-be12b0b00a2f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaf4e4a03&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=1148&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ded78e1-5092-4773-9c69-8dd1d9d867c&amp;title=" alt=""><br>假设第70个数是(a,b)这两维数据, 先定位a是谁, 数组长度是11<br>必须以0位置的1做为第一维数据的一共有11个<br>必须以1位置的1做为第一维数据的一共有11个<br>必须以2位置的1做为第一维数据的一共有11个<br>必须以3位置的2做为第一维数据的一共有11个<br>所以你想求第 70 个怎么定位这个a？你就看看它是哪一组里的, 说明它第一维就是那个位置的数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574305-dac448dc-7170-485a-a101-f723d251e819.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ueab68af7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=407&amp;originWidth=1136&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u052e5313-afe0-43a7-8a72-428388a3bf1&amp;title=" alt=""><br>定位70是哪一组里的,<br>第70个数来自于3的组, 第一维数据是3<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575227-31b8ed61-55a5-4dfe-9627-7c7149d896d6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1a4f9244&amp;margin=%5Bobject%20Object%5D&amp;originHeight=540&amp;originWidth=1133&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucf6b52e7-70e5-4015-a29f-6c52f65ea6e&amp;title=" alt=""><br>怎么得到b<br>b肯定是3组里的数值对,<br>3之前一共搞定了55个, 所以你要第 70 个，它应该是三大组中的第 15 个。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575288-74bcd08a-9b14-434a-8bff-c504f8dabde3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=ufa15bced&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2db97466-6de6-4213-9d9d-840e2b29949&amp;title=&amp;width=635" alt=""><br>3大组中再细分,<br>必须以0位置的1做二维数据的有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575449-630237a5-8e4c-44e5-8adf-02ebd9c41cf7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u2e30a4fd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=1129&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uca568bff-376a-4bb3-812f-4b3fa039d94&amp;title=&amp;width=527" alt=""><br>相求3大组中的第15个, 一共有4个3, 所以<br>必须0位置的1做第二维数据的, 4个<br>必须1位置的1做第二维数据的,4个<br>必须2位置的1做第二维数据的,4个<br>必须3位置的2做第二维数据的,4个<br>看看这第15个来自那一组, 就可以定位第二维的数字来自哪儿了</p><p><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575700-2e9c1dc6-1c5a-434e-8f4a-34e244c6162e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=239&amp;id=ue603987f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=390&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u494d13cd-e862-4e22-a402-187828b9bf6&amp;title=&amp;width=689" alt=""><br>第一维的数字是4<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575882-6c7e9e5d-1b94-4951-841f-d623a6840864.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=322&amp;id=udeef2653&amp;margin=%5Bobject%20Object%5D&amp;originHeight=542&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u06579f25-1baa-49c4-81f0-bda6a471bfc&amp;title=&amp;width=667" alt=""><br>1,2,3开头的一共有70个<br>第一维是4的情况下,<br>4里的12<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576014-43be7fca-337b-4cbf-9dd6-ac93d054933f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6ae98023&amp;margin=%5Bobject%20Object%5D&amp;originHeight=542&amp;originWidth=1126&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufe456ad6-a016-4ec4-9226-9d0d844b402&amp;title=" alt=""><br>4的组细分<br>第二维数字是1,2,3,4的那些<br>第一维数字是 4 的情况下再往下细分组是啥?<br>第二维数据是 1 的那些<br>第二维数据是 2 的那些<br>第二维数据是 3 的那些<br>第二维数据是 4 的那些</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576961-4018a1d4-8795-402b-ad61-9094ebaf856f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=uc4ab67a7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=556&amp;originWidth=1135&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub026b4b3-619a-4a77-a4a5-ae1fc99b04f&amp;title=&amp;width=629" alt=""><br>第一维的数字已经确实是4了<br>第二维数据是 1 的那些分为<br>0位置的1做第二维的数据, 3个, 7,8,9位置的4都是<br>1位置的1做第二维的数据, 3个, 7,8,9位置的4都是</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577008-8175b831-2b92-4719-bc9c-ea5b8bf3434e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=372&amp;id=u8e3187a1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=547&amp;originWidth=873&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2f6ca15-0d35-46b9-be0d-6928f79b21f&amp;title=&amp;width=594" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576966-c18e528a-b6b0-4d36-b9ad-54ce913287a5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u2b5ae72a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1121&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uee646ef9-bab2-4946-9ef3-cdd53fb4f48&amp;title=&amp;width=627" alt=""><br><strong>抽象化</strong><br>假设一共有N个数,求第K小数值对<br>怎么定位第一维数据?<br>K/N的下标对应的值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577141-db303288-f81d-47eb-a691-3490f7349eeb.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u855fa134&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8076f660-ae44-4486-a8c9-004532ef1a2&amp;title=&amp;width=563" alt=""><br>边界考虑<br>第一维数字的下标<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577309-cb5440cc-ec6c-42d0-a207-c3f531c35f16.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u3731a3d1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=530&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue81e3ddb-626b-4ef0-b035-e2b5239cb4e&amp;title=&amp;width=508" alt=""><br>无序数组中找到第k小, bfprt<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577557-ad44f93d-e7d0-4003-ba23-3ae7897ccd42.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ud35ec140&amp;margin=%5Bobject%20Object%5D&amp;originHeight=557&amp;originWidth=1120&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u38e4bc18-5977-4562-9d02-123c3e64abe&amp;title=&amp;width=545" alt=""><br><strong>怎么定义第二维数字</strong><br>你必须数一下小于 7 的数字有几个你才能知道前面做的一位数字的组帮你搞定了几个，<br>然后拿k减去它才是属于7的组，在第一位数字是 7 的情况下，在这个内部组里面我是第几个呢？<br>这事怎么求?<br>你必须数一下前面小于 7 的数字有几个</p><p><strong>代码 </strong><br>必须搞清楚的第一维数字小于 5 的，之前的数字有几个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577715-e66d1dd1-8985-476f-a263-11335040c1ba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u9c8a0bcd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=1044&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uedae6774-6831-4395-9c5d-11ba2520332&amp;title=&amp;width=551" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577892-e34c0223-de0d-4c47-88cc-c15cd07653ef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=301&amp;id=uc48d9a27&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1134&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u939b5448-34f1-459a-a8cb-f98e841f015&amp;title=&amp;width=631" alt=""></p><p>| <strong>public static class </strong>Pair <strong>{<br>   public int x</strong>;<br>   <strong>public int y</strong>;</p><p>   Pair<strong>(int </strong>a, <strong>int </strong>b<strong>) {<br>      x </strong>= a;<br>      <strong>y </strong>= b;<br>   **}<br>}</p><p>public static class <strong>PairComparator </strong>implements <strong>Comparator</strong>&lt;<strong>Pair</strong>&gt; {</p><p>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Pair arg0, Pair arg1</strong>) {<br>      return <strong>arg0.</strong>x <strong>!= arg1.</strong>x <strong>? arg0.</strong>x <strong>- arg1.</strong>x <strong>: arg0.</strong>y <strong>- arg1.</strong>y<strong>;   </strong>}</p><p>}</p><p><strong>// O(N^2 * log (N^2))的复杂度，你肯定过不了<br>// 返回的int[] 长度是2，{3,1} int[2] = [3,1]</strong>public static int[] <strong>kthMinPair1</strong>(int[] <strong>arr, </strong>int <strong>k</strong>) {<br>   int <strong>N = arr.</strong>length<strong>;   </strong>if (<strong>k &gt; N * N</strong>) {<br>      return null<strong>;   </strong>}<br>   <strong>Pair</strong>[] <strong>pairs = </strong>new <strong>Pair</strong>[<strong>N * N</strong>]<strong>;   </strong>int <strong>index = 0;   </strong>for (int <strong>i = 0; i &lt; N; i++</strong>) {<br>      for (int <strong>j = 0; j &lt; N; j++</strong>) {<br>         <strong>pairs</strong>[<strong>index++</strong>] <strong>= </strong>new <strong>Pair</strong>(<strong>arr</strong>[<strong>i</strong>]<strong>, arr</strong>[<strong>j</strong>])<strong>;      </strong>}<br>   }<br>   <strong>Arrays.sort</strong>(<strong>pairs, </strong>new <strong>PairComparator</strong>())<strong>;   </strong>return new int[] { <strong>pairs</strong>[<strong>k - 1</strong>]<strong>.</strong>x<strong>, pairs</strong>[<strong>k - 1</strong>]<strong>.</strong>y }<strong>;</strong>}</p><p>** |<br>| —- |</p><p>| // O(N<em>logN)的复杂度，你肯定过了<br><strong>public static int[] </strong>kthMinPair2<strong>(int[] </strong>arr, <strong>int </strong>k<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>if (</strong>k &gt; N </em> N<strong>) {<br>      return null</strong>;<br>   <strong>}   </strong>// O(N<em>logN)<br>   Arrays.sort<strong>(</strong>arr<strong>)</strong>;<br>   // 第K小的数值对，第一维数字，是什么 是arr中<br>   <strong>int </strong>fristNum = arr<strong>[(</strong>k - 1<strong>) </strong>/ N<strong>]</strong>;<br>   <strong>int </strong>lessFristNumSize = 0;// 数出比fristNum小的数有几个<br>   <strong>int </strong>fristNumSize = 0; // 数出==fristNum的数有几个<br>   // &lt;= fristNum<br>   <strong>for (int </strong>i = 0; i &lt; N &amp;&amp; arr<strong>[</strong>i<strong>] </strong>&lt;= fristNum; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&lt; fristNum<strong>) {         </strong>lessFristNumSize++;<br>      <strong>} else {         </strong>fristNumSize++;<br>      <strong>}<br>   }<br>   int </strong>rest = k - <strong>(</strong>lessFristNumSize </em> N<strong>)</strong>;<br>   <strong>return new int[] { </strong>fristNum, arr<strong>[(</strong>rest - 1<strong>) </strong>/ fristNumSize<strong>] }</strong>;<br><strong>}</strong> |<br>| —- |</p><p>| // O(N)的复杂度，你肯定蒙了<br><strong>public static int[] </strong>kthMinPair3<strong>(int[] </strong>arr, <strong>int </strong>k<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>if (</strong>k &gt; N <em> N<strong>) {<br>      return null</strong>;<br>   <strong>}   </strong>// 在无序数组中，找到第K小的数（k表示下标），返回值<br>   // 第K小，以1作为开始<br>   <strong>int </strong>fristNum = getMinKth<strong>(</strong>arr, <strong>(</strong>k - 1<strong>) </strong>/ N<strong>)</strong>;<br>   // 第1维数字<br>   <strong>int </strong>lessFristNumSize = 0;<br>   <strong>int </strong>fristNumSize = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&lt; fristNum<strong>) {         </strong>lessFristNumSize++;<br>      <strong>}<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>== fristNum<strong>) {         </strong>fristNumSize++;<br>      <strong>}<br>   }   </strong>//切记不能死记硬背<br>   /*</em></p><pre><code>*  2 1 5 3 6 5 4 7 2 长度为9 求K = 58*  1 2 2 3 4 5 5 6 7   firstNum = 5(第6小的数)*  rest = 58 - 45 = 13*/</code></pre><p>   <strong>int </strong>rest = k - <strong>(</strong>lessFristNumSize <em> N<strong>)</strong>;<br>   System.<strong>out</strong>.println<strong>(“rest = “ </strong>+ rest<strong>)</strong>;<br>   <strong>return new int[] { </strong>fristNum, getMinKth<strong>(</strong>arr, <strong>(</strong>rest - 1<strong>) </strong>/ fristNumSize<strong>) }</strong>;<br>*</em>}</p><p><strong>// 改写快排，时间复杂度O(N)<br>// 在无序数组arr中，找到，如果排序的话，arr[index]的数是什么？</strong>public static int <strong>getMinKth</strong>(int[] <strong>arr, </strong>int <strong>index</strong>) {<br>   int <strong>L = 0;   </strong>int <strong>R = arr.</strong>length <strong>- 1;   </strong>int <strong>pivot = 0;   </strong>int[] <strong>range = </strong>null<strong>;   </strong>while (<strong>L &lt; R</strong>) {<br>      <strong>pivot = arr</strong>[<strong>L + </strong>(int) (<strong>Math.random</strong>() <strong>* </strong>(<strong>R - L + 1</strong>))]<strong>;<br>      range = partition</strong>(<strong>arr, L, R, pivot</strong>)<strong>;      </strong>if (<strong>index &lt; range</strong>[<strong>0</strong>]) {<br>         <strong>R = range</strong>[<strong>0</strong>] <strong>- 1;      </strong>} else if (<strong>index &gt; range</strong>[<strong>1</strong>]) {<br>         <strong>L = range</strong>[<strong>1</strong>] <strong>+ 1;      </strong>} else {<br>         return <strong>pivot;      </strong>}<br>   }<br>   return <strong>arr</strong>[<strong>L</strong>]<strong>;</strong>}</p><p>public static int[] <strong>partition</strong>(int[] <strong>arr, </strong>int <strong>L, </strong>int <strong>R, </strong>int <strong>pivot</strong>) {<br>   int <strong>less = L - 1;   </strong>int <strong>more = R + 1;   </strong>int <strong>cur = L;   </strong>while (<strong>cur &lt; more</strong>) {<br>      if (<strong>arr</strong>[<strong>cur</strong>] <strong>&lt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, ++less, cur++</strong>)<strong>;      </strong>} else if (<strong>arr</strong>[<strong>cur</strong>] <strong>&gt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, cur, —more</strong>)<strong>;      </strong>} else {<br>         <strong>cur++;      </strong>}<br>   }<br>   return new int[] { <strong>less + 1, more - 1 </strong>}<strong>;</strong>}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-数组能不能分成4个相等的部分"><a href="#·-数组能不能分成4个相等的部分" class="headerlink" title="· 数组能不能分成4个相等的部分"></a>· 数组能不能分成4个相等的部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533468062-870ee3db-9ba1-438d-bfba-f1f0eaca5b6e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=139&amp;id=u21da3700&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=174&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31102&amp;status=done&amp;style=none&amp;taskId=u552b24ea-96ee-414d-8b28-0f5ce24cea0&amp;title=&amp;width=456.8" alt="image.png"><br><strong>题意</strong><br>N&gt;=7, 正数数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471540-fc6df3a7-1744-4cd5-abf5-c52f0a31e14f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=u3c662ee6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=302&amp;originWidth=808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u91f5bb87-ba17-433f-954d-94343906014&amp;title=&amp;width=508" alt=""><br>你能不能切出四个部分，让四个部分累加和一样。但是切掉的数字是不算的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471734-ee7c3286-54dc-49c0-9841-5a6297def955.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=ucc6800d7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u02fc3a3e-8ed3-4c74-9bd3-99e837f2411&amp;title=&amp;width=578" alt=""><br><strong>题解</strong><br>做出前缀和数组, 假设来到i位置, 想问<br>i位置做第一刀的情况下有没有可能切出4个部分累加和一样<br><strong>例子</strong><br>找209的前缀和<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471524-5d3a4faa-2313-4e57-b4a0-f8c9f5f4cd8b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=u24736741&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=651&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b0e8c1c-ddc2-4fac-829c-3118343a3af&amp;title=&amp;width=483" alt=""><br>14位置是第二刀<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471485-660cacba-56bd-4b13-a478-cf66a91eec8a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=240&amp;id=uf0101aab&amp;margin=%5Bobject%20Object%5D&amp;originHeight=433&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae1dd84f-46f8-46f8-af79-6a3c3d93766&amp;title=&amp;width=541" alt=""><br>验证7位置能不能第一刀, O(1), 然后验证每一个位置做为第一刀, 就可以了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471488-436b2399-5728-40d0-8da9-e1a64ed33a89.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u97f20565&amp;margin=%5Bobject%20Object%5D&amp;originHeight=475&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6f84d7de-0496-43f3-a6c5-e1cb29a148d&amp;title=" alt=""></p><p><strong>代码</strong></p><p>| <strong>public static boolean </strong>canSplits2<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>&lt; 7<strong>) {<br>      return false</strong>;<br>   <strong>}   </strong>// key 某一个累加和， value出现的位置<br>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt;()</strong>;<br>   <strong>int </strong>sum = arr<strong>[</strong>0<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>map.put<strong>(</strong>sum, i<strong>)</strong>;<br>      sum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   int </strong>lsum = arr<strong>[</strong>0<strong>]</strong>; // 第一刀左侧的累加和<br>   <strong>for (int </strong>s1 = 1; s1 &lt; arr.<strong>length </strong>- 5; s1++<strong>) { </strong>// s1是第一刀的位置<br>      <strong>int </strong>checkSum = lsum <em> 2 + arr<strong>[</strong>s1<strong>]</strong>; // 100 x 100   100</em>2 + x<br>      <strong>if (</strong>map.containsKey<strong>(</strong>checkSum<strong>)) {<br>         int </strong>s2 = map.get<strong>(</strong>checkSum<strong>)</strong>; // j -&gt; y<br>         checkSum += (lsum + arr<strong>[</strong>s2<strong>])</strong>;<br>         <strong>if (</strong>map.containsKey<strong>(</strong>checkSum<strong>)) { </strong>// 100 <em> 3 + x + y<br>            <strong>int </strong>s3 = map.get<strong>(</strong>checkSum<strong>)</strong>; // k -&gt; z<br>            <strong>if (</strong>checkSum + (arr<strong>[</strong>s3<strong>] </strong>+ lsum) == sum<strong>) {<br>               return true</strong>;<br>            <strong>}<br>         }<br>      }      </strong>lsum += arr<strong>[</strong>s1<strong>]</strong>;<br>   <strong>}<br>   return false</strong>;<br><em>*}</em></em> |<br>| —- |</p><h2 id="·-✊316-去除重复字母-M"><a href="#·-✊316-去除重复字母-M" class="headerlink" title="· ✊316. 去除重复字母  [M]"></a>· ✊316. 去除重复字母  [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533504865-a0411f35-f468-4fe7-ba62-98a6ffb066a1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=322&amp;id=udc341fe0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=402&amp;originWidth=828&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32042&amp;status=done&amp;style=none&amp;taskId=u83a362da-6605-45be-b799-61f01d3e0bb&amp;title=&amp;width=662.4" alt="image.png"><br><strong>题意</strong><br>每种字符只保留一个, 请你返回字典序最小的结果<br>相对次序不能乱<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940519-92d4b450-75f4-4738-b2fc-d448dabee78d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=uc3a5dde1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=393&amp;originWidth=973&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7ea7df2e-ecc2-4679-8640-20a95c7d97c&amp;title=&amp;width=502" alt=""><br><strong>题解</strong><br>先建立词频统计表, 从左往右划线, 划线的词从词频表里删除</p><p>我如果在这线里面，这条线代表啥意思，我如果要选保留的第一个字符的话，我只能在这条线里选，<br>不能够再把右侧的字符考虑进来了。<br>当我决定保留一个字符的时候，我保留这个字符的同时，左侧字符全不要, 右侧字符可以继续选，<br>我在后面的字符里再选一个字符Y，那么 Y 左边的字符就不能再选了，在后面继续选，这是我的主流程。<br>选ascii码最小的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940426-5bd3de48-60bb-4186-b3f0-dafc220489fd.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=uec914f16&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=931&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d28ade0-97a0-4e57-8028-5f5f382ea6d&amp;title=&amp;width=598" alt=""><br>因为如果我这个 C 作为我保留第一个字符的话，后面就没 A 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940449-8ead876f-9228-42c5-9a3a-9e1da7419ba8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u7b220aee&amp;margin=%5Bobject%20Object%5D&amp;originHeight=498&amp;originWidth=918&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueb18526a-30cb-44be-9a19-beabfa28a43&amp;title=&amp;width=586" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940483-a32ca227-5889-422a-a8a6-b692068da001.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u476f8fde&amp;margin=%5Bobject%20Object%5D&amp;originHeight=343&amp;originWidth=861&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua441ad0d-c491-4083-8559-fa70fc38f5b&amp;title=&amp;width=550" alt=""><br><strong>代码</strong></p><p>| //递归版本： 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回<br><strong>public static </strong>String removeDuplicateLetters1<strong>(</strong>String str<strong>) {<br>   if (</strong>str == <strong>null </strong>&#124;&#124; str.length<strong>() </strong>&lt; 2<strong>) {<br>      return </strong>str;<br>   <strong>}<br>   int[] </strong>map = <strong>new int[</strong>256<strong>]</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; str.length<strong>()</strong>; i++<strong>) {      </strong>map<strong>[</strong>str.charAt<strong>(</strong>i<strong>)]</strong>++;<br>   <strong>}<br>   int </strong>minACSIndex = 0;<br>   <strong>for (int </strong>i = 0; i &lt; str.length<strong>()</strong>; i++<strong>) {      </strong>minACSIndex = str.charAt<strong>(</strong>minACSIndex<strong>) </strong>&gt; str.charAt<strong>(</strong>i<strong>) </strong>? i : minACSIndex;<br>      <strong>if (</strong>—map<strong>[</strong>str.charAt<strong>(</strong>i<strong>)] </strong>== 0<strong>) {<br>         break</strong>;<br>      <strong>}<br>   }   </strong>// 0…break(之前) minACSIndex<br>   // str[minACSIndex] 剩下的字符串str[minACSIndex+1…] -&gt; 去掉str[minACSIndex]字符 -&gt; s’<br>   // s’…<br>   <strong>return </strong>String.valueOf<strong>(</strong>str.charAt<strong>(</strong>minACSIndex<strong>)) </strong>+ removeDuplicateLetters1<strong>(         </strong>str.substring<strong>(</strong>minACSIndex + 1<strong>)</strong>.replaceAll<strong>(</strong>String.valueOf<strong>(</strong>str.charAt<strong>(</strong>minACSIndex<strong>))</strong>, <strong>“”))</strong>;<br><strong>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>遍历一遍总会保留一个字符, 而且以后的字符串中是不含有这个字符的。<br>所以你str中如果含有 K 种字符，复杂度就是O(K*N)。这个 K 大写加小写也不就是 52 种字符, 所以O(N)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940987-5cb7a264-d11d-41c0-b9e1-8e61798e55c6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=u7ac43425&amp;margin=%5Bobject%20Object%5D&amp;originHeight=458&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69a4ec90-04ea-41f8-acde-5152dda5a2b&amp;title=&amp;width=586" alt=""></p><h2 id="·-15-三数之和-M"><a href="#·-15-三数之和-M" class="headerlink" title="· 15.三数之和 [M]"></a>· 15.三数之和 [M]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168720-6b744df4-7946-45c9-a331-a2bea7ca808b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u91a5461c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=418&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u47aed55e-205d-42c8-b687-db174d78dfa&amp;title=&amp;width=466" alt=""><br>字面值都不一样，就算不同的，有几个三元组全返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168713-93b17778-7f67-446e-90c9-05862b57e449.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ubaf6ddac&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=964&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u18986bf3-72d6-45ce-9a40-801113f1696&amp;title=&amp;width=440" alt=""><br><strong>题解</strong><br>2sum<br>双指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168718-d3daae68-041e-4709-83d2-24ed9706dcf1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=161&amp;id=u3abbd115&amp;margin=%5Bobject%20Object%5D&amp;originHeight=244&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u13162b89-c8f0-4a19-a91b-a82270cb67d&amp;title=&amp;width=665" alt=""><br><strong>去重复:</strong><br>1) 收集所有二元组, 过滤<br>2) 通过好的流程设计规避重复<br>L移动到下一个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168760-f5557fad-41a1-4981-9a4a-e7b1be9554d8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ue9ce0c40&amp;margin=%5Bobject%20Object%5D&amp;originHeight=471&amp;originWidth=1076&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1155980f-554e-48b9-9513-a53e4dfc988&amp;title=&amp;width=574" alt=""><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168722-ed693ec3-17f3-40db-875b-40df7a3e3bc2.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc9bb16c8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=604&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue3cc0675-8fd4-41a6-82ad-5ab956d174d&amp;title=" alt=""><br><strong>题解</strong><br>你只要保证第1个数字不一样后面就是二元组的问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169245-eb3b0c0f-0f36-4691-9b6d-a4d24f65c0f9.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=ubddc1e46&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9cfee96b-8401-44c4-8bfc-7cbfccc2aa1&amp;title=&amp;width=623" alt=""><br>避免arrayList插到开头的代价有点高, 所以从右往左生成所有的三元组, 把一个数塞在最后<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169284-19a38708-e6da-4a5e-bb4a-20a29232ee3c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u9d26ce66&amp;margin=%5Bobject%20Object%5D&amp;originHeight=520&amp;originWidth=1064&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f65a980-7862-4577-af50-86a27112905&amp;title=&amp;width=614" alt=""><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169425-e3392844-3840-45f1-9ab5-46624ba97638.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue27c0fc3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=278&amp;originWidth=689&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc8ba67a7-38d3-4a72-af12-8e3c795c18e&amp;title=" alt=""></p><p>| <strong>public static </strong>List<List<Integer>&gt; threeSum(<strong>int</strong>[] nums) {<br>   Arrays.<em>sort</em>(nums);<br>   <strong>int </strong>N = nums.<strong>length</strong>;<br>   List<List<Integer>&gt; ans = <strong>new </strong>ArrayList&lt;&gt;();<br>   <strong>for </strong>(<strong>int </strong>i = N - 1; i &gt; 1; i—) { <em>// 三元组最后一个数，是arr[i]   之前….二元组 + arr[i]      </em><strong>if </strong>(i == N - 1 &#124;&#124; nums[i] != nums[i + 1]) {<br>         List<List<Integer>&gt; nexts = <em>twoSum</em>(nums, i - 1, -nums[i]);<br>         <strong>for </strong>(List<Integer> cur : nexts) {<br>            cur.add(nums[i]);<br>            ans.add(cur);<br>         }<br>      }<br>   }<br>   <strong>return </strong>ans;<br>}</p><p><em>// nums[0…end]这个范围上，有多少个不同二元组，相加==target，全返回<br>// {-1,5}     K = 4<br>// {1, 3}</em><strong>public static </strong>List<List<Integer>&gt; twoSum(<strong>int</strong>[] nums, <strong>int </strong>end, <strong>int </strong>target) {<br>   <strong>int </strong>L = 0;<br>   <strong>int </strong>R = end;<br>   List<List<Integer>&gt; ans = <strong>new </strong>ArrayList&lt;&gt;();<br>   <strong>while </strong>(L &lt; R) {<br>      <strong>if </strong>(nums[L] + nums[R] &gt; target) {<br>         R—;<br>      } <strong>else if </strong>(nums[L] + nums[R] &lt; target) {<br>         L++;<br>      } <strong>else </strong>{ <em>// nums[L] + nums[R] == target         </em><strong>if </strong>(L == 0 &#124;&#124; nums[L - 1] != nums[L]) {<br>            List<Integer> cur = <strong>new </strong>ArrayList&lt;&gt;();<br>            cur.add(nums[L]);<br>            cur.add(nums[R]);<br>            ans.add(cur);<br>         }<br>         L++;<br>      }<br>   }<br>   <strong>return </strong>ans;<br>} |<br>| —- |</p><h2 id="·-小朋友排队的最高分数"><a href="#·-小朋友排队的最高分数" class="headerlink" title="· 小朋友排队的最高分数"></a>· 小朋友排队的最高分数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652536502099-7223e529-c2d9-4f8f-a4a9-a6ab1fcd7ad3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=91&amp;id=u6ea2c2e9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=114&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22491&amp;status=done&amp;style=none&amp;taskId=u67386263-86db-4666-a03d-34b0bd10782&amp;title=&amp;width=665.6" alt="image.png"><br>暴力递归，把所有的全排列(N!)搞出来, 分数最大的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537096712-968d9c3d-2f9f-44bc-b6e9-a801cf34a8ba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=330&amp;id=ue4cc4511&amp;margin=%5Bobject%20Object%5D&amp;originHeight=511&amp;originWidth=925&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub1f9f15f-045e-4823-bf05-f159007dd6a&amp;title=&amp;width=597" alt=""></p><p>| <strong>public static int </strong>process<strong>(int[][] </strong>matrix,<strong>int </strong>index,<strong>int </strong>score<strong>) {<br>    int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>    <strong>int </strong>ans = 0;<br>    <strong>if (</strong>index == matrix.<strong>length) {<br>        return </strong>score;<br>    <strong>} else {<br>        for (int </strong>i = index; i &lt; matrix.<strong>length</strong>; i++<strong>) {<br>            int </strong>num = 0;<br>            swap<strong>(</strong>matrix,index,i<strong>)</strong>;</p><pre><code>        **if (**i-1&gt;0 &amp;&amp; matrix**[**i**][**0**] **&gt; matrix**[**i-1**][**0**]) &#123;            **num += 1;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**]) &#123;            **num += 2;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**] **&amp;&amp; matrix**[**i+1**][**0**] **&gt; matrix**[**i**][**0**]) &#123;            **num += 5;        **&#125;        **ans = process**(**matrix,index+1,score+num**)**;        max = Math.max**(**max,ans**)**;        swap**(**matrix,index,i**)**;    **&#125;    return **max;**&#125;</code></pre><p>}<br>public static void <strong>swap</strong>(int[][] <strong>matrix,</strong>int <strong>i,</strong>int <strong>j</strong>) {<br>    int[] <strong>temp = matrix</strong>[<strong>i</strong>]<strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>0</strong>] <strong>= matrix</strong>[<strong>j</strong>][<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>1</strong>] <strong>= matrix</strong>[<strong>j</strong>][<strong>1</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>0</strong>] <strong>= temp</strong>[<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>1</strong>] <strong>= temp</strong>[<strong>1</strong>]<strong>;</strong>}** |<br>| —- |</p><h2 id="·-❓乐队演出的最少花费"><a href="#·-❓乐队演出的最少花费" class="headerlink" title="· ❓乐队演出的最少花费"></a>· ❓乐队演出的最少花费</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537423682-efe033ec-3f72-424f-bde7-e5014b897bef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=165&amp;id=u4f042f4e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=845&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43808&amp;status=done&amp;style=none&amp;taskId=u0e6f551b-d211-4ea1-b57c-7c37cc19b72&amp;title=&amp;width=676" alt="image.png"><br>题意<br>乐队数量编号跟numbers*2是严格绑定的<br>nums=5, 乐队数量下标一定是0~9<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448658-3dab8950-a21f-43a1-b17b-7ed848f64840.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u7d539c9d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=533&amp;originWidth=1051&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uacdc5ae2-9463-4236-b703-588b8875dfa&amp;title=&amp;width=592" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448639-8358f990-06dd-4df5-92ae-7f64d89c5234.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=u8052bab1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=1124&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u76a2c942-9cfb-413c-87b0-e6c87ef102c&amp;title=&amp;width=585" alt=""><br>nums=1, 一定有0,1两支乐队<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448741-b140f77d-7e96-44c8-84b8-5fc2a709c6d8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=285&amp;id=u403bc2c5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=906&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucb4940ea-7279-443e-9b7d-0ae124ea889&amp;title=&amp;width=583" alt=""><br>nums=2, 一定有0,1, 2, 3 四支乐队<br>一个乐队只能在一个项目里被挑到，它不能同时为两个项目挑到, 把所有乐队都挑全, 返回最低报价</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448667-377bf58a-896b-4092-92b2-f8b2a5e09815.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=286&amp;id=u32fa3de3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=531&amp;originWidth=1106&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u65c2b037-7834-4cf3-ab10-f0b6e2bf05e&amp;title=&amp;width=596" alt=""><br>题解<br>乐队数量16只, 任何两个乐队的组合为C_16^2, 共120种情况, 现在题目中有500组,<br>有大量冗余项目, 只选报价低的, 剩余的删掉<br>如果某个乐队不在报价中返回-1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448679-f9b98e3e-d745-4b02-bdae-869c77c67a26.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u6948a087&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=1137&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucaf4f2e9-9d3d-4a61-975f-3175ffd7c66&amp;title=&amp;width=589" alt=""><br>洗数据<br>调整乐队编号, 两个乐队最小值放第一位, 最大值放第二位, 最后是花费<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449231-9d45d470-a1c6-43c9-9588-469ca0f1e264.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u46433d67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=419&amp;originWidth=1033&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8f5bb06b-f43c-4077-8a14-5d13c732d90&amp;title=&amp;width=647" alt=""><br>排序: 第一维小的排前面，第一维数据相等的，根据第二维数据小的排前面，前两维数据都相同的，<br>根据报价小的排前面<br>前两项一样的这一组，我只要第一个, 剩下的都删掉<br>把价格大的都删掉。两个乐队之间最低报价的留下来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449453-bf550b3c-8f14-4478-83d9-7deee2932b11.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=ud0a23bf4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=491&amp;originWidth=1118&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6ee4650d-6457-4fb0-9ab1-c041cd0877a&amp;title=&amp;width=541" alt=""><br>暴力递归<br>通过size控制<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449574-6cc51376-eedc-4492-9837-2b7fe7a5137b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=441&amp;id=u19699120&amp;margin=%5Bobject%20Object%5D&amp;originHeight=586&amp;originWidth=778&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue22b83d6-55e4-4b95-829f-40f960b64cd&amp;title=&amp;width=586" alt=""><br>可以用一个整数的二进制状态，表示哪个乐队挑了哪个没挑<br>一共就8组, 16个乐队<br>最低位就代表0号乐队挑没有挑, 上面如果是1代表挑了, 上面如果是 0 , 代表没挑</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449591-6da74ef6-513b-4524-9b3a-b672e0db5668.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=u2fe508db&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1006&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u94eb5d67-dd4e-4672-9456-0ae104e69b9&amp;title=&amp;width=554" alt=""><br>乐队全挑是啥样？<br>应该是某一个整数，后面 16 位全是1，前面 16 位全是0。这个状态就表示你所有的都挑到了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449813-4c4d0188-00e0-4d90-94b2-91dde3d4e2ee.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=u2abab5d3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7278723a-a0c2-4568-a86d-a0851da4baf&amp;title=&amp;width=555" alt=""><br>之前 5 位置的 5 乐队已经考虑过了，此时的项目无论如何不能考虑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449921-dabce459-c444-48ca-9b0d-38842a88bea8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=276&amp;id=u91c52048&amp;margin=%5Bobject%20Object%5D&amp;originHeight=543&amp;originWidth=1051&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69d7ed52-13ce-44af-b614-77ad78833ad&amp;title=&amp;width=534" alt=""><br>不能改动态规划, 可变参数太多了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450094-53b89c36-d138-4950-9855-9eb41da56b81.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaefbf1e8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1189&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f03743c-eabf-4d20-b806-7572874a0d2&amp;title=" alt=""><br>优化<br>可以省掉done参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450158-14d02b8e-1908-4948-8d94-927946c3838e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4a13716a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=369&amp;originWidth=825&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf1a8774c-e654-4e8e-80e7-5bbedb5bdff&amp;title=" alt=""><br>复杂度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450320-12c34c5a-b718-43e3-b910-ce5cd6be6e48.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5fa9848d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1110&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0d5c8479-84af-4bde-b87e-fdc85878b0a&amp;title=" alt=""><br><br>分治<br>复杂度<br>一共 120 个项目挑 8 个项目就停。<br>C_{120}^8_C_1208 超过 10^8了, 这个方法不行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450494-e0629605-12c2-45c0-ba4d-8981a6fc2e84.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue97cf8a0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u40393ab8-0e3f-4b26-ae96-d80c6c2c4d1&amp;title=" alt=""><br>特殊情况, num=7<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450801-bf9dd979-4d42-4c30-9acd-45c6b4e7f866.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u628d5bce&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u16e23e4a-120c-4887-adee-11b29cab4e1&amp;title=" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450938-6f42c655-5387-4db9-b9db-d38ddc55848f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7ea57ad3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=767&amp;originWidth=713&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u340a0fea-3523-4622-b767-bc6d89db7eb&amp;title=" alt=""></p><h2 id="·-❓题目2-企鹅的最少数量-781-森林中的兔子-M"><a href="#·-❓题目2-企鹅的最少数量-781-森林中的兔子-M" class="headerlink" title="· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]"></a>· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537527351-44459aaf-41e1-458d-bae2-5ce71a0191b1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=176&amp;id=u67946780&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=797&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40177&amp;status=done&amp;style=none&amp;taskId=u47ce9f2e-8b46-4f21-a705-0ea9eefe640&amp;title=&amp;width=637.6" alt="image.png"><br>题意</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-b877c03c-a285-4712-9615-258c243e8ed7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u5b0b2b90&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufafc36af-a0b5-4e28-9db2-89eb9b6b178&amp;title=&amp;width=570" alt=""><br>a,b必然不同<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512800-25772203-c346-4bbe-8237-30518dbdb60b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9a8e07f0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=183&amp;originWidth=228&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c66b2ce-92ce-46a9-b14b-4a3751310b8&amp;title=" alt=""><br><br>题解<br><br>排序, 让说的一样数量的人在一起<br>自我消化<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-cf987f51-87b0-448b-ac46-e9d5faf98eb3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=uaaa8f52f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=392&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud38b542a-cec3-4e17-b52e-70e2f50bd8f&amp;title=&amp;width=570" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512924-12bacc17-7f26-4686-85f0-7f71db1bfa89.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=uf697393a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7604ddcd-7966-4e3a-b5d3-8f4cabf5c5a&amp;title=&amp;width=573" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512826-891ffc75-377e-4fc5-9d7a-da4028ceae6f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u2a3485d2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1088&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6df243e7-fbc7-4a92-ab5c-bae5a440dbc&amp;title=&amp;width=559" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513286-e4853f30-976d-4afb-a9c2-1c0843765303.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=uc338299f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1109&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf7ddc6e6-1972-40c5-8878-9a5754d7b21&amp;title=&amp;width=553" alt=""><br>规律, 如果当前数是x, 有c个, 有几组?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513383-501045f8-319a-4179-b47c-9c0c02e0badf.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u5d11b8c0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=869&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c2f6b9e-c173-4c10-9c13-75c4fbdd5e3&amp;title=&amp;width=503" alt=""><br>a/b怎么向上取整<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513552-6e8d37f3-9848-4900-8eda-b864d1d22c3c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u20f90519&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=1146&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u396d7a21-be1d-44e9-877e-02a28b7fadc&amp;title=&amp;width=525" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513704-ac750a4e-7f0b-4700-8c7d-443c6aff347c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ucf35688f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u103b599a-2ac9-4946-ae00-a479d0b8f24&amp;title=&amp;width=560" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513881-861b81c5-c61d-4e5d-92f4-e7f56b5dc042.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=150&amp;id=u74b861b9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=1088&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75cc545e-f180-4c5d-90b8-b2e36446e6f&amp;title=&amp;width=544" alt=""><br>代码<br>不能约<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514082-45e66cf1-cbdf-48bd-80ce-7343743b8fca.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u32d23b83&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1010&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1f8888e6-27db-45fb-867a-dc516aff8af&amp;title=&amp;width=503" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514370-fba438f5-6e52-45a9-b7ff-ffe1427d7e10.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udbfd29aa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=447&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u877d5405-cfd1-4b2e-b825-ffe2521430e&amp;title=" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2022/08/09/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/08/09/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>多练的代码也就是不容易写出来的：✊<br>困难的代码：😡<br>了解：👌</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>heap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;((</strong>a, b<strong>) </strong>-&gt; a.<strong>value </strong>- b.<strong>value)</strong>;<br>要练熟的代码：</p><p>排序：Arrays.sort()<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650254542022-b29c6afb-07da-458f-aad0-d9195e2cbb60.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=37&amp;id=BvypH&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=46&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29461&amp;status=done&amp;style=none&amp;taskId=ue1e9cf3b-75fb-4abc-a0d2-566f55d0aec&amp;title=&amp;width=466.4" alt="image.png"></p><p>子串子数组想到以i结尾往左推 class3例子</p><h2 id="·-返回离非负整数num最近的2的某次方"><a href="#·-返回离非负整数num最近的2的某次方" class="headerlink" title="· 返回离非负整数num最近的2的某次方"></a>· 返回离非负整数num最近的2的某次方</h2><p><strong>题意</strong><br>num=7, 返回8   num=8，返回8   num=13，返回6<br><strong>题解</strong><br>二进制第一个1后面全部填充完1后加1返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606374038-5dc3bdff-f8db-4cea-b539-13bc0f241519.png#clientId=u24411928-8d24-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=u6f518ae8&amp;margin=%5Bobject%20Object%5D&amp;name=DEF082573F9BE5D1BD2D58935BF11CDD.png&amp;originHeight=1166&amp;originWidth=1502&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=328379&amp;status=done&amp;style=none&amp;taskId=uc329201a-a346-4a48-9408-2ab96b91a62&amp;title=&amp;width=448.2857666015625" alt="DEF082573F9BE5D1BD2D58935BF11CDD.png"></p><p>| // 已知n是正数<br>// 返回大于等于，且最接近n的，2的某次方的值<br>public static final int tableSizeFor(int n) {<br>   //这个是为了如果正好是2的某次方，打散！！<br>   n—;<br>   //&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补0。<br>   n &#124;= n &gt;&gt;&gt; 1;<br>   n &#124;= n &gt;&gt;&gt; 2;<br>   n &#124;= n &gt;&gt;&gt; 4;<br>   n &#124;= n &gt;&gt;&gt; 8;<br>   //整型最多32位<br>   n &#124;= n &gt;&gt;&gt; 16;<br>   return (n &lt; 0) ? 1 : n + 1;//负数最高位是1，填满32个1，返回1<br>} |<br>| —- |</p><h2 id="·-相邻字符的交换次数"><a href="#·-相邻字符的交换次数" class="headerlink" title="· 相邻字符的交换次数"></a>· 相邻字符的交换次数</h2><p><strong>题意</strong><br>刻意的说两个标准, 搞你一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704873615-836bf286-fab2-47cb-8817-a817f740da5d.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=70&amp;id=u73201307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=88&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19948&amp;status=done&amp;style=none&amp;taskId=ub30207ba-f24d-4b60-884e-75662524657&amp;title=&amp;width=660.8" alt="image.png"><br><strong>题解</strong><br>贪心:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704850684-0c6b231e-483f-4ad1-99fb-9b7d76b6ffc9.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u5d3653f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=398&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u976907e3-3bde-438a-891c-5605344be3c&amp;title=&amp;width=556" alt=""><br><strong>两个指针</strong><br>index: 往右扫, 不是G就往右飘<br>L: 如果发现了放到哪儿的位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606588940-7b194664-6549-49a7-bec8-3209b6c93f08.png#clientId=u24411928-8d24-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=uab987630&amp;margin=%5Bobject%20Object%5D&amp;name=39A8E84629C793605662823ED198A9D4.png&amp;originHeight=718&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=126502&amp;status=done&amp;style=none&amp;taskId=uc016d720-79cd-42d8-8978-bf6dafda160&amp;title=&amp;width=390.2857666015625" alt="39A8E84629C793605662823ED198A9D4.png"><br>如何确定这是最优解?<br>这个过程, L, index都不回退, 复杂度O(N)<br>原题: 你可以选择让 G 在左边B 在右边或者你可以选择让 B 在左边G在右边哪种更省。<br>哪种更剩你用哪种, 问你最小的用代价</p><p>| <em>// 可以让G在左，或者在右</em><strong>public static int </strong>minSteps2(String s) {<br>   <strong>if </strong>(s == <strong>null </strong>&#124;&#124; s.equals(<strong>“”</strong>)) {<br>      <strong>return </strong>0;<br>   }<br>   <strong>char</strong>[] str = s.toCharArray();<br>   <strong>int </strong>step1 = 0;<br>   <strong>int </strong>step2 = 0;<br>   <strong>int </strong>gi = 0;<br>   <strong>int </strong>bi = 0;<br>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; str.<strong>length</strong>; i++) {<br>      <strong>if </strong>(str[i] == <strong>‘G’</strong>) { <em>// 当前的G，去左边   方案1<br>         _step1 += i - (gi++);<br>      } <strong>else </strong>{</em>// 当前的B，去左边   方案2<br>         <em>step2 += i - (bi++);<br>      }<br>   }<br>   <strong>return </strong>Math._min</em>(step1, step2);<br>} |<br>| —- |</p><h2 id="·-无序数组需要排序的最短子数组长度"><a href="#·-无序数组需要排序的最短子数组长度" class="headerlink" title="· 无序数组需要排序的最短子数组长度"></a>· 无序数组需要排序的最短子数组长度</h2><p><strong>题意</strong><br>想让整体有序<br>时间复杂度 O(N)额外空间复杂度O(1)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710897296-aa25c260-3795-403f-a63d-abcb51e33ff8.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u907fe5bc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=593&amp;originWidth=1216&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8e7d06d1-a6cb-4207-a123-ea9ca887b8c&amp;title=&amp;width=477" alt=""><br><strong>题解</strong><br>最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654696304737-51815bbc-5fb1-4258-8122-5b4218ecc06f.png#clientId=uaf1c0b48-9cd0-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=2891&amp;id=u37b19965&amp;margin=%5Bobject%20Object%5D&amp;name=63E3A64272C54C218FDD9192B70053CB.png&amp;originHeight=5059&amp;originWidth=1612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=673473&amp;status=done&amp;style=none&amp;taskId=u1c723737-203b-4864-b838-1417ede3aeb&amp;title=&amp;width=921.1428571428571" alt="63E3A64272C54C218FDD9192B70053CB.png"><br>需要排序范围2~5<br>你第一回从左往右遍历最右的违规，然后从右往左遍历最左的违规这之间需要排序。</p><p>左面max&lt;=当前数, 比如左max=6, 最后8,9是对号, 说明如果真要排序的话, 8不必给前面的最大值让位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898543-234a31d2-30e8-43f4-8676-33e52a7b9d25.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u2443991c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90eff19c-58f3-47d7-a63a-a785a4fd9f9&amp;title=&amp;width=572" alt=""><br>9不必给前面的最大值让位置<br>10也不必给前面的最大值让位置<br>你后面连续的对号说明如果真的排序的话，它们动都不需要动<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898593-d8fbbadb-d557-419e-867b-23549142645e.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u9fabbcb7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1258&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud6eca0a4-35e4-44ff-9ecc-aeb906a1b14&amp;title=&amp;width=631" alt=""><br>从右往左滑同理, 最左的对号说明在往左一直到开头全是对号,<br>说明如果真的排序的话，这些数据也不用给右边部分的最小值让位置。<br>你确定了一个右边不需要排的部分, 确定了一个左边不需要排的部分，那中间就是需要排序的部分, 搞定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898762-58901f0c-bbed-431c-a9f4-1bbd7fea4661.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u670e797a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=609&amp;originWidth=1212&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4471b33b-6b3d-4372-8a6b-4a2b4749e8c&amp;title=&amp;width=484" alt=""><br>第一个X到最后一个X中间直接排序不行吗?<br>不行, 因为你只关注了最大值, 例子中8没有人处理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710899406-b03a72c2-596b-40b2-b0a1-9d726f5d16a4.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u033c7053&amp;margin=%5Bobject%20Object%5D&amp;originHeight=275&amp;originWidth=1204&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u59606f10-dbf2-4450-924e-ed0813e7169&amp;title=" alt=""></p><p>| <strong>public static int </strong>findUnsortedSubarray2(<strong>int</strong>[] nums) {</p><p>   <strong>if </strong>(nums == <strong>null </strong>&#124;&#124; nums.<strong>length </strong>&lt; 2) {<br>      <strong>return </strong>0;<br>   }<br>   <strong>int </strong>N = nums.<strong>length</strong>;<br>   <strong>int </strong>right = -1;<br>   <strong>int </strong>max = Integer.<strong><em>MIN_VALUE</em></strong>;</p><p>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; nums.<strong>length</strong>; i++) {<br>      <strong>if </strong>(nums[i] &gt;= max) {<br>         max = nums[i];<br>      } <strong>else </strong>{<br>         right = i;<br>      }</p><p>   }<br>   <strong>int </strong>left = N;<br>   <strong>int </strong>min = Integer.<strong><em>MAX_VALUE</em></strong>;</p><p>   <strong>for </strong>(<strong>int </strong>i = N - 1; i &gt;= 0; i—) {<br>      <strong>if </strong>(nums[i] &lt; min) {<br>         min = nums[i];<br>      } <strong>else </strong>{<br>         left = i;<br>      }<br>   }<br>   <strong>return </strong>Math.<em>max</em>(0,right-left+1);<br>} |<br>| —- |</p><h2 id="·-字符串种类"><a href="#·-字符串种类" class="headerlink" title="· 字符串种类"></a>· 字符串种类</h2><p>你只有26种字符，一个整数是不是有32位了，<br>你就拿这个整数的第0位表示a从没出现过，它是1是出现过，它是0就没出现过，<br>你拿这个整数第1位表示b拿这个整数，第2位表示c拿一个整数，第25位表示z，<br>你还结余了这么多倍不用了，那你的摘要是不是就不用是str类型了，变成一个<br>整数就可以表示一个摘要了<br>最后看这个set中留下了多少不同的整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351350-dc64aa66-e5f5-44a0-a5d7-96736ca8680d.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=207&amp;id=u5fa830fc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=582&amp;originWidth=1183&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue6d9144b-3a7b-4eca-8c40-f73d1b2aa6d&amp;title=&amp;width=420" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351667-30911ef7-b885-449e-ab70-5c2e626b1445.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u6191cdd4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=257&amp;originWidth=422&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uece8ee91-b5ee-4851-a947-dd631519c75&amp;title=&amp;width=358" alt=""></p><h2 id="·-最大的以-1-为边界的正方形-M"><a href="#·-最大的以-1-为边界的正方形-M" class="headerlink" title="· 最大的以 1 为边界的正方形 [M]"></a>· 最大的以 1 为边界的正方形 [M]</h2><p><strong>题意</strong><br>边框全是1就达标，它不要求内部也有1, 内部有1, 也可以没有1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-9c36b203-d37d-46a9-9483-0348e3180719.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=ub37f09bb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=578&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a91b9c9-d45e-406e-9103-c6290e2fc15&amp;title=&amp;width=427" alt=""><br><strong>题解</strong><br>预处理数组技巧</p><p><strong>前置</strong><br>N<em>N区域中长方形正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399168-04bf1552-399a-4c84-9e06-1ba7badf959e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=151&amp;id=ud0e60c23&amp;margin=%5Bobject%20Object%5D&amp;originHeight=566&amp;originWidth=1167&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1bf94e4e-6018-42e3-bfac-44286cc6e9a&amp;title=&amp;width=311.0000305175781" alt=""><br>N</em>N区域中正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399176-f2349f13-30c8-4f6b-8779-a086f36cb16e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=163&amp;id=u2f2a5857&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1160&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a4e536e-ea47-4b8f-acd2-17bb7283331&amp;title=&amp;width=359" alt=""><br><strong>代码</strong><br>所以边长的枚举一定是哪个少，就到那个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-09736a59-aa8a-4393-b496-335dd697275c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u3d7bd96a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=501&amp;originWidth=738&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u924c016e-b4a5-492d-890b-d66b64c878a&amp;title=&amp;width=403" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399153-31e8e2ec-e0f7-4ab7-a328-8b2e74742a8f.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u6d60a1cb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0b2a46c-d586-4bff-99d6-7555284bbb0&amp;title=&amp;width=414" alt=""><br>当我们点一个点的时候，我们只要那个长方形，它往右下方向拉, 然后看你能拉多远<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401624-62771dcc-0e46-4e02-95be-f03c4a11dd8d.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=181&amp;id=u20bd98fa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=275&amp;originWidth=741&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9ee39ed7-94fc-449b-ba80-16d2550e136&amp;title=&amp;width=487" alt=""><br>验证过程能不能快一点 O(1)内<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401970-88428577-d5a9-4b70-8787-83d3001063ea.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uada68211&amp;margin=%5Bobject%20Object%5D&amp;originHeight=304&amp;originWidth=692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua0608d42-bb77-46f4-b982-6c6e649dd36&amp;title=" alt=""><br>假设我知道任何一个(i,j)位置右边有多少个连续的1, 下方有多少个连续的1(包括自己在内)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402673-739ba559-43f0-4cfc-9907-3a8c7357f9aa.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=359&amp;id=uda259ca9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=603&amp;originWidth=670&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uef3ee539-2f80-47f9-813c-47d085e71b8&amp;title=&amp;width=399" alt=""><br>17,29的左上顶点, 边长是7的这么一个正方形。<br>怎么验证?<br>你先看看(7,29)右方连续的1够不够 7 个，你再看看(7,29)这个点下方连续的1够不够 7个<br>…<br>只需要调出这 3 个点的信息, O(1)的过程<br>接下来就是求任何一个(i,j)点，让它右方和下方有这个信息</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402900-dc768550-cd1a-4853-a5d8-f871f5fcabfc.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=uc6970c91&amp;margin=%5Bobject%20Object%5D&amp;originHeight=547&amp;originWidth=995&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08ef4750-7959-4b40-969e-e9a6bda8fc0&amp;title=&amp;width=572" alt=""><br>怎么求这个信息呢?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781186419-16a3698d-6e4e-4407-9643-68dfc9156b32.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=810&amp;id=u0773d943&amp;margin=%5Bobject%20Object%5D&amp;name=8594CD1133E89D6E5D0DE8C781C7E60E.png&amp;originHeight=1418&amp;originWidth=1034&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=457290&amp;status=done&amp;style=none&amp;taskId=ub2bac3a4-0128-47f0-b5ea-c0907f659e3&amp;title=&amp;width=590.8571428571429" alt="8594CD1133E89D6E5D0DE8C781C7E60E.png"><br>咋知道这个O(N^3)的解需不需要继续优化?<br>矩阵规模告诉你, 最多100*100, 你拿N^3一套没到10^8这个级别,<br>你知道O(N^3)的这个解不需要再优化了, 这个题目必过.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403570-4bf72a85-3dce-4515-959c-f1866430fbbd.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u8da21f2c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=63&amp;originWidth=246&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc724a96e-b8cd-4797-97b5-7198d88597b&amp;title=" alt=""></p><p>怎么想到是预处理数组呢?<br>当写完3个for循环之后, 底层一个正方形再验的时候不想再遍历了,<br>势必会设计一种查询的结构来支持它, 不让它遍历来保证O(1)<br>这就是思想的开端,<br>预处理数组怎么用?<br>就是当你最后卡在最后一步，一个小的元件需要遍历搞定，这样的时候特别的多，<br>你就想着我怎么样做出一个能够提前查询的结构，到这一步的时候把遍历省掉, 比如前缀数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403652-75a89599-d8f8-43a3-a1e1-5d2643008a8c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=ub5033baf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=884&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1f7af3b0-f56a-4be7-b7cc-baeebc9e05a&amp;title=&amp;width=492" alt=""></p><p>| <strong>public static int </strong>largest1BorderedSquare<strong>(int[][] </strong>m<strong>) {<br>   int[][] </strong>right = <strong>new int[</strong>m.<strong>length][</strong>m<strong>[</strong>0<strong>]</strong>.<strong>length]</strong>;<br>   <strong>int[][] </strong>down = <strong>new int[</strong>m.<strong>length][</strong>m<strong>[</strong>0<strong>]</strong>.<strong>length]</strong>;<br>   //==生成右信息 下信息<br>   setBorderMap<strong>(</strong>m, right, down<strong>)</strong>;<br>   <strong>for (int </strong>size = Math.min<strong>(</strong>m.<strong>length</strong>, m<strong>[</strong>0<strong>]</strong>.<strong>length)</strong>; size != 0; size—<strong>) {<br>      if (</strong>hasSizeOfBorder<strong>(</strong>size, right, down<strong>)) {<br>         return </strong>size <em> size;<br>      <strong>}<br>   }<br>   return </strong>0;<br><strong>}</strong><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781251250-6c80220e-fc56-430a-b4c9-377e6c3fa002.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=455&amp;id=uadd39646&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=797&amp;originWidth=995&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=221761&amp;status=done&amp;style=none&amp;taskId=udef49ab0-cccf-4360-9f48-ec0dcec606e&amp;title=&amp;width=568.5714285714286" alt="image.png"><strong>**public static void </strong>setBorderMap<strong>(int[][] </strong>m, <strong>int[][] </strong>right, <strong>int[][] </strong>down<strong>) {<br>   int </strong>r = m.<strong>length</strong>;<br>   <strong>int </strong>c = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   //右下角<br>   <strong>if (</strong>m<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>== 1<strong>) {      </strong>right<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>= 1;<br>      down<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>= 1;<br>   <strong>}   </strong>//最右侧的数据<br>   <strong>for (int </strong>i = r - 2; i != -1; i—<strong>) {<br>      if (</strong>m<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>== 1<strong>) {         </strong>right<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>= 1;<br>         //等于1的话九四下一行加1<br>         down<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>= down<strong>[</strong>i + 1<strong>][</strong>c - 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }   </strong>//最后一行的数据<br>   <strong>for (int </strong>i = c - 2; i != -1; i—<strong>) {<br>      if (</strong>m<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>== 1<strong>) {         </strong>right<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>= right<strong>[</strong>r - 1<strong>][</strong>i + 1<strong>] </strong>+ 1;<br>         down<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>= 1;<br>      <strong>}<br>   }   </strong>//然后从倒数第二行开始，从倒数第二列往前一行一行的推 &lt;—  ^<br>   <strong>for (int </strong>i = r - 2; i != -1; i—<strong>) {<br>      for (int </strong>j = c - 2; j != -1; j—<strong>) {<br>         if (</strong>m<strong>[</strong>i<strong>][</strong>j<strong>] </strong>== 1<strong>) {            </strong>right<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= right<strong>[</strong>i<strong>][</strong>j + 1<strong>] </strong>+ 1;<br>            down<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= down<strong>[</strong>i + 1<strong>][</strong>j<strong>] </strong>+ 1;<br>         *</em>}<br>      }<br>   }<br>}</p><p>** |<br>| —- |</p><p>| <strong>public static boolean </strong>hasSizeOfBorder<strong>(int </strong>size, <strong>int[][] </strong>right, <strong>int[][] </strong>down<strong>) {<br>   for (int </strong>i = 0; i != right.<strong>length </strong>- size + 1; i++<strong>) {<br>      for (int </strong>j = 0; j != right<strong>[</strong>0<strong>]</strong>.<strong>length </strong>- size + 1; j++<strong>) {         </strong>//找那三个点！！  左上的那个点              下方的那个点<br>         <strong>if (</strong>right<strong>[</strong>i<strong>][</strong>j<strong>] </strong>&gt;= size &amp;&amp; down<strong>[</strong>i<strong>][</strong>j<strong>] </strong>&gt;= size &amp;&amp; right<strong>[</strong>i + size - 1<strong>][</strong>j<strong>] </strong>&gt;= size<br>               //右边的那个点<br>               &amp;&amp; down<strong>[</strong>i<strong>][</strong>j + size - 1<strong>] </strong>&gt;= size<strong>) {<br>            return true</strong>;<br>         <strong>}<br>      }<br>   }<br>   return false</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-乘客坐船使用的最少船数"><a href="#·-乘客坐船使用的最少船数" class="headerlink" title="· 乘客坐船使用的最少船数"></a>· 乘客坐船使用的最少船数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266540654-bc52c017-346b-4c9c-ba85-2f8363a2f43d.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=123&amp;id=u90d68d8f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20339&amp;status=done&amp;style=none&amp;taskId=ua7a2c8fd-24f1-479b-b9e4-4bb22b8c84a&amp;title=&amp;width=412.8" alt="image.png"><br><strong>题意</strong><br>每艘船最多坐两人，且不能超过载重。问你让所有人同时过河，并且用最好的分配方法，<br>使船尽量少返回最少的船数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754920033-d23a14f3-997f-4f13-a9f0-7b561f79d2f2.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=u96abc735&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1151&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25fc0b67-d916-4e77-8078-1029b98c178&amp;title=&amp;width=428" alt=""><br><strong>题解</strong><br>你先遍历一遍数组，如果有单独一个人的体重已经超过了limit返回无穷大。<br>多少条船都搞不定的<br><strong>流程</strong><br>先排序<br>从中间分界点开始往左右两边滑</p><p>找&lt;=limit/2最右的位置, 做为L指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919993-2fc7575c-c414-4b7e-a832-5bf0bcb40ff6.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=ufb0881ef&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75a44641-53ce-4de8-8f74-8ac55b102d0&amp;title=&amp;width=446" alt=""><br>R指针: 第一个超过limit/2的位置<br>看L位置和R位置能否凑一个船, 不能, 超了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919953-4a90aa2e-3033-4477-8930-018ff980a464.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u95912d5e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=1102&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue7bf048f-aaa8-4400-803d-9d57b976d24&amp;title=&amp;width=538" alt=""><br>L往左飘, L来到3, 可以<br>先不忙分配船, R往右滑, 一直划到R再往下进一个就没有办法跟 3凑一船为止<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919952-f9d1b099-1792-43c3-931a-0e97bdbaec96.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u65f47ec7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1076&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u854235fa-c1f2-44a8-9746-bc7d404a688&amp;title=&amp;width=522" alt=""><br>贪心的核心点:<br>从3出发往左数6个的这6个，去消化这6个，一定是最省的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919986-6ed6fbd8-2c1a-41ba-9150-e1e3bb4a60e3.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u93e568a4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=1162&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u91791187-7421-4fec-b6c7-edf0f6db13c&amp;title=&amp;width=445" alt=""><br><strong>例子1: 右侧先耗尽</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921589-39ec9db9-b791-4250-84a0-959f28c10384.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u89cdb406&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1019&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5babd024-fc3f-4e18-897a-c9982047463&amp;title=&amp;width=475" alt=""><br>俩对号装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921991-8f261b8f-5962-4c73-85b3-f6a17ed90471.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=u2d0e63b4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=558&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08d96e78-dff0-43b7-a5d1-52d57f628ed&amp;title=&amp;width=503" alt=""><br>X号两两可以装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922406-6a35f17e-24ef-4b59-92c8-c94d60e2eeaa.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u608ae23c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=548&amp;originWidth=1040&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud57e21a5-c48a-4d3e-a609-646cb20f153&amp;title=&amp;width=439" alt=""><br><strong>例子2: 左侧先耗尽</strong><br>最后对号的数量除2，加上×号的数量除2(向上取整)，加上右侧剩几个数它们一定单独一艘船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922475-c578911c-83dd-4b73-a887-e8c5088bf359.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=198&amp;id=u2c8f3183&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=1191&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua593a755-3782-413c-ab6c-595e375b6c0&amp;title=&amp;width=456" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654782938733-ff5ae0ad-f593-4836-8ee2-b595c618751a.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=867&amp;id=u98f15db6&amp;margin=%5Bobject%20Object%5D&amp;name=2B163C063CD4521C4323347FAFB38F50.png&amp;originHeight=1518&amp;originWidth=1036&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=511608&amp;status=done&amp;style=none&amp;taskId=uee0c2454-79c7-4464-a51a-0459a5ae855&amp;title=&amp;width=592" alt="2B163C063CD4521C4323347FAFB38F50.png"></p><p>| public static int numRescueBoats(int[] arr, int limit) {<br>   if (arr == null &#124;&#124; arr.length == 0) {<br>      return 0;<br>   }<br>   int N = arr.length;<br>   Arrays.sort(arr);<br>   if (arr[N - 1] &gt; limit) {<br>      return -1;<br>   }<br>   int lessR = -1;<br>   //找到 最左侧里 limit/2最接近的数<br>   for (int i = N - 1; i &gt;= 0; i—) {<br>      if (arr[i] &lt;= (limit / 2)) {<br>         lessR = i;<br>         break;<br>      }<br>   }<br>   if (lessR == -1) {<br>      return N;<br>   }<br>   int L = lessR;<br>   int R = lessR + 1;<br>   int noUsed = 0;<br>   while (L &gt;= 0) {<br>      int solved = 0;//用来更新L下标的<br>      while (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) {<br>         R++;<br>         solved++;<br>      }<br>      //表示上述结束了右边没有一个能和当前的L乘坐<br>      if (solved == 0) {<br>         noUsed++;//左侧未使用的<br>         L—;<br>      } else {<br>         L = Math.max(-1, L - solved);<br>      }<br>   }<br>  //下面的要用具体的例子来换算下标<br>   int leftAll = lessR + 1;//理解的好方法：因为数组是下标0开始的 +1就表示左侧的全部数量<br>   int leftUsed = leftAll - noUsed;//左侧的全部数量-未使用的就是使用的<br>   //右侧还剩下未使用的<br>   int rightUnsolved = (N - all) - used;<br>   return used + ((noUsed + 1) &gt;&gt; 1) + moreUnsolved;<br>} |<br>| —- |</p><h2 id="·-子数组最大累加和"><a href="#·-子数组最大累加和" class="headerlink" title="· 子数组最大累加和"></a>· 子数组最大累加和</h2><p><strong>题解</strong><br>看到子数组子串想想每个位置结尾是答案是什么<br>如果子数组必须以0结尾, 它往左扩到什么程度，能让累加和最大<br>如果子数组必须以1位置结尾, 它往左扩到什么程度，能让累加和最大</p><p><strong>大流程</strong><br><strong>可能性划分</strong><br>必须以i位置结尾答案可能来自什么?<br>1) 完全不向左扩, 只有自己<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677717-e5aafff1-1b52-4e5e-80db-0a14e490e373.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=uea3b3eb0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=389&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u498816dd-5c0d-429b-81ef-e611245e7c0&amp;title=&amp;width=489" alt=""><br>2) 要向左扩， i-1结尾的时候扩出来的最好决定了当前能扩出来的最好<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677743-cc8cf0a5-a0c2-459a-abbe-6d083b658117.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=315&amp;id=ue16cd42f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=863&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89741c3c-0ea1-41a0-8082-0ac2dd610c1&amp;title=&amp;width=559" alt=""><br><strong>例子</strong><br>dp[i]: 必须以i位置的数结尾的时候最好累加和多少<br>dp中的max就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677733-ba8e98b6-b4cd-4ab5-8570-929835020c5b.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u3525b401&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1029&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udbb81fdc-2585-4a4b-9adb-f55a90e2193&amp;title=&amp;width=470" alt=""><br><strong>代码</strong><br>没有必要准备一整个 BP 有几个变量滚动更新下去就完了<br>因为它只依赖左边的一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756678781-859e8520-7df4-4d2f-887d-9be3467f97b0.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubf36503d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=355&amp;originWidth=788&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u515da530-1d5b-46cd-8343-4404bd2aed8&amp;title=" alt=""></p><h2 id="·-😡子矩阵最大累加和-H"><a href="#·-😡子矩阵最大累加和-H" class="headerlink" title="· 😡子矩阵最大累加和 [H]"></a>· 😡子矩阵最大累加和 [H]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655000610147-a7d3a92b-d3ae-4465-94ce-a8a8d694215c.png#clientId=u7bc39c19-43ea-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=313&amp;id=u0e2403c7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=547&amp;originWidth=1170&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=92137&amp;status=done&amp;style=none&amp;taskId=u927eb0d4-d5e2-468d-8556-18104e0bc5a&amp;title=&amp;width=668.5714285714286" alt="image.png"><br><strong>题解</strong><br>大流程<br>矩形必须包含第0行数据, 且只包含第0行的情况下, 最大累加和是多少?<br>矩形必须包含0,1两行数据, 且只包含0,1两行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2三行数据, 且只包含0,1,2三行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2,3四行数据, 且只包含0,1,2,3四行的情况下, 最大累加和是多少?<br>….<br>然后<br>1行~1行<br>1行~2行<br>1行~3行<br>1行~4行<br>…<br>然后<br>2行~2行<br>2行~3行<br>2行~4行<br>…<br>然后<br>3行~3行<br>…<br>然后<br>4行~4行<br>如果我们能够每一个都求出来，答案一定在其中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884708-799a0b20-7c1c-47b3-977e-90592414790a.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u0156074e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1078&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7b53efdb-4fdf-4833-8ad0-bd3bc9bb71d&amp;title=&amp;width=432" alt=""><br>如果我们能够每一个都求出来答案一定在其中</p><p>压缩数组技巧<br>0行<br>必须包含第0行数据，且只有第0行情况下画框, 最大累加和多少?<br>就是子数组的最大累加和问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884722-2be04454-65aa-4ab1-bf9a-f9b97da2206c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u4164a828&amp;margin=%5Bobject%20Object%5D&amp;originHeight=429&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud1f9b8e9-8a11-4a1f-9e61-14d37d138b3&amp;title=&amp;width=554" alt=""><br>下面<br>矩形必须包含0, 1两行数据, 且只包含0, 1两行的情况下, 最大累加和是多少?<br>两行上下数据压在一起,形成一个新数组<br>对这个数组求最大累加和就代表必须包含0, 1两行数据，且只包含01两行数据画框的最好答案是啥。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884649-aa42ef84-bb7a-4136-98bb-9fd3691bc443.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ude7883e6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=1075&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2740ec61-35a4-4813-9a55-36c15b2fcb8&amp;title=&amp;width=526" alt=""><br>复杂度O(行^2*列)<br>在行上玩了一个O(行^2)的事<br>0~0<br>0~1<br>…<br>1~1<br>1~2<br>…<br>但你每次解决一个子任务它就是过一遍数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884664-75b98c0a-3eaa-493f-bfb2-184b1e00835a.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=ue4e4a946&amp;margin=%5Bobject%20Object%5D&amp;originHeight=507&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u95e57951-deb2-47df-983f-7072b817740&amp;title=&amp;width=506" alt=""><br>进一步优化: 让行列小的当平方项<br>如果是5行, 100列, 选择让行做平方项<br>如果是100行, 5列, 选择让列做平方项</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884772-ba08c36e-d98b-45f2-8291-2432422e914c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=uf99229ea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=496&amp;originWidth=1061&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6a44cb24-c550-46f5-888f-c474dd72d23&amp;title=&amp;width=559" alt=""><br><strong>代码</strong></p><p>| <strong>public static int </strong>maxSum<strong>(int[][] </strong>m<strong>) {<br>   if (</strong>m == <strong>null </strong>&#124;&#124; m.<strong>length </strong>== 0 &#124;&#124; m<strong>[</strong>0<strong>]</strong>.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}   </strong>// O(N^2 <em> M)<br>   <strong>int </strong>N = m.<strong>length</strong>;<br>   <strong>int </strong>M = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {      </strong>// i行~j行<br>      <strong>int[] </strong>s = <strong>new int[</strong>M<strong>]</strong>;<br>      <strong>for (int </strong>j = i; j &lt; N; j++<strong>) {<br>         for (int </strong>k = 0; k &lt; M; k++<strong>) {            </strong>s<strong>[</strong>k<strong>] </strong>+= m<strong>[</strong>j<strong>][</strong>k<strong>]</strong>;<br>         <strong>}         </strong>max = Math.max<strong>(</strong>max, maxSubArray<strong>(</strong>s<strong>))</strong>;<br>      <strong>}<br>   }<br>   return </strong>max;<br>*</em>}</p><p>public static int <strong>maxSubArray</strong>(int[] <strong>arr</strong>) {<br>   if (<strong>arr == </strong>null <strong>&#124;&#124; arr.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   int <strong>max = Integer.</strong>MIN_VALUE<strong>;   </strong>int <strong>cur = 0;   </strong>for (int <strong>i = 0; i &lt; arr.</strong>length<strong>; i++</strong>) {<br>      <strong>cur += arr</strong>[<strong>i</strong>]<strong>;<br>      max = Math.max</strong>(<strong>max, cur</strong>)<strong>;<br>      cur = cur &lt; 0 ? 0 : cur;   </strong>}<br>   return <strong>max;</strong>}** |<br>| —- |</p><p>LeetCode原题<br>需要返回最大累加和矩形的左上角跟右下角点<br>当你发现了更大的答案， 你把它左上角点跟右下角点抓一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655001837943-7e030c8e-9549-42e0-a28a-31e013cd2d7b.png#clientId=ub6405de6-621a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=530&amp;id=u0049c974&amp;margin=%5Bobject%20Object%5D&amp;name=A19EA1E0AF7663EFCF77985E2517F6F4.png&amp;originHeight=1296&amp;originWidth=1216&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=510166&amp;status=done&amp;style=none&amp;taskId=u1f0706bf-c56b-4e69-9411-9025019afa5&amp;title=&amp;width=497.2857360839844" alt="A19EA1E0AF7663EFCF77985E2517F6F4.png"></p><p>| //返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。<br>// 本题测试链接 : <a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">https://leetcode-cn.com/problems/max-submatrix-lcci/</a><br><strong>public static int[] </strong>getMaxMatrix<strong>(int[][] </strong>m<strong>) {<br>   int </strong>N = m.<strong>length</strong>;<br>   <strong>int </strong>M = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>int </strong>cur = 0;<br>   <strong>int </strong>a = 0;<br>   <strong>int </strong>b = 0;<br>   <strong>int </strong>c = 0;<br>   <strong>int </strong>d = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {<br>      int[] </strong>s = <strong>new int[</strong>M<strong>]</strong>;<br>      <strong>for (int </strong>j = i; j &lt; N; j++<strong>) {         </strong>cur = 0;<br>         //记录左上角的列<br>         <strong>int </strong>begin = 0;<br>         /**</p><pre><code>      * [1 1 1 1]      * [0 1 1 2]      * [2 1 0 1]      */     **for (int **k = 0; k &lt; M; k++**) &#123;        **s**[**k**] **+= m**[**j**][**k**]**;        cur += s**[**k**]**;        **if (**max &lt; cur**) &#123;           **max = cur;           a = i;           //主要这一句           b = begin;           //           c = j;           d = k;        **&#125;        **//只有一开始就为负数的情况下，0列        **if (**cur &lt; 0**) &#123;           **cur = 0;           begin = k + 1;        **&#125;     &#125;  &#125;</code></pre><p>   }<br>   return new int[] { <strong>a, b, c, d </strong>}<strong>;</strong>}** |<br>| —- |</p><h2 id="·-135-分糖果问题-H"><a href="#·-135-分糖果问题-H" class="headerlink" title="· 135.分糖果问题 [H]"></a>· 135.分糖果问题 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757640476-f9879a7a-09ff-4b7e-9894-dcc5fb7a88f1.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=294&amp;id=uefc12a68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=368&amp;originWidth=717&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26786&amp;status=done&amp;style=none&amp;taskId=u1a5c1fb5-6fbe-4e76-9b2f-86a45e8de44&amp;title=&amp;width=573.6" alt="image.png"><br><strong>原问题</strong><br>一个数组是所有孩子的得分, 规则是，每个孩子至少一颗糖。相等不管, 只管严格大小关系<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486177-e5f2c5b1-bff0-4a8a-b27f-80ba3eac2b1c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=u249a86d3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8840862e-eeb8-4455-87ff-fdf3aa4e161&amp;title=&amp;width=504" alt=""><br><strong>题解</strong><br><strong>预处理数组+贪心</strong><br>左边没东西1块糖, 比左边大, 数字就++, 不再大了就返回1, left代表每一个点左边的坡度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486316-27402c6e-a9dd-4a3a-b72e-c09cae8103ee.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u59a65f06&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=1093&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u999c1aa3-b272-4cb8-9003-279e9af6e87&amp;title=&amp;width=499" alt=""><br>右边没东西1块糖, 比右边打了就++, 不再大了就回1<br>每个位置的max就是分糖数量，因为左坡跟右坡以较大坡为准<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486225-aba65e85-23b1-4233-a76e-2e967ed35bc0.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=ud59977cd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf3423d64-9cb4-4a2c-9e49-352f333674a&amp;title=&amp;width=652" alt=""><br><strong>复杂度</strong><br>时间复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757488676-248c8add-ee09-4fe4-9157-ff396f83324e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=ued7c1b61&amp;margin=%5Bobject%20Object%5D&amp;originHeight=508&amp;originWidth=913&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u552fabd9-cd94-48a3-bc14-1d1ab0ac4fe&amp;title=&amp;width=479" alt=""><br><strong>最优解</strong><br>我遍历的过程中，我先认为进入到上坡阶段和下坡阶段，我如果能找出一个坡来<br>就是上坡跟下坡共同构成这么一个坡度的话，该怎么分糖我就知道了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489305-1d4f8a25-b3af-43b7-9067-6174a5c50d95.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=180&amp;id=ucfc19315&amp;margin=%5Bobject%20Object%5D&amp;originHeight=329&amp;originWidth=1101&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8812c98d-eef3-4d11-8bbc-cbd7af31d8c&amp;title=&amp;width=603" alt=""><br>对coding要求比较高<br>Coding技巧可以让我找到一组上坡下坡, 等找到的时候, 再回过去给糖</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489355-8a08973f-476c-46d2-8817-37ea96dc2203.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=ua20e6791&amp;margin=%5Bobject%20Object%5D&amp;originHeight=412&amp;originWidth=942&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9aab8328-aca0-4baa-acf8-3a67fc6e1b5&amp;title=&amp;width=646" alt=""><br>没有重复值的例子<br>先遍历一遍找到坡, 然后再回去给糖, 两个坡度较大的那个+1<br>然后处理下个坡<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489655-913e2252-71e6-43df-9f0f-e11e4963f752.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u9023b751&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u293717ff-dce2-472f-a9bc-18f6b77868d&amp;title=&amp;width=525" alt=""><br>要保证两个坡中间同样的那个1不要重复给<br>相当于遍历两遍这个事儿就出来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489683-68970db3-f71e-47f9-a62e-43d3352f2041.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ud4227d7e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=1016&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u373ac26e-6280-4b9b-9741-d0f405fca4a&amp;title=&amp;width=567" alt=""><br>有相等值就更考验coding<br>相等是无非就是你认为上坡停止下会停止, 更考研Coding技巧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490765-ec269bd1-cd03-4caf-a292-1556e258aaed.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=uf2363b7e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=420&amp;originWidth=751&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1aa1af8b-180e-44d1-adbd-6f02d306b85&amp;title=&amp;width=498" alt=""><br>补充问题<br>相邻孩子分数一样, 糖的数量必须一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490609-1e02392c-0c28-4911-aabe-a0e441adc3b2.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u9114b783&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1041&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u74edf940-9fec-4510-bf50-509068979ff&amp;title=&amp;width=441" alt=""><br><strong>例子</strong><br>生成辅助数组<br>三个原则，第一比左边大就++，<br>第二，跟左边相等就继承, 就是不变，<br>第三比左边小就归1<br>同样方法生成right<br>还是每个位置的值求max</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490724-1661c665-c1f5-4df8-8d39-1a84b646d746.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ubc071e71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=533&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubd737b23-0203-49bd-9d92-6f6dddc3625&amp;title=&amp;width=492" alt=""><br>可以Coding省掉辅助数组, 更难（idea上有代码）<br>相等认为坡没变<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757491157-d5860f2a-c415-4dba-a996-a2ef506de57f.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=u5b8b35db&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=971&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8911ce37-03e3-4967-8e7d-037c74c385c&amp;title=&amp;width=426" alt=""></p><p>| // 这是原问题的优良解<br>// 时间复杂度O(N)，额外空间复杂度O(N)<br><strong>public static int </strong>candy1<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>int[] </strong>left = <strong>new int[</strong>N<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; N; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i - 1<strong>] </strong>&lt; arr<strong>[</strong>i<strong>]) {         </strong>left<strong>[</strong>i<strong>] </strong>= left<strong>[</strong>i - 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }<br>   int[] </strong>right = <strong>new int[</strong>N<strong>]</strong>;<br>   <strong>for (int </strong>i = N - 2; i &gt;= 0; i—<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&gt; arr<strong>[</strong>i + 1<strong>]) {         </strong>right<strong>[</strong>i<strong>] </strong>= right<strong>[</strong>i + 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }<br>   int </strong>ans = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {      </strong>ans += Math.max<strong>(</strong>left<strong>[</strong>i<strong>]</strong>, right<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   return </strong>ans + N;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-小人过有鳄鱼的河-博弈论"><a href="#·-小人过有鳄鱼的河-博弈论" class="headerlink" title="· 小人过有鳄鱼的河(博弈论)"></a>· 小人过有鳄鱼的河(博弈论)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757912442-ad573f17-7f4a-489a-ad67-3e78f85412e8.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=76&amp;id=uacedcc1b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=95&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17519&amp;status=done&amp;style=none&amp;taskId=u60591a67-ac3f-4cdc-b743-12dc5bc1e43&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题解</strong><br>思路: 从小推到大<br>这个人在一只鳄鱼的时候就过不了河了，<br>两只鳄鱼的时候就可以过河<br>三只鳄鱼等同于一个人两条鳄鱼的时候, 也不能过河, 因为任何一个鳄鱼吃掉人是没风险的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885276-012e6b97-e501-4f4e-be4b-fa012f482633.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=u9ca7460a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=444&amp;originWidth=937&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud1dff254-e3ae-49c7-94e2-2f88822fd1d&amp;title=&amp;width=530" alt=""><br>奇数能过河, 偶数不能过河<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885221-16ccb180-9d2a-48a8-bd80-9148fde82953.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=u2548e3b4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=925&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u299d4d20-2cf8-471b-8a64-0863faf084d&amp;title=&amp;width=457" alt=""></p><h2 id="·-Nim博弈问题"><a href="#·-Nim博弈问题" class="headerlink" title="· Nim博弈问题"></a>· Nim博弈问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800477496-814bb547-f09d-498f-abe5-e2c0e47bb5df.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=79&amp;id=u4fd49066&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=99&amp;originWidth=843&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22068&amp;status=done&amp;style=none&amp;taskId=uc93319c5-ad21-4523-9ae1-dc89387a500&amp;title=&amp;width=674.4" alt="image.png"><br><strong>题意</strong><br>所有的数&gt;=0, 每一轮不管谁都不能拿0<br>谁最先把最后一点数拿完谁赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457877-281d0894-d81e-47d0-987e-47ebb159a8b0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u3d1eed1b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=607&amp;originWidth=1273&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7304e460-0286-465e-aee9-75c63e9b7ec&amp;title=&amp;width=478" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457894-773ef509-f81a-4726-b0ee-d9cf10ef31bd.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=uf044b29a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=468&amp;originWidth=672&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue799c9d7-94cb-4cac-8596-1d6808cdfa8&amp;title=&amp;width=342" alt=""><br>先手跟后手，绝顶聪明，每一个人都充分为所有为自己打算，<br>而且绝对理智，问你，给你一个数组状况返回谁会赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800467223-97b4ba95-223a-4115-827b-edf542fc7b0c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=ud3a77b39&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=734&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue582679d-eb0a-4430-ac2a-50f530a132f&amp;title=&amp;width=410" alt=""><br>先手第一回拿把它拿成两个数都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458021-1b935de2-12bb-47d3-8f26-530ef46b89a0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=281&amp;id=udc3de2b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=515&amp;originWidth=693&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u18bf42a8-f831-4160-8833-13cff2b33f1&amp;title=&amp;width=378" alt=""><br>后手接下来不管拿多少, 先手都让它两个数一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457964-b74ab48f-bb7e-453a-beb0-160600a24846.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=u85f511af&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u107afaec-9b34-4b96-8fe4-32cb147b4a3&amp;title=&amp;width=418" alt=""><br>这样先手一定会赢<br>这是两个数的规律<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458667-6220c51c-3dd2-47e9-bde9-b5b33c5a54a4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=u163724fc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=862&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufbf57780-7d21-4ca3-8ca3-77502419af6&amp;title=&amp;width=391" alt=""><br><strong>题解</strong><br>由1900年数学家尼姆搞出来一个非常牛逼的解，<br>结论:<br>所有的数异或起来，如果异或和不等于零先手赢，如果异或和等于0后手赢</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458782-28023103-8346-46b2-a8dc-de62f52c13ac.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=u8660b253&amp;margin=%5Bobject%20Object%5D&amp;originHeight=563&amp;originWidth=987&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5dfad24-d8cf-4843-9bf3-a66fb04062c&amp;title=&amp;width=442" alt=""><br>先手的大目标:<br>让后手最先面对所有数组中都是 0 的状态。<br>大目标不知道怎么实现, 转换一下目标</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458900-733597fd-a958-4f2d-bd91-7dee949c8ffa.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=192&amp;id=u50188994&amp;margin=%5Bobject%20Object%5D&amp;originHeight=459&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud4ecb940-750d-4418-b3c3-e54b7d7592a&amp;title=&amp;width=446" alt=""></p><p>所有数都异或起来的异或和, 我如果先手能够做到我面对这坨数的异或和它不等于零，<br>但是我拿完之后每一次都让后手面对的异或和等于0，那么最后胜利是先手<br>我们知道最后全 0 的时候异或和是0。所以就这么玩下去，它总有一个时刻全 0 的时候，<br>而我是遇不到的，只会让后手遇到，所以我必胜的大目标被我们变成一个看似更难的目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458936-68a35d98-dbb4-4fbc-8eb7-a1dd85180307.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=uda72b545&amp;margin=%5Bobject%20Object%5D&amp;originHeight=629&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u505fe591-a3c8-41b2-ab41-bd6884a1f14&amp;title=&amp;width=500" alt=""><br><strong>例子</strong><br>把二进制写出来, 数组7,5,3 整体异或和001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459312-eddefebf-42c9-45db-9b8e-ddbd313e4e16.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=ua7fccb0e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=1310&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud2f98016-c6b9-4d1d-a11e-a52172c1446&amp;title=&amp;width=560" alt=""><br>先手在1这拿一个, 变成6, 更后面的5,3异或和为6的合起来异或和为0<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459424-4f4051be-b558-49e1-90b9-860f4b9f0660.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=230&amp;id=u72048edf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=617&amp;originWidth=1318&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e0608f9-d441-45c1-80f0-19fbc6e06d1&amp;title=&amp;width=491" alt=""><br>后手再拿的时候，他不管在哪个位置上拿哪个数都一定会让异或和从 0 变成不是零，<br>因为他必然会改变某一个位置上一的数量, 改变了它的异或和就不是0，然后先手继续让<br>它异或和变0, 先手必胜.<br>但是这样做的前提是什么?初始的时候异或和得是非零的先手才能这么干，如果先手面<br>对一个一上来就是异或和等于0的状态，后手赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459439-1138e3cb-d17b-4fe9-810b-e54a6fc1742f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u2905cd61&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=1307&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2bff4b1-484e-4ee0-9b03-d077dffc405&amp;title=&amp;width=510" alt=""><br>先手不一定在最大值上拿</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459509-11aaa21d-d569-4be6-9afa-9d6e11b76fa1.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u5f1b26a9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1179&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3841b959-e751-45bc-9027-7d4efd1ad33&amp;title=&amp;width=507" alt=""><br>就是先手一定能做到一个不是0 异或和的东西变成全零，但不一定是在最大值上拿的，但是他一定能做到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800460027-d4c6583e-9e89-43ce-92f4-10ed5c3be356.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=uc64a46f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1331&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8bef9a58-5ca7-415c-85d2-26b3416a918&amp;title=&amp;width=566" alt=""></p><p>| // 保证arr是正数数组<br><strong>public static void </strong>printWinner<strong>(int[] </strong>arr<strong>) {<br>   int </strong>eor = 0;<br>   <strong>for (int </strong>num : arr<strong>) {      </strong>eor ^= num;<br>   <strong>}<br>   if (</strong>eor == 0<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“后手赢”)</strong>;<br>   <strong>} else {      </strong>System.<strong>out</strong>.println<strong>(“先手赢”)</strong>;<br>   <strong>}<br>}</strong> |<br>| —- |</p><h2 id="·-非负数组中两个数相与的最大结果"><a href="#·-非负数组中两个数相与的最大结果" class="headerlink" title="· 非负数组中两个数相与的最大结果"></a>· 非负数组中两个数相与的最大结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650113590488-8110c2b9-7a47-41d5-a42b-f0a7399ead91.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=u485e8bbb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=394&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15539&amp;status=done&amp;style=none&amp;taskId=u122a7d6b-ae77-4da4-8b41-ac244820e50&amp;title=&amp;width=315.2" alt="image.png"><br><strong>题解</strong><br>可以用前缀树, 额外空间比较大, 存在更好的解法<br>思路: 高位尽量变1<br>因为我如果选一些数让30位变成0，它就不如30位变成1的值大</p><p>先遍历一遍所有的数字, 只考察30位是1的有几个, 分情况<br>1) 小于两个<br>这说明最终的结果30位上肯定不是1，因为你小于两个就不存在任何两个数，两个两个数与玩之后第30位是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800811891-1b46d42a-fe12-4196-af17-9775c90ea3a4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u164ba3a7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=500&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf326dddf-1871-4357-abfd-fc5d79a368e&amp;title=&amp;width=518" alt=""><br>2) 正好有两个数， 就是这两个数与完的结果最大， 直接返回就行<br>3） 大于两个数<br>那我就把这100个数淘汰掉，剩下的我只留这23个数，我再去看第29位</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812084-94f090b2-a658-437e-8dc0-a7931e7bc517.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u2d559d95&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1108&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub142840c-3848-4aa9-ae7d-5317a77cf57&amp;title=&amp;width=549" alt=""><br>假设目前这一批数还剩20个， 来到第i位<br>第i位上有1的数：<br>1） <2个2） =2个3） > 2个</p><p>我们遍历一遍整个数组，如果有第i位上有1的数，<br>第1种情况小于两个，那么这20个数一个也不淘汰，你接下来去看a减，<br>第2种情况如果这20个数中第i位上1的只有两个数，你不用再看，就这两个是结果<br>第3种情况如果大约在在地在第i位上有1的数是大于两个的，比如说他有7个，那么删掉剩余的13个，只留这7个数去搞安检一位不就玩儿去了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812139-21391412-9c69-4642-866d-d3f960d20bc7.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=ucefcac7f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=554&amp;originWidth=1083&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54468d3d-1d2f-4ae3-b207-9d23095f3ba&amp;title=&amp;width=504" alt=""><br><strong>时间复杂度</strong><br>30位遍历一遍数组， 29位遍历一遍数组…<br>一共遍历32遍数组, O(32N)</p><p><strong>空间复杂度怎么计算</strong><br>如果删到只剩下6个数, 17位的时候<br>保留数字这件事情, 在原数组上操作, 原数组末尾做垃圾区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812121-214352ae-98c3-4159-91d0-39878e511b6c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u73578c17&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=833&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue4361ff8-1204-42b3-9953-9cab2cc1866&amp;title=" alt=""><br><strong>代码</strong><br>垃圾区</p><p>&lt;2个, 一个数也不淘汰, 让M跳回去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812117-fb4a8866-f4ce-4796-9d6f-e723dcabb358.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u3dfa6e88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=895&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud964a6ce-61a5-49cc-bd8b-f81d3549e57&amp;title=&amp;width=483" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812536-2890f02a-970d-48af-90d3-2e5b41d3edb8.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0869c0ec&amp;margin=%5Bobject%20Object%5D&amp;originHeight=516&amp;originWidth=575&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u146e66a2-ea4d-4abe-92ce-6d990b399e2&amp;title=" alt=""></p><p>| <strong>public static int </strong>maxAndValue2<strong>(int[] </strong>arr<strong>) {   </strong>// arr[0…M-1]  arr[M….]<br>   <strong>int </strong>M = arr.<strong>length</strong>;<br>   <strong>int </strong>ans = 0;<br>   <strong>for (int </strong>bit = 30; bit &gt;= 0; bit—<strong>) {      </strong>// arr[0…M-1] arr[M…]<br>      <strong>int </strong>i = 0;<br>      <strong>int </strong>tmp = M;//有可能跳回去<br>      <strong>while (</strong>i &lt; M<strong>) { </strong>// arr[0…M-1]<br>         <strong>if ((</strong>arr<strong>[</strong>i<strong>] </strong>&amp; <strong>(</strong>1 &lt;&lt; bit<strong>)) </strong>== 0<strong>) {            </strong>swap<strong>(</strong>arr, i, —M<strong>)</strong>;<br>         <strong>} else {            </strong>i++;<br>         <strong>}<br>      }<br>      if (</strong>M == 2<strong>) { </strong>// arr[0,1]<br>         <strong>return </strong>arr<strong>[</strong>0<strong>] </strong>&amp; arr<strong>[</strong>1<strong>]</strong>;<br>      <strong>}      </strong>//==<br>      <strong>if (</strong>M &lt; 2<strong>) {</strong>//当前bit为无法得到1，M跳回原来位置，一个数也不删<strong>**         </strong>M = tmp;<br>      <strong>} else { </strong>// &gt; 2个数  bit位上有1<br>         ans &#124;= <strong>(</strong>1 &lt;&lt; bit<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>ans;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-✊括号嵌套系列问题"><a href="#·-✊括号嵌套系列问题" class="headerlink" title="· ✊括号嵌套系列问题"></a>· ✊括号嵌套系列问题</h2><h3 id="①计算str表达式结果"><a href="#①计算str表达式结果" class="headerlink" title="①计算str表达式结果"></a>①计算str表达式结果</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650098950782-2396606a-0bbb-4b55-9cb6-f263b9578ad9.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=uaeee7735&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49751&amp;status=done&amp;style=none&amp;taskId=u4b5b7ea1-393b-431b-8ac2-e4790d56699&amp;title=&amp;width=679.2" alt="image.png"><br><strong>题意</strong><br>负数作为公式的开头 或括号部分的开头，可以没有括号<br><strong>题解</strong><br>先处理没有小括号的情况</p><p>指针从零开始就有两种情况:</p><ol><li>当前压中的是数字</li><li>当前压中的是符号<br>准备一个栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569314-732407d5-15f9-4a7e-955b-af2e37ff100f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u1a923818&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=1096&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc508edf6-c054-45e5-b769-4791d54b022&amp;title=&amp;width=505" alt=""><br>压中运算符号, 当初过数字阶段结束了, 找到了34<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569315-adc8cd07-34b4-4302-9e41-3b97c55765fb.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=uce5b21e3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=493&amp;originWidth=1115&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua15fcfcf-0634-4317-b4a3-83765138bda&amp;title=&amp;width=536" alt=""><br><strong>1, * </strong>入栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569327-d3093cd3-afae-4027-a13c-21a795ed98e4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u8b5cb035&amp;margin=%5Bobject%20Object%5D&amp;originHeight=477&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0f70762-e91b-40e6-ad16-29f364c33ce&amp;title=&amp;width=567" alt=""><br>栈顶乘除, 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569326-10c63ce7-1bb7-4088-b202-5669ddcfa1ce.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud0ca380b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=1116&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u19d8bda1-3868-4505-8ef6-06decfae122&amp;title=" alt=""><br>栈顶 / 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569330-71ccfd20-9804-4216-a208-53f5b5d350c1.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=uaea7846f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=507&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69bde130-2897-4078-9dfd-67844659fef&amp;title=&amp;width=570" alt=""><br>最后位置， 7 入栈， 栈里只有+-符号了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802570274-71211b4b-b360-454e-af84-04dd0cae9fc3.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=ub7bce47c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1112&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8191caa6-71ac-442a-8cc3-02e1fd3d0ff&amp;title=&amp;width=558" alt=""><br>定义递归函数f<br>int[] f(int i)<br>从i位置出发, 遇到右括号或者整个字符串终止位置停止， 返回两个值</li></ol><ul><li><ol><li>answer</li></ol></li><li><ol><li>F函数算到哪个位置了</li></ol></li></ul><p>条件情况：<br>①遇到数字</p><ul><li>设置cur</li></ul><p>②遇到运算符，结合cur加入到队列中<br>③遇到左括号就交给递归去搞，递归返回两个值</p><ul><li><ol><li>answer</li></ol></li><li><ol><li>F函数算到哪个位置了</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127597996-d7be7b6e-c490-4bea-bd31-166716737d7e.png#clientId=u7251bedd-719d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=504&amp;id=u8c22e28e&amp;margin=%5Bobject%20Object%5D&amp;name=B03D96AEEDFC16F1164F383A3C4FA837.png&amp;originHeight=1081&amp;originWidth=1739&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=456166&amp;status=done&amp;style=none&amp;taskId=u8a1e2898-b1b8-4344-a8d0-08c331b7bf2&amp;title=&amp;width=811.0000610351562" alt="B03D96AEEDFC16F1164F383A3C4FA837.png"></p><p><strong>例子2</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802571970-a1640f24-2c37-483d-b77a-efbb1b989559.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=ua50d068b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=445&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u99525ff6-64ba-48bf-b068-cce57175db3&amp;title=&amp;width=506" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572172-4a4912ea-4cde-4445-8205-a79369f2c4ca.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=187&amp;id=u81b31c60&amp;margin=%5Bobject%20Object%5D&amp;originHeight=416&amp;originWidth=1109&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf9fcaa9a-38b5-4adf-97e8-c0b34eab9cd&amp;title=&amp;width=498" alt=""><br>遇到左括号了就调递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572369-f6d4f508-2cf3-4096-944a-dd73f55c5d87.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u0ecc431b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=1103&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub543cc02-862d-4386-ac2e-09562639620&amp;title=&amp;width=546" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572690-1f71ba4c-d5a1-4bca-b4b9-84e14c4ec028.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u1ef6c4e6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=1112&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u81b410fe-4bce-4b03-ae45-37ae4dc0511&amp;title=&amp;width=543" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572941-2ab03421-1f4d-4d27-89e2-904c73ddb9d8.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u5a645239&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=1105&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u43dfc911-4281-454a-8e5d-0e49de897e6&amp;title=&amp;width=515" alt=""><br>压缩数组例子<br>只要是括号嵌套的都这玩意儿。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573019-d4ab5767-707d-4c9e-b387-12602d4bcdc0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=206&amp;id=u794d34bb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=388&amp;originWidth=940&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u011e5f47-e7bf-4aeb-9bb3-746df83d1bb&amp;title=&amp;width=498" alt=""><br>开头为负怎么计算<br>一上来碰到-号, 0, -, 压栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573351-066ab599-0ef9-4c1a-9f56-c63f6a74181f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=u36ef568b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=464&amp;originWidth=1184&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud82d0514-6263-41c7-b9d5-faaef151f10&amp;title=&amp;width=485" alt=""><br><strong>代码</strong><br>最后一个数字还没入栈， 放进去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573451-a23baef1-630a-43f3-89a6-cd2766a53edd.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=312&amp;id=u878bd00f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=483&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0b6eb0c-a03c-4a1a-8d42-f425afa6344&amp;title=&amp;width=582" alt=""><br>这种方法一定要牢牢掌握，因为任何括号嵌套的题都可以这么改</p><p>| <strong>public static int[] </strong>f<strong>(char[] </strong>str, <strong>int </strong>i<strong>) {   </strong>LinkedList<strong>&lt;</strong>String<strong>&gt; </strong>que = <strong>new </strong>LinkedList<strong>&lt;</strong>String<strong>&gt;()</strong>;<br>   <strong>int </strong>cur = 0;<br>   <strong>int[] </strong>bra = <strong>null</strong>;<br>   // 从i出发，开始撸串<br>   <strong>while (</strong>i &lt; str.<strong>length </strong>&amp;&amp; str<strong>[</strong>i<strong>] </strong>!= <strong>‘)’) {<br>      if (</strong>str<strong>[</strong>i<strong>] </strong>&gt;= <strong>‘0’ </strong>&amp;&amp; str<strong>[</strong>i<strong>] </strong>&lt;= <strong>‘9’) {         </strong>cur = cur <em> 10 + str<strong>[</strong>i++<strong>] </strong>- <strong>‘0’</strong>;<br>      <strong>} else if (</strong>str<strong>[</strong>i<strong>] </strong>!= <strong>‘(‘) { </strong>// 遇到的是运算符号<br>         addNum<strong>(</strong>que, cur<strong>)</strong>;//比如队列中此时有 1 +   cur = 2  来到+ 放入 2 +<br>         que.addLast<strong>(</strong>String.valueOf<strong>(</strong>str<strong>[</strong>i++<strong>]))</strong>;<br>         cur = 0;<br>      <strong>} else { </strong>// 遇到左括号了<br>         bra = f<strong>(</strong>str, i + 1<strong>)</strong>;<br>         cur = bra<strong>[</strong>0<strong>]</strong>;<br>         i = bra<strong>[</strong>1<strong>] </strong>+ 1;<br>      <strong>}<br>   }   </strong>//注意！要结束了，把最后一个数字放进去<br>   addNum<strong>(</strong>que, cur<strong>)</strong>;<br>   <strong>return new int[] { </strong>getNum<strong>(</strong>que<strong>)</strong>, i <strong>}</strong>;<br>*</em>}</p><p>public static void <strong>addNum</strong>(<strong>LinkedList</strong>&lt;<strong>String</strong>&gt; <strong>que, </strong>int <strong>num</strong>) {<br>   if (<strong>!que.isEmpty</strong>()) {<br>      int <strong>cur = 0;<br>      String top = que.pollLast</strong>()<strong>;      </strong>if (<strong>top.equals</strong>(“+”) <strong>&#124;&#124; top.equals</strong>(“-“)) {<br>         <strong>que.addLast</strong>(<strong>top</strong>)<strong>;      </strong>} else {<br>         <strong>cur = Integer.valueOf</strong>(<strong>que.pollLast</strong>())<strong>;<br>         num = top.equals</strong>(“<em>“) <strong>? </strong>(**cur </em> num<strong>) </strong>: <strong>(</strong>cur / num<strong>)</strong>;<br>      <strong>}<br>   }   </strong>que.addLast<strong>(</strong>String.valueOf<strong>(</strong>num<strong>))</strong>;<br><strong>}</strong><br><strong>public static int </strong>getNum<strong>(</strong>LinkedList<strong>&lt;</strong>String<strong>&gt; </strong>que<strong>) {<br>   int </strong>res = 0;<br>   <strong>boolean </strong>add = <strong>true</strong>;<br>   String cur = <strong>null</strong>;<br>   <strong>int </strong>num = 0;<br>   <strong>while (</strong>!que.isEmpty<strong>()) {      </strong>cur = que.pollFirst<strong>()</strong>;<br>      <strong>if (</strong>cur.equals<strong>(“+”)) {         </strong>add = <strong>true</strong>;<br>      <strong>} else if (</strong>cur.equals<strong>(“-“)) {         </strong>add = <strong>false</strong>;<br>      <strong>} else {         </strong>num = Integer.valueOf<strong>(</strong>cur<strong>)</strong>;<br>         res += add ? num : <strong>(</strong>-num<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>res;<br><strong>}</strong> |<br>| —- |</p><h3 id="②字符串解码"><a href="#②字符串解码" class="headerlink" title="②字符串解码"></a>②字符串解码</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127913238-063d6a0a-b032-4ca8-89e2-5dc17f30d0be.png#clientId=u7251bedd-719d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u2e367064&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=365&amp;originWidth=771&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22499&amp;status=done&amp;style=none&amp;taskId=u6402f452-c01d-4576-b24d-7d027b199f9&amp;title=&amp;width=440.57142857142856" alt="image.png"></p><p>| <strong>public static </strong>String calculate(String str) {<br>        <strong>return </strong>f(str.toCharArray(), 0)[0];<br>    }</p><pre><code>**public static **String[] f(**char**[] str, **int **i) &#123;    String ans = **&quot;&quot;**;    **int **cur = 0;    // 从i出发，开始撸串    **while **(i &lt; str.**length **&amp;&amp; str[i] != **&#39;]&#39;**) &#123;        //遇到数字        **if **(str[i] &gt;= **&#39;0&#39; **&amp;&amp; str[i] &lt;= **&#39;9&#39;**) &#123;            cur = cur * 10 + str[i++] - **&#39;0&#39;**;        &#125; **else if **(str[i] &gt;= **&#39;a&#39; **&amp;&amp; str[i] &lt;= **&#39;z&#39;**) &#123; //            ans += str[i++];        &#125; **else **&#123; // 遇到左括号了            String[] f = f(str, i + 1);            **for **(**int **j = 0; j &lt; cur; j++) &#123;                ans += f[0];            &#125;            cur = 0;            i = Integer.valueOf(f[1]);            i++;        &#125;    &#125;    **return new **String[] &#123; ans, String.valueOf(i) &#125;;&#125; |</code></pre><p>| —- |</p><h3 id="③❓原子的数量"><a href="#③❓原子的数量" class="headerlink" title="③❓原子的数量"></a>③❓原子的数量</h3><p><strong>扩展：计算括号字符串的分数</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650109458205-b1b14786-40bd-4f1c-bfa1-9a055b24847d.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=uabd6313c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=260&amp;originWidth=711&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36399&amp;status=done&amp;style=none&amp;taskId=u2890ec75-3800-40a2-aabe-f170319bf19&amp;title=&amp;width=568.8" alt="image.png"><br>记住代码，比较难理解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650110035627-385b43a8-6afc-437b-bb16-74508df9d7f8.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u52f0ac7e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=380&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=111603&amp;status=done&amp;style=none&amp;taskId=uc24e086b-659c-49f0-b945-4a1fb06b24d&amp;title=&amp;width=304" alt="image.png"></p><h2 id="·-盛最多水的容器"><a href="#·-盛最多水的容器" class="headerlink" title="· 盛最多水的容器"></a>· 盛最多水的容器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652803229358-74a054ba-5506-4cb4-888f-08fb6bd8faed.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=339&amp;id=uab3100b9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=609&amp;originWidth=926&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40053&amp;status=done&amp;style=none&amp;taskId=u5e22d377-cb6c-42c5-a11e-f25dd5bf093&amp;title=&amp;width=514.7999877929688" alt="image.png"><br><strong>题解</strong><br>先假设无重复值, 左右两个指针<br>左边跟右边比大小， 谁小结算谁的水量<br>两个左右两个指针依次划的过程中算出所有水量的最大值就是答案</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603322-564cdac1-d9b0-46b5-ae4f-e90597069858.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=ue0abe2ca&amp;margin=%5Bobject%20Object%5D&amp;originHeight=526&amp;originWidth=1044&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u56957f64-7d7b-4946-9167-ea72d58d406&amp;title=&amp;width=462" alt=""><br>而事实上3可以继续往右扩大，那我为什么不求出唯一的正确答案，<br>只求3~8这一段的答案呢，这是因为a的答案包含这一段，所以我只关注会不会有把答案推高的可能性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603354-4d6989ad-b2b5-4a05-8c69-6f7008972fd5.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=uf256ec8f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=441&amp;originWidth=1019&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uba4cb029-1101-4abf-a81a-be756f71cbe&amp;title=&amp;width=496" alt=""><br>它不是严格要求每一个数都能够准确的算出来它的答案, 它只关心有没有推高答案的可能性<br>为啥你不知道这道题怎么做?<br>但是你看数据量，你就知道自己一定会憋出一个O(N)的解，<br>那势必可能会想到双指针，谁大移动谁跟谁小移动谁都试一遍这题就出来了，不用知道为什么有可能都能猜出来<br>复杂度O(N)<br>我不去严格纠结到底这个值他真实的最优解是什么，我只纠结会不会让答案变大<br>ref： 数组三连第三连<br><strong>例子</strong><br>只关注它推高答案的可能性，但是我们不去严格纠结每一个位置的值，它具体答案是多少<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603343-312db809-99e8-414c-a228-7fc6ae108e0c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=200&amp;id=u90840346&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=928&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u82dc8d2e-0c79-4da0-9b9b-729957c3535&amp;title=&amp;width=419" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603345-91268f80-07fa-46fd-9be0-2ac568756483.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u9a46939d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2229fb65-1462-44d2-a2f2-ad111e6093d&amp;title=&amp;width=475" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603340-dff504be-50d9-4110-bde8-60d0eaa86e2f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u5153fc20&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1094&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54178eed-544a-423b-9a03-b4e0b59ea95&amp;title=&amp;width=488" alt=""></p><p>| <strong>public static int </strong>maxArea1<strong>(int[] </strong>h<strong>) {<br>   int </strong>max = 0;<br>   <strong>int </strong>N = h.<strong>length</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) { </strong>// h[i]<br>      <strong>for (int </strong>j = i + 1; j &lt; N; j++<strong>) { </strong>// h[j]<br>         max = Math.max<strong>(</strong>max, Math.min<strong>(</strong>h<strong>[</strong>i<strong>]</strong>, h<strong>[</strong>j<strong>]) *</strong> <strong>(</strong>j - i<strong>))</strong>;<br>      <strong>}<br>   }<br>   return </strong>max;<br>**}</p><p>public static int <strong>maxArea2</strong>(int[] <strong>h</strong>) {<br>   int <strong>max = 0;   </strong>int <strong>l = 0;   </strong>int <strong>r = h.</strong>length <strong>- 1;   </strong>while (<strong>l &lt; r</strong>) {<br>      <strong>max = Math.max</strong>(<strong>max, Math.min</strong>(<strong>h</strong>[<strong>l</strong>]<strong>, h</strong>[<strong>r</strong>]) <strong>* </strong>(<strong>r - l</strong>))<strong>;      </strong>if (<strong>h</strong>[<strong>l</strong>] <strong>&gt; h</strong>[<strong>r</strong>]) {<br>         <strong>r—;      </strong>} else {<br>         <strong>l++;      </strong>}<br>   }<br>   return <strong>max;</strong>}** |<br>| —- |</p><h2 id="·-多个有序list中的top-100-大"><a href="#·-多个有序list中的top-100-大" class="headerlink" title="· 多个有序list中的top 100 大"></a>· 多个有序list中的top 100 大</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882236750-67c0af3e-05fa-4bed-98b7-fcf80e36b74c.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=30&amp;id=ufd509bb4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=38&amp;originWidth=637&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7392&amp;status=done&amp;style=none&amp;taskId=uef743611-362e-49ac-b624-c0c7dc58095&amp;title=&amp;width=509.6" alt="image.png"><br>大根堆<br>先把链表逆序<br>所有头部拿出来组成一个大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882248310-fbb2aa87-caa0-422c-a083-a8713a7d4694.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=u5395c82a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=618&amp;originWidth=1291&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u437d1bae-2ae6-40d8-a1af-96d46908e56&amp;title=&amp;width=624" alt=""></p><h2 id="·-跳跃游戏Ⅱ"><a href="#·-跳跃游戏Ⅱ" class="headerlink" title="· 跳跃游戏Ⅱ"></a>· 跳跃游戏Ⅱ</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650029478423-12a50e13-5642-45ad-9e9e-04f762f5b727.png#clientId=u98aeb21b-e583-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=u7efc409b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=666&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=37693&amp;status=done&amp;style=none&amp;taskId=u765ebde4-b464-4164-bf78-e8a292676f9&amp;title=&amp;width=532.8" alt="image.png"><br><strong>题意</strong><br>存在一个选择<br>如果尽着最大步数跳他可能得不到最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305648-957d0562-d157-4d3d-ae6c-fc146f1a4502.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=u7daad865&amp;margin=%5Bobject%20Object%5D&amp;originHeight=510&amp;originWidth=1237&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3f318203-80a6-4650-85bf-4d1f226ff95&amp;title=&amp;width=609" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305602-7f9f8032-223f-476c-b74f-d76bef9d32ac.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=210&amp;id=u21788ad8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1216&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufb841da7-04af-4c5b-907e-0212ae690a1&amp;title=&amp;width=524" alt=""><br>用贪心, 老紧着最大步数跳是不对的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305681-d01ab949-c241-4243-bac5-4c66c124efae.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=uc2a1cfe5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1252&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u926d9fc0-6e2a-4122-a843-128c9c2436c&amp;title=&amp;width=521" alt=""><br><strong>题解</strong><br>流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655211162287-fd0710b0-b985-4a90-bfed-0abe223715f1.png#clientId=u83bd60c9-5fa5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=812&amp;id=u6a026509&amp;margin=%5Bobject%20Object%5D&amp;name=41D4CCD93F04922A9F2D17AA467437A5.png&amp;originHeight=1421&amp;originWidth=1232&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=417915&amp;status=done&amp;style=none&amp;taskId=u26adf01b-d2c7-4f51-8d3d-1813a4c2bf8&amp;title=&amp;width=704" alt="41D4CCD93F04922A9F2D17AA467437A5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882306957-1850e9b7-de8b-4a4a-adea-eb2cfffcc9eb.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=ufbe8fdc9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=579&amp;originWidth=1043&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc564cc66-4380-40a6-a766-66d63c6b832&amp;title=&amp;width=509" alt=""><br>反例<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307533-6f1f96c5-ad80-4f9e-9ab2-54da1412c258.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=uc54b612f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=1132&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3debd364-ff69-4b03-b637-3746408f53d&amp;title=&amp;width=507" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307672-7a9a40e1-5757-4e56-8392-55c6b983411e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u9fe696a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=434&amp;originWidth=797&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u381a4f25-cc9a-4da0-94f2-80b9ae28f16&amp;title=&amp;width=428" alt=""><br><strong>代码</strong></p><p>| <strong>public static int </strong>jump<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>step = 0;//目前位置跳了几步<br>   <strong>int </strong>cur = 0;//如果你不增加步数，step以内，你最远能到哪儿<br>   <strong>int </strong>next = 0;//如果允许我多跳一步，请问我最远的到哪儿<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882687455-34de4ef7-d45e-4515-8847-2cdd7261f16a.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=141&amp;id=u998e7fdc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=219&amp;originWidth=456&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15857&amp;status=done&amp;style=none&amp;taskId=uf377eb45-a694-43de-80a6-f4277e28737&amp;title=&amp;width=292.8000183105469" alt="image.png"><strong>**      if (</strong>cur &lt; i<strong>) {         </strong>step++;<br>         cur = next;<br>      <strong>}      </strong>next = Math.max<strong>(</strong>next, i + arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   return </strong>step;<br><strong>}</strong> |<br>| —- |</p><h2 id="·✊在两个都有序的数组找整体第k小的数"><a href="#·✊在两个都有序的数组找整体第k小的数" class="headerlink" title="·✊在两个都有序的数组找整体第k小的数"></a><strong>·✊在两个都有序的数组找整体第k小的数</strong></h2><h3 id="①算法模型：在两个都有序的数组中找上中位数"><a href="#①算法模型：在两个都有序的数组中找上中位数" class="headerlink" title="①算法模型：在两个都有序的数组中找上中位数"></a>①算法模型：在两个都有序的数组中找上中位数</h3><p><strong>题意</strong><br>O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884443226-1de0ecb3-1471-4e81-899c-0e32b5ca4a66.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ub50901c6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=567&amp;originWidth=891&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua642aa49-06f2-439b-a489-64f4f71a01d&amp;title=&amp;width=426" alt=""><br><strong>题解</strong><br>分情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655299291411-6ecd16bb-340f-4d93-9539-e4bb4a986a8a.png#clientId=u02685321-15d8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1841&amp;id=uf949730e&amp;margin=%5Bobject%20Object%5D&amp;name=7A99CC63E8320AA8102F6ACA846A0A14.png&amp;originHeight=3222&amp;originWidth=1849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1850552&amp;status=done&amp;style=none&amp;taskId=ucde9adac-f3e4-459e-a56d-0b19154fa4c&amp;title=&amp;width=1056.5714285714287" alt="7A99CC63E8320AA8102F6ACA846A0A14.png"><br><strong>代码</strong></p><p>| <strong>public static int </strong>getUpMedian<strong>(int[] </strong>A, <strong>int </strong>s1, <strong>int </strong>e1, <strong>int[] </strong>B, <strong>int </strong>s2, <strong>int </strong>e2<strong>) {<br>   int </strong>mid1 = 0;<br>   <strong>int </strong>mid2 = 0;<br>   <strong>while (</strong>s1 &lt; e1<strong>) {      </strong>// mid1 = s1 + (e1 - s1) &gt;&gt; 1<br>      mid1 = <strong>(</strong>s1 + e1<strong>) </strong>/ 2;<br>      mid2 = <strong>(</strong>s2 + e2<strong>) </strong>/ 2;<br>      <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>== B<strong>[</strong>mid2<strong>]) {<br>         return </strong>A<strong>[</strong>mid1<strong>]</strong>;<br>      <strong>}      </strong>// 两个中点一定不等！<br>      //e1 - s1 + 1就是个数 奇数&amp;1 == 1<br>      <strong>if (((</strong>e1 - s1 + 1<strong>) </strong>&amp; 1<strong>) </strong>== 1<strong>) { </strong>// 奇数长度<br>         //一定要对着例子<br>         <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt; B<strong>[</strong>mid2<strong>]) {<br>            if (</strong>B<strong>[</strong>mid2<strong>] </strong>&gt;= A<strong>[</strong>mid1 - 1<strong>]) {<br>               return </strong>B<strong>[</strong>mid2<strong>]</strong>;<br>            <strong>}            </strong>e1 = mid1 - 1;<br>            s2 = mid2 + 1;<br>         <strong>} else { </strong>// A[mid1] &lt; B[mid2]<br>            <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt;= B<strong>[</strong>mid2 - 1<strong>]) {<br>               return </strong>A<strong>[</strong>mid1<strong>]</strong>;<br>            <strong>}            </strong>e2 = mid2 - 1;<br>            s1 = mid1 + 1;<br>         <strong>}<br>      } else { </strong>// 偶数长度<br>         <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt; B<strong>[</strong>mid2<strong>]) {            </strong>e1 = mid1;<br>            s2 = mid2 + 1;<br>         <strong>} else {            </strong>e2 = mid2;<br>            s1 = mid1 + 1;<br>         <strong>}<br>      }<br>   }<br>   return </strong>Math.min<strong>(</strong>A<strong>[</strong>s1<strong>]</strong>, B<strong>[</strong>s2<strong>])</strong>;<br><strong>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>每一次比价砍一半, 二分, O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884449524-c998a42f-d576-4006-9cf1-9c30739af9d7.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=342&amp;id=Dep6S&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=945&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25c8aeb9-2c09-4667-9058-e9474a70a88&amp;title=&amp;width=517" alt=""></p><h3 id="②进阶：在两个都有序的数组找整体第k小的数"><a href="#②进阶：在两个都有序的数组找整体第k小的数" class="headerlink" title="②进阶：在两个都有序的数组找整体第k小的数"></a><strong>②进阶：在两个都有序的数组找整体第k小的数</strong></h3><p><strong>例子：arr1 17个 arr2 10个</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655300515983-61e193b4-7e6a-4b2e-8067-4cd547c49684.png#clientId=u02685321-15d8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1109&amp;id=uc06c0ab8&amp;margin=%5Bobject%20Object%5D&amp;name=ACE1391B1036C5CD896CD36C7A4E1AF8.png&amp;originHeight=1941&amp;originWidth=2212&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1248551&amp;status=done&amp;style=none&amp;taskId=u7e89ae7d-1de4-45b4-a7ae-d3b2e6a1f95&amp;title=&amp;width=1264" alt="ACE1391B1036C5CD896CD36C7A4E1AF8.png"></p><p>| // 进阶问题 : 在两个都有序的数组中，找整体第K小的数<br>// 可以做到O(log(Min(M,N)))<br><strong>public static int </strong>findKthNum<strong>(int[] </strong>arr1, <strong>int[] </strong>arr2, <strong>int </strong>kth<strong>) {<br>   int[] </strong>longs = arr1.<strong>length </strong>&gt;= arr2.<strong>length </strong>? arr1 : arr2;<br>   <strong>int[] </strong>shorts = arr1.<strong>length </strong>&lt; arr2.<strong>length </strong>? arr1 : arr2;<br>   <strong>int </strong>l = longs.<strong>length</strong>;<br>   <strong>int </strong>s = shorts.<strong>length</strong>;<br>   <strong>if (</strong>kth &lt;= s<strong>) { </strong>// 1)<br>      <strong>return </strong>getUpMedian<strong>(</strong>shorts, 0, kth - 1, longs, 0, kth - 1<strong>)</strong>;<br>   <strong>}<br>   if (</strong>kth &gt; l<strong>) { </strong>// 3)  对着例子【例子太重要了，具象化的代码改为抽象化就可以了】看代码就懂了  贴图过来非常简单！<br>      <strong>if (</strong>shorts<strong>[</strong>kth - l - 1<strong>] </strong>&gt;= longs<strong>[</strong>l - 1<strong>]) {<br>         return </strong>shorts<strong>[</strong>kth - l - 1<strong>]</strong>;<br>      <strong>}<br>      if (</strong>longs<strong>[</strong>kth - s - 1<strong>] </strong>&gt;= shorts<strong>[</strong>s - 1<strong>]) {<br>         return </strong>longs<strong>[</strong>kth - s - 1<strong>]</strong>;<br>      <strong>}<br>      return </strong>getUpMedian<strong>(</strong>shorts, kth - l, s - 1, longs, kth - s, l - 1<strong>)</strong>;<br>   <strong>}</strong><br><strong>**   </strong>// 2)  s &lt; k &lt;= l<br>   <strong>if (</strong>longs<strong>[</strong>kth - s - 1<strong>] </strong>&gt;= shorts<strong>[</strong>s - 1<strong>]) {<br>      return </strong>longs<strong>[</strong>kth - s - 1<strong>]</strong>;<br>   <strong>}<br>   return </strong>getUpMedian<strong>(</strong>shorts, 0, s - 1, longs, kth - s, kth - 1<strong>)</strong>;<br><strong>}</strong> |<br>| —- |</p><h3 id="·-394-字符串解码-M"><a href="#·-394-字符串解码-M" class="headerlink" title="· 394. 字符串解码 [M]"></a>· 394. 字符串解码 [M]</h3><p><strong>题意</strong><br>字符串还原成全是小写字母<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500821-75a18c69-29c4-4b24-b7e5-887be3cb6749.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=ucd62da43&amp;margin=%5Bobject%20Object%5D&amp;originHeight=596&amp;originWidth=1175&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u468d9297-5ca7-472c-88dc-6d62e3ef096&amp;title=&amp;width=488" alt=""><br>原始串只有a~z<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500842-3195e513-118a-4630-af49-7b8ed4406f4d.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=uf17c79f4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u987e1af2-77b6-46ca-b800-4512ab05154&amp;title=&amp;width=364" alt=""><br><strong>题解</strong><br>定义递归函数:</p><ol><li>返回结果字符串</li><li>处理到的位置</li></ol><p>从压缩串str i位置往后转换, 遇到]或者压缩串结尾停止, 停的时候, 从i…停这段返回, 并返回计算到的位置</p><p>所有的嵌套结构可以用这个递归结构求解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500729-ad1aeada-e94d-4f7f-9263-31b5031971c8.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=ua4899735&amp;margin=%5Bobject%20Object%5D&amp;originHeight=660&amp;originWidth=1306&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4a9acdf8-1639-498c-b25c-8532d5b9013&amp;title=&amp;width=451" alt=""><br>比如表达式计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500774-5f55cb4a-375e-4628-8a25-c5886f9b8ecf.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=ub4b51deb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1050&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6130fe28-6f0f-4e73-8f26-03514873989&amp;title=&amp;width=505" alt=""><br>例子<br>一个字符串的总结果， ans<br>一个收集数字的 cur</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500812-577e8e62-310b-441d-b5fc-70f6264da78d.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ueb3f028b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=1249&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2e762acf-74d3-4f32-a96c-9b00be09246&amp;title=&amp;width=643" alt=""><br>2位置遇到左括号, 调子过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504551-ef54c717-a12c-4ef7-a8e6-1dea07860e9f.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u174ad8d4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=1290&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubb7240e5-7fd4-4f17-9d0c-dc13026baee&amp;title=&amp;width=530" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504525-6706a8a2-0c1d-4b36-941c-b9c59ded0d45.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u689b0aea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=668&amp;originWidth=1371&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7f4f3313-621b-4ad6-a317-6341b366355&amp;title=&amp;width=513" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504536-785698a9-0b58-4ea5-bb85-e5870cbed403.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u107f1f9b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=665&amp;originWidth=1262&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8359b1d3-cd55-4872-a3b1-24b10aa2d4d&amp;title=&amp;width=468" alt=""><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504635-339d1550-5bd7-4f34-8eca-7de606f92831.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3a36b325&amp;margin=%5Bobject%20Object%5D&amp;originHeight=795&amp;originWidth=747&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5993c173-de94-4eac-806d-e4d0ee9a8b5&amp;title=" alt=""></p><p>| <strong>public static </strong>String decodeString<strong>(</strong>String s<strong>) {<br>   char[] </strong>str = s.toCharArray<strong>()</strong>;<br>   <strong>return </strong>process<strong>(</strong>str, 0<strong>)</strong>.<strong>ans</strong>;<br>**}</p><p>public static class <strong>Info </strong>{<br>   public <strong>String </strong>ans<strong>;   </strong>public int stop**;</p><p>   <strong>public </strong>Info<strong>(</strong>String a, <strong>int </strong>e<strong>) {<br>      ans </strong>= a;<br>      <strong>stop </strong>= e;<br>   **}<br>}</p><p><strong>// s[i….]  何时停？遇到   ‘]’  或者遇到 s的终止位置，停止<br>// 返回Info<br>// 0) 串<br>// 1) 算到了哪</strong>public static <strong>Info process</strong>(char[] <strong>s, </strong>int <strong>i</strong>) {<br>   <strong>StringBuilder ans = </strong>new <strong>StringBuilder</strong>()<strong>;   </strong>int <strong>count = 0;   </strong>while (<strong>i &lt; s.</strong>length <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>!= </strong>‘]’) {<br>      if ((<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘a’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘z’) <strong>&#124;&#124; </strong>(<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘A’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘Z’)) {<br>         <strong>ans.append</strong>(<strong>s</strong>[<strong>i++</strong>])<strong>;      </strong>} else if (<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘0’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘9’) {<br>         <strong>count = count * 10 + s</strong>[<strong>i++</strong>] <strong>- </strong>‘0’<strong>;      </strong>} else { <strong>// str[index] = ‘[‘<br>         Info next = process</strong>(<strong>s, i + 1</strong>)<strong>;<br>         ans.append</strong>(<strong>timesString</strong>(<strong>count, next.</strong>ans))<strong>;<br>         //<br>         count = 0;<br>         i = next.</strong>stop <strong>+ 1;      </strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>ans.toString</strong>()<strong>, i</strong>)<strong>;</strong>}</p><p>public static <strong>String timesString</strong>(int <strong>times, String str</strong>) {<br>   <strong>StringBuilder ans = </strong>new <strong>StringBuilder</strong>()<strong>;   </strong>for (int <strong>i = 0; i &lt; times; i++</strong>) {<br>      <strong>ans.append</strong>(<strong>str</strong>)<strong>;   </strong>}<br>   return <strong>ans.toString</strong>()<strong>;</strong>}** |<br>| —- |</p><h2 id="·-最长连续序列"><a href="#·-最长连续序列" class="headerlink" title="· 最长连续序列"></a>· 最长连续序列</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650027587467-9c71453c-132e-4e65-92ea-5e95c4838e80.png#clientId=u98aeb21b-e583-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=341&amp;id=uc6150b29&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=833&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35602&amp;status=done&amp;style=none&amp;taskId=u165c0c4b-a7e3-4fba-bdad-65d2fc46eed&amp;title=&amp;width=666.4" alt="image.png"><br><strong>题解</strong><br>连续区间头表+连续区间尾表<br>100来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450085-90058467-9331-4e7f-afc9-abfc89b72c9e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u25beeefc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=397&amp;originWidth=1139&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e7bb74f-ea0e-4c9a-93a4-d29beffe1e0&amp;title=&amp;width=530" alt=""><br>3来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450084-3d961eca-d28d-4f43-b7fe-e707f3e47a19.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=uac2eb7d7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=461&amp;originWidth=1141&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u17d37d9c-915a-46fd-ab24-ef6eb833409&amp;title=&amp;width=498" alt=""><br>4来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450169-15fadec0-cbd9-4797-82c9-51f4aa1f8295.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u4eee0f77&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=1108&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9de3535e-8e32-4ff8-bc47-4d00a37927c&amp;title=&amp;width=480" alt=""><br>合并<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450083-6829ff9b-d260-46f0-b4f6-170148bd867e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ud0fd55ea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=1136&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1511e11d-3175-4713-8409-9f9a8863080&amp;title=&amp;width=457" alt=""><br>6来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450067-4a7f66f8-a015-411b-a4cc-095f219446d4.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u00347243&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90b8fbaa-d0f1-43c4-8845-9a8afae0a7f&amp;title=&amp;width=480" alt=""><br>7来了<br>5<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450782-178be574-6064-458a-9275-a8f116757def.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=230&amp;id=u9c05a450&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u85da3f43-5abc-4192-bdfc-dccfad0d0ca&amp;title=&amp;width=472" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450958-39fc9099-3c15-44d8-bc54-5f2a4a86304a.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=uaca38d01&amp;margin=%5Bobject%20Object%5D&amp;originHeight=567&amp;originWidth=1110&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udcfcab17-b0c7-49d5-b493-4931f6a3233&amp;title=&amp;width=448" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450977-0bb7308a-fa05-40a5-9dcf-9540516264b5.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=uedf3ad85&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=1091&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u863f4790-bc00-4d11-b7ac-4d41a2ecfc5&amp;title=&amp;width=428" alt=""><br>总结<br>每个数来的时候都自己建出自己的区间，看看跟之前都不能合，看看后面能不能合,<br>你每次都严严格格的合完之后，你问我最后有多长的连续区间，你随便找一张表，把value最大值拿出来<br>每一个数来到的时候, 对于哈希表的操作都是O(1)<br><strong>代码</strong><br>难点在于它怎么只用一张哈表搞出来。</p><p>| <strong>public static int </strong>longestConsecutive<strong>(int[] </strong>nums<strong>) {   </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>len = 0;<br>   <strong>for (int </strong>num : nums<strong>) {<br>      if (</strong>!map.containsKey<strong>(</strong>num<strong>)) {         </strong>map.put<strong>(</strong>num, 1<strong>)</strong>;<br>         <strong>int </strong>preLen = map.containsKey<strong>(</strong>num - 1<strong>) </strong>? map.get<strong>(</strong>num - 1<strong>) </strong>: 0;<br>         <strong>int </strong>posLen = map.containsKey<strong>(</strong>num + 1<strong>) </strong>? map.get<strong>(</strong>num + 1<strong>) </strong>: 0;<br>         <strong>int </strong>all = preLen + posLen + 1;<br>         map.put<strong>(</strong>num - preLen, all<strong>)</strong>;<br>         map.put<strong>(</strong>num + posLen, all<strong>)</strong>;<br>         len = Math.max<strong>(</strong>len, all<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>len;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-超级洗衣机（硬记）"><a href="#·-超级洗衣机（硬记）" class="headerlink" title="· 超级洗衣机（硬记）"></a><strong>· 超级洗衣机（硬记）</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932367995-bbe4de73-2904-4594-916c-9533bbc0f67e.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=332&amp;id=uea6a2d41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=415&amp;originWidth=835&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39680&amp;status=done&amp;style=none&amp;taskId=u8f0f91ee-9a43-4785-a206-f20939def19&amp;title=&amp;width=668" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403145-b876e20d-8562-4eff-b4f8-d442cf06b0f4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=u3a840e1e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=554&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0ffadcba-008c-4d96-b91e-d0ebf518fa5&amp;title=&amp;width=482" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403138-c0c32760-5291-473e-8c7b-ed2d0d17ab3d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=193&amp;id=u2bc83435&amp;margin=%5Bobject%20Object%5D&amp;originHeight=569&amp;originWidth=1275&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udf474620-5c39-4ccf-9947-d5377322ff9&amp;title=&amp;width=432" alt=""><br><strong>题解</strong><br>大过滤器<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403158-39eaeb21-beea-423a-9a81-ab1b3e4f0c8a.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u5dbce6c0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=889&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b72d3a9-8d80-444f-a2a7-71510f9fd37&amp;title=&amp;width=381" alt=""><br>思想传统: 算单点的瓶颈, 最后看总答案跟单点瓶颈之间的关系</p><p>假设来到某一台(i号)洗衣机, 衣服数量?<br>假设每台机器该有的平均数我们知道<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403159-bc4570ef-622d-4f66-b7b2-806dd142a67c.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=uaf6e2a70&amp;margin=%5Bobject%20Object%5D&amp;originHeight=526&amp;originWidth=1229&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc26ff0ff-3a4e-4e24-ae5a-aa0f7723c5f&amp;title=&amp;width=589" alt=""><br><strong>第一种情况</strong><br>左右两侧有一个为正数有一个为负数<br>左侧整体欠15件。而它右侧整体多10件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403191-6e7e37d7-0bf5-4987-a6ce-5be5b43a0741.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=u95da6da5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=622&amp;originWidth=837&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u070d6067-1b7d-42c5-b8ff-3bc599784ca&amp;title=&amp;width=386" alt=""><br>左侧整体欠15件。而它右侧整体多20件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932412835-bcbf1abd-1049-4490-a288-38569f24b131.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u491fbc95&amp;margin=%5Bobject%20Object%5D&amp;originHeight=604&amp;originWidth=899&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua656072e-d9c0-41e4-8e4c-954b2598c76&amp;title=&amp;width=402" alt=""><br><strong>总结</strong><br>左右两侧有一个为正数有一个为负数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932414115-732d2fca-785a-4f8e-a095-b8ca0fbe23b4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=ucc357489&amp;margin=%5Bobject%20Object%5D&amp;originHeight=546&amp;originWidth=1002&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5290c3aa-c695-47a0-9411-e0238a73417&amp;title=&amp;width=394" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932417841-5e9e3984-a2c9-4e68-9694-6b85c58bafd0.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u6fe2d0e8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=556&amp;originWidth=971&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ac861c9-058d-4e4e-8e96-d5996a3c43d&amp;title=&amp;width=365" alt=""><br><strong>第二种情况</strong><br>左右两侧都为正数<br>i如果衣服特别少就可能左右两侧都要给它衣服<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932420558-7c95096e-d93b-4f93-b6f3-4eb0b7ca8c5c.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=220&amp;id=ud8e9e4fd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=638&amp;originWidth=857&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6165a81f-c605-4f9c-a6aa-8fe99ad651f&amp;title=&amp;width=296" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421080-d8bf23ca-28a5-4431-aa0e-425b360ae4bd.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u2fc15dd2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=561&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u720e32f9-1f9c-4cd3-bec7-e5cff31ee20&amp;title=&amp;width=394" alt=""><br><strong>最后一种情况</strong><br>左右两侧都为负数<br>如果左侧欠15件。右侧欠7件，我问你是要搬多少轮, 两侧都指望着i出力, 它一次只能扔一件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421484-2e38c5da-e2b5-44fc-b02a-0f6932eb9510.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=udc41672d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=601&amp;originWidth=745&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6afbd492-5e3d-4243-ae8d-d15ddd0797d&amp;title=&amp;width=408" alt=""><br>先算一个总衣服的数量，你再算一个左侧部分的累加和, i位置自己有值。<br>左侧部分欠几件还多几件, 右侧部分欠几件还是多几件。都能算出来<br>有一个衣服的总数量，有一个i左侧的累加和, 接下来你到任何一个i位置。<br>你左侧, 右侧到底是多还是少？你都能算出来</p><p>根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,<br>2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。<br>因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了<br>因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421558-5fddfdda-a71d-4671-aece-dc0b34e07408.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u75e1afcf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u550aae88-3e80-416e-bdc1-1f855da6fc1&amp;title=&amp;width=445" alt=""><br><strong>单点思维传统</strong><br>接雨水的问题, 左侧最大值最小值问题，这些东西都是以单点算出来一个答案，然后去决策等。<br>洗衣机问题它属于我把整个问题，我不去想它整体我就想它单点的答案是啥，你给我整出一个答案，<br>然后我去决策出来什么东西，以后单点去求然后再得到整体答案的办法，将会成为我们的一个思想传统。<br>类似子串子数组问题, 每个位置结尾时候啥答案。其实这也是<strong>单点思维。</strong><br><strong>代码</strong></p><p>| <strong>public static int </strong>findMinMoves<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>size = arr.<strong>length</strong>;<br>   <strong>int </strong>sum = 0;<br>   <strong>for (int </strong>i = 0; i &lt; size; i++<strong>) {      </strong>sum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   if (</strong>sum % size != 0<strong>) {<br>      return </strong>-1;<br>   <strong>}<br>   int </strong>avg = sum / size;<br>   //左侧部分累加和<br>   <strong>int </strong>leftSum = 0;<br>   <strong>int </strong>ans = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>//左侧部分剩余<br>      <strong>int </strong>leftRest = leftSum - i <em> avg;<br>      //右侧部分剩余<br>      <strong>int </strong>rightRest = <strong>(</strong>sum - leftSum - arr<strong>[</strong>i<strong>]) </strong>- <strong>(</strong>size - i - 1<strong>) </strong></em> avg;<br>      <strong>if (</strong>leftRest &lt; 0 &amp;&amp; rightRest &lt; 0<strong>) {         </strong>ans = Math.max<strong>(</strong>ans, Math.abs<strong>(</strong>leftRest<strong>) </strong>+ Math.abs<strong>(</strong>rightRest<strong>))</strong>;<br>      <strong>} else {         </strong>ans = Math.max<strong>(</strong>ans, Math.max<strong>(</strong>Math.abs<strong>(</strong>leftRest<strong>)</strong>, Math.abs<strong>(</strong>rightRest<strong>)))</strong>;<br>      <strong>}      </strong>leftSum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   return </strong>ans;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-缺失的第一个正数"><a href="#·-缺失的第一个正数" class="headerlink" title="· 缺失的第一个正数"></a><strong>· 缺失的第一个正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922711623-5f275d70-6ad9-4a85-b908-b754c4c08188.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=377&amp;id=u10e943fc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=471&amp;originWidth=671&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31833&amp;status=done&amp;style=none&amp;taskId=u01469d94-35f3-4ad3-8669-3edd28f7319&amp;title=&amp;width=536.8" alt="image.png"><br>核心就是<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922917933-411751da-967b-4a5a-bba8-08ca6afba789.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u1d4d9e20&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=629&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=81409&amp;status=done&amp;style=none&amp;taskId=uea4d21e0-d3fc-4dc9-be76-12aa8351e2e&amp;title=&amp;width=503.2" alt="image.png"><br>分为有效区和垃圾区<br>核心</p><ul><li>如果L位置上的数 &lt;=L跟垃圾区交换</li><li><blockquote><p>R位置的数 跟垃圾区交换</p></blockquote></li><li>等于 arr[arr[L]-1]的数也交换<br>| <strong>public static int </strong>firstMissingPositive<strong>(int[] </strong>arr<strong>) { </strong>// l是盯着的位置<br> // 0 ~ L-1有效区<br> <strong>int </strong>L = 0;<br> <strong>int </strong>R = arr.<strong>length</strong>;<br> <strong>while (</strong>L != R**) {<pre><code>**//有效区向右扩**if (**arr**[**L**] **== L + 1**) &#123;   **L++;**&#125; else if (**arr**[**L**] **&lt;= L &amp;#124;&amp;#124; arr**[**L**] **&gt; R &amp;#124;&amp;#124; arr**[**arr**[**L**] **- 1**] **== arr**[**L**]) &#123; **// 垃圾的情况   swap**(**arr, L, --R**)**;**&#125; else &#123;   **swap**(**arr, L, arr**[**L**] **- 1**)**;**&#125;</code></pre> }<br> return <strong>L + 1;</strong>}</li></ul><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-数组的自己不能累加和出的最小正数"><a href="#·-数组的自己不能累加和出的最小正数" class="headerlink" title="· 数组的自己不能累加和出的最小正数"></a><strong>· 数组的自己不能累加和出的最小正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649908121718-8953c38b-c4f7-47ac-ae29-35e9ffd72e37.png#clientId=u66160ce2-b06d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=99&amp;id=u1ea6fc03&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=124&amp;originWidth=366&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12897&amp;status=done&amp;style=none&amp;taskId=u8559eaa1-8292-41bd-a5cc-ca091503438&amp;title=&amp;width=292.8" alt="image.png"><br><strong>第一问</strong><br>同上问<br>arr所有值的累加和从一个负数到一个整数做出一张表, 然后看最后一行<br>arr 0~N-1宿友的值能不能搞定1, 2, 3…, 哪一个最早不行的, 返回就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274512-42b3c5d7-4c34-41d1-90af-b01987c4bcf7.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=ub0253dce&amp;margin=%5Bobject%20Object%5D&amp;originHeight=664&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c3059f8-c8ca-4e0e-8def-f24e2bb3715&amp;title=&amp;width=434" alt=""></p><p>| <strong>public static int </strong>unformedSum2<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>1;<br>   <strong>}<br>   int </strong>sum = 0;<br>   <strong>int </strong>min = Integer.<strong>MAX_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {      </strong>sum += arr<strong>[</strong>i<strong>]</strong>;<br>      min = Math.min<strong>(</strong>min, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}   </strong>// boolean[][] dp …<br>   <strong>int </strong>N = arr.<strong>length</strong>;<br>   <strong>boolean[][] </strong>dp = <strong>new boolean[</strong>N<strong>][</strong>sum + 1<strong>]</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {</strong>// arr[0..i] 0<br>      dp<strong>[</strong>i<strong>][</strong>0<strong>] </strong>= <strong>true</strong>;<br>   <strong>}   </strong>dp<strong>[</strong>0<strong>][</strong>arr<strong>[</strong>0<strong>]] </strong>= <strong>true</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; N; i++<strong>) {<br>      for (int </strong>j = 1; j &lt;= sum; j++<strong>) {         </strong>dp<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= dp<strong>[</strong>i - 1<strong>][</strong>j<strong>] </strong>&#124;&#124; <strong>((</strong>j - arr<strong>[</strong>i<strong>] </strong>&gt;= 0<strong>) </strong>? dp<strong>[</strong>i - 1<strong>][</strong>j - arr<strong>[</strong>i<strong>]] </strong>: <strong>false)</strong>;<br>      <strong>}<br>   }<br>   for (int </strong>j = min; j &lt;= sum; j++<strong>) {<br>      if (</strong>!dp<strong>[</strong>N - 1<strong>][</strong>j<strong>]) {<br>         return </strong>j;<br>      <strong>}<br>   }<br>   return </strong>sum + 1;<br><strong>}</strong> |<br>| —- |</p><p><strong>第二问</strong><br>先把array排序, 正数数组排完序, 左边0位置肯定是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274407-d5bb7112-75b6-4c1a-8c5a-636c29d2da74.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=u7c7998e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=598&amp;originWidth=914&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6d443944-221f-4578-af40-df6b9538517&amp;title=&amp;width=428" alt=""><br>定义变量range =1, 表示从1~1范围上的正数都能累加出来<br>range=k, 代表1~k上的所有正数都能搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-064d2ceb-c903-444a-8b3b-def179bd1054.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=udb091615&amp;margin=%5Bobject%20Object%5D&amp;originHeight=627&amp;originWidth=1208&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u87640a35-779d-455c-92d7-3d66170c5b2&amp;title=&amp;width=451" alt=""><br>当arr 0位置是1的情况下, range=1, 代表1~1范围的正数都可以搞出来<br>如果1位置也是1, range变成2, 代表1~2范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-3a9c1b06-df19-4cbf-a1a0-8890c1df2d33.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=u4a638e7d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1197&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uacb8b2ee-8e40-476b-b0e6-d3dd0902597&amp;title=&amp;width=546" alt=""><br>如果2位置也是2, range变成4, 代表1~4范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274433-c44f8de2-ab64-4735-a4ae-0d303eaeb2be.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=u36d33f1c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=629&amp;originWidth=1218&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75c49504-7235-4203-9e18-e0efd1c066a&amp;title=&amp;width=500" alt=""><br>如果0~i-1是0~100, range=100<br>i位置17, 可以让range扩充到117</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276639-76ea18e4-1553-4416-b729-602f169e4256.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=ud24b4420&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=1188&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf800b3ae-b828-40f4-9f35-e53b5b30e59&amp;title=&amp;width=540" alt=""><br>注意一点<br>如果0~i-1能搞定的数是1~100, 此时i位置是102, 那么101不可以搞定<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276627-25522d30-aa31-47f1-a2c0-70754b005b35.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=ub8d18f54&amp;margin=%5Bobject%20Object%5D&amp;originHeight=641&amp;originWidth=946&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c78c50f-b4c4-4174-aeb2-65532acedc1&amp;title=&amp;width=484" alt=""><br><strong>抽象化</strong><br>如果0~i-1搞定1~a, 如果i位置上是b:<br>1)如果b&lt;= a+1, 能扩充, 范围到1~a+b<br>2)如果b&gt; a+1, a+1就是搞定不了的最小正整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276617-5b986e34-cf33-4d56-a953-8b54313b7cb9.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=309&amp;id=u561892aa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=661&amp;originWidth=1101&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8618d200-7b25-4c41-89a5-14bb0c7e026&amp;title=&amp;width=515" alt=""><br><strong>代码</strong></p><p>| <strong>// 已知arr中肯定有1这个数</strong>public static int <strong>unformedSum3</strong>(int[] <strong>arr</strong>) {<br>   if (<strong>arr == </strong>null <strong>&#124;&#124; arr.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   <strong>Arrays.sort</strong>(<strong>arr</strong>)<strong>; // O (N * logN)   </strong>int <strong>range = 1;<br>   // arr[0] == 1   </strong>for (int <strong>i = 1; i != arr.</strong>length<strong>; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; range + 1</strong>) {<br>         return <strong>range + 1;      </strong>} else {<br>         <strong>range += arr</strong>[<strong>i</strong>]<strong>;      </strong>}<br>   }<br>   return <strong>range + 1;</strong>}** |<br>| —- |</p><p>原题<br>arr是正数, 要求子集不能是空集, 最小子集累加和到最大子集累加和的范围中哪个数是最小不可组成的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927277249-0071ad5e-e13b-4370-bfe9-c4e82ef62414.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=u10a4ace4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=644&amp;originWidth=1230&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6504140f-42f0-4cdd-ab09-4e8752f37b5&amp;title=&amp;width=385" alt=""></p><h2 id="·-按要求补齐数组"><a href="#·-按要求补齐数组" class="headerlink" title="· 按要求补齐数组"></a>· 按要求补齐数组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649917704725-47286ee2-4581-440e-87d2-40217bdc6892.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=401&amp;id=uafa838b3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=501&amp;originWidth=821&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36432&amp;status=done&amp;style=none&amp;taskId=u650b2498-cf20-4fe1-bdde-0a59049f6aa&amp;title=&amp;width=656.8" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555620-061a554b-82b5-41e0-9e92-a690ce40510d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=ud98747b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=559&amp;originWidth=1248&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc3bcf646-19ce-4700-8f4a-bd401665f44&amp;title=&amp;width=389" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555641-e30d7e5e-1c75-4f52-a033-af5aee074d54.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u7ba03d88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=1240&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4a3bc28c-d3a2-4b58-ba9a-de9d7ca6744&amp;title=&amp;width=477" alt=""><br>到达数字+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555680-c1d3ccf6-3771-4e93-96b8-39c885a5a4bf.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=211&amp;id=ub2e23613&amp;margin=%5Bobject%20Object%5D&amp;originHeight=639&amp;originWidth=1262&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc2cbb657-a0c0-4d31-afee-d802e35c8fe&amp;title=&amp;width=417" alt=""><br><strong>题解</strong><br>先把数组排序<br>数组中每个数最经济的使用<br>只能是 1~3 范围，你先都搞定之后，你舒舒服服，使用这个4，就能扩到1~7了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555600-28054282-00a3-4ada-b588-8c83daa1343d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=165&amp;id=u36009711&amp;margin=%5Bobject%20Object%5D&amp;originHeight=414&amp;originWidth=1355&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c1ace8f-dc3d-4e30-aa37-c80e0af525c&amp;title=&amp;width=540" alt=""><br>给自己提了小目标，这个小目标是搞定1~3 范围上，你缺几个数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555576-2c52f0c4-a3ee-4fe0-99fd-d5ad4194db98.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=u2bb70482&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=1326&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u30cd7616-6530-4109-9843-187a632bcd8&amp;title=&amp;width=539" alt=""><br>对于5, 小目标1~4范围上都可以搞定, 已经满足了<br>可以直接使用这个5，让它变成12，不用添任何数字</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559417-d4b87abf-d387-42d2-8d80-4a0a8ec4f0c4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u32d93753&amp;margin=%5Bobject%20Object%5D&amp;originHeight=584&amp;originWidth=1317&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u127e139e-6b60-4227-ad19-1e323514d0d&amp;title=&amp;width=521" alt=""><br>想使用17, 要求目标1~16必须具备<br>目前有1~12, 缺13, 补13之后范围扩到1~25<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559808-215561a1-ff63-415f-bf78-fad7b73a64ba.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=uea5b1f49&amp;margin=%5Bobject%20Object%5D&amp;originHeight=611&amp;originWidth=1322&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2cc09c61-ee32-4302-b314-4ba0be0fea5&amp;title=&amp;width=507" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927560402-d3d539ae-2061-402e-8409-47fe164264a2.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=227&amp;id=u09c809c8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=618&amp;originWidth=1338&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7877baab-db60-4c74-96b5-33a014c76fd&amp;title=&amp;width=491" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561057-82a9fd44-9823-4f41-858c-acdcdc07147b.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u1757f08b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=660&amp;originWidth=1340&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucad0fd2b-6999-4754-89cb-2a2fdc5f0e0&amp;title=&amp;width=468" alt=""><br><strong>例子</strong><br>如果n特别大, 整个数组都使用完以后范围是1~3050, 先补3051<br>整个数组都使完之后，如果你还没到，接下来的过程就等同于给了你一个范围，你一个数也没有了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561285-f47b7093-d077-49ef-9d8a-40af2438e4b0.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=u48355d80&amp;margin=%5Bobject%20Object%5D&amp;originHeight=587&amp;originWidth=1165&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25fd03f5-cf32-4ea9-b5a2-10523fc59b6&amp;title=&amp;width=399" alt=""><br>注意点<br>只要范围扩充了，我就盯着总目标有没有实现，我不一定要使用完所有数字，我可能已经提前搞定考了，<br>我缺了多少数字，如果发现我range已经到它了，直接返回就可以了，不用看后面的数字<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927562331-6d5e0b3b-b786-468c-a940-7c5b9ed70aa2.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=u84594179&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1341&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3d649c1a-e5d8-43f0-87e0-47de55d83b7&amp;title=&amp;width=510" alt=""></p><p>| // arr请保证有序，且正数  1~aim<br><strong>public static int </strong>minPatches<strong>(int[] </strong>arr, <strong>int </strong>aim<strong>) {<br>   int </strong>patches = 0; // 缺多少个数字<br>   <strong>long </strong>range = 0; // 已经完成了1 ~ range的目标<br>   Arrays.sort<strong>(</strong>arr<strong>)</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {      </strong>// arr[i]<br>      // 要求：1 ~ arr[i]-1 范围被搞定！<br>      <strong>while (</strong>arr<strong>[</strong>i<strong>] </strong>- 1 &gt; range<strong>) { </strong>// arr[i] 1 ~ arr[i]-1<br>         range += (range + 1); // range + 1 是缺的数字<br>         patches++;<br>         //只要范围一变化就盯着目标<br>         <strong>if (</strong>range &gt;= aim<strong>) {<br>            return </strong>patches;<br>         <strong>}<br>      }      </strong>// 要求被满足了！<br>      range += arr<strong>[</strong>i<strong>]</strong>;<br>      <strong>if (</strong>range &gt;= aim<strong>) {<br>         return </strong>patches;<br>      <strong>}<br>   }<br>   while (</strong>aim &gt;= range + 1<strong>) {      </strong>range += range + 1;<br>      patches++;<br>   <strong>}<br>   return </strong>patches;<br><strong>}</strong> |<br>| —- |</p><h2 id=""><a href="#" class="headerlink" title="//======================"></a>//======================</h2><h2 id="·-240-行列递增矩阵的查找-搜索二维矩阵-II-M"><a href="#·-240-行列递增矩阵的查找-搜索二维矩阵-II-M" class="headerlink" title="· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]"></a>· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538431656-6b591c24-62b5-4f4d-a992-0e2ee6455b85.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=78&amp;id=ucaa40dd5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=549&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11740&amp;status=done&amp;style=none&amp;taskId=u76050ce0-5216-4663-83e4-b58fdd5ced0&amp;title=&amp;width=439.2" alt="image.png"><br><strong>题意</strong><br>让你找某一个数字在其中是否存在<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537626124-5e69971c-798a-4382-a6c0-56062f07a154.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u825d9625&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=642&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u938e2c19-6aff-4589-84b0-79641bb03ae&amp;title=&amp;width=348" alt=""><br><strong>题解</strong><br>经典解法:<br>从右上角开始找<br>复杂度O(N+M)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624515-057e50f5-c481-4b0a-8091-003f019142d4.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u86a3eab4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=611&amp;originWidth=1257&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufda2a2e9-c766-4bc5-9780-98846953c45&amp;title=&amp;width=553" alt=""><br>从左下角走</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624507-9f4bca2b-fa51-4bd1-ae0a-cc127e634a97.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ubf5cba53&amp;margin=%5Bobject%20Object%5D&amp;originHeight=601&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0f5c24b9-5e75-475b-96da-fcd5f286991&amp;title=&amp;width=515" alt=""></p><p>| <strong>public static boolean </strong>isContains<strong>(int[][] </strong>matrix, <strong>int </strong>K<strong>) {<br>   int </strong>row = 0;<br>   <strong>int </strong>col = matrix<strong>[</strong>0<strong>]</strong>.<strong>length </strong>- 1;<br>   <strong>while (</strong>row &lt; matrix.<strong>length </strong>&amp;&amp; col &gt; -1<strong>) {<br>      if (</strong>matrix<strong>[</strong>row<strong>][</strong>col<strong>] </strong>== K<strong>) {<br>         return true</strong>;<br>      <strong>} else if (</strong>matrix<strong>[</strong>row<strong>][</strong>col<strong>] </strong>&gt; K<strong>) {         </strong>col—;<br>      <strong>} else {         </strong>row++;<br>      <strong>}<br>   }<br>   return false</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-✊378-行列递增矩阵中的第K小-M"><a href="#·-✊378-行列递增矩阵中的第K小-M" class="headerlink" title="· ✊378.行列递增矩阵中的第K小 [M]"></a>· ✊378.行列递增矩阵中的第K小 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538447469-55d93518-20af-4ac9-bb0d-cc650b505a39.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=75&amp;id=ue2220b92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=94&amp;originWidth=543&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12027&amp;status=done&amp;style=none&amp;taskId=u7642227d-241c-4306-8adb-3d21d1474a6&amp;title=&amp;width=434.4" alt="image.png"><br><strong>最优解</strong><br>给定一个目标, 想知道&lt;=100的数有几个, 怎么快能求出来?<br>往左走, 获得0个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464907-2dead8bf-8612-4941-8c80-3b22ba09131b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=192&amp;id=u2e5cfef4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=584&amp;originWidth=1302&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5722571-1037-41c0-a18e-d6fb6cb934b&amp;title=&amp;width=427" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464900-3f1bafb2-1bae-4cdb-8c53-cc846c69f134.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u4704966e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=599&amp;originWidth=1269&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4d022a33-b6ba-45b1-8229-acd68f70a81&amp;title=&amp;width=500" alt=""><br>就这样一直卡到结束，你正确的获得整个数组中有多少个数&lt;=100<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464925-50973775-2761-4ed9-8cd5-5337041bf338.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=ua11d3edf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=636&amp;originWidth=1279&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueff346fb-ab57-4bd5-9a3e-3880b1e4b7b&amp;title=&amp;width=534" alt=""><br><strong>例子</strong><br>&lt;=100的有几个, 同时也可以知道最接近100的是啥数?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464932-49c9b5d2-a01d-4a5c-8975-50303fa6a936.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u56983f42&amp;margin=%5Bobject%20Object%5D&amp;originHeight=588&amp;originWidth=1296&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u67098799-26c6-4f3c-8175-19f94ecb673&amp;title=&amp;width=521" alt=""><br>120&gt;100获得0个</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464930-de301eda-d2b0-440b-b938-1bc52130534e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=u2cdb7407&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=1311&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b4b31cf-26dc-496f-8390-87189a86c68&amp;title=&amp;width=411" alt=""><br>100&gt;90 假设90所在的列是col<br>获得的个数是rol+1<br>同时更新接近100的数字为90</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465650-44206736-0a80-4be1-b524-3e42d7c92086.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=u653e1491&amp;margin=%5Bobject%20Object%5D&amp;originHeight=566&amp;originWidth=1304&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uefd5909b-1438-4e68-8c39-07bb5605a84&amp;title=&amp;width=549" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465710-67505b3a-0cc8-4c66-b908-40ff88ecab43.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=181&amp;id=u66d628df&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1310&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufefde839-ee65-4893-88e1-ff39a92a975&amp;title=&amp;width=431" alt=""><br>解决原问题<br><strong>二分</strong><br>整个数组中最小的是谁？左上角的数<br>那整个数组中，最大的数是谁？右下角的数<br>第一百小的数一定在一到1000之间, 看看&lt;=500的数有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465810-e8be4f70-42f7-4fa5-b7a0-c81514b2ff5d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=256&amp;id=u9bcf7146&amp;margin=%5Bobject%20Object%5D&amp;originHeight=599&amp;originWidth=1219&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u479e614c-408d-4eb6-9c84-94373d1aa27&amp;title=&amp;width=521" alt=""><br>如果&lt;=500有200个, 目标大了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465999-a6e86772-a3ac-4585-a06c-2081f5cdd43e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=284&amp;id=uddbef8b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=650&amp;originWidth=1265&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u361c54da-f6cb-48a8-9aaf-db96a0a03c1&amp;title=&amp;width=553" alt=""><br>有可能最后得到&lt;=785的数有100个, 但是数组中没有这个数, 应该是&lt;=785并离它最近<br>的数<br>我每次让你过的时候求俩信息，</p><ul><li>第一小于等于某一个值个数有几个</li><li>第二，最接近它的是谁？</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466133-869c69d6-fbbd-4e08-b85f-e7affbbdba50.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=u32fd171a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=632&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf7b5a0ae-78a1-4110-90ef-898624a9d91&amp;title=&amp;width=560" alt=""><br><strong>复杂度</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466525-0b2fee08-0f44-4e91-b063-3992ab4853f0.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=268&amp;id=ucbc9934f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=659&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua58a75d8-03db-4569-b937-1af685bff8d&amp;title=&amp;width=513" alt=""><br><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466467-9e5f348e-c41d-4268-9b00-b0c0e20be6de.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u762a2f31&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1285&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8fa0287d-25c4-48b9-a7cf-aa1e3e128a1&amp;title=&amp;width=516" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466606-1c01a2b3-8288-4f63-a32f-5ef20107ec9d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=ua6082d71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=912&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1827838a-ed61-4d55-b0e4-80808063065&amp;title=&amp;width=564" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466819-f599b5d1-bfaf-409d-9a8b-05f51b31ee1a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u7c9fce28&amp;margin=%5Bobject%20Object%5D&amp;originHeight=671&amp;originWidth=1356&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u150b1272-8545-4d16-8622-d69dad22697&amp;title=&amp;width=544" alt=""><br><strong>代码</strong></p><p>| // 二分的方法<br><strong>public static int </strong>kthSmallest2<strong>(int[][] </strong>matrix, <strong>int </strong>k<strong>) {<br>   int </strong>N = matrix.<strong>length</strong>;<br>   <strong>int </strong>M = matrix<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>left = matrix<strong>[</strong>0<strong>][</strong>0<strong>]</strong>;<br>   <strong>int </strong>right = matrix<strong>[</strong>N - 1<strong>][</strong>M - 1<strong>]</strong>;<br>   <strong>int </strong>ans = 0;<br>   <strong>while (</strong>left &lt;= right<strong>) {<br>      int </strong>mid = left + <strong>((</strong>right - left<strong>) </strong>&gt;&gt; 1<strong>)</strong>;<br>      // &lt;=mid 有几个 &lt;= mid 在矩阵中真实出现的数，谁最接近mid<br>      Info info = noMoreNum<strong>(</strong>matrix, mid<strong>)</strong>;<br>      <strong>if (</strong>info.<strong>num </strong>&lt; k<strong>) {         </strong>left = mid + 1;<br>      <strong>} else {         </strong>//这里就是有可能&lt;=785的数有100个，但是数组中没有这个数，所以要记录与他最接近的<br>         ans = info.<strong>near</strong>;<br>         right = mid - 1;<br>      <strong>}<br>   }<br>   return </strong>ans;<br>**}</p><p>public static class <strong>Info </strong>{<br>   public int near<strong>;   </strong>public int num**;</p><p>   <strong>public </strong>Info<strong>(int </strong>n1, <strong>int </strong>n2<strong>) {<br>      near </strong>= n1;<br>      <strong>num </strong>= n2;<br>   **}<br>}</p><p>public static <strong>Info noMoreNum</strong>(int[][] <strong>matrix, </strong>int <strong>value</strong>) {<br>   int <strong>near = Integer.</strong>MIN_VALUE<strong>;   </strong>int <strong>num = 0;   </strong>int <strong>N = matrix.</strong>length<strong>;   </strong>int <strong>M = matrix</strong>[<strong>0</strong>]<strong>.</strong>length<strong>;   </strong>int <strong>row = 0;   </strong>int <strong>col = M - 1;   </strong>while (<strong>row &lt; N &amp;&amp; col &gt;= 0</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&lt;= value</strong>) {<br>         <strong>near = Math.max</strong>(<strong>near, matrix</strong>[<strong>row</strong>][<strong>col</strong>])<strong>;<br>         num += col + 1;<br>         row++;      </strong>} else {<br>         <strong>col—;      </strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>near, num</strong>)<strong>;</strong>}** |<br>| —- |</p><p>| // 堆的方法<br><strong>public static int </strong>kthSmallest1<strong>(int[][] </strong>matrix, <strong>int </strong>k<strong>) {<br>   int </strong>N = matrix.<strong>length</strong>;<br>   <strong>int </strong>M = matrix<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>heap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;(new </strong>NodeComparator<strong>())</strong>;<br>   <strong>boolean[][] </strong>set = <strong>new boolean[</strong>N<strong>][</strong>M<strong>]</strong>;<br>   heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>0<strong>][</strong>0<strong>]</strong>, 0, 0<strong>))</strong>;<br>   set<strong>[</strong>0<strong>][</strong>0<strong>] </strong>= <strong>true</strong>;<br>   <strong>int </strong>count = 0;<br>   Node ans = <strong>null</strong>;<br>   <strong>while (</strong>!heap.isEmpty<strong>()) {      </strong>ans = heap.poll<strong>()</strong>;<br>      <strong>if (</strong>++count == k<strong>) {<br>         break</strong>;<br>      <strong>}<br>      int </strong>row = ans.<strong>row</strong>;<br>      <strong>int </strong>col = ans.<strong>col</strong>;<br>      <strong>if (</strong>row + 1 &lt; N &amp;&amp; !set<strong>[</strong>row + 1<strong>][</strong>col<strong>]) {         </strong>heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>row + 1<strong>][</strong>col<strong>]</strong>, row + 1, col<strong>))</strong>;<br>         set<strong>[</strong>row + 1<strong>][</strong>col<strong>] </strong>= <strong>true</strong>;<br>      <strong>}<br>      if (</strong>col + 1 &lt; M &amp;&amp; !set<strong>[</strong>row<strong>][</strong>col + 1<strong>]) {         </strong>heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>row<strong>][</strong>col + 1<strong>]</strong>, row, col + 1<strong>))</strong>;<br>         set<strong>[</strong>row<strong>][</strong>col + 1<strong>] </strong>= <strong>true</strong>;<br>      <strong>}<br>   }<br>   return </strong>ans.<strong>value</strong>;<br>**}</p><p>public static class <strong>Node </strong>{<br>   public int value<strong>;   </strong>public int row<strong>;   </strong>public int col**;</p><p>   <strong>public </strong>Node<strong>(int </strong>v, <strong>int </strong>r, <strong>int </strong>c<strong>) {<br>      value </strong>= v;<br>      <strong>row </strong>= r;<br>      <strong>col </strong>= c;<br>   **}</p><p>}</p><p>public static class <strong>NodeComparator </strong>implements <strong>Comparator</strong>&lt;<strong>Node</strong>&gt; {</p><p>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return <strong>o1.</strong>value <strong>- o2.</strong>value<strong>;   </strong>}</p><p>}** |<br>| —- |</p><h2 id="·-940-不同的子序列-II-H"><a href="#·-940-不同的子序列-II-H" class="headerlink" title="· 940.不同的子序列 II [H]"></a>· 940.不同的子序列 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538612708-fda8d9fb-bb27-4677-8080-a6c88db86f79.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=330&amp;id=u64377b4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=412&amp;originWidth=662&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24324&amp;status=done&amp;style=none&amp;taskId=ub9741443-896e-42ce-8c56-8a848253493&amp;title=&amp;width=529.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-ffb30de6-f89e-4cc2-97f9-f689fa201501.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=u1fea0879&amp;margin=%5Bobject%20Object%5D&amp;originHeight=587&amp;originWidth=1215&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u55df378d-a803-40de-a808-0dedf0ccfe0&amp;title=&amp;width=458" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-f0b61739-d00f-48b6-998c-26a3711ea3bf.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u1df3788a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1042&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4f9cf5bd-ef8b-440e-8b26-ba037940ecf&amp;title=&amp;width=429" alt=""><br><strong>题解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655384932788-bf089bd0-c6f2-473c-a397-a313422b8837.png#clientId=u782dedcd-cafb-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1810&amp;id=ua0fa29c9&amp;margin=%5Bobject%20Object%5D&amp;name=779E39B64BA9EC69E5A1C515E4200530.png&amp;originHeight=3168&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1164522&amp;status=done&amp;style=none&amp;taskId=udfa184cd-8bbd-4169-93f5-29e4850f4c6&amp;title=&amp;width=813.7142857142857" alt="779E39B64BA9EC69E5A1C515E4200530.png"><br>模操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538826795-e3410ba0-a512-485d-951d-69bb5cb981a6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9b1dd3e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=755&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u811d823a-3961-4f75-b8f3-4b6d6da427b&amp;title=" alt=""></p><p>| <strong>public static int </strong>zuo1<strong>(</strong>String s<strong>) {<br>      if (</strong>s == <strong>null </strong>&#124;&#124; s.length<strong>() </strong>== 0<strong>) {<br>         return </strong>0;<br>      <strong>}<br>      int </strong>m = 1000000007;<br>      <strong>char[] </strong>str = s.toCharArray<strong>()</strong>;<br>      HashMap<strong>&lt;</strong>Character, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>      <strong>int </strong>all = 1; // 一个字符也没遍历的时候，有空集<br>      <strong>for (char </strong>x : str<strong>) {         </strong>//新加出来的玩意儿就是以什么结尾的数量<br>         <strong>int </strong>newAdd = all;<br>         <strong>int </strong>curAll = all + newAdd - <strong>(</strong>map.containsKey<strong>(</strong>x<strong>) </strong>? map.get<strong>(</strong>x<strong>) </strong>: 0<strong>)</strong>;<br>         all = curAll;<br>         map.put<strong>(</strong>x, newAdd<strong>)</strong>;<br>      <strong>}<br>      return </strong>all;<br>   <strong>}<br>   public static int </strong>zuo<strong>(</strong>String s<strong>) {<br>      if (</strong>s == <strong>null </strong>&#124;&#124; s.length<strong>() </strong>== 0<strong>) {<br>         return </strong>0;<br>      <strong>}<br>      int </strong>m = 1000000007;<br>      <strong>char[] </strong>str = s.toCharArray<strong>()</strong>;<br>      HashMap<strong>&lt;</strong>Character, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>      <strong>int </strong>all = 1; // 一个字符也没遍历的时候，有空集<br>      <strong>for (char </strong>x : str<strong>) {<br>         int </strong>newAdd = all;<br>//       int curAll = all + newAdd - (map.containsKey(x) ? map.get(x) : 0);<br>         <strong>int </strong>curAll = all;<br>         curAll = <strong>(</strong>curAll + newAdd<strong>) </strong>% m;<br>         //减完可能为负数，所以要先加<br>         curAll = <strong>(</strong>curAll - <strong>(</strong>map.containsKey<strong>(</strong>x<strong>) </strong>? map.get<strong>(</strong>x<strong>) </strong>: 0<strong>) </strong>+ m<strong>) </strong>% m;<br>         all = curAll;<br>         map.put<strong>(</strong>x, newAdd<strong>)</strong>;<br>      <strong>}<br>      return </strong>all;<br>   <strong>}</strong> |<br>| —- |</p><h2 id="·-汉诺塔游戏中的最优状态"><a href="#·-汉诺塔游戏中的最优状态" class="headerlink" title="· 汉诺塔游戏中的最优状态"></a>· 汉诺塔游戏中的最优状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539211568-a1dd0839-322f-4a09-8fbb-4427209b059d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=156&amp;id=u5e9bcd3b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=195&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40554&amp;status=done&amp;style=none&amp;taskId=u75553f41-4211-4e03-b1c3-af09e2d344e&amp;title=&amp;width=489.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187846-f70f3d8f-0157-43bd-b853-e65f7208f8ce.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=ua14962a4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=1280&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u50a5c929-49c5-44bd-bc95-307b8dadc4c&amp;title=&amp;width=585" alt=""><br>7层汉诺塔问题的一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187621-d66d9436-5fa6-4b96-8665-50fa8b081a64.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=uc20ed9ff&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1260&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1831e6fb-2ea6-4897-b345-95c2d0e887b&amp;title=&amp;width=559" alt=""><br>最优解的第一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187608-84fce00e-ce50-476f-8097-9a88be815ab3.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=188&amp;id=u606020c1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=373&amp;originWidth=1323&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udc765580-8b82-4da7-9d75-d59459d93e9&amp;title=&amp;width=666" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187793-ebb720d3-d2df-44dd-b600-10e2915349d5.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ue283094b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=633&amp;originWidth=1368&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub9dc08a9-ad4f-48c3-9036-b1723d5d890&amp;title=&amp;width=595" alt=""><br><strong>题解</strong><br>复杂度 O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187754-902ce282-eb4d-4ffa-b9f2-08d5bb24a1ca.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=265&amp;id=ueee15b1a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=594&amp;originWidth=1173&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5fe3be44-3808-4c07-a651-80f9cb66498&amp;title=&amp;width=523" alt=""><br>先忘掉左中右, 目标是逐渐分解的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281818-8f55bc3d-600b-4fe1-9a28-194a2e14b313.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=uc72a3d6d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=632&amp;originWidth=1309&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9972a330-30f9-4bb4-b8c7-08fe6f74d00&amp;title=&amp;width=560" alt=""><br><strong>抽象</strong><br>i: 1~i的圆盘需要移动<br>F: 1~i的圆盘现在处在什么圆盘上, 可能是左, 中, 右<br>t: 需要去的位置, 可能是左, 中, 右<br>other: 除了from, to的另外一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281875-9d349353-6eed-4b5a-9c10-e6e7433d67c4.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=ua78ed761&amp;margin=%5Bobject%20Object%5D&amp;originHeight=633&amp;originWidth=1251&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ued654e3c-92fc-4ef3-a314-9c63cc17362&amp;title=&amp;width=574" alt=""><br><strong>代码</strong><br>i层的圆盘没有任何道理是在other上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358889-bf247fdd-e580-4abd-8d24-c40995fab0f6.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=316&amp;id=u5e1ef882&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=1171&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d288535-fb85-41b3-98d3-2cf5fb5d4b2&amp;title=&amp;width=591" alt=""><br>如果index还在From上, 说明第一大步没走完<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358848-516f2145-a3f9-46ba-81c9-e9ce28edee97.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=293&amp;id=u07d3b69a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=651&amp;originWidth=1255&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u48e1996c-d742-490a-96d7-66c6462a3a3&amp;title=&amp;width=565" alt=""><br><strong>n层汉诺塔最优解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358910-0c4cbbd5-0292-44fe-b9d6-b53981389b71.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=ua0d8af67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=654&amp;originWidth=879&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d18edcc-fa98-42fc-8d83-170aa0206d6&amp;title=&amp;width=386" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028378401-1aa4cb61-81e0-4606-934e-dbf7cd028030.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u5785399a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=612&amp;originWidth=1203&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uea4922b0-8da4-4a95-abb3-8986b68ee4c&amp;title=&amp;width=491" alt=""><br>后续有任何一点点无效，你整体就无效</p><p>| <strong>public static int </strong>kth<strong>(int[] </strong>arr<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>return </strong>step<strong>(</strong>arr, N - 1, 1, 3, 2<strong>)</strong>;<br>**}</p><p><strong>// 0…index这些圆盘，arr[0..index] index+1层塔<br>// 在哪？from 去哪？to 另一个是啥？other<br>// arr[0..index]这些状态，是index+1层汉诺塔问题的，最优解第几步</strong>public static int <strong>step</strong>(int[] <strong>arr, </strong>int <strong>index, </strong>int <strong>from, </strong>int <strong>to, </strong>int <strong>other</strong>) {<br>   if (<strong>index == -1</strong>) {<br>      return <strong>0;   </strong>}<br>   if (<strong>arr</strong>[<strong>index</strong>] <strong>== other</strong>) {<br>      return <strong>-1;   </strong>}<br>   <strong>/</strong>多想想就明白了</p><pre><code>* 比如 arr[3,2,1] 三层汉诺塔问题** 第一个在to区* 第二个在**/</code></pre><p>   // arr[index] == from arr[index] == to;<br>   <strong>if (</strong>arr<strong>[</strong>index<strong>] </strong>== from<strong>) {<br>      return </strong>step<strong>(</strong>arr, index - 1, from, other, to<strong>)</strong>;<br>   <strong>} else {<br>      int </strong>p1 = <strong>(</strong>1 &lt;&lt; index<strong>) </strong>- 1;<br>      <strong>int </strong>p2 = 1;<br>      <strong>int </strong>p3 = step<strong>(</strong>arr, index - 1, other, to, from<strong>)</strong>;<br>      <strong>if (</strong>p3 == -1<strong>) {<br>         return </strong>-1;<br>      <strong>}<br>      return </strong>p1 + p2 + p3;<br>   <strong>}<br>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>单决策递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028426636-08060a50-74cc-4c62-8e62-424f512cf88c.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=338&amp;id=u443ec777&amp;margin=%5Bobject%20Object%5D&amp;originHeight=634&amp;originWidth=943&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u203f3cdf-b1ab-456b-b0c3-d0034313049&amp;title=&amp;width=502" alt=""></p><h2 id="·-两个有序数组间相加和的Topk问题"><a href="#·-两个有序数组间相加和的Topk问题" class="headerlink" title="· 两个有序数组间相加和的Topk问题"></a>· 两个有序数组间相加和的Topk问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539251891-3de0d850-c8d0-4239-a81d-fa1a2210426c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=414&amp;id=ue5640a4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=830&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43271&amp;status=done&amp;style=none&amp;taskId=u6feb9167-120c-415a-b74d-95ac0e48b98&amp;title=&amp;width=664" alt="image.png"><br>用大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031978240-dce8b855-e997-478e-933a-aab5c7268225.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=u92e50c4d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82696&amp;status=done&amp;style=none&amp;taskId=ue0cf5ae5-f712-4140-aac0-9aa695e0286&amp;title=&amp;width=456.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031989072-10c19f0a-4015-407a-8fb7-176cef820206.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=u9583c67c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=90083&amp;status=done&amp;style=none&amp;taskId=ufffa987b-c980-44a0-89a3-38926c6b62d&amp;title=&amp;width=478.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032000117-c9d348c8-6b94-4a91-a50e-1a47217c9b57.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u80c59775&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=646&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119662&amp;status=done&amp;style=none&amp;taskId=udb562210-be25-49bb-981b-b2ccf26efe2&amp;title=&amp;width=516.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032013255-95030714-b09e-4f25-a865-2758167fb7b1.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u49edc7c2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=649&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=146468&amp;status=done&amp;style=none&amp;taskId=u5745c217-4dbe-4db4-b967-7cfbd0548ac&amp;title=&amp;width=519.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032038337-4b6eddac-52e2-40b0-ac4f-694be2af4927.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u7efe8179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=638&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145293&amp;status=done&amp;style=none&amp;taskId=uc4397788-c306-4e30-b954-1c34575127e&amp;title=&amp;width=510.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032058547-5ce5c648-4d2f-4c69-a0ca-51424b5f5c83.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=uec145c06&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=317&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=38852&amp;status=done&amp;style=none&amp;taskId=uee16e7db-0793-4ade-bcf7-ae43094fe60&amp;title=&amp;width=420" alt="image.png"></p><p>| // 放入大根堆中的结构<br><strong>public static class </strong>Node <strong>{<br>   public int index1</strong>;// arr1中的位置<br>   <strong>public int index2</strong>;// arr2中的位置<br>   <strong>public int sum</strong>;// arr1[index1] + arr2[index2]的值</p><p>   <strong>public </strong>Node<strong>(int </strong>i1, <strong>int </strong>i2, <strong>int </strong>s<strong>) {<br>      index1 </strong>= i1;<br>      <strong>index2 </strong>= i2;<br>      <strong>sum </strong>= s;<br>   **}<br>}</p><p><strong>// 生成大根堆的比较器</strong>public static class <strong>MaxHeapComp </strong>implements <strong>Comparator</strong>&lt;<strong>Node</strong>&gt; {<br>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return <strong>o2.</strong>sum <strong>- o1.</strong>sum<strong>;   </strong>}<br>}</p><p>public static int[] <strong>topKSum</strong>(int[] <strong>arr1, </strong>int[] <strong>arr2, </strong>int <strong>topK</strong>) {<br>   if (<strong>arr1 == </strong>null <strong>&#124;&#124; arr2 == </strong>null <strong>&#124;&#124; topK &lt; 1</strong>) {<br>      return null<strong>;   </strong>}<br>   int <strong>N = arr1.</strong>length<strong>;   </strong>int <strong>M = arr2.</strong>length**;</p><p>   topK = Math.min<strong>(</strong>topK, N <em> M<em>*)</em></em>;</p><p>   <strong>int[] </strong>res = <strong>new int[</strong>topK<strong>]</strong>;<br>   <strong>int </strong>resIndex = 0;</p><p>   PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>maxHeap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;(new </strong>MaxHeapComp<strong>())</strong>;<br>   HashSet<strong>&lt;</strong>Long<strong>&gt; </strong>set = <strong>new </strong>HashSet<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>i1 = N - 1;<br>   <strong>int </strong>i2 = M - 1;<br>   maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1, i2, arr1<strong>[</strong>i1<strong>] </strong>+ arr2<strong>[</strong>i2<strong>]))</strong>;<br>   set.add<strong>(</strong>x<strong>(</strong>i1, i2, M<strong>))</strong>;//二维变一维<br>   <strong>while (</strong>resIndex != topK<strong>) {      </strong>Node curNode = maxHeap.poll<strong>()</strong>;<br>      res<strong>[</strong>resIndex++<strong>] </strong>= curNode.<strong>sum</strong>;<br>      i1 = curNode.<strong>index1</strong>;<br>      i2 = curNode.<strong>index2</strong>;<br>      set.remove<strong>(</strong>x<strong>(</strong>i1, i2, M<strong>))</strong>;<br>      <strong>if (</strong>i1 - 1 &gt;= 0 &amp;&amp; !set.contains<strong>(</strong>x<strong>(</strong>i1 - 1, i2, M<strong>))) {         </strong>set.add<strong>(</strong>x<strong>(</strong>i1 - 1, i2, M<strong>))</strong>;<br>         maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1 - 1, i2, arr1<strong>[</strong>i1 - 1<strong>] </strong>+ arr2<strong>[</strong>i2<strong>]))</strong>;<br>      <strong>}<br>      if (</strong>i2 - 1 &gt;= 0 &amp;&amp; !set.contains<strong>(</strong>x<strong>(</strong>i1, i2 - 1, M<strong>))) {         </strong>set.add<strong>(</strong>x<strong>(</strong>i1, i2 - 1, M<strong>))</strong>;<br>         maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1, i2 - 1, arr1<strong>[</strong>i1<strong>] </strong>+ arr2<strong>[</strong>i2 - 1<strong>]))</strong>;<br>      <strong>}<br>   }<br>   return </strong>res;<br>**}</p><p>public static long <strong>x</strong>(int <strong>i1, </strong>int <strong>i2, </strong>int <strong>M</strong>) {<br>   return (long) <strong>i1 * </strong>(long) <strong>M + </strong>(long) <strong>i2;</strong>}</p><p>** |<br>| —- |</p><h2 id="·-42-接雨水-H"><a href="#·-42-接雨水-H" class="headerlink" title="· 42. 接雨水 [H]"></a>· 42. 接雨水 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267273178-987b1982-ef81-4324-8306-8f79b8e3d6ff.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=353&amp;id=u9a387aaa&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=441&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33271&amp;status=done&amp;style=none&amp;taskId=u7e5d0662-374f-45a2-926d-fe2e07cee61&amp;title=&amp;width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653183809624-bfe54faa-fc8e-4c66-a37c-99bf00c7ccb2.png#clientId=u9486b31d-676a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=uc43d2755&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=359&amp;originWidth=905&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17507&amp;status=done&amp;style=none&amp;taskId=u90fb9776-20c1-498f-95f0-ab5a02da7b7&amp;title=&amp;width=724" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323108-3482efdf-9617-4893-953d-ccef84395862.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uf94fe60c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=484&amp;originWidth=855&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue2587b40-59ad-4b39-8b70-6184ba23117&amp;title=&amp;width=490" alt=""><br><strong>题解</strong><br>跟踪坡峰坡谷的Coding解法不正确<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323100-9d08de8c-b1e3-4f1d-9d28-813b0490efef.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=u98c83e06&amp;margin=%5Bobject%20Object%5D&amp;originHeight=366&amp;originWidth=986&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c3e4756-b5a8-4817-8a39-e247925cb50&amp;title=&amp;width=578" alt=""><br>i位置自己整个位置上方有几格水?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323023-37d28c90-8cf6-460d-96e9-9cf07801d95d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=298&amp;id=u691728f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=984&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5e997542-0ba1-4e3b-9bf7-b430884218a&amp;title=&amp;width=614" alt=""><br>边界情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323022-bf49b7ca-7a22-499d-89e4-9ba96be952dc.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=319&amp;id=u185b9d89&amp;margin=%5Bobject%20Object%5D&amp;originHeight=399&amp;originWidth=681&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1a037bb2-07a4-406b-b36a-a860e287ed7&amp;title=&amp;width=545" alt=""><br>i位置的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268325675-aeb3f9d1-c2fd-4218-89f5-368d9ac0bf4f.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ua64db485&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=960&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4474289a-e974-4f64-822b-7bed7e7cc27&amp;title=&amp;width=506" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326254-52267b69-79ad-4bf9-9fa8-cd8d26a94a8d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=292&amp;id=u4434b4f8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5338f041-b732-47d3-b061-8a59c39d9b4&amp;title=&amp;width=587" alt=""><br><strong>辅助数组</strong><br>需要0~i范围上的最大值max<br>i~N-1范围上的最大值max<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326340-b8cc0df3-73c2-4d4e-a267-dbe509ac09a4.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=358&amp;id=u3182ff51&amp;margin=%5Bobject%20Object%5D&amp;originHeight=471&amp;originWidth=710&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e3ff214-4949-458e-a458-e98f1d2275a&amp;title=&amp;width=540" alt=""><br><strong>最优解</strong><br>不需要辅助数组<br>0位置最左 20位置最右是不可能留下水的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326487-100d9b8f-7d1c-416f-9c3f-d57fed517bdc.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue35ef49f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=1065&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5f3ada90-3915-4cab-ae55-b2018430e01&amp;title=" alt=""><br>19位置的最大高度假设6, 要结算算水量<br>需要求6的左边, 右边部分的max, 以13做瓶颈,<br>因为6它的左边这么多最大值还没看过，但它的最大值是17，恐怕它真实的左边最大值是大于17的。<br>而我右边的最大值，这可是个真实最大值, 所以6位置的水量就是13-6 = 7 格子水<br>左边跟右边max谁小就先结算那边的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326627-e696ef0d-bcf9-4c31-b14d-f8340253c3b2.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=278&amp;id=uac262f4d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=1063&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uecb45efd-f557-48a5-b00f-d7bd73562f1&amp;title=&amp;width=635" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327142-fa9a9589-71a6-4d59-aa66-b7c33cee30c5.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u4c693001&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=1067&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2adf84f1-1a9b-4fe1-b0a8-886ae13e2cf&amp;title=&amp;width=564" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327723-c5a819e2-e219-4a73-a4fb-5d3e37bc01c7.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u59b410f0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1074&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u401cfdd3-d2fd-4b7e-9f90-aa11bcb92b4&amp;title=&amp;width=568" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327914-13401c07-43a7-45f0-b9fb-be52bf672963.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u0fcb1059&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=1075&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u33092d65-5421-468c-961f-251f018357f&amp;title=&amp;width=562" alt=""><br>相等怎么办<br>可以一起结算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328197-0ef67c95-b205-4b96-bb3b-4861e493c575.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=197&amp;id=u58c81a8a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=340&amp;originWidth=1038&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d5765fc-e857-484a-bb9b-b63c2ef9a07&amp;title=&amp;width=602" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328220-048d534c-040c-4157-851b-81ffab6e636e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=ub7259426&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud895d562-3d89-4df9-973d-e6e4a3153f3&amp;title=&amp;width=557" alt=""><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328354-f6461e69-c9fc-464e-b55d-98e8f7a989f6.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2f50eac9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=381&amp;originWidth=433&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufd62e68c-e8d6-4953-ae67-65811a0750c&amp;title=" alt=""></p><h2 id="·-✊407-接雨水-II-H"><a href="#·-✊407-接雨水-II-H" class="headerlink" title="· ✊407. 接雨水 II [H]"></a>· ✊407. 接雨水 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267310891-9ae51e62-eb36-4c3d-aecf-42757c8bc9da.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=424&amp;id=u4348eeb0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=633&amp;originWidth=921&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=167029&amp;status=done&amp;style=none&amp;taskId=u12c089cc-f48c-4fe5-b32a-f49a6ad36f5&amp;title=&amp;width=616.7999877929688" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567058-f79a7202-de25-40fb-a9e7-36ee14452e6c.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uf198170f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=835&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc30f9554-6db3-457f-b0f2-32d091524b1&amp;title=&amp;width=489" alt=""><br><strong>题解</strong><br>这一圈的值放到小根堆去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566883-18c6b4b4-30c6-4a82-a82a-59b43835a5db.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=u3d5807f8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=806&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u427cc3c0-49d7-4081-aa59-7229fad2c68&amp;title=&amp;width=542" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566896-0282f120-5392-4308-9d6e-ecdfee83e80e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=u9d229db5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=1004&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u218c752a-31e6-48f8-919c-307b08a911f&amp;title=&amp;width=595" alt=""><br>都会以max做为瓶颈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567083-2497db05-4afd-4681-82b4-112847d15636.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=316&amp;id=u799526e3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=498&amp;originWidth=957&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc83a1690-d0de-4210-95ad-eb1fbc9439e&amp;title=&amp;width=608" alt=""><br>只要max不更新, 都是max的内湖区域<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566876-7b3a2096-ce22-4ac5-90e4-10ffa818dc49.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=319&amp;id=u8728c50f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=480&amp;originWidth=916&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae7d39ad-2aa8-4dd3-922b-4deb1c5a810&amp;title=&amp;width=608" alt=""><br><strong>例子</strong><br>一个数进去的时候结算水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568452-8d0329f2-01e6-457a-af5e-535b96a0aa9e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=324&amp;id=u2d7d0a44&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2363d263-1b25-4389-b468-1c17f534e8d&amp;title=&amp;width=642" alt=""><br><strong>代码</strong><br>max不更新就说明出海口就没有变</p><p>| <strong>public static class </strong>Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   <strong>public </strong>Node<strong>(int </strong>v, <strong>int </strong>r, <strong>int </strong>c<strong>) {<br>      value </strong>= v;<br>      <strong>row </strong>= r;<br>      <strong>col </strong>= c;<br>   **}</p><p>}</p><p>public static int <strong>trapRainWater</strong>(int[][] <strong>heightMap</strong>) {<br>   if (<strong>heightMap == </strong>null <strong>&#124;&#124; heightMap.</strong>length <strong>== 0 &#124;&#124; heightMap</strong>[<strong>0</strong>] <strong>== </strong>null <strong>&#124;&#124; heightMap</strong>[<strong>0</strong>]<strong>.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   int <strong>N = heightMap.</strong>length<strong>;   </strong>int <strong>M = heightMap</strong>[<strong>0</strong>]<strong>.</strong>length<strong>;   </strong>boolean[][] <strong>isEnter = </strong>new boolean[<strong>N</strong>][<strong>M</strong>]<strong>;<br>   PriorityQueue</strong>&lt;<strong>Node</strong>&gt; <strong>heap = </strong>new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) <strong>-&gt; a.</strong>value <strong>- b.</strong>value)<strong>;   </strong>for (int <strong>col = 0; col &lt; M - 1; col++</strong>) {<br>      <strong>isEnter</strong>[<strong>0</strong>][<strong>col</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>0</strong>][<strong>col</strong>]<strong>, 0, col</strong>))<strong>;   </strong>}<br>   for (int <strong>row = 0; row &lt; N - 1; row++</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>M - 1</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>M - 1</strong>]<strong>, row, M - 1</strong>))<strong>;   </strong>}<br>   for (int <strong>col = M - 1; col &gt; 0; col—</strong>) {<br>      <strong>isEnter</strong>[<strong>N - 1</strong>][<strong>col</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>N - 1</strong>][<strong>col</strong>]<strong>, N - 1, col</strong>))<strong>;   </strong>}<br>   for (int <strong>row = N - 1; row &gt; 0; row—</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>0</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>0</strong>]<strong>, row, 0</strong>))<strong>;   </strong>}<br>   int <strong>water = 0;   </strong>int <strong>max = 0;   </strong>while (<strong>!heap.isEmpty</strong>()) {<br>      <strong>Node cur = heap.poll</strong>()<strong>;<br>      max = Math.max</strong>(<strong>max, cur.</strong>value)<strong>;      </strong>int <strong>r = cur.</strong>row<strong>;      </strong>int <strong>c = cur.</strong>col<strong>;<br>      //上下左右去放<br>      //有上面      </strong>if (<strong>r &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>])<strong>;<br>         isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>]<strong>, r - 1, c</strong>))<strong>;      </strong>}<br>      <strong>//有下      </strong>if (<strong>r &lt; N - 1 &amp;&amp; !isEnter</strong>[<strong>r + 1</strong>][<strong>c</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r + 1</strong>][<strong>c</strong>])<strong>;<br>         isEnter</strong>[<strong>r + 1</strong>][<strong>c</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r + 1</strong>][<strong>c</strong>]<strong>, r + 1, c</strong>))<strong>;      </strong>}<br>      <strong>//有左      </strong>if (<strong>c &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>])<strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>]<strong>, r, c - 1</strong>))<strong>;      </strong>}<br>      <strong>//有右      </strong>if (<strong>c &lt; M - 1 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>])<strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>]<strong>, r, c + 1</strong>))<strong>;      </strong>}<br>   }<br>   return <strong>water;</strong>}** |<br>| —- |</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568940-16d91986-3ce5-4170-995b-25e5eb327a2d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=333&amp;id=ua197f36f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=560&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5856214b-6641-45ba-838e-b397b8823c9&amp;title=&amp;width=378" alt=""></p><h2 id="·-找出最大的左部分最大值减去右部分最大值的绝对值"><a href="#·-找出最大的左部分最大值减去右部分最大值的绝对值" class="headerlink" title="· 找出最大的左部分最大值减去右部分最大值的绝对值"></a>· 找出最大的左部分最大值减去右部分最大值的绝对值</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652270318016-0e37cdc1-b8e3-47ba-bf01-6f42eb4e6247.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=ua69a96f6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=816&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17778&amp;status=done&amp;style=none&amp;taskId=u26260abf-215f-42d6-9e95-5f6eace034c&amp;title=&amp;width=652.8" alt="image.png"><br><strong>题意</strong><br>所以你每切一刀都会有一个左部分的最大值，减去右部分的最大值的绝对值<br>一共有N-1种切法。那么哪一种切法下，这个值能最大, 把这个最大的结果返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009637-2441118c-f8dd-47dd-afef-1bf81668b74a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=pClpf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1223&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5f94afae-e9f4-41ae-8f51-6fb3c2947e8&amp;title=&amp;width=485" alt=""><br><strong>题解</strong><br>暴力: 遍历<br>当我来到i位置的时候, 0~i是左部分, i+1~N-1是右部分, 枚举i, 遍历一下找左右部分的最大值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009601-259b07db-0b03-422c-aa80-7360e0e29474.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=zBUSt&amp;margin=%5Bobject%20Object%5D&amp;originHeight=525&amp;originWidth=1171&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u68d556cd-13fd-4bfa-b226-e655edba474&amp;title=&amp;width=605" alt=""><br><strong>辅助数组</strong><br>left数组: 记录0~i范围上的最大值<br>当前数跟前一个位置的数, 谁大拷贝谁</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009616-8360c1b6-bd21-47cf-b05a-4894b6301470.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=w2PrR&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=1020&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue3dd0bbc-0eb9-4eda-8708-0ac0d2dcf67&amp;title=&amp;width=656" alt=""><br>right数组:从右往左生成,i+1~N-1范围上的最大值<br>有了两个辅助数组, 再去枚举i的时候<br>0~i范围上的最大值直接从left数组里取, i+1~N-1范围上的最大值直接从right数组里拿<br>把O(N^2)的暴力解优化成O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009605-dbca0f91-6ad8-4748-9f10-8885d7311c83.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=337&amp;id=qF9iP&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1035&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8518c4be-731f-43bd-910f-44af73685c7&amp;title=&amp;width=690" alt=""></p><p>| <strong>public static int </strong>maxABS2<strong>(int[] </strong>arr<strong>) {<br>   int[] </strong>lArr = <strong>new int[</strong>arr.<strong>length]</strong>;<br>   <strong>int[] </strong>rArr = <strong>new int[</strong>arr.<strong>length]</strong>;<br>   lArr<strong>[</strong>0<strong>] </strong>= arr<strong>[</strong>0<strong>]</strong>;<br>   rArr<strong>[</strong>arr.<strong>length </strong>- 1<strong>] </strong>= arr<strong>[</strong>arr.<strong>length </strong>- 1<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>lArr<strong>[</strong>i<strong>] </strong>= Math.max<strong>(</strong>lArr<strong>[</strong>i - 1<strong>]</strong>, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   for (int </strong>i = arr.<strong>length </strong>- 2; i &gt; -1; i—<strong>) {      </strong>rArr<strong>[</strong>i<strong>] </strong>= Math.max<strong>(</strong>rArr<strong>[</strong>i + 1<strong>]</strong>, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   int </strong>max = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length </strong>- 1; i++<strong>) {      </strong>max = Math.max<strong>(</strong>max, Math.abs<strong>(</strong>lArr<strong>[</strong>i<strong>] </strong>- rArr<strong>[</strong>i + 1<strong>]))</strong>;<br>   <strong>}<br>   return </strong>max;<br><strong>}</strong> |<br>| —- |</p><p><strong>最优解</strong><br>arr 遍历一遍找到全局最大值, 然后0位置数跟N-1位置数, 谁小减谁就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009794-49174c11-7c15-4f33-86e2-e55388ed91d5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=cLoHI&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=885&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c009e6b-c545-4de7-913a-67aee64f8ad&amp;title=&amp;width=519" alt=""><br>可能性罗列<br>1) 全局max被划分到了左边<br>2) 全局max被划分到了右边</p><p>1) max - 右边的最大值就是答案<br>让右max尽量小<br>右部分一定要有数, 一定会包含N-1位置的数<br>右部分只包含最右边一个数是右边max最小的时候<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010132-31eed44f-ffcb-4639-bc25-e746726c22ef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=D4cKJ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=453&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3d6af354-eb1a-467a-8e6e-9faad6833e9&amp;title=" alt=""><br>2)<br>左max尽量小, 左部分一定会包含0位置的数<br>就让左部分只包含0位置的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010235-2ac3a3a2-5e64-4573-90c1-1ce1513e4177.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=dhLOT&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1030&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue7dd0c92-9bcb-4ee3-ae1f-c25a9700fb7&amp;title=" alt=""><br><strong>代码</strong></p><p>| //amazing！<br><strong>public static int </strong>maxABS3<strong>(int[] </strong>arr<strong>) {<br>   int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>max = Math.max<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, max<strong>)</strong>;<br>   <strong>}<br>   return </strong>max - Math.min<strong>(</strong>arr<strong>[</strong>0<strong>]</strong>, arr<strong>[</strong>arr.<strong>length </strong>- 1<strong>])</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-✊最大可整合子数组的长度"><a href="#·-✊最大可整合子数组的长度" class="headerlink" title="· ✊最大可整合子数组的长度"></a>· ✊最大可整合子数组的长度</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532365836-3c8093cf-782d-4f0e-854a-8c3427e0a834.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=244&amp;id=u867734bf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61875&amp;status=done&amp;style=none&amp;taskId=u53f84319-b0b7-4cfb-9d4d-beafbf2b477&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题意</strong><br>排完序之后依次加1得到就是可整合<br>只要有重复值，它就没办法做可整合数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386766-8b1f7bae-ec0c-4109-bd44-011cacc7d351.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=ua84eeb28&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=581&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u015f7cff-9f62-4bfc-954d-9440e8dd640&amp;title=&amp;width=396" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386782-0ba22845-7afc-4f9e-a81b-9283c470caba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u3850d3b2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=438&amp;originWidth=728&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubb9990b4-f7ff-479c-94d4-943e8d57ac3&amp;title=&amp;width=449" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386975-f5f84998-bdcd-4f75-8fb4-702dc86cb261.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=udf385003&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d425bbc-9f7b-4f84-bf26-d91fcd501fa&amp;title=&amp;width=462" alt=""><br>哪一个子数组是可整合的而且最长, 返回最长长度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386935-72cadf66-19f6-4562-b619-f95e67f91c55.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=212&amp;id=u6cceb4e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=694&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4089eb32-f3bb-4b90-9c15-e35b315eb17&amp;title=&amp;width=491" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386866-d20c76bd-4969-4bce-ad9b-c784eb6a76a2.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=224&amp;id=u7df7ee5c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=387&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua502ac2b-174e-47d6-b4d4-4187fa647f2&amp;title=&amp;width=521" alt=""><br>不能排序<br>因为他问的就是你原始arr的数据状况，最长可整合子数组是啥？<br>排完序0,1,2原数组没有这个子数组<br>原数据状况是不能够动的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387154-7c295c6a-1838-45a2-ae75-508ced86774f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=320&amp;id=u735cfd92&amp;margin=%5Bobject%20Object%5D&amp;originHeight=451&amp;originWidth=882&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0882a71c-1ed1-4ec5-bce0-e4fbd3b9685&amp;title=&amp;width=625" alt=""><br><strong>题解</strong><br>不能用滑动窗口, 没有单调性<br>因为如果一个窗口是可整合的, 它扩大或缩小不一定可整合<br>子数组范围这件事和可整合这件事建立不起单调性。<br>能用滑动窗口的最重要的性质就是某种范围上的单调性<br>子数组范围扩大了，或者子数组范围缩小了，对于可整合的东西，<br>它是有一定的单调性的，我菜可以去利用，而本题是没有的。<br>所以滑动窗口也用不了。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387319-f3df4fef-b417-4636-bfc4-b098e97ad628.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=325&amp;id=u07077d33&amp;margin=%5Bobject%20Object%5D&amp;originHeight=483&amp;originWidth=738&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6d45fb4c-a596-4283-a50a-b3b83d3dd28&amp;title=&amp;width=496" alt=""><br><strong>暴力解:</strong><br>枚举所有子数组<br>比如说我验证从L到R这一段是不是可整合的,<br>可以把它拷贝出来, 拍完序再验证是不是可整合的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387425-c3b5c57f-08b3-4119-a9d3-65813f51fc17.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=307&amp;id=uf7a760b5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=435&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u83b81b1d-d7d6-49c7-ac07-77c4d2696e1&amp;title=&amp;width=636" alt=""><br><strong>复杂度</strong><br>子数组数量O(N^2), 子数组平均长度N<br>把子数组拷贝一下O(N), 子数组排序O(N<em>logN), 排序后的验证O(N)<br>取最高阶O(N</em>logN), 最终复杂度O(N^3<em>logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387470-931d4e55-faee-4d65-aaf2-82ec28e91d09.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=332&amp;id=u9026a328&amp;margin=%5Bobject%20Object%5D&amp;originHeight=496&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89e7ad6f-b03b-4734-b328-39d568514d8&amp;title=&amp;width=625" alt=""><br><em>*重新定义可整合数组标准！！！</em></em><br>1) 没有重复值<br>2) 数组最大值-最小值=个数-1<br>满足这两个条件就是可整合数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387491-c2cc6771-68b6-4a63-a0ab-83e7c4f0ed43.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u4220dfc8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=965&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u23575989-4df0-4efb-a468-212b66ddbef&amp;title=&amp;width=532" alt=""><br>简化的过程</p><p>| <strong>public static int </strong>maxLen<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>N = arr.<strong>length</strong>;<br>   HashSet<strong>&lt;</strong>Integer<strong>&gt; </strong>set = <strong>new </strong>HashSet<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>ans = 1;//答案至少是1<br>   <strong>for (int </strong>L = 0; L &lt; N; L++<strong>) {      </strong>set.clear<strong>()</strong>;//因为r要归为<br>      <strong>int </strong>min = arr<strong>[</strong>L<strong>]</strong>;<br>      <strong>int </strong>max = arr<strong>[</strong>L<strong>]</strong>;<br>      set.add<strong>(</strong>arr<strong>[</strong>L<strong>])</strong>;<br>      // L..R<br>      <strong>for (int </strong>R = L + 1; R &lt; N; R++<strong>) {         </strong>// L….R<br>         <strong>if(</strong>set.contains<strong>(</strong>arr<strong>[</strong>R<strong>])) {<br>            break</strong>;<br>         <strong>}         </strong>set.add<strong>(</strong>arr<strong>[</strong>R<strong>])</strong>;<br>         min = Math.min<strong>(</strong>min, arr<strong>[</strong>R<strong>])</strong>;//可能r的值更小<br>         max = Math.max<strong>(</strong>max, arr<strong>[</strong>R<strong>])</strong>;//也可能r的值更大<br>         //个数：R-L+1,再减个1<br>         <strong>if(</strong>max - min == R - L<strong>) {            </strong>ans = Math.max<strong>(</strong>ans, R - L + 1<strong>)</strong>;<br>         <strong>}<br>      }<br>   }<br>   return </strong>ans;</p><p><strong>}</strong> |<br>| —- |</p><p><strong>总结: 改题目的设定让它变得更简洁</strong><br>就是当你发现，比如说面试场上给了你一道题，它的定义部分让你求解的部分是如此之复杂。<br>你不要硬着头皮，就按照他的说法就硬上了，你要改成你自己的定义。比如说我们把这个就<br>拆分成了系统最大值减两头这样一个问题，把可整合数组重新写了定义之后，能让我们验证<br>可整合这个过程变快，这种就属于在面试场上遇到了一类，它给你来一个设定，但是你要改<br>它的设定让它变得更简洁的。要有这个心眼，你发现这道题目设定的部分写得特别的绕。<br>那说明它可能不够简洁，这时要有一个心眼，就是要改设定。这样改设定的题型很多，<br>我们以后遇到再说。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532543649-53d3de55-8561-4ff0-add7-817357bd81ac.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=u7ad3e556&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=1002&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ce4aaab-9297-47d3-9ce8-fbaa226b91f&amp;title=&amp;width=474" alt=""></p><h2 id="·-✊超级水王问题"><a href="#·-✊超级水王问题" class="headerlink" title="· ✊超级水王问题"></a>· ✊超级水王问题</h2><p><strong>题意</strong><br>我给你个数组，如果有水王数你打印出来，如果无水王数，你告诉用户没有<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564573-18f0aae5-4c48-4583-a5fc-908f05f918aa.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ub63ef09a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=475&amp;originWidth=946&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueb3f9d95-2385-4717-ab8a-502c4ce9c0f&amp;title=&amp;width=489" alt=""><br>要求时间复杂度O(N)<br>空间复杂度O(1)<br>把用hash表的路堵死了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564812-7f6017f2-4972-4dde-b65e-5065ad21c9b5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=ua3b9fe6a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=455&amp;originWidth=963&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u345c305d-94e0-4908-a782-ea6311d8772&amp;title=&amp;width=533" alt=""><br><strong>题解</strong><br>一次删掉两个不同值的数, 如果arr中真的有水王的话, 这个水王数一定会剩下来<br>因为水王数是大于一半的次数的。哪怕其它所有的数字都跟水王数为敌<br>水王数也会活下来, 更不用说其它数字之间还会有内战的情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564621-4c4d07c4-1905-4d22-8161-ba7827127276.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=220&amp;id=ud9c14c93&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uac5cb9f7-4ed2-4d56-99bd-234e14ca061&amp;title=&amp;width=470" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564724-40df89be-6e7c-479d-b755-0479f9168ce6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1df2e5b3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=144&amp;originWidth=382&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u94cefb0a-39fc-4749-88dc-a340c7f447b&amp;title=" alt=""><br>arr一次删掉两个不同的数, 最后剩下的数一定是水王吗?<br>不一定是水王<br>如果有水王的话, 一定会剩下来<br>如果没有水王的话, 如果剩下来的数都不是水王，那就没有数是了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564674-454bc6b4-a8ff-479c-938b-e6e9a24a390d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua49eec8c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=143&amp;originWidth=421&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1cb3b4b7-b9f8-4379-a900-ef09a62f703&amp;title=" alt=""><br><strong>思路</strong><br>1) arr 一次删除两个不同值的数, 看最终谁会剩下来</p><p>可能性<br>1: 没有数字剩下来: 无水王数<br>2: 有数剩下来<br>x剩下来, 再遍历看x真实出现的次数跟N/2对比</p><p><strong>怎么一次删除两个不同的数?</strong><br>时间复杂度O(N)<br>空间复杂度O(1)<br>两个变量<br>1) 候选cand<br>2) 血量hp<br>当血量=0, 认为没有候选人<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565245-13d042e9-15ce-451f-9d00-22fb6b8c37eb.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u22eda463&amp;margin=%5Bobject%20Object%5D&amp;originHeight=431&amp;originWidth=1026&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua04fdaf1-7f3e-4a6d-9286-dad2914a968&amp;title=&amp;width=542" alt=""><br><strong>流程</strong><br>一个一个数遍历, 三条规则:<br>1) 如果没有候选, 当前数立为候选, 血量+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565228-0cb5c6f0-77d1-4a27-9618-82f95127135e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=u3e918b1a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=399&amp;originWidth=1021&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8d87f13b-7fc7-4e50-aa59-77782c0c05d&amp;title=&amp;width=585" alt=""><br>2) 如果有候选<br>    1)当前数跟候选不一样,血量—<br>    2)当前数是候选,血量++<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565221-c7dde5a0-148c-4fc2-9ce8-9c33a38b526a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u9c9600a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=1032&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c27cf79-9f62-4684-95ac-0cb1bb50623&amp;title=&amp;width=571" alt=""><br>解释</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565427-1f53495a-7f90-4a2e-b08b-43af2f9f0147.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=296&amp;id=u1cb7e569&amp;margin=%5Bobject%20Object%5D&amp;originHeight=506&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf9fba9e6-c81e-4f75-a1bc-54ac7326b4d&amp;title=&amp;width=592" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565702-b20446ee-a34b-4303-85dc-18bfb790a1ab.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=u81618e25&amp;margin=%5Bobject%20Object%5D&amp;originHeight=497&amp;originWidth=1022&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua102ae15-5ac8-4490-a8d4-6d41c0048d7&amp;title=&amp;width=623" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565738-f2a9bd97-215c-4362-9d4d-23af8dc985b1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=305&amp;id=u9538e7a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=1009&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u72d5eca0-0819-455a-bb9a-c4de485e2ab&amp;title=&amp;width=634" alt=""><br>遍历完成后,如果血量=0,表示什么数也没有剩下来,如果血量不等于零，候选就是剩下来的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565794-847db360-2964-4094-8ffe-a086883180e7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=u676fec88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=904&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e114edf-2d28-4477-a82d-92b2a494048&amp;title=&amp;width=634" alt=""><br><strong>代码</strong></p><p>| <strong>public static void </strong>printHalfMajor<strong>(int[] </strong>arr<strong>) {<br>   int </strong>cand = 0;<br>   <strong>int </strong>HP = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>HP == 0<strong>) {         </strong>cand = arr<strong>[</strong>i<strong>]</strong>;<br>         HP = 1;<br>      <strong>} else if (</strong>arr<strong>[</strong>i<strong>] </strong>== cand<strong>) {         </strong>HP++;<br>      <strong>} else {         </strong>HP—;<br>      <strong>}<br>   }<br>   if(</strong>HP == 0<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“no such number.”)</strong>;<br>      <strong>return</strong>;<br>   <strong>}   </strong>HP = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>== cand<strong>) {         </strong>HP++;<br>      <strong>}<br>   }<br>   if (</strong>HP &gt; arr.<strong>length </strong>/ 2<strong>) {      </strong>System.<strong>out</strong>.println<strong>(</strong>cand<strong>)</strong>;<br>   <strong>} else {      </strong>System.<strong>out</strong>.println<strong>(“no such number.”)</strong>;<br>   <strong>}<br>}</strong> |<br>| —- |</p><p><strong>扩展</strong><br>给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N/K，打印这些数，如果没有不打印</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692268-ec19fdb8-d919-4ff4-989b-a9441d09217c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u794e348d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=467&amp;originWidth=904&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c744658-4ae3-453a-95bc-6b4354a53a7&amp;title=&amp;width=532" alt=""><br>至多K-1个出现N/K次的数（假设k = 2，至多只有一个数字）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692364-02aa48c0-9e3a-4054-aaa4-0a8176783fbc.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=u7c355bf8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=480&amp;originWidth=820&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u22b99e23-11f2-4517-ad75-24ab4f0e7ac&amp;title=&amp;width=477" alt=""><br><strong>例子</strong><br>K=4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692393-908c6f08-2bfa-4465-812d-6007cce170df.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=udfebc94e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=919&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c9dd817-5300-40b5-818b-31b809878ad&amp;title=&amp;width=563" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692292-a6252411-18f3-4e51-a21c-65ab7d2fe782.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=281&amp;id=uc29f6c64&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=907&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udfc00b4d-da71-4486-92cc-4c1ec0d3bb6&amp;title=&amp;width=521" alt=""><br>4来了, 所有人-1点血量<br>血量是0不要, 删掉, 一次删掉了4个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692349-175242d0-ebac-4c64-8c62-f814f64470dd.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u59831a71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=603&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub7fa5c34-2c6b-4a84-8c3a-dac5f6647df&amp;title=" alt=""><br><strong>代码</strong><br>必须验证真实次数<br>候选有什么，也不代表它就代表唯一考虑的集合<br>但它是不是, 不收集真实次数没人知道</p><p>| <strong>public static void </strong>printKMajor<strong>(int[] </strong>arr, <strong>int </strong>K<strong>) {<br>   if (</strong>K &lt; 2<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“the value of K is invalid.”)</strong>;<br>      <strong>return</strong>;<br>   <strong>}   </strong>// 攒候选，cands，候选表，最多K-1条记录！ &gt; N / K次的数字，最多有K-1个<br>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>cands = <strong>new </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt;()</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>cands.containsKey<strong>(</strong>arr<strong>[</strong>i<strong>])) {         </strong>cands.put<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, cands.get<strong>(</strong>arr<strong>[</strong>i<strong>]) </strong>+ 1<strong>)</strong>;<br>      <strong>} else { </strong>// arr[i] 不是候选<br>         <strong>if (</strong>cands.size<strong>() </strong>== K - 1<strong>) { </strong>// 当前数肯定不要！，每一个候选付出1点血量，血量变成0的候选，要删掉！<br>            allCandsMinusOne<strong>(</strong>cands<strong>)</strong>;<br>         <strong>} else {            </strong>cands.put<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, 1<strong>)</strong>;<br>         <strong>}<br>      }<br>   }   </strong>// 所有可能的候选，都在cands表中！遍历一遍arr，每个候选收集真实次数</p><p>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>reals = getReals<strong>(</strong>arr, cands<strong>)</strong>;<br>   <strong>boolean </strong>hasPrint = <strong>false</strong>;<br>   <strong>for (</strong>Entry<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>set : cands.entrySet<strong>()) {      </strong>Integer key = set.getKey<strong>()</strong>;<br>      <strong>if (</strong>reals.get<strong>(</strong>key<strong>) </strong>&gt; arr.<strong>length </strong>/ K<strong>) {         </strong>hasPrint = <strong>true</strong>;<br>         System.<strong>out</strong>.print<strong>(</strong>key + <strong>“ “)</strong>;<br>      <strong>}<br>   }   </strong>System.<strong>out</strong>.println<strong>(</strong>hasPrint ? <strong>“” </strong>: <strong>“no such number.”)</strong>;<br>**}</p><p>public static void <strong>allCandsMinusOne</strong>(<strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>map</strong>) {<br>   <strong>List</strong>&lt;<strong>Integer</strong>&gt; <strong>removeList = </strong>new <strong>LinkedList</strong>&lt;<strong>Integer</strong>&gt;()<strong>;   </strong>for (<strong>Entry</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>set : map.entrySet</strong>()) {<br>      <strong>Integer key = set.getKey</strong>()<strong>;<br>      Integer value = set.getValue</strong>()<strong>;      </strong>if (<strong>value == 1</strong>) {<br>         <strong>removeList.add</strong>(<strong>key</strong>)<strong>;      </strong>}<br>      <strong>map.put</strong>(<strong>key, value - 1</strong>)<strong>;   </strong>}<br>   for (<strong>Integer removeKey : removeList</strong>) {<br>      <strong>map.remove</strong>(<strong>removeKey</strong>)<strong>;   </strong>}<br>}</p><p>public static <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>getReals</strong>(int[] <strong>arr,<br>      HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>cands</strong>) {<br>   <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>reals = </strong>new <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt;()<strong>;   </strong>for (int <strong>i = 0; i != arr.</strong>length<strong>; i++</strong>) {<br>      int <strong>curNum = arr</strong>[<strong>i</strong>]<strong>;      </strong>if (<strong>cands.containsKey</strong>(<strong>curNum</strong>)) {<br>         if (<strong>reals.containsKey</strong>(<strong>curNum</strong>)) {<br>            <strong>reals.put</strong>(<strong>curNum, reals.get</strong>(<strong>curNum</strong>) <strong>+ 1</strong>)<strong>;         </strong>} else {<br>            <strong>reals.put</strong>(<strong>curNum, 1</strong>)<strong>;         </strong>}<br>      }<br>   }<br>   return <strong>reals;</strong>}** |<br>| —- |</p><h2 id="·-✊第k小的数值对"><a href="#·-✊第k小的数值对" class="headerlink" title="· ✊第k小的数值对"></a>· ✊第k小的数值对</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533451839-1dcc4f86-8175-4b98-bb2d-33fab076095b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=ucc6bd1e8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=231&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43310&amp;status=done&amp;style=none&amp;taskId=udbf48c7b-c5c2-41b0-807a-c792b021443&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题解</strong><br><strong>暴力解</strong><br>两个for循环生成所有数值对, 放到数组里用比较器排序, 取出第K位的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574288-932f369b-6665-4975-870e-8d798fe5b12a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=ue3aaa206&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1081&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1fb1f388-552d-4f2a-a109-a817c3ba4b9&amp;title=&amp;width=604" alt=""><br>复杂度 O(N^2<em>logN^2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574337-82315d0f-95c8-492b-9c77-3fc02ea2091e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=u7073562e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1147&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6c9f817e-0dab-474c-857c-d4fef6c040a&amp;title=&amp;width=655" alt=""><br><strong>最优解</strong><br>最优解复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574399-0f80a80f-e29a-446a-91ed-6eb65d947887.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ud6983707&amp;margin=%5Bobject%20Object%5D&amp;originHeight=323&amp;originWidth=806&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u84b6d280-143f-4d10-abd7-57f845288b9&amp;title=&amp;width=626" alt=""><br><em>*过程</em></em><br>根据第一维数据进行分组<br>第一维的数字是1的叫第1组里的数值对<br>第一维的数字是2的叫第2组里的数值对<br>第一维的数字是3的叫第3组里的数值对<br>第一维的数字是5的叫第4组里的数值对<br>大体上分块就这么多块<br>想知道第70个数是哪个数值对里的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574353-1821c432-0685-4133-b7b9-be12b0b00a2f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaf4e4a03&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=1148&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ded78e1-5092-4773-9c69-8dd1d9d867c&amp;title=" alt=""><br>假设第70个数是(a,b)这两维数据, 先定位a是谁, 数组长度是11<br>必须以0位置的1做为第一维数据的一共有11个<br>必须以1位置的1做为第一维数据的一共有11个<br>必须以2位置的1做为第一维数据的一共有11个<br>必须以3位置的2做为第一维数据的一共有11个<br>所以你想求第 70 个怎么定位这个a？你就看看它是哪一组里的, 说明它第一维就是那个位置的数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574305-dac448dc-7170-485a-a101-f723d251e819.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ueab68af7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=407&amp;originWidth=1136&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u052e5313-afe0-43a7-8a72-428388a3bf1&amp;title=" alt=""><br>定位70是哪一组里的,<br>第70个数来自于3的组, 第一维数据是3<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575227-31b8ed61-55a5-4dfe-9627-7c7149d896d6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1a4f9244&amp;margin=%5Bobject%20Object%5D&amp;originHeight=540&amp;originWidth=1133&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucf6b52e7-70e5-4015-a29f-6c52f65ea6e&amp;title=" alt=""><br>怎么得到b<br>b肯定是3组里的数值对,<br>3之前一共搞定了55个, 所以你要第 70 个，它应该是三大组中的第 15 个。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575288-74bcd08a-9b14-434a-8bff-c504f8dabde3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=ufa15bced&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2db97466-6de6-4213-9d9d-840e2b29949&amp;title=&amp;width=635" alt=""><br>3大组中再细分,<br>必须以0位置的1做二维数据的有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575449-630237a5-8e4c-44e5-8adf-02ebd9c41cf7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u2e30a4fd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=1129&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uca568bff-376a-4bb3-812f-4b3fa039d94&amp;title=&amp;width=527" alt=""><br>相求3大组中的第15个, 一共有4个3, 所以<br>必须0位置的1做第二维数据的, 4个<br>必须1位置的1做第二维数据的,4个<br>必须2位置的1做第二维数据的,4个<br>必须3位置的2做第二维数据的,4个<br>看看这第15个来自那一组, 就可以定位第二维的数字来自哪儿了</p><p><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575700-2e9c1dc6-1c5a-434e-8f4a-34e244c6162e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=239&amp;id=ue603987f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=390&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u494d13cd-e862-4e22-a402-187828b9bf6&amp;title=&amp;width=689" alt=""><br>第一维的数字是4<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575882-6c7e9e5d-1b94-4951-841f-d623a6840864.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=322&amp;id=udeef2653&amp;margin=%5Bobject%20Object%5D&amp;originHeight=542&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u06579f25-1baa-49c4-81f0-bda6a471bfc&amp;title=&amp;width=667" alt=""><br>1,2,3开头的一共有70个<br>第一维是4的情况下,<br>4里的12<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576014-43be7fca-337b-4cbf-9dd6-ac93d054933f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6ae98023&amp;margin=%5Bobject%20Object%5D&amp;originHeight=542&amp;originWidth=1126&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufe456ad6-a016-4ec4-9226-9d0d844b402&amp;title=" alt=""><br>4的组细分<br>第二维数字是1,2,3,4的那些<br>第一维数字是 4 的情况下再往下细分组是啥?<br>第二维数据是 1 的那些<br>第二维数据是 2 的那些<br>第二维数据是 3 的那些<br>第二维数据是 4 的那些</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576961-4018a1d4-8795-402b-ad61-9094ebaf856f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=uc4ab67a7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=556&amp;originWidth=1135&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub026b4b3-619a-4a77-a4a5-ae1fc99b04f&amp;title=&amp;width=629" alt=""><br>第一维的数字已经确实是4了<br>第二维数据是 1 的那些分为<br>0位置的1做第二维的数据, 3个, 7,8,9位置的4都是<br>1位置的1做第二维的数据, 3个, 7,8,9位置的4都是</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577008-8175b831-2b92-4719-bc9c-ea5b8bf3434e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=372&amp;id=u8e3187a1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=547&amp;originWidth=873&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2f6ca15-0d35-46b9-be0d-6928f79b21f&amp;title=&amp;width=594" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576966-c18e528a-b6b0-4d36-b9ad-54ce913287a5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u2b5ae72a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1121&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uee646ef9-bab2-4946-9ef3-cdd53fb4f48&amp;title=&amp;width=627" alt=""><br><strong>抽象化</strong><br>假设一共有N个数,求第K小数值对<br>怎么定位第一维数据?<br>K/N的下标对应的值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577141-db303288-f81d-47eb-a691-3490f7349eeb.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u855fa134&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8076f660-ae44-4486-a8c9-004532ef1a2&amp;title=&amp;width=563" alt=""><br>边界考虑<br>第一维数字的下标<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577309-cb5440cc-ec6c-42d0-a207-c3f531c35f16.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u3731a3d1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=530&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue81e3ddb-626b-4ef0-b035-e2b5239cb4e&amp;title=&amp;width=508" alt=""><br>无序数组中找到第k小, bfprt<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577557-ad44f93d-e7d0-4003-ba23-3ae7897ccd42.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ud35ec140&amp;margin=%5Bobject%20Object%5D&amp;originHeight=557&amp;originWidth=1120&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u38e4bc18-5977-4562-9d02-123c3e64abe&amp;title=&amp;width=545" alt=""><br><strong>怎么定义第二维数字</strong><br>你必须数一下小于 7 的数字有几个你才能知道前面做的一位数字的组帮你搞定了几个，<br>然后拿k减去它才是属于7的组，在第一位数字是 7 的情况下，在这个内部组里面我是第几个呢？<br>这事怎么求?<br>你必须数一下前面小于 7 的数字有几个</p><p><strong>代码 </strong><br>必须搞清楚的第一维数字小于 5 的，之前的数字有几个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577715-e66d1dd1-8985-476f-a263-11335040c1ba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u9c8a0bcd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=1044&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uedae6774-6831-4395-9c5d-11ba2520332&amp;title=&amp;width=551" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577892-e34c0223-de0d-4c47-88cc-c15cd07653ef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=301&amp;id=uc48d9a27&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1134&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u939b5448-34f1-459a-a8cb-f98e841f015&amp;title=&amp;width=631" alt=""></p><p>| <strong>public static class </strong>Pair <strong>{<br>   public int x</strong>;<br>   <strong>public int y</strong>;</p><p>   Pair<strong>(int </strong>a, <strong>int </strong>b<strong>) {<br>      x </strong>= a;<br>      <strong>y </strong>= b;<br>   **}<br>}</p><p>public static class <strong>PairComparator </strong>implements <strong>Comparator</strong>&lt;<strong>Pair</strong>&gt; {</p><p>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Pair arg0, Pair arg1</strong>) {<br>      return <strong>arg0.</strong>x <strong>!= arg1.</strong>x <strong>? arg0.</strong>x <strong>- arg1.</strong>x <strong>: arg0.</strong>y <strong>- arg1.</strong>y<strong>;   </strong>}</p><p>}</p><p><strong>// O(N^2 * log (N^2))的复杂度，你肯定过不了<br>// 返回的int[] 长度是2，{3,1} int[2] = [3,1]</strong>public static int[] <strong>kthMinPair1</strong>(int[] <strong>arr, </strong>int <strong>k</strong>) {<br>   int <strong>N = arr.</strong>length<strong>;   </strong>if (<strong>k &gt; N * N</strong>) {<br>      return null<strong>;   </strong>}<br>   <strong>Pair</strong>[] <strong>pairs = </strong>new <strong>Pair</strong>[<strong>N * N</strong>]<strong>;   </strong>int <strong>index = 0;   </strong>for (int <strong>i = 0; i &lt; N; i++</strong>) {<br>      for (int <strong>j = 0; j &lt; N; j++</strong>) {<br>         <strong>pairs</strong>[<strong>index++</strong>] <strong>= </strong>new <strong>Pair</strong>(<strong>arr</strong>[<strong>i</strong>]<strong>, arr</strong>[<strong>j</strong>])<strong>;      </strong>}<br>   }<br>   <strong>Arrays.sort</strong>(<strong>pairs, </strong>new <strong>PairComparator</strong>())<strong>;   </strong>return new int[] { <strong>pairs</strong>[<strong>k - 1</strong>]<strong>.</strong>x<strong>, pairs</strong>[<strong>k - 1</strong>]<strong>.</strong>y }<strong>;</strong>}</p><p>** |<br>| —- |</p><p>| // O(N<em>logN)的复杂度，你肯定过了<br><strong>public static int[] </strong>kthMinPair2<strong>(int[] </strong>arr, <strong>int </strong>k<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>if (</strong>k &gt; N </em> N<strong>) {<br>      return null</strong>;<br>   <strong>}   </strong>// O(N<em>logN)<br>   Arrays.sort<strong>(</strong>arr<strong>)</strong>;<br>   // 第K小的数值对，第一维数字，是什么 是arr中<br>   <strong>int </strong>fristNum = arr<strong>[(</strong>k - 1<strong>) </strong>/ N<strong>]</strong>;<br>   <strong>int </strong>lessFristNumSize = 0;// 数出比fristNum小的数有几个<br>   <strong>int </strong>fristNumSize = 0; // 数出==fristNum的数有几个<br>   // &lt;= fristNum<br>   <strong>for (int </strong>i = 0; i &lt; N &amp;&amp; arr<strong>[</strong>i<strong>] </strong>&lt;= fristNum; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&lt; fristNum<strong>) {         </strong>lessFristNumSize++;<br>      <strong>} else {         </strong>fristNumSize++;<br>      <strong>}<br>   }<br>   int </strong>rest = k - <strong>(</strong>lessFristNumSize </em> N<strong>)</strong>;<br>   <strong>return new int[] { </strong>fristNum, arr<strong>[(</strong>rest - 1<strong>) </strong>/ fristNumSize<strong>] }</strong>;<br><strong>}</strong> |<br>| —- |</p><p>| // O(N)的复杂度，你肯定蒙了<br><strong>public static int[] </strong>kthMinPair3<strong>(int[] </strong>arr, <strong>int </strong>k<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>if (</strong>k &gt; N <em> N<strong>) {<br>      return null</strong>;<br>   <strong>}   </strong>// 在无序数组中，找到第K小的数（k表示下标），返回值<br>   // 第K小，以1作为开始<br>   <strong>int </strong>fristNum = getMinKth<strong>(</strong>arr, <strong>(</strong>k - 1<strong>) </strong>/ N<strong>)</strong>;<br>   // 第1维数字<br>   <strong>int </strong>lessFristNumSize = 0;<br>   <strong>int </strong>fristNumSize = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&lt; fristNum<strong>) {         </strong>lessFristNumSize++;<br>      <strong>}<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>== fristNum<strong>) {         </strong>fristNumSize++;<br>      <strong>}<br>   }   </strong>//切记不能死记硬背<br>   /*</em></p><pre><code>*  2 1 5 3 6 5 4 7 2 长度为9 求K = 58*  1 2 2 3 4 5 5 6 7   firstNum = 5(第6小的数)*  rest = 58 - 45 = 13*/</code></pre><p>   <strong>int </strong>rest = k - <strong>(</strong>lessFristNumSize <em> N<strong>)</strong>;<br>   System.<strong>out</strong>.println<strong>(“rest = “ </strong>+ rest<strong>)</strong>;<br>   <strong>return new int[] { </strong>fristNum, getMinKth<strong>(</strong>arr, <strong>(</strong>rest - 1<strong>) </strong>/ fristNumSize<strong>) }</strong>;<br>*</em>}</p><p><strong>// 改写快排，时间复杂度O(N)<br>// 在无序数组arr中，找到，如果排序的话，arr[index]的数是什么？</strong>public static int <strong>getMinKth</strong>(int[] <strong>arr, </strong>int <strong>index</strong>) {<br>   int <strong>L = 0;   </strong>int <strong>R = arr.</strong>length <strong>- 1;   </strong>int <strong>pivot = 0;   </strong>int[] <strong>range = </strong>null<strong>;   </strong>while (<strong>L &lt; R</strong>) {<br>      <strong>pivot = arr</strong>[<strong>L + </strong>(int) (<strong>Math.random</strong>() <strong>* </strong>(<strong>R - L + 1</strong>))]<strong>;<br>      range = partition</strong>(<strong>arr, L, R, pivot</strong>)<strong>;      </strong>if (<strong>index &lt; range</strong>[<strong>0</strong>]) {<br>         <strong>R = range</strong>[<strong>0</strong>] <strong>- 1;      </strong>} else if (<strong>index &gt; range</strong>[<strong>1</strong>]) {<br>         <strong>L = range</strong>[<strong>1</strong>] <strong>+ 1;      </strong>} else {<br>         return <strong>pivot;      </strong>}<br>   }<br>   return <strong>arr</strong>[<strong>L</strong>]<strong>;</strong>}</p><p>public static int[] <strong>partition</strong>(int[] <strong>arr, </strong>int <strong>L, </strong>int <strong>R, </strong>int <strong>pivot</strong>) {<br>   int <strong>less = L - 1;   </strong>int <strong>more = R + 1;   </strong>int <strong>cur = L;   </strong>while (<strong>cur &lt; more</strong>) {<br>      if (<strong>arr</strong>[<strong>cur</strong>] <strong>&lt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, ++less, cur++</strong>)<strong>;      </strong>} else if (<strong>arr</strong>[<strong>cur</strong>] <strong>&gt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, cur, —more</strong>)<strong>;      </strong>} else {<br>         <strong>cur++;      </strong>}<br>   }<br>   return new int[] { <strong>less + 1, more - 1 </strong>}<strong>;</strong>}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-数组能不能分成4个相等的部分"><a href="#·-数组能不能分成4个相等的部分" class="headerlink" title="· 数组能不能分成4个相等的部分"></a>· 数组能不能分成4个相等的部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533468062-870ee3db-9ba1-438d-bfba-f1f0eaca5b6e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=139&amp;id=u21da3700&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=174&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31102&amp;status=done&amp;style=none&amp;taskId=u552b24ea-96ee-414d-8b28-0f5ce24cea0&amp;title=&amp;width=456.8" alt="image.png"><br><strong>题意</strong><br>N&gt;=7, 正数数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471540-fc6df3a7-1744-4cd5-abf5-c52f0a31e14f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=u3c662ee6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=302&amp;originWidth=808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u91f5bb87-ba17-433f-954d-94343906014&amp;title=&amp;width=508" alt=""><br>你能不能切出四个部分，让四个部分累加和一样。但是切掉的数字是不算的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471734-ee7c3286-54dc-49c0-9841-5a6297def955.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=ucc6800d7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u02fc3a3e-8ed3-4c74-9bd3-99e837f2411&amp;title=&amp;width=578" alt=""><br><strong>题解</strong><br>做出前缀和数组, 假设来到i位置, 想问<br>i位置做第一刀的情况下有没有可能切出4个部分累加和一样<br><strong>例子</strong><br>找209的前缀和<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471524-5d3a4faa-2313-4e57-b4a0-f8c9f5f4cd8b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=u24736741&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=651&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b0e8c1c-ddc2-4fac-829c-3118343a3af&amp;title=&amp;width=483" alt=""><br>14位置是第二刀<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471485-660cacba-56bd-4b13-a478-cf66a91eec8a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=240&amp;id=uf0101aab&amp;margin=%5Bobject%20Object%5D&amp;originHeight=433&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae1dd84f-46f8-46f8-af79-6a3c3d93766&amp;title=&amp;width=541" alt=""><br>验证7位置能不能第一刀, O(1), 然后验证每一个位置做为第一刀, 就可以了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471488-436b2399-5728-40d0-8da9-e1a64ed33a89.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u97f20565&amp;margin=%5Bobject%20Object%5D&amp;originHeight=475&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6f84d7de-0496-43f3-a6c5-e1cb29a148d&amp;title=" alt=""></p><p><strong>代码</strong></p><p>| <strong>public static boolean </strong>canSplits2<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>&lt; 7<strong>) {<br>      return false</strong>;<br>   <strong>}   </strong>// key 某一个累加和， value出现的位置<br>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt;()</strong>;<br>   <strong>int </strong>sum = arr<strong>[</strong>0<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>map.put<strong>(</strong>sum, i<strong>)</strong>;<br>      sum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   int </strong>lsum = arr<strong>[</strong>0<strong>]</strong>; // 第一刀左侧的累加和<br>   <strong>for (int </strong>s1 = 1; s1 &lt; arr.<strong>length </strong>- 5; s1++<strong>) { </strong>// s1是第一刀的位置<br>      <strong>int </strong>checkSum = lsum <em> 2 + arr<strong>[</strong>s1<strong>]</strong>; // 100 x 100   100</em>2 + x<br>      <strong>if (</strong>map.containsKey<strong>(</strong>checkSum<strong>)) {<br>         int </strong>s2 = map.get<strong>(</strong>checkSum<strong>)</strong>; // j -&gt; y<br>         checkSum += (lsum + arr<strong>[</strong>s2<strong>])</strong>;<br>         <strong>if (</strong>map.containsKey<strong>(</strong>checkSum<strong>)) { </strong>// 100 <em> 3 + x + y<br>            <strong>int </strong>s3 = map.get<strong>(</strong>checkSum<strong>)</strong>; // k -&gt; z<br>            <strong>if (</strong>checkSum + (arr<strong>[</strong>s3<strong>] </strong>+ lsum) == sum<strong>) {<br>               return true</strong>;<br>            <strong>}<br>         }<br>      }      </strong>lsum += arr<strong>[</strong>s1<strong>]</strong>;<br>   <strong>}<br>   return false</strong>;<br><em>*}</em></em> |<br>| —- |</p><h2 id="·-✊316-去除重复字母-M"><a href="#·-✊316-去除重复字母-M" class="headerlink" title="· ✊316. 去除重复字母  [M]"></a>· ✊316. 去除重复字母  [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533504865-a0411f35-f468-4fe7-ba62-98a6ffb066a1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=322&amp;id=udc341fe0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=402&amp;originWidth=828&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32042&amp;status=done&amp;style=none&amp;taskId=u83a362da-6605-45be-b799-61f01d3e0bb&amp;title=&amp;width=662.4" alt="image.png"><br><strong>题意</strong><br>每种字符只保留一个, 请你返回字典序最小的结果<br>相对次序不能乱<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940519-92d4b450-75f4-4738-b2fc-d448dabee78d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=uc3a5dde1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=393&amp;originWidth=973&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7ea7df2e-ecc2-4679-8640-20a95c7d97c&amp;title=&amp;width=502" alt=""><br><strong>题解</strong><br>先建立词频统计表, 从左往右划线, 划线的词从词频表里删除</p><p>我如果在这线里面，这条线代表啥意思，我如果要选保留的第一个字符的话，我只能在这条线里选，<br>不能够再把右侧的字符考虑进来了。<br>当我决定保留一个字符的时候，我保留这个字符的同时，左侧字符全不要, 右侧字符可以继续选，<br>我在后面的字符里再选一个字符Y，那么 Y 左边的字符就不能再选了，在后面继续选，这是我的主流程。<br>选ascii码最小的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940426-5bd3de48-60bb-4186-b3f0-dafc220489fd.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=uec914f16&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=931&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d28ade0-97a0-4e57-8028-5f5f382ea6d&amp;title=&amp;width=598" alt=""><br>因为如果我这个 C 作为我保留第一个字符的话，后面就没 A 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940449-8ead876f-9228-42c5-9a3a-9e1da7419ba8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u7b220aee&amp;margin=%5Bobject%20Object%5D&amp;originHeight=498&amp;originWidth=918&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueb18526a-30cb-44be-9a19-beabfa28a43&amp;title=&amp;width=586" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940483-a32ca227-5889-422a-a8a6-b692068da001.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u476f8fde&amp;margin=%5Bobject%20Object%5D&amp;originHeight=343&amp;originWidth=861&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua441ad0d-c491-4083-8559-fa70fc38f5b&amp;title=&amp;width=550" alt=""><br><strong>代码</strong></p><p>| //递归版本： 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回<br><strong>public static </strong>String removeDuplicateLetters1<strong>(</strong>String str<strong>) {<br>   if (</strong>str == <strong>null </strong>&#124;&#124; str.length<strong>() </strong>&lt; 2<strong>) {<br>      return </strong>str;<br>   <strong>}<br>   int[] </strong>map = <strong>new int[</strong>256<strong>]</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; str.length<strong>()</strong>; i++<strong>) {      </strong>map<strong>[</strong>str.charAt<strong>(</strong>i<strong>)]</strong>++;<br>   <strong>}<br>   int </strong>minACSIndex = 0;<br>   <strong>for (int </strong>i = 0; i &lt; str.length<strong>()</strong>; i++<strong>) {      </strong>minACSIndex = str.charAt<strong>(</strong>minACSIndex<strong>) </strong>&gt; str.charAt<strong>(</strong>i<strong>) </strong>? i : minACSIndex;<br>      <strong>if (</strong>—map<strong>[</strong>str.charAt<strong>(</strong>i<strong>)] </strong>== 0<strong>) {<br>         break</strong>;<br>      <strong>}<br>   }   </strong>// 0…break(之前) minACSIndex<br>   // str[minACSIndex] 剩下的字符串str[minACSIndex+1…] -&gt; 去掉str[minACSIndex]字符 -&gt; s’<br>   // s’…<br>   <strong>return </strong>String.valueOf<strong>(</strong>str.charAt<strong>(</strong>minACSIndex<strong>)) </strong>+ removeDuplicateLetters1<strong>(         </strong>str.substring<strong>(</strong>minACSIndex + 1<strong>)</strong>.replaceAll<strong>(</strong>String.valueOf<strong>(</strong>str.charAt<strong>(</strong>minACSIndex<strong>))</strong>, <strong>“”))</strong>;<br><strong>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>遍历一遍总会保留一个字符, 而且以后的字符串中是不含有这个字符的。<br>所以你str中如果含有 K 种字符，复杂度就是O(K*N)。这个 K 大写加小写也不就是 52 种字符, 所以O(N)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940987-5cb7a264-d11d-41c0-b9e1-8e61798e55c6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=u7ac43425&amp;margin=%5Bobject%20Object%5D&amp;originHeight=458&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69a4ec90-04ea-41f8-acde-5152dda5a2b&amp;title=&amp;width=586" alt=""></p><h2 id="·-15-三数之和-M"><a href="#·-15-三数之和-M" class="headerlink" title="· 15.三数之和 [M]"></a>· 15.三数之和 [M]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168720-6b744df4-7946-45c9-a331-a2bea7ca808b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u91a5461c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=418&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u47aed55e-205d-42c8-b687-db174d78dfa&amp;title=&amp;width=466" alt=""><br>字面值都不一样，就算不同的，有几个三元组全返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168713-93b17778-7f67-446e-90c9-05862b57e449.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ubaf6ddac&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=964&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u18986bf3-72d6-45ce-9a40-801113f1696&amp;title=&amp;width=440" alt=""><br><strong>题解</strong><br>2sum<br>双指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168718-d3daae68-041e-4709-83d2-24ed9706dcf1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=161&amp;id=u3abbd115&amp;margin=%5Bobject%20Object%5D&amp;originHeight=244&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u13162b89-c8f0-4a19-a91b-a82270cb67d&amp;title=&amp;width=665" alt=""><br><strong>去重复:</strong><br>1) 收集所有二元组, 过滤<br>2) 通过好的流程设计规避重复<br>L移动到下一个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168760-f5557fad-41a1-4981-9a4a-e7b1be9554d8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ue9ce0c40&amp;margin=%5Bobject%20Object%5D&amp;originHeight=471&amp;originWidth=1076&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1155980f-554e-48b9-9513-a53e4dfc988&amp;title=&amp;width=574" alt=""><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168722-ed693ec3-17f3-40db-875b-40df7a3e3bc2.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc9bb16c8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=604&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue3cc0675-8fd4-41a6-82ad-5ab956d174d&amp;title=" alt=""><br><strong>题解</strong><br>你只要保证第1个数字不一样后面就是二元组的问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169245-eb3b0c0f-0f36-4691-9b6d-a4d24f65c0f9.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=ubddc1e46&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9cfee96b-8401-44c4-8bfc-7cbfccc2aa1&amp;title=&amp;width=623" alt=""><br>避免arrayList插到开头的代价有点高, 所以从右往左生成所有的三元组, 把一个数塞在最后<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169284-19a38708-e6da-4a5e-bb4a-20a29232ee3c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u9d26ce66&amp;margin=%5Bobject%20Object%5D&amp;originHeight=520&amp;originWidth=1064&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f65a980-7862-4577-af50-86a27112905&amp;title=&amp;width=614" alt=""><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169425-e3392844-3840-45f1-9ab5-46624ba97638.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue27c0fc3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=278&amp;originWidth=689&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc8ba67a7-38d3-4a72-af12-8e3c795c18e&amp;title=" alt=""></p><p>| <strong>public static </strong>List<List<Integer>&gt; threeSum(<strong>int</strong>[] nums) {<br>   Arrays.<em>sort</em>(nums);<br>   <strong>int </strong>N = nums.<strong>length</strong>;<br>   List<List<Integer>&gt; ans = <strong>new </strong>ArrayList&lt;&gt;();<br>   <strong>for </strong>(<strong>int </strong>i = N - 1; i &gt; 1; i—) { <em>// 三元组最后一个数，是arr[i]   之前….二元组 + arr[i]      </em><strong>if </strong>(i == N - 1 &#124;&#124; nums[i] != nums[i + 1]) {<br>         List<List<Integer>&gt; nexts = <em>twoSum</em>(nums, i - 1, -nums[i]);<br>         <strong>for </strong>(List<Integer> cur : nexts) {<br>            cur.add(nums[i]);<br>            ans.add(cur);<br>         }<br>      }<br>   }<br>   <strong>return </strong>ans;<br>}</p><p><em>// nums[0…end]这个范围上，有多少个不同二元组，相加==target，全返回<br>// {-1,5}     K = 4<br>// {1, 3}</em><strong>public static </strong>List<List<Integer>&gt; twoSum(<strong>int</strong>[] nums, <strong>int </strong>end, <strong>int </strong>target) {<br>   <strong>int </strong>L = 0;<br>   <strong>int </strong>R = end;<br>   List<List<Integer>&gt; ans = <strong>new </strong>ArrayList&lt;&gt;();<br>   <strong>while </strong>(L &lt; R) {<br>      <strong>if </strong>(nums[L] + nums[R] &gt; target) {<br>         R—;<br>      } <strong>else if </strong>(nums[L] + nums[R] &lt; target) {<br>         L++;<br>      } <strong>else </strong>{ <em>// nums[L] + nums[R] == target         </em><strong>if </strong>(L == 0 &#124;&#124; nums[L - 1] != nums[L]) {<br>            List<Integer> cur = <strong>new </strong>ArrayList&lt;&gt;();<br>            cur.add(nums[L]);<br>            cur.add(nums[R]);<br>            ans.add(cur);<br>         }<br>         L++;<br>      }<br>   }<br>   <strong>return </strong>ans;<br>} |<br>| —- |</p><h2 id="·-小朋友排队的最高分数"><a href="#·-小朋友排队的最高分数" class="headerlink" title="· 小朋友排队的最高分数"></a>· 小朋友排队的最高分数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652536502099-7223e529-c2d9-4f8f-a4a9-a6ab1fcd7ad3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=91&amp;id=u6ea2c2e9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=114&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22491&amp;status=done&amp;style=none&amp;taskId=u67386263-86db-4666-a03d-34b0bd10782&amp;title=&amp;width=665.6" alt="image.png"><br>暴力递归，把所有的全排列(N!)搞出来, 分数最大的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537096712-968d9c3d-2f9f-44bc-b6e9-a801cf34a8ba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=330&amp;id=ue4cc4511&amp;margin=%5Bobject%20Object%5D&amp;originHeight=511&amp;originWidth=925&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub1f9f15f-045e-4823-bf05-f159007dd6a&amp;title=&amp;width=597" alt=""></p><p>| <strong>public static int </strong>process<strong>(int[][] </strong>matrix,<strong>int </strong>index,<strong>int </strong>score<strong>) {<br>    int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>    <strong>int </strong>ans = 0;<br>    <strong>if (</strong>index == matrix.<strong>length) {<br>        return </strong>score;<br>    <strong>} else {<br>        for (int </strong>i = index; i &lt; matrix.<strong>length</strong>; i++<strong>) {<br>            int </strong>num = 0;<br>            swap<strong>(</strong>matrix,index,i<strong>)</strong>;</p><pre><code>        **if (**i-1&gt;0 &amp;&amp; matrix**[**i**][**0**] **&gt; matrix**[**i-1**][**0**]) &#123;            **num += 1;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**]) &#123;            **num += 2;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**] **&amp;&amp; matrix**[**i+1**][**0**] **&gt; matrix**[**i**][**0**]) &#123;            **num += 5;        **&#125;        **ans = process**(**matrix,index+1,score+num**)**;        max = Math.max**(**max,ans**)**;        swap**(**matrix,index,i**)**;    **&#125;    return **max;**&#125;</code></pre><p>}<br>public static void <strong>swap</strong>(int[][] <strong>matrix,</strong>int <strong>i,</strong>int <strong>j</strong>) {<br>    int[] <strong>temp = matrix</strong>[<strong>i</strong>]<strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>0</strong>] <strong>= matrix</strong>[<strong>j</strong>][<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>1</strong>] <strong>= matrix</strong>[<strong>j</strong>][<strong>1</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>0</strong>] <strong>= temp</strong>[<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>1</strong>] <strong>= temp</strong>[<strong>1</strong>]<strong>;</strong>}** |<br>| —- |</p><h2 id="·-❓乐队演出的最少花费"><a href="#·-❓乐队演出的最少花费" class="headerlink" title="· ❓乐队演出的最少花费"></a>· ❓乐队演出的最少花费</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537423682-efe033ec-3f72-424f-bde7-e5014b897bef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=165&amp;id=u4f042f4e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=845&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43808&amp;status=done&amp;style=none&amp;taskId=u0e6f551b-d211-4ea1-b57c-7c37cc19b72&amp;title=&amp;width=676" alt="image.png"><br>题意<br>乐队数量编号跟numbers*2是严格绑定的<br>nums=5, 乐队数量下标一定是0~9<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448658-3dab8950-a21f-43a1-b17b-7ed848f64840.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u7d539c9d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=533&amp;originWidth=1051&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uacdc5ae2-9463-4236-b703-588b8875dfa&amp;title=&amp;width=592" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448639-8358f990-06dd-4df5-92ae-7f64d89c5234.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=u8052bab1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=1124&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u76a2c942-9cfb-413c-87b0-e6c87ef102c&amp;title=&amp;width=585" alt=""><br>nums=1, 一定有0,1两支乐队<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448741-b140f77d-7e96-44c8-84b8-5fc2a709c6d8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=285&amp;id=u403bc2c5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=906&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucb4940ea-7279-443e-9b7d-0ae124ea889&amp;title=&amp;width=583" alt=""><br>nums=2, 一定有0,1, 2, 3 四支乐队<br>一个乐队只能在一个项目里被挑到，它不能同时为两个项目挑到, 把所有乐队都挑全, 返回最低报价</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448667-377bf58a-896b-4092-92b2-f8b2a5e09815.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=286&amp;id=u32fa3de3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=531&amp;originWidth=1106&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u65c2b037-7834-4cf3-ab10-f0b6e2bf05e&amp;title=&amp;width=596" alt=""><br>题解<br>乐队数量16只, 任何两个乐队的组合为C_16^2, 共120种情况, 现在题目中有500组,<br>有大量冗余项目, 只选报价低的, 剩余的删掉<br>如果某个乐队不在报价中返回-1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448679-f9b98e3e-d745-4b02-bdae-869c77c67a26.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u6948a087&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=1137&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucaf4f2e9-9d3d-4a61-975f-3175ffd7c66&amp;title=&amp;width=589" alt=""><br>洗数据<br>调整乐队编号, 两个乐队最小值放第一位, 最大值放第二位, 最后是花费<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449231-9d45d470-a1c6-43c9-9588-469ca0f1e264.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u46433d67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=419&amp;originWidth=1033&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8f5bb06b-f43c-4077-8a14-5d13c732d90&amp;title=&amp;width=647" alt=""><br>排序: 第一维小的排前面，第一维数据相等的，根据第二维数据小的排前面，前两维数据都相同的，<br>根据报价小的排前面<br>前两项一样的这一组，我只要第一个, 剩下的都删掉<br>把价格大的都删掉。两个乐队之间最低报价的留下来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449453-bf550b3c-8f14-4478-83d9-7deee2932b11.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=ud0a23bf4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=491&amp;originWidth=1118&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6ee4650d-6457-4fb0-9ab1-c041cd0877a&amp;title=&amp;width=541" alt=""><br>暴力递归<br>通过size控制<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449574-6cc51376-eedc-4492-9837-2b7fe7a5137b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=441&amp;id=u19699120&amp;margin=%5Bobject%20Object%5D&amp;originHeight=586&amp;originWidth=778&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue22b83d6-55e4-4b95-829f-40f960b64cd&amp;title=&amp;width=586" alt=""><br>可以用一个整数的二进制状态，表示哪个乐队挑了哪个没挑<br>一共就8组, 16个乐队<br>最低位就代表0号乐队挑没有挑, 上面如果是1代表挑了, 上面如果是 0 , 代表没挑</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449591-6da74ef6-513b-4524-9b3a-b672e0db5668.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=u2fe508db&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1006&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u94eb5d67-dd4e-4672-9456-0ae104e69b9&amp;title=&amp;width=554" alt=""><br>乐队全挑是啥样？<br>应该是某一个整数，后面 16 位全是1，前面 16 位全是0。这个状态就表示你所有的都挑到了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449813-4c4d0188-00e0-4d90-94b2-91dde3d4e2ee.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=u2abab5d3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7278723a-a0c2-4568-a86d-a0851da4baf&amp;title=&amp;width=555" alt=""><br>之前 5 位置的 5 乐队已经考虑过了，此时的项目无论如何不能考虑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449921-dabce459-c444-48ca-9b0d-38842a88bea8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=276&amp;id=u91c52048&amp;margin=%5Bobject%20Object%5D&amp;originHeight=543&amp;originWidth=1051&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69d7ed52-13ce-44af-b614-77ad78833ad&amp;title=&amp;width=534" alt=""><br>不能改动态规划, 可变参数太多了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450094-53b89c36-d138-4950-9855-9eb41da56b81.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaefbf1e8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1189&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f03743c-eabf-4d20-b806-7572874a0d2&amp;title=" alt=""><br>优化<br>可以省掉done参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450158-14d02b8e-1908-4948-8d94-927946c3838e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4a13716a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=369&amp;originWidth=825&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf1a8774c-e654-4e8e-80e7-5bbedb5bdff&amp;title=" alt=""><br>复杂度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450320-12c34c5a-b718-43e3-b910-ce5cd6be6e48.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5fa9848d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1110&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0d5c8479-84af-4bde-b87e-fdc85878b0a&amp;title=" alt=""><br><br>分治<br>复杂度<br>一共 120 个项目挑 8 个项目就停。<br>C_{120}^8_C_1208 超过 10^8了, 这个方法不行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450494-e0629605-12c2-45c0-ba4d-8981a6fc2e84.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue97cf8a0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u40393ab8-0e3f-4b26-ae96-d80c6c2c4d1&amp;title=" alt=""><br>特殊情况, num=7<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450801-bf9dd979-4d42-4c30-9acd-45c6b4e7f866.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u628d5bce&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u16e23e4a-120c-4887-adee-11b29cab4e1&amp;title=" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450938-6f42c655-5387-4db9-b9db-d38ddc55848f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7ea57ad3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=767&amp;originWidth=713&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u340a0fea-3523-4622-b767-bc6d89db7eb&amp;title=" alt=""></p><h2 id="·-❓题目2-企鹅的最少数量-781-森林中的兔子-M"><a href="#·-❓题目2-企鹅的最少数量-781-森林中的兔子-M" class="headerlink" title="· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]"></a>· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537527351-44459aaf-41e1-458d-bae2-5ce71a0191b1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=176&amp;id=u67946780&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=797&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40177&amp;status=done&amp;style=none&amp;taskId=u47ce9f2e-8b46-4f21-a705-0ea9eefe640&amp;title=&amp;width=637.6" alt="image.png"><br>题意</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-b877c03c-a285-4712-9615-258c243e8ed7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u5b0b2b90&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufafc36af-a0b5-4e28-9db2-89eb9b6b178&amp;title=&amp;width=570" alt=""><br>a,b必然不同<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512800-25772203-c346-4bbe-8237-30518dbdb60b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9a8e07f0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=183&amp;originWidth=228&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c66b2ce-92ce-46a9-b14b-4a3751310b8&amp;title=" alt=""><br><br>题解<br><br>排序, 让说的一样数量的人在一起<br>自我消化<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-cf987f51-87b0-448b-ac46-e9d5faf98eb3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=uaaa8f52f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=392&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud38b542a-cec3-4e17-b52e-70e2f50bd8f&amp;title=&amp;width=570" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512924-12bacc17-7f26-4686-85f0-7f71db1bfa89.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=uf697393a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7604ddcd-7966-4e3a-b5d3-8f4cabf5c5a&amp;title=&amp;width=573" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512826-891ffc75-377e-4fc5-9d7a-da4028ceae6f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u2a3485d2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1088&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6df243e7-fbc7-4a92-ab5c-bae5a440dbc&amp;title=&amp;width=559" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513286-e4853f30-976d-4afb-a9c2-1c0843765303.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=uc338299f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1109&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf7ddc6e6-1972-40c5-8878-9a5754d7b21&amp;title=&amp;width=553" alt=""><br>规律, 如果当前数是x, 有c个, 有几组?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513383-501045f8-319a-4179-b47c-9c0c02e0badf.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u5d11b8c0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=869&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c2f6b9e-c173-4c10-9c13-75c4fbdd5e3&amp;title=&amp;width=503" alt=""><br>a/b怎么向上取整<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513552-6e8d37f3-9848-4900-8eda-b864d1d22c3c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u20f90519&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=1146&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u396d7a21-be1d-44e9-877e-02a28b7fadc&amp;title=&amp;width=525" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513704-ac750a4e-7f0b-4700-8c7d-443c6aff347c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ucf35688f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u103b599a-2ac9-4946-ae00-a479d0b8f24&amp;title=&amp;width=560" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513881-861b81c5-c61d-4e5d-92f4-e7f56b5dc042.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=150&amp;id=u74b861b9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=1088&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75cc545e-f180-4c5d-90b8-b2e36446e6f&amp;title=&amp;width=544" alt=""><br>代码<br>不能约<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514082-45e66cf1-cbdf-48bd-80ce-7343743b8fca.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u32d23b83&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1010&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1f8888e6-27db-45fb-867a-dc516aff8af&amp;title=&amp;width=503" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514370-fba438f5-6e52-45a9-b7ff-ffe1427d7e10.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udbfd29aa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=447&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u877d5405-cfd1-4b2e-b825-ffe2521430e&amp;title=" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈哈</title>
      <link href="/2022/08/09/E-M/"/>
      <url>/2022/08/09/E-M/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>多练的代码也就是不容易写出来的：✊<br>困难的代码：😡<br>了解：👌</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>heap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;((</strong>a, b<strong>) </strong>-&gt; a.<strong>value </strong>- b.<strong>value)</strong>;<br>要练熟的代码：</p><p>排序：Arrays.sort()<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650254542022-b29c6afb-07da-458f-aad0-d9195e2cbb60.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=37&amp;id=BvypH&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=46&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29461&amp;status=done&amp;style=none&amp;taskId=ue1e9cf3b-75fb-4abc-a0d2-566f55d0aec&amp;title=&amp;width=466.4" alt="image.png"></p><p>子串子数组想到以i结尾往左推 class3例子</p><h2 id="·-返回离非负整数num最近的2的某次方"><a href="#·-返回离非负整数num最近的2的某次方" class="headerlink" title="· 返回离非负整数num最近的2的某次方"></a>· 返回离非负整数num最近的2的某次方</h2><p><strong>题意</strong><br>num=7, 返回8   num=8，返回8   num=13，返回6<br><strong>题解</strong><br>二进制第一个1后面全部填充完1后加1返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606374038-5dc3bdff-f8db-4cea-b539-13bc0f241519.png#clientId=u24411928-8d24-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=u6f518ae8&amp;margin=%5Bobject%20Object%5D&amp;name=DEF082573F9BE5D1BD2D58935BF11CDD.png&amp;originHeight=1166&amp;originWidth=1502&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=328379&amp;status=done&amp;style=none&amp;taskId=uc329201a-a346-4a48-9408-2ab96b91a62&amp;title=&amp;width=448.2857666015625" alt="DEF082573F9BE5D1BD2D58935BF11CDD.png"></p><p>| // 已知n是正数<br>// 返回大于等于，且最接近n的，2的某次方的值<br>public static final int tableSizeFor(int n) {<br>   //这个是为了如果正好是2的某次方，打散！！<br>   n—;<br>   //&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补0。<br>   n &#124;= n &gt;&gt;&gt; 1;<br>   n &#124;= n &gt;&gt;&gt; 2;<br>   n &#124;= n &gt;&gt;&gt; 4;<br>   n &#124;= n &gt;&gt;&gt; 8;<br>   //整型最多32位<br>   n &#124;= n &gt;&gt;&gt; 16;<br>   return (n &lt; 0) ? 1 : n + 1;//负数最高位是1，填满32个1，返回1<br>} |<br>| —- |</p><h2 id="·-相邻字符的交换次数"><a href="#·-相邻字符的交换次数" class="headerlink" title="· 相邻字符的交换次数"></a>· 相邻字符的交换次数</h2><p><strong>题意</strong><br>刻意的说两个标准, 搞你一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704873615-836bf286-fab2-47cb-8817-a817f740da5d.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=70&amp;id=u73201307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=88&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19948&amp;status=done&amp;style=none&amp;taskId=ub30207ba-f24d-4b60-884e-75662524657&amp;title=&amp;width=660.8" alt="image.png"><br><strong>题解</strong><br>贪心:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652704850684-0c6b231e-483f-4ad1-99fb-9b7d76b6ffc9.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u5d3653f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=398&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u976907e3-3bde-438a-891c-5605344be3c&amp;title=&amp;width=556" alt=""><br><strong>两个指针</strong><br>index: 往右扫, 不是G就往右飘<br>L: 如果发现了放到哪儿的位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654606588940-7b194664-6549-49a7-bec8-3209b6c93f08.png#clientId=u24411928-8d24-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=uab987630&amp;margin=%5Bobject%20Object%5D&amp;name=39A8E84629C793605662823ED198A9D4.png&amp;originHeight=718&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=126502&amp;status=done&amp;style=none&amp;taskId=uc016d720-79cd-42d8-8978-bf6dafda160&amp;title=&amp;width=390.2857666015625" alt="39A8E84629C793605662823ED198A9D4.png"><br>如何确定这是最优解?<br>这个过程, L, index都不回退, 复杂度O(N)<br>原题: 你可以选择让 G 在左边B 在右边或者你可以选择让 B 在左边G在右边哪种更省。<br>哪种更剩你用哪种, 问你最小的用代价</p><p>| <em>// 可以让G在左，或者在右</em><strong>public static int </strong>minSteps2(String s) {<br>   <strong>if </strong>(s == <strong>null </strong>&#124;&#124; s.equals(<strong>“”</strong>)) {<br>      <strong>return </strong>0;<br>   }<br>   <strong>char</strong>[] str = s.toCharArray();<br>   <strong>int </strong>step1 = 0;<br>   <strong>int </strong>step2 = 0;<br>   <strong>int </strong>gi = 0;<br>   <strong>int </strong>bi = 0;<br>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; str.<strong>length</strong>; i++) {<br>      <strong>if </strong>(str[i] == <strong>‘G’</strong>) { <em>// 当前的G，去左边   方案1<br>         _step1 += i - (gi++);<br>      } <strong>else </strong>{</em>// 当前的B，去左边   方案2<br>         <em>step2 += i - (bi++);<br>      }<br>   }<br>   <strong>return </strong>Math._min</em>(step1, step2);<br>} |<br>| —- |</p><h2 id="·-无序数组需要排序的最短子数组长度"><a href="#·-无序数组需要排序的最短子数组长度" class="headerlink" title="· 无序数组需要排序的最短子数组长度"></a>· 无序数组需要排序的最短子数组长度</h2><p><strong>题意</strong><br>想让整体有序<br>时间复杂度 O(N)额外空间复杂度O(1)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710897296-aa25c260-3795-403f-a63d-abcb51e33ff8.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u907fe5bc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=593&amp;originWidth=1216&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8e7d06d1-a6cb-4207-a123-ea9ca887b8c&amp;title=&amp;width=477" alt=""><br><strong>题解</strong><br>最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654696304737-51815bbc-5fb1-4258-8122-5b4218ecc06f.png#clientId=uaf1c0b48-9cd0-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=2891&amp;id=u37b19965&amp;margin=%5Bobject%20Object%5D&amp;name=63E3A64272C54C218FDD9192B70053CB.png&amp;originHeight=5059&amp;originWidth=1612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=673473&amp;status=done&amp;style=none&amp;taskId=u1c723737-203b-4864-b838-1417ede3aeb&amp;title=&amp;width=921.1428571428571" alt="63E3A64272C54C218FDD9192B70053CB.png"><br>需要排序范围2~5<br>你第一回从左往右遍历最右的违规，然后从右往左遍历最左的违规这之间需要排序。</p><p>左面max&lt;=当前数, 比如左max=6, 最后8,9是对号, 说明如果真要排序的话, 8不必给前面的最大值让位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898543-234a31d2-30e8-43f4-8676-33e52a7b9d25.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u2443991c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90eff19c-58f3-47d7-a63a-a785a4fd9f9&amp;title=&amp;width=572" alt=""><br>9不必给前面的最大值让位置<br>10也不必给前面的最大值让位置<br>你后面连续的对号说明如果真的排序的话，它们动都不需要动<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898593-d8fbbadb-d557-419e-867b-23549142645e.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u9fabbcb7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1258&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud6eca0a4-35e4-44ff-9ecc-aeb906a1b14&amp;title=&amp;width=631" alt=""><br>从右往左滑同理, 最左的对号说明在往左一直到开头全是对号,<br>说明如果真的排序的话，这些数据也不用给右边部分的最小值让位置。<br>你确定了一个右边不需要排的部分, 确定了一个左边不需要排的部分，那中间就是需要排序的部分, 搞定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710898762-58901f0c-bbed-431c-a9f4-1bbd7fea4661.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u670e797a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=609&amp;originWidth=1212&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4471b33b-6b3d-4372-8a6b-4a2b4749e8c&amp;title=&amp;width=484" alt=""><br>第一个X到最后一个X中间直接排序不行吗?<br>不行, 因为你只关注了最大值, 例子中8没有人处理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652710899406-b03a72c2-596b-40b2-b0a1-9d726f5d16a4.png#clientId=u5ffea8cf-8d32-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u033c7053&amp;margin=%5Bobject%20Object%5D&amp;originHeight=275&amp;originWidth=1204&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u59606f10-dbf2-4450-924e-ed0813e7169&amp;title=" alt=""></p><p>| <strong>public static int </strong>findUnsortedSubarray2(<strong>int</strong>[] nums) {</p><p>   <strong>if </strong>(nums == <strong>null </strong>&#124;&#124; nums.<strong>length </strong>&lt; 2) {<br>      <strong>return </strong>0;<br>   }<br>   <strong>int </strong>N = nums.<strong>length</strong>;<br>   <strong>int </strong>right = -1;<br>   <strong>int </strong>max = Integer.<strong><em>MIN_VALUE</em></strong>;</p><p>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; nums.<strong>length</strong>; i++) {<br>      <strong>if </strong>(nums[i] &gt;= max) {<br>         max = nums[i];<br>      } <strong>else </strong>{<br>         right = i;<br>      }</p><p>   }<br>   <strong>int </strong>left = N;<br>   <strong>int </strong>min = Integer.<strong><em>MAX_VALUE</em></strong>;</p><p>   <strong>for </strong>(<strong>int </strong>i = N - 1; i &gt;= 0; i—) {<br>      <strong>if </strong>(nums[i] &lt; min) {<br>         min = nums[i];<br>      } <strong>else </strong>{<br>         left = i;<br>      }<br>   }<br>   <strong>return </strong>Math.<em>max</em>(0,right-left+1);<br>} |<br>| —- |</p><h2 id="·-字符串种类"><a href="#·-字符串种类" class="headerlink" title="· 字符串种类"></a>· 字符串种类</h2><p>你只有26种字符，一个整数是不是有32位了，<br>你就拿这个整数的第0位表示a从没出现过，它是1是出现过，它是0就没出现过，<br>你拿这个整数第1位表示b拿这个整数，第2位表示c拿一个整数，第25位表示z，<br>你还结余了这么多倍不用了，那你的摘要是不是就不用是str类型了，变成一个<br>整数就可以表示一个摘要了<br>最后看这个set中留下了多少不同的整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351350-dc64aa66-e5f5-44a0-a5d7-96736ca8680d.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=207&amp;id=u5fa830fc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=582&amp;originWidth=1183&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue6d9144b-3a7b-4eca-8c40-f73d1b2aa6d&amp;title=&amp;width=420" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266351667-30911ef7-b885-449e-ab70-5c2e626b1445.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u6191cdd4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=257&amp;originWidth=422&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uece8ee91-b5ee-4851-a947-dd631519c75&amp;title=&amp;width=358" alt=""></p><h2 id="·-最大的以-1-为边界的正方形-M"><a href="#·-最大的以-1-为边界的正方形-M" class="headerlink" title="· 最大的以 1 为边界的正方形 [M]"></a>· 最大的以 1 为边界的正方形 [M]</h2><p><strong>题意</strong><br>边框全是1就达标，它不要求内部也有1, 内部有1, 也可以没有1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-9c36b203-d37d-46a9-9483-0348e3180719.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=ub37f09bb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=578&amp;originWidth=1082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a91b9c9-d45e-406e-9103-c6290e2fc15&amp;title=&amp;width=427" alt=""><br><strong>题解</strong><br>预处理数组技巧</p><p><strong>前置</strong><br>N<em>N区域中长方形正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399168-04bf1552-399a-4c84-9e06-1ba7badf959e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=151&amp;id=ud0e60c23&amp;margin=%5Bobject%20Object%5D&amp;originHeight=566&amp;originWidth=1167&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1bf94e4e-6018-42e3-bfac-44286cc6e9a&amp;title=&amp;width=311.0000305175781" alt=""><br>N</em>N区域中正方形的数据量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399176-f2349f13-30c8-4f6b-8779-a086f36cb16e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=163&amp;id=u2f2a5857&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1160&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a4e536e-ea47-4b8f-acd2-17bb7283331&amp;title=&amp;width=359" alt=""><br><strong>代码</strong><br>所以边长的枚举一定是哪个少，就到那个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399180-09736a59-aa8a-4393-b496-335dd697275c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u3d7bd96a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=501&amp;originWidth=738&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u924c016e-b4a5-492d-890b-d66b64c878a&amp;title=&amp;width=403" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754399153-31e8e2ec-e0f7-4ab7-a328-8b2e74742a8f.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u6d60a1cb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0b2a46c-d586-4bff-99d6-7555284bbb0&amp;title=&amp;width=414" alt=""><br>当我们点一个点的时候，我们只要那个长方形，它往右下方向拉, 然后看你能拉多远<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401624-62771dcc-0e46-4e02-95be-f03c4a11dd8d.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=181&amp;id=u20bd98fa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=275&amp;originWidth=741&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9ee39ed7-94fc-449b-ba80-16d2550e136&amp;title=&amp;width=487" alt=""><br>验证过程能不能快一点 O(1)内<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754401970-88428577-d5a9-4b70-8787-83d3001063ea.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uada68211&amp;margin=%5Bobject%20Object%5D&amp;originHeight=304&amp;originWidth=692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua0608d42-bb77-46f4-b982-6c6e649dd36&amp;title=" alt=""><br>假设我知道任何一个(i,j)位置右边有多少个连续的1, 下方有多少个连续的1(包括自己在内)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402673-739ba559-43f0-4cfc-9907-3a8c7357f9aa.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=359&amp;id=uda259ca9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=603&amp;originWidth=670&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uef3ee539-2f80-47f9-813c-47d085e71b8&amp;title=&amp;width=399" alt=""><br>17,29的左上顶点, 边长是7的这么一个正方形。<br>怎么验证?<br>你先看看(7,29)右方连续的1够不够 7 个，你再看看(7,29)这个点下方连续的1够不够 7个<br>…<br>只需要调出这 3 个点的信息, O(1)的过程<br>接下来就是求任何一个(i,j)点，让它右方和下方有这个信息</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754402900-dc768550-cd1a-4853-a5d8-f871f5fcabfc.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=uc6970c91&amp;margin=%5Bobject%20Object%5D&amp;originHeight=547&amp;originWidth=995&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08ef4750-7959-4b40-969e-e9a6bda8fc0&amp;title=&amp;width=572" alt=""><br>怎么求这个信息呢?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781186419-16a3698d-6e4e-4407-9643-68dfc9156b32.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=810&amp;id=u0773d943&amp;margin=%5Bobject%20Object%5D&amp;name=8594CD1133E89D6E5D0DE8C781C7E60E.png&amp;originHeight=1418&amp;originWidth=1034&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=457290&amp;status=done&amp;style=none&amp;taskId=ub2bac3a4-0128-47f0-b5ea-c0907f659e3&amp;title=&amp;width=590.8571428571429" alt="8594CD1133E89D6E5D0DE8C781C7E60E.png"><br>咋知道这个O(N^3)的解需不需要继续优化?<br>矩阵规模告诉你, 最多100*100, 你拿N^3一套没到10^8这个级别,<br>你知道O(N^3)的这个解不需要再优化了, 这个题目必过.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403570-4bf72a85-3dce-4515-959c-f1866430fbbd.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u8da21f2c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=63&amp;originWidth=246&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc724a96e-b8cd-4797-97b5-7198d88597b&amp;title=" alt=""></p><p>怎么想到是预处理数组呢?<br>当写完3个for循环之后, 底层一个正方形再验的时候不想再遍历了,<br>势必会设计一种查询的结构来支持它, 不让它遍历来保证O(1)<br>这就是思想的开端,<br>预处理数组怎么用?<br>就是当你最后卡在最后一步，一个小的元件需要遍历搞定，这样的时候特别的多，<br>你就想着我怎么样做出一个能够提前查询的结构，到这一步的时候把遍历省掉, 比如前缀数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754403652-75a89599-d8f8-43a3-a1e1-5d2643008a8c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=ub5033baf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=884&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1f7af3b0-f56a-4be7-b7cc-baeebc9e05a&amp;title=&amp;width=492" alt=""></p><p>| <strong>public static int </strong>largest1BorderedSquare<strong>(int[][] </strong>m<strong>) {<br>   int[][] </strong>right = <strong>new int[</strong>m.<strong>length][</strong>m<strong>[</strong>0<strong>]</strong>.<strong>length]</strong>;<br>   <strong>int[][] </strong>down = <strong>new int[</strong>m.<strong>length][</strong>m<strong>[</strong>0<strong>]</strong>.<strong>length]</strong>;<br>   //==生成右信息 下信息<br>   setBorderMap<strong>(</strong>m, right, down<strong>)</strong>;<br>   <strong>for (int </strong>size = Math.min<strong>(</strong>m.<strong>length</strong>, m<strong>[</strong>0<strong>]</strong>.<strong>length)</strong>; size != 0; size—<strong>) {<br>      if (</strong>hasSizeOfBorder<strong>(</strong>size, right, down<strong>)) {<br>         return </strong>size <em> size;<br>      <strong>}<br>   }<br>   return </strong>0;<br><strong>}</strong><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654781251250-6c80220e-fc56-430a-b4c9-377e6c3fa002.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=455&amp;id=uadd39646&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=797&amp;originWidth=995&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=221761&amp;status=done&amp;style=none&amp;taskId=udef49ab0-cccf-4360-9f48-ec0dcec606e&amp;title=&amp;width=568.5714285714286" alt="image.png"><strong>**public static void </strong>setBorderMap<strong>(int[][] </strong>m, <strong>int[][] </strong>right, <strong>int[][] </strong>down<strong>) {<br>   int </strong>r = m.<strong>length</strong>;<br>   <strong>int </strong>c = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   //右下角<br>   <strong>if (</strong>m<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>== 1<strong>) {      </strong>right<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>= 1;<br>      down<strong>[</strong>r - 1<strong>][</strong>c - 1<strong>] </strong>= 1;<br>   <strong>}   </strong>//最右侧的数据<br>   <strong>for (int </strong>i = r - 2; i != -1; i—<strong>) {<br>      if (</strong>m<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>== 1<strong>) {         </strong>right<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>= 1;<br>         //等于1的话九四下一行加1<br>         down<strong>[</strong>i<strong>][</strong>c - 1<strong>] </strong>= down<strong>[</strong>i + 1<strong>][</strong>c - 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }   </strong>//最后一行的数据<br>   <strong>for (int </strong>i = c - 2; i != -1; i—<strong>) {<br>      if (</strong>m<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>== 1<strong>) {         </strong>right<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>= right<strong>[</strong>r - 1<strong>][</strong>i + 1<strong>] </strong>+ 1;<br>         down<strong>[</strong>r - 1<strong>][</strong>i<strong>] </strong>= 1;<br>      <strong>}<br>   }   </strong>//然后从倒数第二行开始，从倒数第二列往前一行一行的推 &lt;—  ^<br>   <strong>for (int </strong>i = r - 2; i != -1; i—<strong>) {<br>      for (int </strong>j = c - 2; j != -1; j—<strong>) {<br>         if (</strong>m<strong>[</strong>i<strong>][</strong>j<strong>] </strong>== 1<strong>) {            </strong>right<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= right<strong>[</strong>i<strong>][</strong>j + 1<strong>] </strong>+ 1;<br>            down<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= down<strong>[</strong>i + 1<strong>][</strong>j<strong>] </strong>+ 1;<br>         *</em>}<br>      }<br>   }<br>}</p><p>** |<br>| —- |</p><p>| <strong>public static boolean </strong>hasSizeOfBorder<strong>(int </strong>size, <strong>int[][] </strong>right, <strong>int[][] </strong>down<strong>) {<br>   for (int </strong>i = 0; i != right.<strong>length </strong>- size + 1; i++<strong>) {<br>      for (int </strong>j = 0; j != right<strong>[</strong>0<strong>]</strong>.<strong>length </strong>- size + 1; j++<strong>) {         </strong>//找那三个点！！  左上的那个点              下方的那个点<br>         <strong>if (</strong>right<strong>[</strong>i<strong>][</strong>j<strong>] </strong>&gt;= size &amp;&amp; down<strong>[</strong>i<strong>][</strong>j<strong>] </strong>&gt;= size &amp;&amp; right<strong>[</strong>i + size - 1<strong>][</strong>j<strong>] </strong>&gt;= size<br>               //右边的那个点<br>               &amp;&amp; down<strong>[</strong>i<strong>][</strong>j + size - 1<strong>] </strong>&gt;= size<strong>) {<br>            return true</strong>;<br>         <strong>}<br>      }<br>   }<br>   return false</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-乘客坐船使用的最少船数"><a href="#·-乘客坐船使用的最少船数" class="headerlink" title="· 乘客坐船使用的最少船数"></a>· 乘客坐船使用的最少船数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650266540654-bc52c017-346b-4c9c-ba85-2f8363a2f43d.png#clientId=u99096dab-5d58-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=123&amp;id=u90d68d8f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20339&amp;status=done&amp;style=none&amp;taskId=ua7a2c8fd-24f1-479b-b9e4-4bb22b8c84a&amp;title=&amp;width=412.8" alt="image.png"><br><strong>题意</strong><br>每艘船最多坐两人，且不能超过载重。问你让所有人同时过河，并且用最好的分配方法，<br>使船尽量少返回最少的船数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754920033-d23a14f3-997f-4f13-a9f0-7b561f79d2f2.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=u96abc735&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1151&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25fc0b67-d916-4e77-8078-1029b98c178&amp;title=&amp;width=428" alt=""><br><strong>题解</strong><br>你先遍历一遍数组，如果有单独一个人的体重已经超过了limit返回无穷大。<br>多少条船都搞不定的<br><strong>流程</strong><br>先排序<br>从中间分界点开始往左右两边滑</p><p>找&lt;=limit/2最右的位置, 做为L指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919993-2fc7575c-c414-4b7e-a832-5bf0bcb40ff6.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=ufb0881ef&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75a44641-53ce-4de8-8f74-8ac55b102d0&amp;title=&amp;width=446" alt=""><br>R指针: 第一个超过limit/2的位置<br>看L位置和R位置能否凑一个船, 不能, 超了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919953-4a90aa2e-3033-4477-8930-018ff980a464.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u95912d5e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=1102&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue7bf048f-aaa8-4400-803d-9d57b976d24&amp;title=&amp;width=538" alt=""><br>L往左飘, L来到3, 可以<br>先不忙分配船, R往右滑, 一直划到R再往下进一个就没有办法跟 3凑一船为止<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919952-f9d1b099-1792-43c3-931a-0e97bdbaec96.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u65f47ec7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1076&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u854235fa-c1f2-44a8-9746-bc7d404a688&amp;title=&amp;width=522" alt=""><br>贪心的核心点:<br>从3出发往左数6个的这6个，去消化这6个，一定是最省的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754919986-6ed6fbd8-2c1a-41ba-9150-e1e3bb4a60e3.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u93e568a4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=1162&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u91791187-7421-4fec-b6c7-edf0f6db13c&amp;title=&amp;width=445" alt=""><br><strong>例子1: 右侧先耗尽</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921589-39ec9db9-b791-4250-84a0-959f28c10384.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u89cdb406&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1019&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5babd024-fc3f-4e18-897a-c9982047463&amp;title=&amp;width=475" alt=""><br>俩对号装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754921991-8f261b8f-5962-4c73-85b3-f6a17ed90471.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=u2d0e63b4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=558&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08d96e78-dff0-43b7-a5d1-52d57f628ed&amp;title=&amp;width=503" alt=""><br>X号两两可以装一船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922406-6a35f17e-24ef-4b59-92c8-c94d60e2eeaa.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u608ae23c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=548&amp;originWidth=1040&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud57e21a5-c48a-4d3e-a609-646cb20f153&amp;title=&amp;width=439" alt=""><br><strong>例子2: 左侧先耗尽</strong><br>最后对号的数量除2，加上×号的数量除2(向上取整)，加上右侧剩几个数它们一定单独一艘船<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652754922475-c578911c-83dd-4b73-a887-e8c5088bf359.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=198&amp;id=u2c8f3183&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=1191&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua593a755-3782-413c-ab6c-595e375b6c0&amp;title=&amp;width=456" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1654782938733-ff5ae0ad-f593-4836-8ee2-b595c618751a.png#clientId=u514a968e-c04c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=867&amp;id=u98f15db6&amp;margin=%5Bobject%20Object%5D&amp;name=2B163C063CD4521C4323347FAFB38F50.png&amp;originHeight=1518&amp;originWidth=1036&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=511608&amp;status=done&amp;style=none&amp;taskId=uee0c2454-79c7-4464-a51a-0459a5ae855&amp;title=&amp;width=592" alt="2B163C063CD4521C4323347FAFB38F50.png"></p><p>| public static int numRescueBoats(int[] arr, int limit) {<br>   if (arr == null &#124;&#124; arr.length == 0) {<br>      return 0;<br>   }<br>   int N = arr.length;<br>   Arrays.sort(arr);<br>   if (arr[N - 1] &gt; limit) {<br>      return -1;<br>   }<br>   int lessR = -1;<br>   //找到 最左侧里 limit/2最接近的数<br>   for (int i = N - 1; i &gt;= 0; i—) {<br>      if (arr[i] &lt;= (limit / 2)) {<br>         lessR = i;<br>         break;<br>      }<br>   }<br>   if (lessR == -1) {<br>      return N;<br>   }<br>   int L = lessR;<br>   int R = lessR + 1;<br>   int noUsed = 0;<br>   while (L &gt;= 0) {<br>      int solved = 0;//用来更新L下标的<br>      while (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) {<br>         R++;<br>         solved++;<br>      }<br>      //表示上述结束了右边没有一个能和当前的L乘坐<br>      if (solved == 0) {<br>         noUsed++;//左侧未使用的<br>         L—;<br>      } else {<br>         L = Math.max(-1, L - solved);<br>      }<br>   }<br>  //下面的要用具体的例子来换算下标<br>   int leftAll = lessR + 1;//理解的好方法：因为数组是下标0开始的 +1就表示左侧的全部数量<br>   int leftUsed = leftAll - noUsed;//左侧的全部数量-未使用的就是使用的<br>   //右侧还剩下未使用的<br>   int rightUnsolved = (N - all) - used;<br>   return used + ((noUsed + 1) &gt;&gt; 1) + moreUnsolved;<br>} |<br>| —- |</p><h2 id="·-子数组最大累加和"><a href="#·-子数组最大累加和" class="headerlink" title="· 子数组最大累加和"></a>· 子数组最大累加和</h2><p><strong>题解</strong><br>看到子数组子串想想每个位置结尾是答案是什么<br>如果子数组必须以0结尾, 它往左扩到什么程度，能让累加和最大<br>如果子数组必须以1位置结尾, 它往左扩到什么程度，能让累加和最大</p><p><strong>大流程</strong><br><strong>可能性划分</strong><br>必须以i位置结尾答案可能来自什么?<br>1) 完全不向左扩, 只有自己<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677717-e5aafff1-1b52-4e5e-80db-0a14e490e373.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=uea3b3eb0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=389&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u498816dd-5c0d-429b-81ef-e611245e7c0&amp;title=&amp;width=489" alt=""><br>2) 要向左扩， i-1结尾的时候扩出来的最好决定了当前能扩出来的最好<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677743-cc8cf0a5-a0c2-459a-abbe-6d083b658117.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=315&amp;id=ue16cd42f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=863&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89741c3c-0ea1-41a0-8082-0ac2dd610c1&amp;title=&amp;width=559" alt=""><br><strong>例子</strong><br>dp[i]: 必须以i位置的数结尾的时候最好累加和多少<br>dp中的max就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756677733-ba8e98b6-b4cd-4ab5-8570-929835020c5b.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u3525b401&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1029&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udbb81fdc-2585-4a4b-9adb-f55a90e2193&amp;title=&amp;width=470" alt=""><br><strong>代码</strong><br>没有必要准备一整个 BP 有几个变量滚动更新下去就完了<br>因为它只依赖左边的一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756678781-859e8520-7df4-4d2f-887d-9be3467f97b0.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubf36503d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=355&amp;originWidth=788&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u515da530-1d5b-46cd-8343-4404bd2aed8&amp;title=" alt=""></p><h2 id="·-😡子矩阵最大累加和-H"><a href="#·-😡子矩阵最大累加和-H" class="headerlink" title="· 😡子矩阵最大累加和 [H]"></a>· 😡子矩阵最大累加和 [H]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655000610147-a7d3a92b-d3ae-4465-94ce-a8a8d694215c.png#clientId=u7bc39c19-43ea-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=313&amp;id=u0e2403c7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=547&amp;originWidth=1170&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=92137&amp;status=done&amp;style=none&amp;taskId=u927eb0d4-d5e2-468d-8556-18104e0bc5a&amp;title=&amp;width=668.5714285714286" alt="image.png"><br><strong>题解</strong><br>大流程<br>矩形必须包含第0行数据, 且只包含第0行的情况下, 最大累加和是多少?<br>矩形必须包含0,1两行数据, 且只包含0,1两行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2三行数据, 且只包含0,1,2三行的情况下, 最大累加和是多少?<br>矩形必须包含0,1,2,3四行数据, 且只包含0,1,2,3四行的情况下, 最大累加和是多少?<br>….<br>然后<br>1行~1行<br>1行~2行<br>1行~3行<br>1行~4行<br>…<br>然后<br>2行~2行<br>2行~3行<br>2行~4行<br>…<br>然后<br>3行~3行<br>…<br>然后<br>4行~4行<br>如果我们能够每一个都求出来，答案一定在其中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884708-799a0b20-7c1c-47b3-977e-90592414790a.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u0156074e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1078&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7b53efdb-4fdf-4833-8ad0-bd3bc9bb71d&amp;title=&amp;width=432" alt=""><br>如果我们能够每一个都求出来答案一定在其中</p><p>压缩数组技巧<br>0行<br>必须包含第0行数据，且只有第0行情况下画框, 最大累加和多少?<br>就是子数组的最大累加和问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884722-2be04454-65aa-4ab1-bf9a-f9b97da2206c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u4164a828&amp;margin=%5Bobject%20Object%5D&amp;originHeight=429&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud1f9b8e9-8a11-4a1f-9e61-14d37d138b3&amp;title=&amp;width=554" alt=""><br>下面<br>矩形必须包含0, 1两行数据, 且只包含0, 1两行的情况下, 最大累加和是多少?<br>两行上下数据压在一起,形成一个新数组<br>对这个数组求最大累加和就代表必须包含0, 1两行数据，且只包含01两行数据画框的最好答案是啥。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884649-aa42ef84-bb7a-4136-98bb-9fd3691bc443.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ude7883e6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=1075&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2740ec61-35a4-4813-9a55-36c15b2fcb8&amp;title=&amp;width=526" alt=""><br>复杂度O(行^2*列)<br>在行上玩了一个O(行^2)的事<br>0~0<br>0~1<br>…<br>1~1<br>1~2<br>…<br>但你每次解决一个子任务它就是过一遍数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884664-75b98c0a-3eaa-493f-bfb2-184b1e00835a.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=ue4e4a946&amp;margin=%5Bobject%20Object%5D&amp;originHeight=507&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u95e57951-deb2-47df-983f-7072b817740&amp;title=&amp;width=506" alt=""><br>进一步优化: 让行列小的当平方项<br>如果是5行, 100列, 选择让行做平方项<br>如果是100行, 5列, 选择让列做平方项</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652756884772-ba08c36e-d98b-45f2-8291-2432422e914c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=uf99229ea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=496&amp;originWidth=1061&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6a44cb24-c550-46f5-888f-c474dd72d23&amp;title=&amp;width=559" alt=""><br><strong>代码</strong></p><p>| <strong>public static int </strong>maxSum<strong>(int[][] </strong>m<strong>) {<br>   if (</strong>m == <strong>null </strong>&#124;&#124; m.<strong>length </strong>== 0 &#124;&#124; m<strong>[</strong>0<strong>]</strong>.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}   </strong>// O(N^2 <em> M)<br>   <strong>int </strong>N = m.<strong>length</strong>;<br>   <strong>int </strong>M = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {      </strong>// i行~j行<br>      <strong>int[] </strong>s = <strong>new int[</strong>M<strong>]</strong>;<br>      <strong>for (int </strong>j = i; j &lt; N; j++<strong>) {<br>         for (int </strong>k = 0; k &lt; M; k++<strong>) {            </strong>s<strong>[</strong>k<strong>] </strong>+= m<strong>[</strong>j<strong>][</strong>k<strong>]</strong>;<br>         <strong>}         </strong>max = Math.max<strong>(</strong>max, maxSubArray<strong>(</strong>s<strong>))</strong>;<br>      <strong>}<br>   }<br>   return </strong>max;<br>*</em>}</p><p>public static int <strong>maxSubArray</strong>(int[] <strong>arr</strong>) {<br>   if (<strong>arr == </strong>null <strong>&#124;&#124; arr.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   int <strong>max = Integer.</strong>MIN_VALUE<strong>;   </strong>int <strong>cur = 0;   </strong>for (int <strong>i = 0; i &lt; arr.</strong>length<strong>; i++</strong>) {<br>      <strong>cur += arr</strong>[<strong>i</strong>]<strong>;<br>      max = Math.max</strong>(<strong>max, cur</strong>)<strong>;<br>      cur = cur &lt; 0 ? 0 : cur;   </strong>}<br>   return <strong>max;</strong>}** |<br>| —- |</p><p>LeetCode原题<br>需要返回最大累加和矩形的左上角跟右下角点<br>当你发现了更大的答案， 你把它左上角点跟右下角点抓一下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655001837943-7e030c8e-9549-42e0-a28a-31e013cd2d7b.png#clientId=ub6405de6-621a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=530&amp;id=u0049c974&amp;margin=%5Bobject%20Object%5D&amp;name=A19EA1E0AF7663EFCF77985E2517F6F4.png&amp;originHeight=1296&amp;originWidth=1216&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=510166&amp;status=done&amp;style=none&amp;taskId=u1f0706bf-c56b-4e69-9411-9025019afa5&amp;title=&amp;width=497.2857360839844" alt="A19EA1E0AF7663EFCF77985E2517F6F4.png"></p><p>| //返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。<br>// 本题测试链接 : <a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">https://leetcode-cn.com/problems/max-submatrix-lcci/</a><br><strong>public static int[] </strong>getMaxMatrix<strong>(int[][] </strong>m<strong>) {<br>   int </strong>N = m.<strong>length</strong>;<br>   <strong>int </strong>M = m<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>int </strong>cur = 0;<br>   <strong>int </strong>a = 0;<br>   <strong>int </strong>b = 0;<br>   <strong>int </strong>c = 0;<br>   <strong>int </strong>d = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {<br>      int[] </strong>s = <strong>new int[</strong>M<strong>]</strong>;<br>      <strong>for (int </strong>j = i; j &lt; N; j++<strong>) {         </strong>cur = 0;<br>         //记录左上角的列<br>         <strong>int </strong>begin = 0;<br>         /**</p><pre><code>      * [1 1 1 1]      * [0 1 1 2]      * [2 1 0 1]      */     **for (int **k = 0; k &lt; M; k++**) &#123;        **s**[**k**] **+= m**[**j**][**k**]**;        cur += s**[**k**]**;        **if (**max &lt; cur**) &#123;           **max = cur;           a = i;           //主要这一句           b = begin;           //           c = j;           d = k;        **&#125;        **//只有一开始就为负数的情况下，0列        **if (**cur &lt; 0**) &#123;           **cur = 0;           begin = k + 1;        **&#125;     &#125;  &#125;</code></pre><p>   }<br>   return new int[] { <strong>a, b, c, d </strong>}<strong>;</strong>}** |<br>| —- |</p><h2 id="·-135-分糖果问题-H"><a href="#·-135-分糖果问题-H" class="headerlink" title="· 135.分糖果问题 [H]"></a>· 135.分糖果问题 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757640476-f9879a7a-09ff-4b7e-9894-dcc5fb7a88f1.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=294&amp;id=uefc12a68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=368&amp;originWidth=717&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26786&amp;status=done&amp;style=none&amp;taskId=u1a5c1fb5-6fbe-4e76-9b2f-86a45e8de44&amp;title=&amp;width=573.6" alt="image.png"><br><strong>原问题</strong><br>一个数组是所有孩子的得分, 规则是，每个孩子至少一颗糖。相等不管, 只管严格大小关系<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486177-e5f2c5b1-bff0-4a8a-b27f-80ba3eac2b1c.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=u249a86d3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8840862e-eeb8-4455-87ff-fdf3aa4e161&amp;title=&amp;width=504" alt=""><br><strong>题解</strong><br><strong>预处理数组+贪心</strong><br>左边没东西1块糖, 比左边大, 数字就++, 不再大了就返回1, left代表每一个点左边的坡度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486316-27402c6e-a9dd-4a3a-b72e-c09cae8103ee.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u59a65f06&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=1093&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u999c1aa3-b272-4cb8-9003-279e9af6e87&amp;title=&amp;width=499" alt=""><br>右边没东西1块糖, 比右边打了就++, 不再大了就回1<br>每个位置的max就是分糖数量，因为左坡跟右坡以较大坡为准<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757486225-aba65e85-23b1-4233-a76e-2e967ed35bc0.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=ud59977cd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf3423d64-9cb4-4a2c-9e49-352f333674a&amp;title=&amp;width=652" alt=""><br><strong>复杂度</strong><br>时间复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757488676-248c8add-ee09-4fe4-9157-ff396f83324e.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=ued7c1b61&amp;margin=%5Bobject%20Object%5D&amp;originHeight=508&amp;originWidth=913&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u552fabd9-cd94-48a3-bc14-1d1ab0ac4fe&amp;title=&amp;width=479" alt=""><br><strong>最优解</strong><br>我遍历的过程中，我先认为进入到上坡阶段和下坡阶段，我如果能找出一个坡来<br>就是上坡跟下坡共同构成这么一个坡度的话，该怎么分糖我就知道了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489305-1d4f8a25-b3af-43b7-9067-6174a5c50d95.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=180&amp;id=ucfc19315&amp;margin=%5Bobject%20Object%5D&amp;originHeight=329&amp;originWidth=1101&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8812c98d-eef3-4d11-8bbc-cbd7af31d8c&amp;title=&amp;width=603" alt=""><br>对coding要求比较高<br>Coding技巧可以让我找到一组上坡下坡, 等找到的时候, 再回过去给糖</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489355-8a08973f-476c-46d2-8817-37ea96dc2203.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=ua20e6791&amp;margin=%5Bobject%20Object%5D&amp;originHeight=412&amp;originWidth=942&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9aab8328-aca0-4baa-acf8-3a67fc6e1b5&amp;title=&amp;width=646" alt=""><br>没有重复值的例子<br>先遍历一遍找到坡, 然后再回去给糖, 两个坡度较大的那个+1<br>然后处理下个坡<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489655-913e2252-71e6-43df-9f0f-e11e4963f752.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u9023b751&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u293717ff-dce2-472f-a9bc-18f6b77868d&amp;title=&amp;width=525" alt=""><br>要保证两个坡中间同样的那个1不要重复给<br>相当于遍历两遍这个事儿就出来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757489683-68970db3-f71e-47f9-a62e-43d3352f2041.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ud4227d7e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=1016&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u373ac26e-6280-4b9b-9741-d0f405fca4a&amp;title=&amp;width=567" alt=""><br>有相等值就更考验coding<br>相等是无非就是你认为上坡停止下会停止, 更考研Coding技巧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490765-ec269bd1-cd03-4caf-a292-1556e258aaed.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=uf2363b7e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=420&amp;originWidth=751&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1aa1af8b-180e-44d1-adbd-6f02d306b85&amp;title=&amp;width=498" alt=""><br>补充问题<br>相邻孩子分数一样, 糖的数量必须一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490609-1e02392c-0c28-4911-aabe-a0e441adc3b2.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u9114b783&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1041&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u74edf940-9fec-4510-bf50-509068979ff&amp;title=&amp;width=441" alt=""><br><strong>例子</strong><br>生成辅助数组<br>三个原则，第一比左边大就++，<br>第二，跟左边相等就继承, 就是不变，<br>第三比左边小就归1<br>同样方法生成right<br>还是每个位置的值求max</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757490724-1661c665-c1f5-4df8-8d39-1a84b646d746.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ubc071e71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=533&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubd737b23-0203-49bd-9d92-6f6dddc3625&amp;title=&amp;width=492" alt=""><br>可以Coding省掉辅助数组, 更难（idea上有代码）<br>相等认为坡没变<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757491157-d5860f2a-c415-4dba-a996-a2ef506de57f.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=u5b8b35db&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=971&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8911ce37-03e3-4967-8e7d-037c74c385c&amp;title=&amp;width=426" alt=""></p><p>| // 这是原问题的优良解<br>// 时间复杂度O(N)，额外空间复杂度O(N)<br><strong>public static int </strong>candy1<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>int[] </strong>left = <strong>new int[</strong>N<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; N; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i - 1<strong>] </strong>&lt; arr<strong>[</strong>i<strong>]) {         </strong>left<strong>[</strong>i<strong>] </strong>= left<strong>[</strong>i - 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }<br>   int[] </strong>right = <strong>new int[</strong>N<strong>]</strong>;<br>   <strong>for (int </strong>i = N - 2; i &gt;= 0; i—<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&gt; arr<strong>[</strong>i + 1<strong>]) {         </strong>right<strong>[</strong>i<strong>] </strong>= right<strong>[</strong>i + 1<strong>] </strong>+ 1;<br>      <strong>}<br>   }<br>   int </strong>ans = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {      </strong>ans += Math.max<strong>(</strong>left<strong>[</strong>i<strong>]</strong>, right<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   return </strong>ans + N;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-小人过有鳄鱼的河-博弈论"><a href="#·-小人过有鳄鱼的河-博弈论" class="headerlink" title="· 小人过有鳄鱼的河(博弈论)"></a>· 小人过有鳄鱼的河(博弈论)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757912442-ad573f17-7f4a-489a-ad67-3e78f85412e8.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=76&amp;id=uacedcc1b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=95&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17519&amp;status=done&amp;style=none&amp;taskId=u60591a67-ac3f-4cdc-b743-12dc5bc1e43&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题解</strong><br>思路: 从小推到大<br>这个人在一只鳄鱼的时候就过不了河了，<br>两只鳄鱼的时候就可以过河<br>三只鳄鱼等同于一个人两条鳄鱼的时候, 也不能过河, 因为任何一个鳄鱼吃掉人是没风险的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885276-012e6b97-e501-4f4e-be4b-fa012f482633.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=u9ca7460a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=444&amp;originWidth=937&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud1dff254-e3ae-49c7-94e2-2f88822fd1d&amp;title=&amp;width=530" alt=""><br>奇数能过河, 偶数不能过河<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652757885221-16ccb180-9d2a-48a8-bd80-9148fde82953.png#clientId=u126c1856-ca70-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=u2548e3b4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=925&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u299d4d20-2cf8-471b-8a64-0863faf084d&amp;title=&amp;width=457" alt=""></p><h2 id="·-Nim博弈问题"><a href="#·-Nim博弈问题" class="headerlink" title="· Nim博弈问题"></a>· Nim博弈问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800477496-814bb547-f09d-498f-abe5-e2c0e47bb5df.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=79&amp;id=u4fd49066&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=99&amp;originWidth=843&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22068&amp;status=done&amp;style=none&amp;taskId=uc93319c5-ad21-4523-9ae1-dc89387a500&amp;title=&amp;width=674.4" alt="image.png"><br><strong>题意</strong><br>所有的数&gt;=0, 每一轮不管谁都不能拿0<br>谁最先把最后一点数拿完谁赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457877-281d0894-d81e-47d0-987e-47ebb159a8b0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u3d1eed1b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=607&amp;originWidth=1273&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7304e460-0286-465e-aee9-75c63e9b7ec&amp;title=&amp;width=478" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457894-773ef509-f81a-4726-b0ee-d9cf10ef31bd.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=uf044b29a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=468&amp;originWidth=672&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue799c9d7-94cb-4cac-8596-1d6808cdfa8&amp;title=&amp;width=342" alt=""><br>先手跟后手，绝顶聪明，每一个人都充分为所有为自己打算，<br>而且绝对理智，问你，给你一个数组状况返回谁会赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800467223-97b4ba95-223a-4115-827b-edf542fc7b0c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=ud3a77b39&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=734&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue582679d-eb0a-4430-ac2a-50f530a132f&amp;title=&amp;width=410" alt=""><br>先手第一回拿把它拿成两个数都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458021-1b935de2-12bb-47d3-8f26-530ef46b89a0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=281&amp;id=udc3de2b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=515&amp;originWidth=693&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u18bf42a8-f831-4160-8833-13cff2b33f1&amp;title=&amp;width=378" alt=""><br>后手接下来不管拿多少, 先手都让它两个数一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800457964-b74ab48f-bb7e-453a-beb0-160600a24846.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=u85f511af&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u107afaec-9b34-4b96-8fe4-32cb147b4a3&amp;title=&amp;width=418" alt=""><br>这样先手一定会赢<br>这是两个数的规律<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458667-6220c51c-3dd2-47e9-bde9-b5b33c5a54a4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=u163724fc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=862&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufbf57780-7d21-4ca3-8ca3-77502419af6&amp;title=&amp;width=391" alt=""><br><strong>题解</strong><br>由1900年数学家尼姆搞出来一个非常牛逼的解，<br>结论:<br>所有的数异或起来，如果异或和不等于零先手赢，如果异或和等于0后手赢</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458782-28023103-8346-46b2-a8dc-de62f52c13ac.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=u8660b253&amp;margin=%5Bobject%20Object%5D&amp;originHeight=563&amp;originWidth=987&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5dfad24-d8cf-4843-9bf3-a66fb04062c&amp;title=&amp;width=442" alt=""><br>先手的大目标:<br>让后手最先面对所有数组中都是 0 的状态。<br>大目标不知道怎么实现, 转换一下目标</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458900-733597fd-a958-4f2d-bd91-7dee949c8ffa.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=192&amp;id=u50188994&amp;margin=%5Bobject%20Object%5D&amp;originHeight=459&amp;originWidth=1066&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud4ecb940-750d-4418-b3c3-e54b7d7592a&amp;title=&amp;width=446" alt=""></p><p>所有数都异或起来的异或和, 我如果先手能够做到我面对这坨数的异或和它不等于零，<br>但是我拿完之后每一次都让后手面对的异或和等于0，那么最后胜利是先手<br>我们知道最后全 0 的时候异或和是0。所以就这么玩下去，它总有一个时刻全 0 的时候，<br>而我是遇不到的，只会让后手遇到，所以我必胜的大目标被我们变成一个看似更难的目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800458936-68a35d98-dbb4-4fbc-8eb7-a1dd85180307.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=uda72b545&amp;margin=%5Bobject%20Object%5D&amp;originHeight=629&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u505fe591-a3c8-41b2-ab41-bd6884a1f14&amp;title=&amp;width=500" alt=""><br><strong>例子</strong><br>把二进制写出来, 数组7,5,3 整体异或和001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459312-eddefebf-42c9-45db-9b8e-ddbd313e4e16.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=ua7fccb0e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=1310&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud2f98016-c6b9-4d1d-a11e-a52172c1446&amp;title=&amp;width=560" alt=""><br>先手在1这拿一个, 变成6, 更后面的5,3异或和为6的合起来异或和为0<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459424-4f4051be-b558-49e1-90b9-860f4b9f0660.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=230&amp;id=u72048edf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=617&amp;originWidth=1318&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e0608f9-d441-45c1-80f0-19fbc6e06d1&amp;title=&amp;width=491" alt=""><br>后手再拿的时候，他不管在哪个位置上拿哪个数都一定会让异或和从 0 变成不是零，<br>因为他必然会改变某一个位置上一的数量, 改变了它的异或和就不是0，然后先手继续让<br>它异或和变0, 先手必胜.<br>但是这样做的前提是什么?初始的时候异或和得是非零的先手才能这么干，如果先手面<br>对一个一上来就是异或和等于0的状态，后手赢<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459439-1138e3cb-d17b-4fe9-810b-e54a6fc1742f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u2905cd61&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=1307&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2bff4b1-484e-4ee0-9b03-d077dffc405&amp;title=&amp;width=510" alt=""><br>先手不一定在最大值上拿</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800459509-11aaa21d-d569-4be6-9afa-9d6e11b76fa1.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=u5f1b26a9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1179&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3841b959-e751-45bc-9027-7d4efd1ad33&amp;title=&amp;width=507" alt=""><br>就是先手一定能做到一个不是0 异或和的东西变成全零，但不一定是在最大值上拿的，但是他一定能做到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800460027-d4c6583e-9e89-43ce-92f4-10ed5c3be356.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=uc64a46f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1331&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8bef9a58-5ca7-415c-85d2-26b3416a918&amp;title=&amp;width=566" alt=""></p><p>| // 保证arr是正数数组<br><strong>public static void </strong>printWinner<strong>(int[] </strong>arr<strong>) {<br>   int </strong>eor = 0;<br>   <strong>for (int </strong>num : arr<strong>) {      </strong>eor ^= num;<br>   <strong>}<br>   if (</strong>eor == 0<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“后手赢”)</strong>;<br>   <strong>} else {      </strong>System.<strong>out</strong>.println<strong>(“先手赢”)</strong>;<br>   <strong>}<br>}</strong> |<br>| —- |</p><h2 id="·-非负数组中两个数相与的最大结果"><a href="#·-非负数组中两个数相与的最大结果" class="headerlink" title="· 非负数组中两个数相与的最大结果"></a>· 非负数组中两个数相与的最大结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650113590488-8110c2b9-7a47-41d5-a42b-f0a7399ead91.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=u485e8bbb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=394&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15539&amp;status=done&amp;style=none&amp;taskId=u122a7d6b-ae77-4da4-8b41-ac244820e50&amp;title=&amp;width=315.2" alt="image.png"><br><strong>题解</strong><br>可以用前缀树, 额外空间比较大, 存在更好的解法<br>思路: 高位尽量变1<br>因为我如果选一些数让30位变成0，它就不如30位变成1的值大</p><p>先遍历一遍所有的数字, 只考察30位是1的有几个, 分情况<br>1) 小于两个<br>这说明最终的结果30位上肯定不是1，因为你小于两个就不存在任何两个数，两个两个数与玩之后第30位是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800811891-1b46d42a-fe12-4196-af17-9775c90ea3a4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u164ba3a7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=500&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf326dddf-1871-4357-abfd-fc5d79a368e&amp;title=&amp;width=518" alt=""><br>2) 正好有两个数， 就是这两个数与完的结果最大， 直接返回就行<br>3） 大于两个数<br>那我就把这100个数淘汰掉，剩下的我只留这23个数，我再去看第29位</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812084-94f090b2-a658-437e-8dc0-a7931e7bc517.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u2d559d95&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1108&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub142840c-3848-4aa9-ae7d-5317a77cf57&amp;title=&amp;width=549" alt=""><br>假设目前这一批数还剩20个， 来到第i位<br>第i位上有1的数：<br>1） <2个2） =2个3） > 2个</p><p>我们遍历一遍整个数组，如果有第i位上有1的数，<br>第1种情况小于两个，那么这20个数一个也不淘汰，你接下来去看a减，<br>第2种情况如果这20个数中第i位上1的只有两个数，你不用再看，就这两个是结果<br>第3种情况如果大约在在地在第i位上有1的数是大于两个的，比如说他有7个，那么删掉剩余的13个，只留这7个数去搞安检一位不就玩儿去了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812139-21391412-9c69-4642-866d-d3f960d20bc7.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=ucefcac7f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=554&amp;originWidth=1083&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54468d3d-1d2f-4ae3-b207-9d23095f3ba&amp;title=&amp;width=504" alt=""><br><strong>时间复杂度</strong><br>30位遍历一遍数组， 29位遍历一遍数组…<br>一共遍历32遍数组, O(32N)</p><p><strong>空间复杂度怎么计算</strong><br>如果删到只剩下6个数, 17位的时候<br>保留数字这件事情, 在原数组上操作, 原数组末尾做垃圾区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812121-214352ae-98c3-4159-91d0-39878e511b6c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u73578c17&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=833&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue4361ff8-1204-42b3-9953-9cab2cc1866&amp;title=" alt=""><br><strong>代码</strong><br>垃圾区</p><p>&lt;2个, 一个数也不淘汰, 让M跳回去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812117-fb4a8866-f4ce-4796-9d6f-e723dcabb358.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u3dfa6e88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=895&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud964a6ce-61a5-49cc-bd8b-f81d3549e57&amp;title=&amp;width=483" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652800812536-2890f02a-970d-48af-90d3-2e5b41d3edb8.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0869c0ec&amp;margin=%5Bobject%20Object%5D&amp;originHeight=516&amp;originWidth=575&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u146e66a2-ea4d-4abe-92ce-6d990b399e2&amp;title=" alt=""></p><p>| <strong>public static int </strong>maxAndValue2<strong>(int[] </strong>arr<strong>) {   </strong>// arr[0…M-1]  arr[M….]<br>   <strong>int </strong>M = arr.<strong>length</strong>;<br>   <strong>int </strong>ans = 0;<br>   <strong>for (int </strong>bit = 30; bit &gt;= 0; bit—<strong>) {      </strong>// arr[0…M-1] arr[M…]<br>      <strong>int </strong>i = 0;<br>      <strong>int </strong>tmp = M;//有可能跳回去<br>      <strong>while (</strong>i &lt; M<strong>) { </strong>// arr[0…M-1]<br>         <strong>if ((</strong>arr<strong>[</strong>i<strong>] </strong>&amp; <strong>(</strong>1 &lt;&lt; bit<strong>)) </strong>== 0<strong>) {            </strong>swap<strong>(</strong>arr, i, —M<strong>)</strong>;<br>         <strong>} else {            </strong>i++;<br>         <strong>}<br>      }<br>      if (</strong>M == 2<strong>) { </strong>// arr[0,1]<br>         <strong>return </strong>arr<strong>[</strong>0<strong>] </strong>&amp; arr<strong>[</strong>1<strong>]</strong>;<br>      <strong>}      </strong>//==<br>      <strong>if (</strong>M &lt; 2<strong>) {</strong>//当前bit为无法得到1，M跳回原来位置，一个数也不删<strong>**         </strong>M = tmp;<br>      <strong>} else { </strong>// &gt; 2个数  bit位上有1<br>         ans &#124;= <strong>(</strong>1 &lt;&lt; bit<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>ans;<br>**}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-✊括号嵌套系列问题"><a href="#·-✊括号嵌套系列问题" class="headerlink" title="· ✊括号嵌套系列问题"></a>· ✊括号嵌套系列问题</h2><h3 id="①计算str表达式结果"><a href="#①计算str表达式结果" class="headerlink" title="①计算str表达式结果"></a>①计算str表达式结果</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650098950782-2396606a-0bbb-4b55-9cb6-f263b9578ad9.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=uaeee7735&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49751&amp;status=done&amp;style=none&amp;taskId=u4b5b7ea1-393b-431b-8ac2-e4790d56699&amp;title=&amp;width=679.2" alt="image.png"><br><strong>题意</strong><br>负数作为公式的开头 或括号部分的开头，可以没有括号<br><strong>题解</strong><br>先处理没有小括号的情况</p><p>指针从零开始就有两种情况:</p><ol><li>当前压中的是数字</li><li>当前压中的是符号<br>准备一个栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569314-732407d5-15f9-4a7e-955b-af2e37ff100f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u1a923818&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=1096&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc508edf6-c054-45e5-b769-4791d54b022&amp;title=&amp;width=505" alt=""><br>压中运算符号, 当初过数字阶段结束了, 找到了34<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569315-adc8cd07-34b4-4302-9e41-3b97c55765fb.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=uce5b21e3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=493&amp;originWidth=1115&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua15fcfcf-0634-4317-b4a3-83765138bda&amp;title=&amp;width=536" alt=""><br><strong>1, * </strong>入栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569327-d3093cd3-afae-4027-a13c-21a795ed98e4.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u8b5cb035&amp;margin=%5Bobject%20Object%5D&amp;originHeight=477&amp;originWidth=1104&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0f70762-e91b-40e6-ad16-29f364c33ce&amp;title=&amp;width=567" alt=""><br>栈顶乘除, 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569326-10c63ce7-1bb7-4088-b202-5669ddcfa1ce.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ud0ca380b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=1116&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u19d8bda1-3868-4505-8ef6-06decfae122&amp;title=" alt=""><br>栈顶 / 计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802569330-71ccfd20-9804-4216-a208-53f5b5d350c1.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=uaea7846f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=507&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69bde130-2897-4078-9dfd-67844659fef&amp;title=&amp;width=570" alt=""><br>最后位置， 7 入栈， 栈里只有+-符号了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802570274-71211b4b-b360-454e-af84-04dd0cae9fc3.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=264&amp;id=ub7bce47c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1112&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8191caa6-71ac-442a-8cc3-02e1fd3d0ff&amp;title=&amp;width=558" alt=""><br>定义递归函数f<br>int[] f(int i)<br>从i位置出发, 遇到右括号或者整个字符串终止位置停止， 返回两个值</li></ol><ul><li><ol><li>answer</li></ol></li><li><ol><li>F函数算到哪个位置了</li></ol></li></ul><p>条件情况：<br>①遇到数字</p><ul><li>设置cur</li></ul><p>②遇到运算符，结合cur加入到队列中<br>③遇到左括号就交给递归去搞，递归返回两个值</p><ul><li><ol><li>answer</li></ol></li><li><ol><li>F函数算到哪个位置了</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127597996-d7be7b6e-c490-4bea-bd31-166716737d7e.png#clientId=u7251bedd-719d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=504&amp;id=u8c22e28e&amp;margin=%5Bobject%20Object%5D&amp;name=B03D96AEEDFC16F1164F383A3C4FA837.png&amp;originHeight=1081&amp;originWidth=1739&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=456166&amp;status=done&amp;style=none&amp;taskId=u8a1e2898-b1b8-4344-a8d0-08c331b7bf2&amp;title=&amp;width=811.0000610351562" alt="B03D96AEEDFC16F1164F383A3C4FA837.png"></p><p><strong>例子2</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802571970-a1640f24-2c37-483d-b77a-efbb1b989559.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=ua50d068b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=445&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u99525ff6-64ba-48bf-b068-cce57175db3&amp;title=&amp;width=506" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572172-4a4912ea-4cde-4445-8205-a79369f2c4ca.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=187&amp;id=u81b31c60&amp;margin=%5Bobject%20Object%5D&amp;originHeight=416&amp;originWidth=1109&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf9fcaa9a-38b5-4adf-97e8-c0b34eab9cd&amp;title=&amp;width=498" alt=""><br>遇到左括号了就调递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572369-f6d4f508-2cf3-4096-944a-dd73f55c5d87.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u0ecc431b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=1103&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub543cc02-862d-4386-ac2e-09562639620&amp;title=&amp;width=546" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572690-1f71ba4c-d5a1-4bca-b4b9-84e14c4ec028.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u1ef6c4e6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=1112&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u81b410fe-4bce-4b03-ae45-37ae4dc0511&amp;title=&amp;width=543" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802572941-2ab03421-1f4d-4d27-89e2-904c73ddb9d8.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u5a645239&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=1105&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u43dfc911-4281-454a-8e5d-0e49de897e6&amp;title=&amp;width=515" alt=""><br>压缩数组例子<br>只要是括号嵌套的都这玩意儿。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573019-d4ab5767-707d-4c9e-b387-12602d4bcdc0.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=206&amp;id=u794d34bb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=388&amp;originWidth=940&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u011e5f47-e7bf-4aeb-9bb3-746df83d1bb&amp;title=&amp;width=498" alt=""><br>开头为负怎么计算<br>一上来碰到-号, 0, -, 压栈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573351-066ab599-0ef9-4c1a-9f56-c63f6a74181f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=u36ef568b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=464&amp;originWidth=1184&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud82d0514-6263-41c7-b9d5-faaef151f10&amp;title=&amp;width=485" alt=""><br><strong>代码</strong><br>最后一个数字还没入栈， 放进去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802573451-a23baef1-630a-43f3-89a6-cd2766a53edd.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=312&amp;id=u878bd00f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=483&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0b6eb0c-a03c-4a1a-8d42-f425afa6344&amp;title=&amp;width=582" alt=""><br>这种方法一定要牢牢掌握，因为任何括号嵌套的题都可以这么改</p><p>| <strong>public static int[] </strong>f<strong>(char[] </strong>str, <strong>int </strong>i<strong>) {   </strong>LinkedList<strong>&lt;</strong>String<strong>&gt; </strong>que = <strong>new </strong>LinkedList<strong>&lt;</strong>String<strong>&gt;()</strong>;<br>   <strong>int </strong>cur = 0;<br>   <strong>int[] </strong>bra = <strong>null</strong>;<br>   // 从i出发，开始撸串<br>   <strong>while (</strong>i &lt; str.<strong>length </strong>&amp;&amp; str<strong>[</strong>i<strong>] </strong>!= <strong>‘)’) {<br>      if (</strong>str<strong>[</strong>i<strong>] </strong>&gt;= <strong>‘0’ </strong>&amp;&amp; str<strong>[</strong>i<strong>] </strong>&lt;= <strong>‘9’) {         </strong>cur = cur <em> 10 + str<strong>[</strong>i++<strong>] </strong>- <strong>‘0’</strong>;<br>      <strong>} else if (</strong>str<strong>[</strong>i<strong>] </strong>!= <strong>‘(‘) { </strong>// 遇到的是运算符号<br>         addNum<strong>(</strong>que, cur<strong>)</strong>;//比如队列中此时有 1 +   cur = 2  来到+ 放入 2 +<br>         que.addLast<strong>(</strong>String.valueOf<strong>(</strong>str<strong>[</strong>i++<strong>]))</strong>;<br>         cur = 0;<br>      <strong>} else { </strong>// 遇到左括号了<br>         bra = f<strong>(</strong>str, i + 1<strong>)</strong>;<br>         cur = bra<strong>[</strong>0<strong>]</strong>;<br>         i = bra<strong>[</strong>1<strong>] </strong>+ 1;<br>      <strong>}<br>   }   </strong>//注意！要结束了，把最后一个数字放进去<br>   addNum<strong>(</strong>que, cur<strong>)</strong>;<br>   <strong>return new int[] { </strong>getNum<strong>(</strong>que<strong>)</strong>, i <strong>}</strong>;<br>*</em>}</p><p>public static void <strong>addNum</strong>(<strong>LinkedList</strong>&lt;<strong>String</strong>&gt; <strong>que, </strong>int <strong>num</strong>) {<br>   if (<strong>!que.isEmpty</strong>()) {<br>      int <strong>cur = 0;<br>      String top = que.pollLast</strong>()<strong>;      </strong>if (<strong>top.equals</strong>(“+”) <strong>&#124;&#124; top.equals</strong>(“-“)) {<br>         <strong>que.addLast</strong>(<strong>top</strong>)<strong>;      </strong>} else {<br>         <strong>cur = Integer.valueOf</strong>(<strong>que.pollLast</strong>())<strong>;<br>         num = top.equals</strong>(“<em>“) <strong>? </strong>(**cur </em> num<strong>) </strong>: <strong>(</strong>cur / num<strong>)</strong>;<br>      <strong>}<br>   }   </strong>que.addLast<strong>(</strong>String.valueOf<strong>(</strong>num<strong>))</strong>;<br><strong>}</strong><br><strong>public static int </strong>getNum<strong>(</strong>LinkedList<strong>&lt;</strong>String<strong>&gt; </strong>que<strong>) {<br>   int </strong>res = 0;<br>   <strong>boolean </strong>add = <strong>true</strong>;<br>   String cur = <strong>null</strong>;<br>   <strong>int </strong>num = 0;<br>   <strong>while (</strong>!que.isEmpty<strong>()) {      </strong>cur = que.pollFirst<strong>()</strong>;<br>      <strong>if (</strong>cur.equals<strong>(“+”)) {         </strong>add = <strong>true</strong>;<br>      <strong>} else if (</strong>cur.equals<strong>(“-“)) {         </strong>add = <strong>false</strong>;<br>      <strong>} else {         </strong>num = Integer.valueOf<strong>(</strong>cur<strong>)</strong>;<br>         res += add ? num : <strong>(</strong>-num<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>res;<br><strong>}</strong> |<br>| —- |</p><h3 id="②字符串解码"><a href="#②字符串解码" class="headerlink" title="②字符串解码"></a>②字符串解码</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655127913238-063d6a0a-b032-4ca8-89e2-5dc17f30d0be.png#clientId=u7251bedd-719d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u2e367064&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=365&amp;originWidth=771&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22499&amp;status=done&amp;style=none&amp;taskId=u6402f452-c01d-4576-b24d-7d027b199f9&amp;title=&amp;width=440.57142857142856" alt="image.png"></p><p>| <strong>public static </strong>String calculate(String str) {<br>        <strong>return </strong>f(str.toCharArray(), 0)[0];<br>    }</p><pre><code>**public static **String[] f(**char**[] str, **int **i) &#123;    String ans = **&quot;&quot;**;    **int **cur = 0;    // 从i出发，开始撸串    **while **(i &lt; str.**length **&amp;&amp; str[i] != **&#39;]&#39;**) &#123;        //遇到数字        **if **(str[i] &gt;= **&#39;0&#39; **&amp;&amp; str[i] &lt;= **&#39;9&#39;**) &#123;            cur = cur * 10 + str[i++] - **&#39;0&#39;**;        &#125; **else if **(str[i] &gt;= **&#39;a&#39; **&amp;&amp; str[i] &lt;= **&#39;z&#39;**) &#123; //            ans += str[i++];        &#125; **else **&#123; // 遇到左括号了            String[] f = f(str, i + 1);            **for **(**int **j = 0; j &lt; cur; j++) &#123;                ans += f[0];            &#125;            cur = 0;            i = Integer.valueOf(f[1]);            i++;        &#125;    &#125;    **return new **String[] &#123; ans, String.valueOf(i) &#125;;&#125; |</code></pre><p>| —- |</p><h3 id="③❓原子的数量"><a href="#③❓原子的数量" class="headerlink" title="③❓原子的数量"></a>③❓原子的数量</h3><p><strong>扩展：计算括号字符串的分数</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650109458205-b1b14786-40bd-4f1c-bfa1-9a055b24847d.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=uabd6313c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=260&amp;originWidth=711&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36399&amp;status=done&amp;style=none&amp;taskId=u2890ec75-3800-40a2-aabe-f170319bf19&amp;title=&amp;width=568.8" alt="image.png"><br>记住代码，比较难理解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650110035627-385b43a8-6afc-437b-bb16-74508df9d7f8.png#clientId=u0ec617b1-5e20-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u52f0ac7e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=380&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=111603&amp;status=done&amp;style=none&amp;taskId=uc24e086b-659c-49f0-b945-4a1fb06b24d&amp;title=&amp;width=304" alt="image.png"></p><h2 id="·-盛最多水的容器"><a href="#·-盛最多水的容器" class="headerlink" title="· 盛最多水的容器"></a>· 盛最多水的容器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652803229358-74a054ba-5506-4cb4-888f-08fb6bd8faed.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=339&amp;id=uab3100b9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=609&amp;originWidth=926&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40053&amp;status=done&amp;style=none&amp;taskId=u5e22d377-cb6c-42c5-a11e-f25dd5bf093&amp;title=&amp;width=514.7999877929688" alt="image.png"><br><strong>题解</strong><br>先假设无重复值, 左右两个指针<br>左边跟右边比大小， 谁小结算谁的水量<br>两个左右两个指针依次划的过程中算出所有水量的最大值就是答案</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603322-564cdac1-d9b0-46b5-ae4f-e90597069858.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=ue0abe2ca&amp;margin=%5Bobject%20Object%5D&amp;originHeight=526&amp;originWidth=1044&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u56957f64-7d7b-4946-9167-ea72d58d406&amp;title=&amp;width=462" alt=""><br>而事实上3可以继续往右扩大，那我为什么不求出唯一的正确答案，<br>只求3~8这一段的答案呢，这是因为a的答案包含这一段，所以我只关注会不会有把答案推高的可能性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603354-4d6989ad-b2b5-4a05-8c69-6f7008972fd5.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=uf256ec8f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=441&amp;originWidth=1019&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uba4cb029-1101-4abf-a81a-be756f71cbe&amp;title=&amp;width=496" alt=""><br>它不是严格要求每一个数都能够准确的算出来它的答案, 它只关心有没有推高答案的可能性<br>为啥你不知道这道题怎么做?<br>但是你看数据量，你就知道自己一定会憋出一个O(N)的解，<br>那势必可能会想到双指针，谁大移动谁跟谁小移动谁都试一遍这题就出来了，不用知道为什么有可能都能猜出来<br>复杂度O(N)<br>我不去严格纠结到底这个值他真实的最优解是什么，我只纠结会不会让答案变大<br>ref： 数组三连第三连<br><strong>例子</strong><br>只关注它推高答案的可能性，但是我们不去严格纠结每一个位置的值，它具体答案是多少<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603343-312db809-99e8-414c-a228-7fc6ae108e0c.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=200&amp;id=u90840346&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=928&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u82dc8d2e-0c79-4da0-9b9b-729957c3535&amp;title=&amp;width=419" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603345-91268f80-07fa-46fd-9be0-2ac568756483.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u9a46939d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2229fb65-1462-44d2-a2f2-ad111e6093d&amp;title=&amp;width=475" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652802603340-dff504be-50d9-4110-bde8-60d0eaa86e2f.png#clientId=u11627af4-eb4e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u5153fc20&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1094&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u54178eed-544a-423b-9a03-b4e0b59ea95&amp;title=&amp;width=488" alt=""></p><p>| <strong>public static int </strong>maxArea1<strong>(int[] </strong>h<strong>) {<br>   int </strong>max = 0;<br>   <strong>int </strong>N = h.<strong>length</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) { </strong>// h[i]<br>      <strong>for (int </strong>j = i + 1; j &lt; N; j++<strong>) { </strong>// h[j]<br>         max = Math.max<strong>(</strong>max, Math.min<strong>(</strong>h<strong>[</strong>i<strong>]</strong>, h<strong>[</strong>j<strong>]) *</strong> <strong>(</strong>j - i<strong>))</strong>;<br>      <strong>}<br>   }<br>   return </strong>max;<br>**}</p><p>public static int <strong>maxArea2</strong>(int[] <strong>h</strong>) {<br>   int <strong>max = 0;   </strong>int <strong>l = 0;   </strong>int <strong>r = h.</strong>length <strong>- 1;   </strong>while (<strong>l &lt; r</strong>) {<br>      <strong>max = Math.max</strong>(<strong>max, Math.min</strong>(<strong>h</strong>[<strong>l</strong>]<strong>, h</strong>[<strong>r</strong>]) <strong>* </strong>(<strong>r - l</strong>))<strong>;      </strong>if (<strong>h</strong>[<strong>l</strong>] <strong>&gt; h</strong>[<strong>r</strong>]) {<br>         <strong>r—;      </strong>} else {<br>         <strong>l++;      </strong>}<br>   }<br>   return <strong>max;</strong>}** |<br>| —- |</p><h2 id="·-多个有序list中的top-100-大"><a href="#·-多个有序list中的top-100-大" class="headerlink" title="· 多个有序list中的top 100 大"></a>· 多个有序list中的top 100 大</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882236750-67c0af3e-05fa-4bed-98b7-fcf80e36b74c.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=30&amp;id=ufd509bb4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=38&amp;originWidth=637&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7392&amp;status=done&amp;style=none&amp;taskId=uef743611-362e-49ac-b624-c0c7dc58095&amp;title=&amp;width=509.6" alt="image.png"><br>大根堆<br>先把链表逆序<br>所有头部拿出来组成一个大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882248310-fbb2aa87-caa0-422c-a083-a8713a7d4694.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=u5395c82a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=618&amp;originWidth=1291&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u437d1bae-2ae6-40d8-a1af-96d46908e56&amp;title=&amp;width=624" alt=""></p><h2 id="·-跳跃游戏Ⅱ"><a href="#·-跳跃游戏Ⅱ" class="headerlink" title="· 跳跃游戏Ⅱ"></a>· 跳跃游戏Ⅱ</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650029478423-12a50e13-5642-45ad-9e9e-04f762f5b727.png#clientId=u98aeb21b-e583-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=u7efc409b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=666&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=37693&amp;status=done&amp;style=none&amp;taskId=u765ebde4-b464-4164-bf78-e8a292676f9&amp;title=&amp;width=532.8" alt="image.png"><br><strong>题意</strong><br>存在一个选择<br>如果尽着最大步数跳他可能得不到最优解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305648-957d0562-d157-4d3d-ae6c-fc146f1a4502.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=u7daad865&amp;margin=%5Bobject%20Object%5D&amp;originHeight=510&amp;originWidth=1237&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3f318203-80a6-4650-85bf-4d1f226ff95&amp;title=&amp;width=609" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305602-7f9f8032-223f-476c-b74f-d76bef9d32ac.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=210&amp;id=u21788ad8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1216&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufb841da7-04af-4c5b-907e-0212ae690a1&amp;title=&amp;width=524" alt=""><br>用贪心, 老紧着最大步数跳是不对的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882305681-d01ab949-c241-4243-bac5-4c66c124efae.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=uc2a1cfe5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1252&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u926d9fc0-6e2a-4122-a843-128c9c2436c&amp;title=&amp;width=521" alt=""><br><strong>题解</strong><br>流程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655211162287-fd0710b0-b985-4a90-bfed-0abe223715f1.png#clientId=u83bd60c9-5fa5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=812&amp;id=u6a026509&amp;margin=%5Bobject%20Object%5D&amp;name=41D4CCD93F04922A9F2D17AA467437A5.png&amp;originHeight=1421&amp;originWidth=1232&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=417915&amp;status=done&amp;style=none&amp;taskId=u26adf01b-d2c7-4f51-8d3d-1813a4c2bf8&amp;title=&amp;width=704" alt="41D4CCD93F04922A9F2D17AA467437A5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882306957-1850e9b7-de8b-4a4a-adea-eb2cfffcc9eb.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=ufbe8fdc9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=579&amp;originWidth=1043&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc564cc66-4380-40a6-a766-66d63c6b832&amp;title=&amp;width=509" alt=""><br>反例<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307533-6f1f96c5-ad80-4f9e-9ab2-54da1412c258.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=uc54b612f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=1132&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3debd364-ff69-4b03-b637-3746408f53d&amp;title=&amp;width=507" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882307672-7a9a40e1-5757-4e56-8392-55c6b983411e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u9fe696a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=434&amp;originWidth=797&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u381a4f25-cc9a-4da0-94f2-80b9ae28f16&amp;title=&amp;width=428" alt=""><br><strong>代码</strong></p><p>| <strong>public static int </strong>jump<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>step = 0;//目前位置跳了几步<br>   <strong>int </strong>cur = 0;//如果你不增加步数，step以内，你最远能到哪儿<br>   <strong>int </strong>next = 0;//如果允许我多跳一步，请问我最远的到哪儿<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652882687455-34de4ef7-d45e-4515-8847-2cdd7261f16a.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=141&amp;id=u998e7fdc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=219&amp;originWidth=456&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15857&amp;status=done&amp;style=none&amp;taskId=uf377eb45-a694-43de-80a6-f4277e28737&amp;title=&amp;width=292.8000183105469" alt="image.png"><strong>**      if (</strong>cur &lt; i<strong>) {         </strong>step++;<br>         cur = next;<br>      <strong>}      </strong>next = Math.max<strong>(</strong>next, i + arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   return </strong>step;<br><strong>}</strong> |<br>| —- |</p><h2 id="·✊在两个都有序的数组找整体第k小的数"><a href="#·✊在两个都有序的数组找整体第k小的数" class="headerlink" title="·✊在两个都有序的数组找整体第k小的数"></a><strong>·✊在两个都有序的数组找整体第k小的数</strong></h2><h3 id="①算法模型：在两个都有序的数组中找上中位数"><a href="#①算法模型：在两个都有序的数组中找上中位数" class="headerlink" title="①算法模型：在两个都有序的数组中找上中位数"></a>①算法模型：在两个都有序的数组中找上中位数</h3><p><strong>题意</strong><br>O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884443226-1de0ecb3-1471-4e81-899c-0e32b5ca4a66.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ub50901c6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=567&amp;originWidth=891&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua642aa49-06f2-439b-a489-64f4f71a01d&amp;title=&amp;width=426" alt=""><br><strong>题解</strong><br>分情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655299291411-6ecd16bb-340f-4d93-9539-e4bb4a986a8a.png#clientId=u02685321-15d8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1841&amp;id=uf949730e&amp;margin=%5Bobject%20Object%5D&amp;name=7A99CC63E8320AA8102F6ACA846A0A14.png&amp;originHeight=3222&amp;originWidth=1849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1850552&amp;status=done&amp;style=none&amp;taskId=ucde9adac-f3e4-459e-a56d-0b19154fa4c&amp;title=&amp;width=1056.5714285714287" alt="7A99CC63E8320AA8102F6ACA846A0A14.png"><br><strong>代码</strong></p><p>| <strong>public static int </strong>getUpMedian<strong>(int[] </strong>A, <strong>int </strong>s1, <strong>int </strong>e1, <strong>int[] </strong>B, <strong>int </strong>s2, <strong>int </strong>e2<strong>) {<br>   int </strong>mid1 = 0;<br>   <strong>int </strong>mid2 = 0;<br>   <strong>while (</strong>s1 &lt; e1<strong>) {      </strong>// mid1 = s1 + (e1 - s1) &gt;&gt; 1<br>      mid1 = <strong>(</strong>s1 + e1<strong>) </strong>/ 2;<br>      mid2 = <strong>(</strong>s2 + e2<strong>) </strong>/ 2;<br>      <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>== B<strong>[</strong>mid2<strong>]) {<br>         return </strong>A<strong>[</strong>mid1<strong>]</strong>;<br>      <strong>}      </strong>// 两个中点一定不等！<br>      //e1 - s1 + 1就是个数 奇数&amp;1 == 1<br>      <strong>if (((</strong>e1 - s1 + 1<strong>) </strong>&amp; 1<strong>) </strong>== 1<strong>) { </strong>// 奇数长度<br>         //一定要对着例子<br>         <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt; B<strong>[</strong>mid2<strong>]) {<br>            if (</strong>B<strong>[</strong>mid2<strong>] </strong>&gt;= A<strong>[</strong>mid1 - 1<strong>]) {<br>               return </strong>B<strong>[</strong>mid2<strong>]</strong>;<br>            <strong>}            </strong>e1 = mid1 - 1;<br>            s2 = mid2 + 1;<br>         <strong>} else { </strong>// A[mid1] &lt; B[mid2]<br>            <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt;= B<strong>[</strong>mid2 - 1<strong>]) {<br>               return </strong>A<strong>[</strong>mid1<strong>]</strong>;<br>            <strong>}            </strong>e2 = mid2 - 1;<br>            s1 = mid1 + 1;<br>         <strong>}<br>      } else { </strong>// 偶数长度<br>         <strong>if (</strong>A<strong>[</strong>mid1<strong>] </strong>&gt; B<strong>[</strong>mid2<strong>]) {            </strong>e1 = mid1;<br>            s2 = mid2 + 1;<br>         <strong>} else {            </strong>e2 = mid2;<br>            s1 = mid1 + 1;<br>         <strong>}<br>      }<br>   }<br>   return </strong>Math.min<strong>(</strong>A<strong>[</strong>s1<strong>]</strong>, B<strong>[</strong>s2<strong>])</strong>;<br><strong>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>每一次比价砍一半, 二分, O(logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652884449524-c998a42f-d576-4006-9cf1-9c30739af9d7.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=342&amp;id=Dep6S&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=945&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25c8aeb9-2c09-4667-9058-e9474a70a88&amp;title=&amp;width=517" alt=""></p><h3 id="②进阶：在两个都有序的数组找整体第k小的数"><a href="#②进阶：在两个都有序的数组找整体第k小的数" class="headerlink" title="②进阶：在两个都有序的数组找整体第k小的数"></a><strong>②进阶：在两个都有序的数组找整体第k小的数</strong></h3><p><strong>例子：arr1 17个 arr2 10个</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655300515983-61e193b4-7e6a-4b2e-8067-4cd547c49684.png#clientId=u02685321-15d8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1109&amp;id=uc06c0ab8&amp;margin=%5Bobject%20Object%5D&amp;name=ACE1391B1036C5CD896CD36C7A4E1AF8.png&amp;originHeight=1941&amp;originWidth=2212&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1248551&amp;status=done&amp;style=none&amp;taskId=u7e89ae7d-1de4-45b4-a7ae-d3b2e6a1f95&amp;title=&amp;width=1264" alt="ACE1391B1036C5CD896CD36C7A4E1AF8.png"></p><p>| // 进阶问题 : 在两个都有序的数组中，找整体第K小的数<br>// 可以做到O(log(Min(M,N)))<br><strong>public static int </strong>findKthNum<strong>(int[] </strong>arr1, <strong>int[] </strong>arr2, <strong>int </strong>kth<strong>) {<br>   int[] </strong>longs = arr1.<strong>length </strong>&gt;= arr2.<strong>length </strong>? arr1 : arr2;<br>   <strong>int[] </strong>shorts = arr1.<strong>length </strong>&lt; arr2.<strong>length </strong>? arr1 : arr2;<br>   <strong>int </strong>l = longs.<strong>length</strong>;<br>   <strong>int </strong>s = shorts.<strong>length</strong>;<br>   <strong>if (</strong>kth &lt;= s<strong>) { </strong>// 1)<br>      <strong>return </strong>getUpMedian<strong>(</strong>shorts, 0, kth - 1, longs, 0, kth - 1<strong>)</strong>;<br>   <strong>}<br>   if (</strong>kth &gt; l<strong>) { </strong>// 3)  对着例子【例子太重要了，具象化的代码改为抽象化就可以了】看代码就懂了  贴图过来非常简单！<br>      <strong>if (</strong>shorts<strong>[</strong>kth - l - 1<strong>] </strong>&gt;= longs<strong>[</strong>l - 1<strong>]) {<br>         return </strong>shorts<strong>[</strong>kth - l - 1<strong>]</strong>;<br>      <strong>}<br>      if (</strong>longs<strong>[</strong>kth - s - 1<strong>] </strong>&gt;= shorts<strong>[</strong>s - 1<strong>]) {<br>         return </strong>longs<strong>[</strong>kth - s - 1<strong>]</strong>;<br>      <strong>}<br>      return </strong>getUpMedian<strong>(</strong>shorts, kth - l, s - 1, longs, kth - s, l - 1<strong>)</strong>;<br>   <strong>}</strong><br><strong>**   </strong>// 2)  s &lt; k &lt;= l<br>   <strong>if (</strong>longs<strong>[</strong>kth - s - 1<strong>] </strong>&gt;= shorts<strong>[</strong>s - 1<strong>]) {<br>      return </strong>longs<strong>[</strong>kth - s - 1<strong>]</strong>;<br>   <strong>}<br>   return </strong>getUpMedian<strong>(</strong>shorts, 0, s - 1, longs, kth - s, kth - 1<strong>)</strong>;<br><strong>}</strong> |<br>| —- |</p><h3 id="·-394-字符串解码-M"><a href="#·-394-字符串解码-M" class="headerlink" title="· 394. 字符串解码 [M]"></a>· 394. 字符串解码 [M]</h3><p><strong>题意</strong><br>字符串还原成全是小写字母<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500821-75a18c69-29c4-4b24-b7e5-887be3cb6749.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=ucd62da43&amp;margin=%5Bobject%20Object%5D&amp;originHeight=596&amp;originWidth=1175&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u468d9297-5ca7-472c-88dc-6d62e3ef096&amp;title=&amp;width=488" alt=""><br>原始串只有a~z<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500842-3195e513-118a-4630-af49-7b8ed4406f4d.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=uf17c79f4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u987e1af2-77b6-46ca-b800-4512ab05154&amp;title=&amp;width=364" alt=""><br><strong>题解</strong><br>定义递归函数:</p><ol><li>返回结果字符串</li><li>处理到的位置</li></ol><p>从压缩串str i位置往后转换, 遇到]或者压缩串结尾停止, 停的时候, 从i…停这段返回, 并返回计算到的位置</p><p>所有的嵌套结构可以用这个递归结构求解<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500729-ad1aeada-e94d-4f7f-9263-31b5031971c8.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=ua4899735&amp;margin=%5Bobject%20Object%5D&amp;originHeight=660&amp;originWidth=1306&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4a9acdf8-1639-498c-b25c-8532d5b9013&amp;title=&amp;width=451" alt=""><br>比如表达式计算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500774-5f55cb4a-375e-4628-8a25-c5886f9b8ecf.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=ub4b51deb&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1050&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6130fe28-6f0f-4e73-8f26-03514873989&amp;title=&amp;width=505" alt=""><br>例子<br>一个字符串的总结果， ans<br>一个收集数字的 cur</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565500812-577e8e62-310b-441d-b5fc-70f6264da78d.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ueb3f028b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=1249&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2e762acf-74d3-4f32-a96c-9b00be09246&amp;title=&amp;width=643" alt=""><br>2位置遇到左括号, 调子过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504551-ef54c717-a12c-4ef7-a8e6-1dea07860e9f.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u174ad8d4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=1290&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubb7240e5-7fd4-4f17-9d0c-dc13026baee&amp;title=&amp;width=530" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504525-6706a8a2-0c1d-4b36-941c-b9c59ded0d45.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u689b0aea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=668&amp;originWidth=1371&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7f4f3313-621b-4ad6-a317-6341b366355&amp;title=&amp;width=513" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504536-785698a9-0b58-4ea5-bb85-e5870cbed403.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u107f1f9b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=665&amp;originWidth=1262&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8359b1d3-cd55-4872-a3b1-24b10aa2d4d&amp;title=&amp;width=468" alt=""><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653565504635-339d1550-5bd7-4f34-8eca-7de606f92831.png#clientId=ub068ef40-dae1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3a36b325&amp;margin=%5Bobject%20Object%5D&amp;originHeight=795&amp;originWidth=747&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5993c173-de94-4eac-806d-e4d0ee9a8b5&amp;title=" alt=""></p><p>| <strong>public static </strong>String decodeString<strong>(</strong>String s<strong>) {<br>   char[] </strong>str = s.toCharArray<strong>()</strong>;<br>   <strong>return </strong>process<strong>(</strong>str, 0<strong>)</strong>.<strong>ans</strong>;<br>**}</p><p>public static class <strong>Info </strong>{<br>   public <strong>String </strong>ans<strong>;   </strong>public int stop**;</p><p>   <strong>public </strong>Info<strong>(</strong>String a, <strong>int </strong>e<strong>) {<br>      ans </strong>= a;<br>      <strong>stop </strong>= e;<br>   **}<br>}</p><p><strong>// s[i….]  何时停？遇到   ‘]’  或者遇到 s的终止位置，停止<br>// 返回Info<br>// 0) 串<br>// 1) 算到了哪</strong>public static <strong>Info process</strong>(char[] <strong>s, </strong>int <strong>i</strong>) {<br>   <strong>StringBuilder ans = </strong>new <strong>StringBuilder</strong>()<strong>;   </strong>int <strong>count = 0;   </strong>while (<strong>i &lt; s.</strong>length <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>!= </strong>‘]’) {<br>      if ((<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘a’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘z’) <strong>&#124;&#124; </strong>(<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘A’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘Z’)) {<br>         <strong>ans.append</strong>(<strong>s</strong>[<strong>i++</strong>])<strong>;      </strong>} else if (<strong>s</strong>[<strong>i</strong>] <strong>&gt;= </strong>‘0’ <strong>&amp;&amp; s</strong>[<strong>i</strong>] <strong>&lt;= </strong>‘9’) {<br>         <strong>count = count * 10 + s</strong>[<strong>i++</strong>] <strong>- </strong>‘0’<strong>;      </strong>} else { <strong>// str[index] = ‘[‘<br>         Info next = process</strong>(<strong>s, i + 1</strong>)<strong>;<br>         ans.append</strong>(<strong>timesString</strong>(<strong>count, next.</strong>ans))<strong>;<br>         //<br>         count = 0;<br>         i = next.</strong>stop <strong>+ 1;      </strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>ans.toString</strong>()<strong>, i</strong>)<strong>;</strong>}</p><p>public static <strong>String timesString</strong>(int <strong>times, String str</strong>) {<br>   <strong>StringBuilder ans = </strong>new <strong>StringBuilder</strong>()<strong>;   </strong>for (int <strong>i = 0; i &lt; times; i++</strong>) {<br>      <strong>ans.append</strong>(<strong>str</strong>)<strong>;   </strong>}<br>   return <strong>ans.toString</strong>()<strong>;</strong>}** |<br>| —- |</p><h2 id="·-最长连续序列"><a href="#·-最长连续序列" class="headerlink" title="· 最长连续序列"></a>· 最长连续序列</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1650027587467-9c71453c-132e-4e65-92ea-5e95c4838e80.png#clientId=u98aeb21b-e583-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=341&amp;id=uc6150b29&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=833&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35602&amp;status=done&amp;style=none&amp;taskId=u165c0c4b-a7e3-4fba-bdad-65d2fc46eed&amp;title=&amp;width=666.4" alt="image.png"><br><strong>题解</strong><br>连续区间头表+连续区间尾表<br>100来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450085-90058467-9331-4e7f-afc9-abfc89b72c9e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u25beeefc&amp;margin=%5Bobject%20Object%5D&amp;originHeight=397&amp;originWidth=1139&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e7bb74f-ea0e-4c9a-93a4-d29beffe1e0&amp;title=&amp;width=530" alt=""><br>3来到的过程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450084-3d961eca-d28d-4f43-b7fe-e707f3e47a19.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=uac2eb7d7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=461&amp;originWidth=1141&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u17d37d9c-915a-46fd-ab24-ef6eb833409&amp;title=&amp;width=498" alt=""><br>4来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450169-15fadec0-cbd9-4797-82c9-51f4aa1f8295.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u4eee0f77&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=1108&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9de3535e-8e32-4ff8-bc47-4d00a37927c&amp;title=&amp;width=480" alt=""><br>合并<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450083-6829ff9b-d260-46f0-b4f6-170148bd867e.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ud0fd55ea&amp;margin=%5Bobject%20Object%5D&amp;originHeight=562&amp;originWidth=1136&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1511e11d-3175-4713-8409-9f9a8863080&amp;title=&amp;width=457" alt=""><br>6来了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450067-4a7f66f8-a015-411b-a4cc-095f219446d4.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u00347243&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90b8fbaa-d0f1-43c4-8845-9a8afae0a7f&amp;title=&amp;width=480" alt=""><br>7来了<br>5<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450782-178be574-6064-458a-9275-a8f116757def.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=230&amp;id=u9c05a450&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u85da3f43-5abc-4192-bdfc-dccfad0d0ca&amp;title=&amp;width=472" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450958-39fc9099-3c15-44d8-bc54-5f2a4a86304a.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=uaca38d01&amp;margin=%5Bobject%20Object%5D&amp;originHeight=567&amp;originWidth=1110&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udcfcab17-b0c7-49d5-b493-4931f6a3233&amp;title=&amp;width=448" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652885450977-0bb7308a-fa05-40a5-9dcf-9540516264b5.png#clientId=u27775d2f-c52a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=uedf3ad85&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=1091&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u863f4790-bc00-4d11-b7ac-4d41a2ecfc5&amp;title=&amp;width=428" alt=""><br>总结<br>每个数来的时候都自己建出自己的区间，看看跟之前都不能合，看看后面能不能合,<br>你每次都严严格格的合完之后，你问我最后有多长的连续区间，你随便找一张表，把value最大值拿出来<br>每一个数来到的时候, 对于哈希表的操作都是O(1)<br><strong>代码</strong><br>难点在于它怎么只用一张哈表搞出来。</p><p>| <strong>public static int </strong>longestConsecutive<strong>(int[] </strong>nums<strong>) {   </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>len = 0;<br>   <strong>for (int </strong>num : nums<strong>) {<br>      if (</strong>!map.containsKey<strong>(</strong>num<strong>)) {         </strong>map.put<strong>(</strong>num, 1<strong>)</strong>;<br>         <strong>int </strong>preLen = map.containsKey<strong>(</strong>num - 1<strong>) </strong>? map.get<strong>(</strong>num - 1<strong>) </strong>: 0;<br>         <strong>int </strong>posLen = map.containsKey<strong>(</strong>num + 1<strong>) </strong>? map.get<strong>(</strong>num + 1<strong>) </strong>: 0;<br>         <strong>int </strong>all = preLen + posLen + 1;<br>         map.put<strong>(</strong>num - preLen, all<strong>)</strong>;<br>         map.put<strong>(</strong>num + posLen, all<strong>)</strong>;<br>         len = Math.max<strong>(</strong>len, all<strong>)</strong>;<br>      <strong>}<br>   }<br>   return </strong>len;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-超级洗衣机（硬记）"><a href="#·-超级洗衣机（硬记）" class="headerlink" title="· 超级洗衣机（硬记）"></a><strong>· 超级洗衣机（硬记）</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932367995-bbe4de73-2904-4594-916c-9533bbc0f67e.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=332&amp;id=uea6a2d41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=415&amp;originWidth=835&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39680&amp;status=done&amp;style=none&amp;taskId=u8f0f91ee-9a43-4785-a206-f20939def19&amp;title=&amp;width=668" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403145-b876e20d-8562-4eff-b4f8-d442cf06b0f4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=u3a840e1e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=554&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0ffadcba-008c-4d96-b91e-d0ebf518fa5&amp;title=&amp;width=482" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403138-c0c32760-5291-473e-8c7b-ed2d0d17ab3d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=193&amp;id=u2bc83435&amp;margin=%5Bobject%20Object%5D&amp;originHeight=569&amp;originWidth=1275&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udf474620-5c39-4ccf-9947-d5377322ff9&amp;title=&amp;width=432" alt=""><br><strong>题解</strong><br>大过滤器<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403158-39eaeb21-beea-423a-9a81-ab1b3e4f0c8a.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u5dbce6c0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=889&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b72d3a9-8d80-444f-a2a7-71510f9fd37&amp;title=&amp;width=381" alt=""><br>思想传统: 算单点的瓶颈, 最后看总答案跟单点瓶颈之间的关系</p><p>假设来到某一台(i号)洗衣机, 衣服数量?<br>假设每台机器该有的平均数我们知道<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403159-bc4570ef-622d-4f66-b7b2-806dd142a67c.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=uaf6e2a70&amp;margin=%5Bobject%20Object%5D&amp;originHeight=526&amp;originWidth=1229&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc26ff0ff-3a4e-4e24-ae5a-aa0f7723c5f&amp;title=&amp;width=589" alt=""><br><strong>第一种情况</strong><br>左右两侧有一个为正数有一个为负数<br>左侧整体欠15件。而它右侧整体多10件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932403191-6e7e37d7-0bf5-4987-a6ce-5be5b43a0741.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=u95da6da5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=622&amp;originWidth=837&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u070d6067-1b7d-42c5-b8ff-3bc599784ca&amp;title=&amp;width=386" alt=""><br>左侧整体欠15件。而它右侧整体多20件, 假设i位置永远有衣服可以搬，至少要几轮。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932412835-bcbf1abd-1049-4490-a288-38569f24b131.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u491fbc95&amp;margin=%5Bobject%20Object%5D&amp;originHeight=604&amp;originWidth=899&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua656072e-d9c0-41e4-8e4c-954b2598c76&amp;title=&amp;width=402" alt=""><br><strong>总结</strong><br>左右两侧有一个为正数有一个为负数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932414115-732d2fca-785a-4f8e-a095-b8ca0fbe23b4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=ucc357489&amp;margin=%5Bobject%20Object%5D&amp;originHeight=546&amp;originWidth=1002&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5290c3aa-c695-47a0-9411-e0238a73417&amp;title=&amp;width=394" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932417841-5e9e3984-a2c9-4e68-9694-6b85c58bafd0.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=209&amp;id=u6fe2d0e8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=556&amp;originWidth=971&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ac861c9-058d-4e4e-8e96-d5996a3c43d&amp;title=&amp;width=365" alt=""><br><strong>第二种情况</strong><br>左右两侧都为正数<br>i如果衣服特别少就可能左右两侧都要给它衣服<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932420558-7c95096e-d93b-4f93-b6f3-4eb0b7ca8c5c.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=220&amp;id=ud8e9e4fd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=638&amp;originWidth=857&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6165a81f-c605-4f9c-a6aa-8fe99ad651f&amp;title=&amp;width=296" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421080-d8bf23ca-28a5-4431-aa0e-425b360ae4bd.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u2fc15dd2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=561&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u720e32f9-1f9c-4cd3-bec7-e5cff31ee20&amp;title=&amp;width=394" alt=""><br><strong>最后一种情况</strong><br>左右两侧都为负数<br>如果左侧欠15件。右侧欠7件，我问你是要搬多少轮, 两侧都指望着i出力, 它一次只能扔一件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421484-2e38c5da-e2b5-44fc-b02a-0f6932eb9510.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=udc41672d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=601&amp;originWidth=745&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6afbd492-5e3d-4243-ae8d-d15ddd0797d&amp;title=&amp;width=408" alt=""><br>先算一个总衣服的数量，你再算一个左侧部分的累加和, i位置自己有值。<br>左侧部分欠几件还多几件, 右侧部分欠几件还是多几件。都能算出来<br>有一个衣服的总数量，有一个i左侧的累加和, 接下来你到任何一个i位置。<br>你左侧, 右侧到底是多还是少？你都能算出来</p><p>根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,<br>2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。<br>因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了<br>因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652932421558-5fddfdda-a71d-4671-aece-dc0b34e07408.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u75e1afcf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=521&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u550aae88-3e80-416e-bdc1-1f855da6fc1&amp;title=&amp;width=445" alt=""><br><strong>单点思维传统</strong><br>接雨水的问题, 左侧最大值最小值问题，这些东西都是以单点算出来一个答案，然后去决策等。<br>洗衣机问题它属于我把整个问题，我不去想它整体我就想它单点的答案是啥，你给我整出一个答案，<br>然后我去决策出来什么东西，以后单点去求然后再得到整体答案的办法，将会成为我们的一个思想传统。<br>类似子串子数组问题, 每个位置结尾时候啥答案。其实这也是<strong>单点思维。</strong><br><strong>代码</strong></p><p>| <strong>public static int </strong>findMinMoves<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>size = arr.<strong>length</strong>;<br>   <strong>int </strong>sum = 0;<br>   <strong>for (int </strong>i = 0; i &lt; size; i++<strong>) {      </strong>sum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   if (</strong>sum % size != 0<strong>) {<br>      return </strong>-1;<br>   <strong>}<br>   int </strong>avg = sum / size;<br>   //左侧部分累加和<br>   <strong>int </strong>leftSum = 0;<br>   <strong>int </strong>ans = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>//左侧部分剩余<br>      <strong>int </strong>leftRest = leftSum - i <em> avg;<br>      //右侧部分剩余<br>      <strong>int </strong>rightRest = <strong>(</strong>sum - leftSum - arr<strong>[</strong>i<strong>]) </strong>- <strong>(</strong>size - i - 1<strong>) </strong></em> avg;<br>      <strong>if (</strong>leftRest &lt; 0 &amp;&amp; rightRest &lt; 0<strong>) {         </strong>ans = Math.max<strong>(</strong>ans, Math.abs<strong>(</strong>leftRest<strong>) </strong>+ Math.abs<strong>(</strong>rightRest<strong>))</strong>;<br>      <strong>} else {         </strong>ans = Math.max<strong>(</strong>ans, Math.max<strong>(</strong>Math.abs<strong>(</strong>leftRest<strong>)</strong>, Math.abs<strong>(</strong>rightRest<strong>)))</strong>;<br>      <strong>}      </strong>leftSum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   return </strong>ans;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-缺失的第一个正数"><a href="#·-缺失的第一个正数" class="headerlink" title="· 缺失的第一个正数"></a><strong>· 缺失的第一个正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922711623-5f275d70-6ad9-4a85-b908-b754c4c08188.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=377&amp;id=u10e943fc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=471&amp;originWidth=671&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31833&amp;status=done&amp;style=none&amp;taskId=u01469d94-35f3-4ad3-8669-3edd28f7319&amp;title=&amp;width=536.8" alt="image.png"><br>核心就是<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649922917933-411751da-967b-4a5a-bba8-08ca6afba789.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u1d4d9e20&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=629&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=81409&amp;status=done&amp;style=none&amp;taskId=uea4d21e0-d3fc-4dc9-be76-12aa8351e2e&amp;title=&amp;width=503.2" alt="image.png"><br>分为有效区和垃圾区<br>核心</p><ul><li>如果L位置上的数 &lt;=L跟垃圾区交换</li><li><blockquote><p>R位置的数 跟垃圾区交换</p></blockquote></li><li>等于 arr[arr[L]-1]的数也交换<br>| <strong>public static int </strong>firstMissingPositive<strong>(int[] </strong>arr<strong>) { </strong>// l是盯着的位置<br> // 0 ~ L-1有效区<br> <strong>int </strong>L = 0;<br> <strong>int </strong>R = arr.<strong>length</strong>;<br> <strong>while (</strong>L != R**) {<pre><code>**//有效区向右扩**if (**arr**[**L**] **== L + 1**) &#123;   **L++;**&#125; else if (**arr**[**L**] **&lt;= L &amp;#124;&amp;#124; arr**[**L**] **&gt; R &amp;#124;&amp;#124; arr**[**arr**[**L**] **- 1**] **== arr**[**L**]) &#123; **// 垃圾的情况   swap**(**arr, L, --R**)**;**&#125; else &#123;   **swap**(**arr, L, arr**[**L**] **- 1**)**;**&#125;</code></pre> }<br> return <strong>L + 1;</strong>}</li></ul><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-数组的自己不能累加和出的最小正数"><a href="#·-数组的自己不能累加和出的最小正数" class="headerlink" title="· 数组的自己不能累加和出的最小正数"></a><strong>· 数组的自己不能累加和出的最小正数</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649908121718-8953c38b-c4f7-47ac-ae29-35e9ffd72e37.png#clientId=u66160ce2-b06d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=99&amp;id=u1ea6fc03&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=124&amp;originWidth=366&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12897&amp;status=done&amp;style=none&amp;taskId=u8559eaa1-8292-41bd-a5cc-ca091503438&amp;title=&amp;width=292.8" alt="image.png"><br><strong>第一问</strong><br>同上问<br>arr所有值的累加和从一个负数到一个整数做出一张表, 然后看最后一行<br>arr 0~N-1宿友的值能不能搞定1, 2, 3…, 哪一个最早不行的, 返回就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274512-42b3c5d7-4c34-41d1-90af-b01987c4bcf7.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=ub0253dce&amp;margin=%5Bobject%20Object%5D&amp;originHeight=664&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c3059f8-c8ca-4e0e-8def-f24e2bb3715&amp;title=&amp;width=434" alt=""></p><p>| <strong>public static int </strong>unformedSum2<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>1;<br>   <strong>}<br>   int </strong>sum = 0;<br>   <strong>int </strong>min = Integer.<strong>MAX_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {      </strong>sum += arr<strong>[</strong>i<strong>]</strong>;<br>      min = Math.min<strong>(</strong>min, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}   </strong>// boolean[][] dp …<br>   <strong>int </strong>N = arr.<strong>length</strong>;<br>   <strong>boolean[][] </strong>dp = <strong>new boolean[</strong>N<strong>][</strong>sum + 1<strong>]</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {</strong>// arr[0..i] 0<br>      dp<strong>[</strong>i<strong>][</strong>0<strong>] </strong>= <strong>true</strong>;<br>   <strong>}   </strong>dp<strong>[</strong>0<strong>][</strong>arr<strong>[</strong>0<strong>]] </strong>= <strong>true</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; N; i++<strong>) {<br>      for (int </strong>j = 1; j &lt;= sum; j++<strong>) {         </strong>dp<strong>[</strong>i<strong>][</strong>j<strong>] </strong>= dp<strong>[</strong>i - 1<strong>][</strong>j<strong>] </strong>&#124;&#124; <strong>((</strong>j - arr<strong>[</strong>i<strong>] </strong>&gt;= 0<strong>) </strong>? dp<strong>[</strong>i - 1<strong>][</strong>j - arr<strong>[</strong>i<strong>]] </strong>: <strong>false)</strong>;<br>      <strong>}<br>   }<br>   for (int </strong>j = min; j &lt;= sum; j++<strong>) {<br>      if (</strong>!dp<strong>[</strong>N - 1<strong>][</strong>j<strong>]) {<br>         return </strong>j;<br>      <strong>}<br>   }<br>   return </strong>sum + 1;<br><strong>}</strong> |<br>| —- |</p><p><strong>第二问</strong><br>先把array排序, 正数数组排完序, 左边0位置肯定是1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274407-d5bb7112-75b6-4c1a-8c5a-636c29d2da74.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=u7c7998e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=598&amp;originWidth=914&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6d443944-221f-4578-af40-df6b9538517&amp;title=&amp;width=428" alt=""><br>定义变量range =1, 表示从1~1范围上的正数都能累加出来<br>range=k, 代表1~k上的所有正数都能搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-064d2ceb-c903-444a-8b3b-def179bd1054.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=udb091615&amp;margin=%5Bobject%20Object%5D&amp;originHeight=627&amp;originWidth=1208&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u87640a35-779d-455c-92d7-3d66170c5b2&amp;title=&amp;width=451" alt=""><br>当arr 0位置是1的情况下, range=1, 代表1~1范围的正数都可以搞出来<br>如果1位置也是1, range变成2, 代表1~2范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274416-3a9c1b06-df19-4cbf-a1a0-8890c1df2d33.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=283&amp;id=u4a638e7d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1197&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uacb8b2ee-8e40-476b-b0e6-d3dd0902597&amp;title=&amp;width=546" alt=""><br>如果2位置也是2, range变成4, 代表1~4范围的正数都可以搞出来<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927274433-c44f8de2-ab64-4735-a4ae-0d303eaeb2be.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=258&amp;id=u36d33f1c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=629&amp;originWidth=1218&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75c49504-7235-4203-9e18-e0efd1c066a&amp;title=&amp;width=500" alt=""><br>如果0~i-1是0~100, range=100<br>i位置17, 可以让range扩充到117</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276639-76ea18e4-1553-4416-b729-602f169e4256.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=ud24b4420&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=1188&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf800b3ae-b828-40f4-9f35-e53b5b30e59&amp;title=&amp;width=540" alt=""><br>注意一点<br>如果0~i-1能搞定的数是1~100, 此时i位置是102, 那么101不可以搞定<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276627-25522d30-aa31-47f1-a2c0-70754b005b35.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=ub8d18f54&amp;margin=%5Bobject%20Object%5D&amp;originHeight=641&amp;originWidth=946&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c78c50f-b4c4-4174-aeb2-65532acedc1&amp;title=&amp;width=484" alt=""><br><strong>抽象化</strong><br>如果0~i-1搞定1~a, 如果i位置上是b:<br>1)如果b&lt;= a+1, 能扩充, 范围到1~a+b<br>2)如果b&gt; a+1, a+1就是搞定不了的最小正整数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927276617-5b986e34-cf33-4d56-a953-8b54313b7cb9.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=309&amp;id=u561892aa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=661&amp;originWidth=1101&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8618d200-7b25-4c41-89a5-14bb0c7e026&amp;title=&amp;width=515" alt=""><br><strong>代码</strong></p><p>| <strong>// 已知arr中肯定有1这个数</strong>public static int <strong>unformedSum3</strong>(int[] <strong>arr</strong>) {<br>   if (<strong>arr == </strong>null <strong>&#124;&#124; arr.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   <strong>Arrays.sort</strong>(<strong>arr</strong>)<strong>; // O (N * logN)   </strong>int <strong>range = 1;<br>   // arr[0] == 1   </strong>for (int <strong>i = 1; i != arr.</strong>length<strong>; i++</strong>) {<br>      if (<strong>arr</strong>[<strong>i</strong>] <strong>&gt; range + 1</strong>) {<br>         return <strong>range + 1;      </strong>} else {<br>         <strong>range += arr</strong>[<strong>i</strong>]<strong>;      </strong>}<br>   }<br>   return <strong>range + 1;</strong>}** |<br>| —- |</p><p>原题<br>arr是正数, 要求子集不能是空集, 最小子集累加和到最大子集累加和的范围中哪个数是最小不可组成的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927277249-0071ad5e-e13b-4370-bfe9-c4e82ef62414.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=u10a4ace4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=644&amp;originWidth=1230&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6504140f-42f0-4cdd-ab09-4e8752f37b5&amp;title=&amp;width=385" alt=""></p><h2 id="·-按要求补齐数组"><a href="#·-按要求补齐数组" class="headerlink" title="· 按要求补齐数组"></a>· 按要求补齐数组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1649917704725-47286ee2-4581-440e-87d2-40217bdc6892.png#clientId=uddadb385-d350-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=401&amp;id=uafa838b3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=501&amp;originWidth=821&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36432&amp;status=done&amp;style=none&amp;taskId=u650b2498-cf20-4fe1-bdde-0a59049f6aa&amp;title=&amp;width=656.8" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555620-061a554b-82b5-41e0-9e92-a690ce40510d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=ud98747b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=559&amp;originWidth=1248&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc3bcf646-19ce-4700-8f4a-bd401665f44&amp;title=&amp;width=389" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555641-e30d7e5e-1c75-4f52-a033-af5aee074d54.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u7ba03d88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=1240&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4a3bc28c-d3a2-4b58-ba9a-de9d7ca6744&amp;title=&amp;width=477" alt=""><br>到达数字+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555680-c1d3ccf6-3771-4e93-96b8-39c885a5a4bf.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=211&amp;id=ub2e23613&amp;margin=%5Bobject%20Object%5D&amp;originHeight=639&amp;originWidth=1262&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc2cbb657-a0c0-4d31-afee-d802e35c8fe&amp;title=&amp;width=417" alt=""><br><strong>题解</strong><br>先把数组排序<br>数组中每个数最经济的使用<br>只能是 1~3 范围，你先都搞定之后，你舒舒服服，使用这个4，就能扩到1~7了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555600-28054282-00a3-4ada-b588-8c83daa1343d.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=165&amp;id=u36009711&amp;margin=%5Bobject%20Object%5D&amp;originHeight=414&amp;originWidth=1355&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c1ace8f-dc3d-4e30-aa37-c80e0af525c&amp;title=&amp;width=540" alt=""><br>给自己提了小目标，这个小目标是搞定1~3 范围上，你缺几个数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927555576-2c52f0c4-a3ee-4fe0-99fd-d5ad4194db98.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=u2bb70482&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=1326&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u30cd7616-6530-4109-9843-187a632bcd8&amp;title=&amp;width=539" alt=""><br>对于5, 小目标1~4范围上都可以搞定, 已经满足了<br>可以直接使用这个5，让它变成12，不用添任何数字</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559417-d4b87abf-d387-42d2-8d80-4a0a8ec4f0c4.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u32d93753&amp;margin=%5Bobject%20Object%5D&amp;originHeight=584&amp;originWidth=1317&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u127e139e-6b60-4227-ad19-1e323514d0d&amp;title=&amp;width=521" alt=""><br>想使用17, 要求目标1~16必须具备<br>目前有1~12, 缺13, 补13之后范围扩到1~25<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927559808-215561a1-ff63-415f-bf78-fad7b73a64ba.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=uea5b1f49&amp;margin=%5Bobject%20Object%5D&amp;originHeight=611&amp;originWidth=1322&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2cc09c61-ee32-4302-b314-4ba0be0fea5&amp;title=&amp;width=507" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927560402-d3d539ae-2061-402e-8409-47fe164264a2.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=227&amp;id=u09c809c8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=618&amp;originWidth=1338&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7877baab-db60-4c74-96b5-33a014c76fd&amp;title=&amp;width=491" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561057-82a9fd44-9823-4f41-858c-acdcdc07147b.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=231&amp;id=u1757f08b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=660&amp;originWidth=1340&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucad0fd2b-6999-4754-89cb-2a2fdc5f0e0&amp;title=&amp;width=468" alt=""><br><strong>例子</strong><br>如果n特别大, 整个数组都使用完以后范围是1~3050, 先补3051<br>整个数组都使完之后，如果你还没到，接下来的过程就等同于给了你一个范围，你一个数也没有了</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927561285-f47b7093-d077-49ef-9d8a-40af2438e4b0.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=201&amp;id=u48355d80&amp;margin=%5Bobject%20Object%5D&amp;originHeight=587&amp;originWidth=1165&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u25fd03f5-cf32-4ea9-b5a2-10523fc59b6&amp;title=&amp;width=399" alt=""><br>注意点<br>只要范围扩充了，我就盯着总目标有没有实现，我不一定要使用完所有数字，我可能已经提前搞定考了，<br>我缺了多少数字，如果发现我range已经到它了，直接返回就可以了，不用看后面的数字<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652927562331-6d5e0b3b-b786-468c-a940-7c5b9ed70aa2.png#clientId=u25bf4cf1-53e5-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=u84594179&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1341&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3d649c1a-e5d8-43f0-87e0-47de55d83b7&amp;title=&amp;width=510" alt=""></p><p>| // arr请保证有序，且正数  1~aim<br><strong>public static int </strong>minPatches<strong>(int[] </strong>arr, <strong>int </strong>aim<strong>) {<br>   int </strong>patches = 0; // 缺多少个数字<br>   <strong>long </strong>range = 0; // 已经完成了1 ~ range的目标<br>   Arrays.sort<strong>(</strong>arr<strong>)</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {      </strong>// arr[i]<br>      // 要求：1 ~ arr[i]-1 范围被搞定！<br>      <strong>while (</strong>arr<strong>[</strong>i<strong>] </strong>- 1 &gt; range<strong>) { </strong>// arr[i] 1 ~ arr[i]-1<br>         range += (range + 1); // range + 1 是缺的数字<br>         patches++;<br>         //只要范围一变化就盯着目标<br>         <strong>if (</strong>range &gt;= aim<strong>) {<br>            return </strong>patches;<br>         <strong>}<br>      }      </strong>// 要求被满足了！<br>      range += arr<strong>[</strong>i<strong>]</strong>;<br>      <strong>if (</strong>range &gt;= aim<strong>) {<br>         return </strong>patches;<br>      <strong>}<br>   }<br>   while (</strong>aim &gt;= range + 1<strong>) {      </strong>range += range + 1;<br>      patches++;<br>   <strong>}<br>   return </strong>patches;<br><strong>}</strong> |<br>| —- |</p><h2 id=""><a href="#" class="headerlink" title="//======================"></a>//======================</h2><h2 id="·-240-行列递增矩阵的查找-搜索二维矩阵-II-M"><a href="#·-240-行列递增矩阵的查找-搜索二维矩阵-II-M" class="headerlink" title="· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]"></a>· 240.行列递增矩阵的查找|搜索二维矩阵 II [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538431656-6b591c24-62b5-4f4d-a992-0e2ee6455b85.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=78&amp;id=ucaa40dd5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=549&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11740&amp;status=done&amp;style=none&amp;taskId=u76050ce0-5216-4663-83e4-b58fdd5ced0&amp;title=&amp;width=439.2" alt="image.png"><br><strong>题意</strong><br>让你找某一个数字在其中是否存在<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537626124-5e69971c-798a-4382-a6c0-56062f07a154.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=u825d9625&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=642&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u938e2c19-6aff-4589-84b0-79641bb03ae&amp;title=&amp;width=348" alt=""><br><strong>题解</strong><br>经典解法:<br>从右上角开始找<br>复杂度O(N+M)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624515-057e50f5-c481-4b0a-8091-003f019142d4.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u86a3eab4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=611&amp;originWidth=1257&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufda2a2e9-c766-4bc5-9780-98846953c45&amp;title=&amp;width=553" alt=""><br>从左下角走</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537624507-9f4bca2b-fa51-4bd1-ae0a-cc127e634a97.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ubf5cba53&amp;margin=%5Bobject%20Object%5D&amp;originHeight=601&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0f5c24b9-5e75-475b-96da-fcd5f286991&amp;title=&amp;width=515" alt=""></p><p>| <strong>public static boolean </strong>isContains<strong>(int[][] </strong>matrix, <strong>int </strong>K<strong>) {<br>   int </strong>row = 0;<br>   <strong>int </strong>col = matrix<strong>[</strong>0<strong>]</strong>.<strong>length </strong>- 1;<br>   <strong>while (</strong>row &lt; matrix.<strong>length </strong>&amp;&amp; col &gt; -1<strong>) {<br>      if (</strong>matrix<strong>[</strong>row<strong>][</strong>col<strong>] </strong>== K<strong>) {<br>         return true</strong>;<br>      <strong>} else if (</strong>matrix<strong>[</strong>row<strong>][</strong>col<strong>] </strong>&gt; K<strong>) {         </strong>col—;<br>      <strong>} else {         </strong>row++;<br>      <strong>}<br>   }<br>   return false</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-✊378-行列递增矩阵中的第K小-M"><a href="#·-✊378-行列递增矩阵中的第K小-M" class="headerlink" title="· ✊378.行列递增矩阵中的第K小 [M]"></a>· ✊378.行列递增矩阵中的第K小 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538447469-55d93518-20af-4ac9-bb0d-cc650b505a39.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=75&amp;id=ue2220b92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=94&amp;originWidth=543&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12027&amp;status=done&amp;style=none&amp;taskId=u7642227d-241c-4306-8adb-3d21d1474a6&amp;title=&amp;width=434.4" alt="image.png"><br><strong>最优解</strong><br>给定一个目标, 想知道&lt;=100的数有几个, 怎么快能求出来?<br>往左走, 获得0个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464907-2dead8bf-8612-4941-8c80-3b22ba09131b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=192&amp;id=u2e5cfef4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=584&amp;originWidth=1302&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua5722571-1037-41c0-a18e-d6fb6cb934b&amp;title=&amp;width=427" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464900-3f1bafb2-1bae-4cdb-8c53-cc846c69f134.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u4704966e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=599&amp;originWidth=1269&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4d022a33-b6ba-45b1-8229-acd68f70a81&amp;title=&amp;width=500" alt=""><br>就这样一直卡到结束，你正确的获得整个数组中有多少个数&lt;=100<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464925-50973775-2761-4ed9-8cd5-5337041bf338.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=ua11d3edf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=636&amp;originWidth=1279&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueff346fb-ab57-4bd5-9a3e-3880b1e4b7b&amp;title=&amp;width=534" alt=""><br><strong>例子</strong><br>&lt;=100的有几个, 同时也可以知道最接近100的是啥数?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464932-49c9b5d2-a01d-4a5c-8975-50303fa6a936.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=236&amp;id=u56983f42&amp;margin=%5Bobject%20Object%5D&amp;originHeight=588&amp;originWidth=1296&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u67098799-26c6-4f3c-8175-19f94ecb673&amp;title=&amp;width=521" alt=""><br>120&gt;100获得0个</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538464930-de301eda-d2b0-440b-b938-1bc52130534e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=u2cdb7407&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=1311&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b4b31cf-26dc-496f-8390-87189a86c68&amp;title=&amp;width=411" alt=""><br>100&gt;90 假设90所在的列是col<br>获得的个数是rol+1<br>同时更新接近100的数字为90</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465650-44206736-0a80-4be1-b524-3e42d7c92086.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=u653e1491&amp;margin=%5Bobject%20Object%5D&amp;originHeight=566&amp;originWidth=1304&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uefd5909b-1438-4e68-8c39-07bb5605a84&amp;title=&amp;width=549" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465710-67505b3a-0cc8-4c66-b908-40ff88ecab43.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=181&amp;id=u66d628df&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1310&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufefde839-ee65-4893-88e1-ff39a92a975&amp;title=&amp;width=431" alt=""><br>解决原问题<br><strong>二分</strong><br>整个数组中最小的是谁？左上角的数<br>那整个数组中，最大的数是谁？右下角的数<br>第一百小的数一定在一到1000之间, 看看&lt;=500的数有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465810-e8be4f70-42f7-4fa5-b7a0-c81514b2ff5d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=256&amp;id=u9bcf7146&amp;margin=%5Bobject%20Object%5D&amp;originHeight=599&amp;originWidth=1219&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u479e614c-408d-4eb6-9c84-94373d1aa27&amp;title=&amp;width=521" alt=""><br>如果&lt;=500有200个, 目标大了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538465999-a6e86772-a3ac-4585-a06c-2081f5cdd43e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=284&amp;id=uddbef8b1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=650&amp;originWidth=1265&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u361c54da-f6cb-48a8-9aaf-db96a0a03c1&amp;title=&amp;width=553" alt=""><br>有可能最后得到&lt;=785的数有100个, 但是数组中没有这个数, 应该是&lt;=785并离它最近<br>的数<br>我每次让你过的时候求俩信息，</p><ul><li>第一小于等于某一个值个数有几个</li><li>第二，最接近它的是谁？</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466133-869c69d6-fbbd-4e08-b85f-e7affbbdba50.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=u32fd171a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=632&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf7b5a0ae-78a1-4110-90ef-898624a9d91&amp;title=&amp;width=560" alt=""><br><strong>复杂度</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466525-0b2fee08-0f44-4e91-b063-3992ab4853f0.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=268&amp;id=ucbc9934f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=659&amp;originWidth=1263&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua58a75d8-03db-4569-b937-1af685bff8d&amp;title=&amp;width=513" alt=""><br><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466467-9e5f348e-c41d-4268-9b00-b0c0e20be6de.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u762a2f31&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1285&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8fa0287d-25c4-48b9-a7cf-aa1e3e128a1&amp;title=&amp;width=516" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466606-1c01a2b3-8288-4f63-a32f-5ef20107ec9d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=374&amp;id=ua6082d71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=912&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1827838a-ed61-4d55-b0e4-80808063065&amp;title=&amp;width=564" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538466819-f599b5d1-bfaf-409d-9a8b-05f51b31ee1a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u7c9fce28&amp;margin=%5Bobject%20Object%5D&amp;originHeight=671&amp;originWidth=1356&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u150b1272-8545-4d16-8622-d69dad22697&amp;title=&amp;width=544" alt=""><br><strong>代码</strong></p><p>| // 二分的方法<br><strong>public static int </strong>kthSmallest2<strong>(int[][] </strong>matrix, <strong>int </strong>k<strong>) {<br>   int </strong>N = matrix.<strong>length</strong>;<br>   <strong>int </strong>M = matrix<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   <strong>int </strong>left = matrix<strong>[</strong>0<strong>][</strong>0<strong>]</strong>;<br>   <strong>int </strong>right = matrix<strong>[</strong>N - 1<strong>][</strong>M - 1<strong>]</strong>;<br>   <strong>int </strong>ans = 0;<br>   <strong>while (</strong>left &lt;= right<strong>) {<br>      int </strong>mid = left + <strong>((</strong>right - left<strong>) </strong>&gt;&gt; 1<strong>)</strong>;<br>      // &lt;=mid 有几个 &lt;= mid 在矩阵中真实出现的数，谁最接近mid<br>      Info info = noMoreNum<strong>(</strong>matrix, mid<strong>)</strong>;<br>      <strong>if (</strong>info.<strong>num </strong>&lt; k<strong>) {         </strong>left = mid + 1;<br>      <strong>} else {         </strong>//这里就是有可能&lt;=785的数有100个，但是数组中没有这个数，所以要记录与他最接近的<br>         ans = info.<strong>near</strong>;<br>         right = mid - 1;<br>      <strong>}<br>   }<br>   return </strong>ans;<br>**}</p><p>public static class <strong>Info </strong>{<br>   public int near<strong>;   </strong>public int num**;</p><p>   <strong>public </strong>Info<strong>(int </strong>n1, <strong>int </strong>n2<strong>) {<br>      near </strong>= n1;<br>      <strong>num </strong>= n2;<br>   **}<br>}</p><p>public static <strong>Info noMoreNum</strong>(int[][] <strong>matrix, </strong>int <strong>value</strong>) {<br>   int <strong>near = Integer.</strong>MIN_VALUE<strong>;   </strong>int <strong>num = 0;   </strong>int <strong>N = matrix.</strong>length<strong>;   </strong>int <strong>M = matrix</strong>[<strong>0</strong>]<strong>.</strong>length<strong>;   </strong>int <strong>row = 0;   </strong>int <strong>col = M - 1;   </strong>while (<strong>row &lt; N &amp;&amp; col &gt;= 0</strong>) {<br>      if (<strong>matrix</strong>[<strong>row</strong>][<strong>col</strong>] <strong>&lt;= value</strong>) {<br>         <strong>near = Math.max</strong>(<strong>near, matrix</strong>[<strong>row</strong>][<strong>col</strong>])<strong>;<br>         num += col + 1;<br>         row++;      </strong>} else {<br>         <strong>col—;      </strong>}<br>   }<br>   return new <strong>Info</strong>(<strong>near, num</strong>)<strong>;</strong>}** |<br>| —- |</p><p>| // 堆的方法<br><strong>public static int </strong>kthSmallest1<strong>(int[][] </strong>matrix, <strong>int </strong>k<strong>) {<br>   int </strong>N = matrix.<strong>length</strong>;<br>   <strong>int </strong>M = matrix<strong>[</strong>0<strong>]</strong>.<strong>length</strong>;<br>   PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>heap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;(new </strong>NodeComparator<strong>())</strong>;<br>   <strong>boolean[][] </strong>set = <strong>new boolean[</strong>N<strong>][</strong>M<strong>]</strong>;<br>   heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>0<strong>][</strong>0<strong>]</strong>, 0, 0<strong>))</strong>;<br>   set<strong>[</strong>0<strong>][</strong>0<strong>] </strong>= <strong>true</strong>;<br>   <strong>int </strong>count = 0;<br>   Node ans = <strong>null</strong>;<br>   <strong>while (</strong>!heap.isEmpty<strong>()) {      </strong>ans = heap.poll<strong>()</strong>;<br>      <strong>if (</strong>++count == k<strong>) {<br>         break</strong>;<br>      <strong>}<br>      int </strong>row = ans.<strong>row</strong>;<br>      <strong>int </strong>col = ans.<strong>col</strong>;<br>      <strong>if (</strong>row + 1 &lt; N &amp;&amp; !set<strong>[</strong>row + 1<strong>][</strong>col<strong>]) {         </strong>heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>row + 1<strong>][</strong>col<strong>]</strong>, row + 1, col<strong>))</strong>;<br>         set<strong>[</strong>row + 1<strong>][</strong>col<strong>] </strong>= <strong>true</strong>;<br>      <strong>}<br>      if (</strong>col + 1 &lt; M &amp;&amp; !set<strong>[</strong>row<strong>][</strong>col + 1<strong>]) {         </strong>heap.add<strong>(new </strong>Node<strong>(</strong>matrix<strong>[</strong>row<strong>][</strong>col + 1<strong>]</strong>, row, col + 1<strong>))</strong>;<br>         set<strong>[</strong>row<strong>][</strong>col + 1<strong>] </strong>= <strong>true</strong>;<br>      <strong>}<br>   }<br>   return </strong>ans.<strong>value</strong>;<br>**}</p><p>public static class <strong>Node </strong>{<br>   public int value<strong>;   </strong>public int row<strong>;   </strong>public int col**;</p><p>   <strong>public </strong>Node<strong>(int </strong>v, <strong>int </strong>r, <strong>int </strong>c<strong>) {<br>      value </strong>= v;<br>      <strong>row </strong>= r;<br>      <strong>col </strong>= c;<br>   **}</p><p>}</p><p>public static class <strong>NodeComparator </strong>implements <strong>Comparator</strong>&lt;<strong>Node</strong>&gt; {</p><p>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return <strong>o1.</strong>value <strong>- o2.</strong>value<strong>;   </strong>}</p><p>}** |<br>| —- |</p><h2 id="·-940-不同的子序列-II-H"><a href="#·-940-不同的子序列-II-H" class="headerlink" title="· 940.不同的子序列 II [H]"></a>· 940.不同的子序列 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538612708-fda8d9fb-bb27-4677-8080-a6c88db86f79.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=330&amp;id=u64377b4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=412&amp;originWidth=662&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24324&amp;status=done&amp;style=none&amp;taskId=ub9741443-896e-42ce-8c56-8a848253493&amp;title=&amp;width=529.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-ffb30de6-f89e-4cc2-97f9-f689fa201501.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=u1fea0879&amp;margin=%5Bobject%20Object%5D&amp;originHeight=587&amp;originWidth=1215&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u55df378d-a803-40de-a808-0dedf0ccfe0&amp;title=&amp;width=458" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538824652-f0b61739-d00f-48b6-998c-26a3711ea3bf.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u1df3788a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1042&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4f9cf5bd-ef8b-440e-8b26-ba037940ecf&amp;title=&amp;width=429" alt=""><br><strong>题解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1655384932788-bf089bd0-c6f2-473c-a397-a313422b8837.png#clientId=u782dedcd-cafb-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=1810&amp;id=ua0fa29c9&amp;margin=%5Bobject%20Object%5D&amp;name=779E39B64BA9EC69E5A1C515E4200530.png&amp;originHeight=3168&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1164522&amp;status=done&amp;style=none&amp;taskId=udfa184cd-8bbd-4169-93f5-29e4850f4c6&amp;title=&amp;width=813.7142857142857" alt="779E39B64BA9EC69E5A1C515E4200530.png"><br>模操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652538826795-e3410ba0-a512-485d-951d-69bb5cb981a6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9b1dd3e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=755&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u811d823a-3961-4f75-b8f3-4b6d6da427b&amp;title=" alt=""></p><p>| <strong>public static int </strong>zuo1<strong>(</strong>String s<strong>) {<br>      if (</strong>s == <strong>null </strong>&#124;&#124; s.length<strong>() </strong>== 0<strong>) {<br>         return </strong>0;<br>      <strong>}<br>      int </strong>m = 1000000007;<br>      <strong>char[] </strong>str = s.toCharArray<strong>()</strong>;<br>      HashMap<strong>&lt;</strong>Character, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>      <strong>int </strong>all = 1; // 一个字符也没遍历的时候，有空集<br>      <strong>for (char </strong>x : str<strong>) {         </strong>//新加出来的玩意儿就是以什么结尾的数量<br>         <strong>int </strong>newAdd = all;<br>         <strong>int </strong>curAll = all + newAdd - <strong>(</strong>map.containsKey<strong>(</strong>x<strong>) </strong>? map.get<strong>(</strong>x<strong>) </strong>: 0<strong>)</strong>;<br>         all = curAll;<br>         map.put<strong>(</strong>x, newAdd<strong>)</strong>;<br>      <strong>}<br>      return </strong>all;<br>   <strong>}<br>   public static int </strong>zuo<strong>(</strong>String s<strong>) {<br>      if (</strong>s == <strong>null </strong>&#124;&#124; s.length<strong>() </strong>== 0<strong>) {<br>         return </strong>0;<br>      <strong>}<br>      int </strong>m = 1000000007;<br>      <strong>char[] </strong>str = s.toCharArray<strong>()</strong>;<br>      HashMap<strong>&lt;</strong>Character, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;&gt;()</strong>;<br>      <strong>int </strong>all = 1; // 一个字符也没遍历的时候，有空集<br>      <strong>for (char </strong>x : str<strong>) {<br>         int </strong>newAdd = all;<br>//       int curAll = all + newAdd - (map.containsKey(x) ? map.get(x) : 0);<br>         <strong>int </strong>curAll = all;<br>         curAll = <strong>(</strong>curAll + newAdd<strong>) </strong>% m;<br>         //减完可能为负数，所以要先加<br>         curAll = <strong>(</strong>curAll - <strong>(</strong>map.containsKey<strong>(</strong>x<strong>) </strong>? map.get<strong>(</strong>x<strong>) </strong>: 0<strong>) </strong>+ m<strong>) </strong>% m;<br>         all = curAll;<br>         map.put<strong>(</strong>x, newAdd<strong>)</strong>;<br>      <strong>}<br>      return </strong>all;<br>   <strong>}</strong> |<br>| —- |</p><h2 id="·-汉诺塔游戏中的最优状态"><a href="#·-汉诺塔游戏中的最优状态" class="headerlink" title="· 汉诺塔游戏中的最优状态"></a>· 汉诺塔游戏中的最优状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539211568-a1dd0839-322f-4a09-8fbb-4427209b059d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=156&amp;id=u5e9bcd3b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=195&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40554&amp;status=done&amp;style=none&amp;taskId=u75553f41-4211-4e03-b1c3-af09e2d344e&amp;title=&amp;width=489.6" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187846-f70f3d8f-0157-43bd-b853-e65f7208f8ce.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=ua14962a4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=605&amp;originWidth=1280&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u50a5c929-49c5-44bd-bc95-307b8dadc4c&amp;title=&amp;width=585" alt=""><br>7层汉诺塔问题的一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187621-d66d9436-5fa6-4b96-8665-50fa8b081a64.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=uc20ed9ff&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=1260&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1831e6fb-2ea6-4897-b345-95c2d0e887b&amp;title=&amp;width=559" alt=""><br>最优解的第一个状态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187608-84fce00e-ce50-476f-8097-9a88be815ab3.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=188&amp;id=u606020c1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=373&amp;originWidth=1323&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udc765580-8b82-4da7-9d75-d59459d93e9&amp;title=&amp;width=666" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187793-ebb720d3-d2df-44dd-b600-10e2915349d5.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=ue283094b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=633&amp;originWidth=1368&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub9dc08a9-ad4f-48c3-9036-b1723d5d890&amp;title=&amp;width=595" alt=""><br><strong>题解</strong><br>复杂度 O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028187754-902ce282-eb4d-4ffa-b9f2-08d5bb24a1ca.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=265&amp;id=ueee15b1a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=594&amp;originWidth=1173&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5fe3be44-3808-4c07-a651-80f9cb66498&amp;title=&amp;width=523" alt=""><br>先忘掉左中右, 目标是逐渐分解的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281818-8f55bc3d-600b-4fe1-9a28-194a2e14b313.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=uc72a3d6d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=632&amp;originWidth=1309&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9972a330-30f9-4bb4-b8c7-08fe6f74d00&amp;title=&amp;width=560" alt=""><br><strong>抽象</strong><br>i: 1~i的圆盘需要移动<br>F: 1~i的圆盘现在处在什么圆盘上, 可能是左, 中, 右<br>t: 需要去的位置, 可能是左, 中, 右<br>other: 除了from, to的另外一个位置<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028281875-9d349353-6eed-4b5a-9c10-e6e7433d67c4.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=290&amp;id=ua78ed761&amp;margin=%5Bobject%20Object%5D&amp;originHeight=633&amp;originWidth=1251&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ued654e3c-92fc-4ef3-a314-9c63cc17362&amp;title=&amp;width=574" alt=""><br><strong>代码</strong><br>i层的圆盘没有任何道理是在other上<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358889-bf247fdd-e580-4abd-8d24-c40995fab0f6.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=316&amp;id=u5e1ef882&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=1171&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d288535-fb85-41b3-98d3-2cf5fb5d4b2&amp;title=&amp;width=591" alt=""><br>如果index还在From上, 说明第一大步没走完<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358848-516f2145-a3f9-46ba-81c9-e9ce28edee97.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=293&amp;id=u07d3b69a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=651&amp;originWidth=1255&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u48e1996c-d742-490a-96d7-66c6462a3a3&amp;title=&amp;width=565" alt=""><br><strong>n层汉诺塔最优解</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028358910-0c4cbbd5-0292-44fe-b9d6-b53981389b71.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=ua0d8af67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=654&amp;originWidth=879&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d18edcc-fa98-42fc-8d83-170aa0206d6&amp;title=&amp;width=386" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028378401-1aa4cb61-81e0-4606-934e-dbf7cd028030.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u5785399a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=612&amp;originWidth=1203&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uea4922b0-8da4-4a95-abb3-8986b68ee4c&amp;title=&amp;width=491" alt=""><br>后续有任何一点点无效，你整体就无效</p><p>| <strong>public static int </strong>kth<strong>(int[] </strong>arr<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>return </strong>step<strong>(</strong>arr, N - 1, 1, 3, 2<strong>)</strong>;<br>**}</p><p><strong>// 0…index这些圆盘，arr[0..index] index+1层塔<br>// 在哪？from 去哪？to 另一个是啥？other<br>// arr[0..index]这些状态，是index+1层汉诺塔问题的，最优解第几步</strong>public static int <strong>step</strong>(int[] <strong>arr, </strong>int <strong>index, </strong>int <strong>from, </strong>int <strong>to, </strong>int <strong>other</strong>) {<br>   if (<strong>index == -1</strong>) {<br>      return <strong>0;   </strong>}<br>   if (<strong>arr</strong>[<strong>index</strong>] <strong>== other</strong>) {<br>      return <strong>-1;   </strong>}<br>   <strong>/</strong>多想想就明白了</p><pre><code>* 比如 arr[3,2,1] 三层汉诺塔问题** 第一个在to区* 第二个在**/</code></pre><p>   // arr[index] == from arr[index] == to;<br>   <strong>if (</strong>arr<strong>[</strong>index<strong>] </strong>== from<strong>) {<br>      return </strong>step<strong>(</strong>arr, index - 1, from, other, to<strong>)</strong>;<br>   <strong>} else {<br>      int </strong>p1 = <strong>(</strong>1 &lt;&lt; index<strong>) </strong>- 1;<br>      <strong>int </strong>p2 = 1;<br>      <strong>int </strong>p3 = step<strong>(</strong>arr, index - 1, other, to, from<strong>)</strong>;<br>      <strong>if (</strong>p3 == -1<strong>) {<br>         return </strong>-1;<br>      <strong>}<br>      return </strong>p1 + p2 + p3;<br>   <strong>}<br>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>单决策递归<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653028426636-08060a50-74cc-4c62-8e62-424f512cf88c.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=338&amp;id=u443ec777&amp;margin=%5Bobject%20Object%5D&amp;originHeight=634&amp;originWidth=943&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u203f3cdf-b1ab-456b-b0c3-d0034313049&amp;title=&amp;width=502" alt=""></p><h2 id="·-两个有序数组间相加和的Topk问题"><a href="#·-两个有序数组间相加和的Topk问题" class="headerlink" title="· 两个有序数组间相加和的Topk问题"></a>· 两个有序数组间相加和的Topk问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652539251891-3de0d850-c8d0-4239-a81d-fa1a2210426c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=414&amp;id=ue5640a4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=830&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43271&amp;status=done&amp;style=none&amp;taskId=u6feb9167-120c-415a-b74d-95ac0e48b98&amp;title=&amp;width=664" alt="image.png"><br>用大根堆<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031978240-dce8b855-e997-478e-933a-aab5c7268225.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=u92e50c4d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82696&amp;status=done&amp;style=none&amp;taskId=ue0cf5ae5-f712-4140-aac0-9aa695e0286&amp;title=&amp;width=456.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653031989072-10c19f0a-4015-407a-8fb7-176cef820206.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=u9583c67c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=90083&amp;status=done&amp;style=none&amp;taskId=ufffa987b-c980-44a0-89a3-38926c6b62d&amp;title=&amp;width=478.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032000117-c9d348c8-6b94-4a91-a50e-1a47217c9b57.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u80c59775&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=646&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119662&amp;status=done&amp;style=none&amp;taskId=udb562210-be25-49bb-981b-b2ccf26efe2&amp;title=&amp;width=516.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032013255-95030714-b09e-4f25-a865-2758167fb7b1.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u49edc7c2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=649&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=146468&amp;status=done&amp;style=none&amp;taskId=u5745c217-4dbe-4db4-b967-7cfbd0548ac&amp;title=&amp;width=519.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032038337-4b6eddac-52e2-40b0-ac4f-694be2af4927.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u7efe8179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=638&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145293&amp;status=done&amp;style=none&amp;taskId=uc4397788-c306-4e30-b954-1c34575127e&amp;title=&amp;width=510.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653032058547-5ce5c648-4d2f-4c69-a0ca-51424b5f5c83.png#clientId=uf4c6500d-8e60-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=uec145c06&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=317&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=38852&amp;status=done&amp;style=none&amp;taskId=uee16e7db-0793-4ade-bcf7-ae43094fe60&amp;title=&amp;width=420" alt="image.png"></p><p>| // 放入大根堆中的结构<br><strong>public static class </strong>Node <strong>{<br>   public int index1</strong>;// arr1中的位置<br>   <strong>public int index2</strong>;// arr2中的位置<br>   <strong>public int sum</strong>;// arr1[index1] + arr2[index2]的值</p><p>   <strong>public </strong>Node<strong>(int </strong>i1, <strong>int </strong>i2, <strong>int </strong>s<strong>) {<br>      index1 </strong>= i1;<br>      <strong>index2 </strong>= i2;<br>      <strong>sum </strong>= s;<br>   **}<br>}</p><p><strong>// 生成大根堆的比较器</strong>public static class <strong>MaxHeapComp </strong>implements <strong>Comparator</strong>&lt;<strong>Node</strong>&gt; {<br>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Node o1, Node o2</strong>) {<br>      return <strong>o2.</strong>sum <strong>- o1.</strong>sum<strong>;   </strong>}<br>}</p><p>public static int[] <strong>topKSum</strong>(int[] <strong>arr1, </strong>int[] <strong>arr2, </strong>int <strong>topK</strong>) {<br>   if (<strong>arr1 == </strong>null <strong>&#124;&#124; arr2 == </strong>null <strong>&#124;&#124; topK &lt; 1</strong>) {<br>      return null<strong>;   </strong>}<br>   int <strong>N = arr1.</strong>length<strong>;   </strong>int <strong>M = arr2.</strong>length**;</p><p>   topK = Math.min<strong>(</strong>topK, N <em> M<em>*)</em></em>;</p><p>   <strong>int[] </strong>res = <strong>new int[</strong>topK<strong>]</strong>;<br>   <strong>int </strong>resIndex = 0;</p><p>   PriorityQueue<strong>&lt;</strong>Node<strong>&gt; </strong>maxHeap = <strong>new </strong>PriorityQueue<strong>&lt;&gt;(new </strong>MaxHeapComp<strong>())</strong>;<br>   HashSet<strong>&lt;</strong>Long<strong>&gt; </strong>set = <strong>new </strong>HashSet<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>i1 = N - 1;<br>   <strong>int </strong>i2 = M - 1;<br>   maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1, i2, arr1<strong>[</strong>i1<strong>] </strong>+ arr2<strong>[</strong>i2<strong>]))</strong>;<br>   set.add<strong>(</strong>x<strong>(</strong>i1, i2, M<strong>))</strong>;//二维变一维<br>   <strong>while (</strong>resIndex != topK<strong>) {      </strong>Node curNode = maxHeap.poll<strong>()</strong>;<br>      res<strong>[</strong>resIndex++<strong>] </strong>= curNode.<strong>sum</strong>;<br>      i1 = curNode.<strong>index1</strong>;<br>      i2 = curNode.<strong>index2</strong>;<br>      set.remove<strong>(</strong>x<strong>(</strong>i1, i2, M<strong>))</strong>;<br>      <strong>if (</strong>i1 - 1 &gt;= 0 &amp;&amp; !set.contains<strong>(</strong>x<strong>(</strong>i1 - 1, i2, M<strong>))) {         </strong>set.add<strong>(</strong>x<strong>(</strong>i1 - 1, i2, M<strong>))</strong>;<br>         maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1 - 1, i2, arr1<strong>[</strong>i1 - 1<strong>] </strong>+ arr2<strong>[</strong>i2<strong>]))</strong>;<br>      <strong>}<br>      if (</strong>i2 - 1 &gt;= 0 &amp;&amp; !set.contains<strong>(</strong>x<strong>(</strong>i1, i2 - 1, M<strong>))) {         </strong>set.add<strong>(</strong>x<strong>(</strong>i1, i2 - 1, M<strong>))</strong>;<br>         maxHeap.add<strong>(new </strong>Node<strong>(</strong>i1, i2 - 1, arr1<strong>[</strong>i1<strong>] </strong>+ arr2<strong>[</strong>i2 - 1<strong>]))</strong>;<br>      <strong>}<br>   }<br>   return </strong>res;<br>**}</p><p>public static long <strong>x</strong>(int <strong>i1, </strong>int <strong>i2, </strong>int <strong>M</strong>) {<br>   return (long) <strong>i1 * </strong>(long) <strong>M + </strong>(long) <strong>i2;</strong>}</p><p>** |<br>| —- |</p><h2 id="·-42-接雨水-H"><a href="#·-42-接雨水-H" class="headerlink" title="· 42. 接雨水 [H]"></a>· 42. 接雨水 [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267273178-987b1982-ef81-4324-8306-8f79b8e3d6ff.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=353&amp;id=u9a387aaa&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=441&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33271&amp;status=done&amp;style=none&amp;taskId=u7e5d0662-374f-45a2-926d-fe2e07cee61&amp;title=&amp;width=665.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1653183809624-bfe54faa-fc8e-4c66-a37c-99bf00c7ccb2.png#clientId=u9486b31d-676a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=uc43d2755&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=359&amp;originWidth=905&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17507&amp;status=done&amp;style=none&amp;taskId=u90fb9776-20c1-498f-95f0-ab5a02da7b7&amp;title=&amp;width=724" alt="image.png"><br><strong>题意</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323108-3482efdf-9617-4893-953d-ccef84395862.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uf94fe60c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=484&amp;originWidth=855&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue2587b40-59ad-4b39-8b70-6184ba23117&amp;title=&amp;width=490" alt=""><br><strong>题解</strong><br>跟踪坡峰坡谷的Coding解法不正确<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323100-9d08de8c-b1e3-4f1d-9d28-813b0490efef.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=u98c83e06&amp;margin=%5Bobject%20Object%5D&amp;originHeight=366&amp;originWidth=986&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c3e4756-b5a8-4817-8a39-e247925cb50&amp;title=&amp;width=578" alt=""><br>i位置自己整个位置上方有几格水?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323023-37d28c90-8cf6-460d-96e9-9cf07801d95d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=298&amp;id=u691728f9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=984&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5e997542-0ba1-4e3b-9bf7-b430884218a&amp;title=&amp;width=614" alt=""><br>边界情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268323022-bf49b7ca-7a22-499d-89e4-9ba96be952dc.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=319&amp;id=u185b9d89&amp;margin=%5Bobject%20Object%5D&amp;originHeight=399&amp;originWidth=681&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1a037bb2-07a4-406b-b36a-a860e287ed7&amp;title=&amp;width=545" alt=""><br>i位置的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268325675-aeb3f9d1-c2fd-4218-89f5-368d9ac0bf4f.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ua64db485&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=960&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4474289a-e974-4f64-822b-7bed7e7cc27&amp;title=&amp;width=506" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326254-52267b69-79ad-4bf9-9fa8-cd8d26a94a8d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=292&amp;id=u4434b4f8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5338f041-b732-47d3-b061-8a59c39d9b4&amp;title=&amp;width=587" alt=""><br><strong>辅助数组</strong><br>需要0~i范围上的最大值max<br>i~N-1范围上的最大值max<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326340-b8cc0df3-73c2-4d4e-a267-dbe509ac09a4.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=358&amp;id=u3182ff51&amp;margin=%5Bobject%20Object%5D&amp;originHeight=471&amp;originWidth=710&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e3ff214-4949-458e-a458-e98f1d2275a&amp;title=&amp;width=540" alt=""><br><strong>最优解</strong><br>不需要辅助数组<br>0位置最左 20位置最右是不可能留下水的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326487-100d9b8f-7d1c-416f-9c3f-d57fed517bdc.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue35ef49f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=1065&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5f3ada90-3915-4cab-ae55-b2018430e01&amp;title=" alt=""><br>19位置的最大高度假设6, 要结算算水量<br>需要求6的左边, 右边部分的max, 以13做瓶颈,<br>因为6它的左边这么多最大值还没看过，但它的最大值是17，恐怕它真实的左边最大值是大于17的。<br>而我右边的最大值，这可是个真实最大值, 所以6位置的水量就是13-6 = 7 格子水<br>左边跟右边max谁小就先结算那边的水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268326627-e696ef0d-bcf9-4c31-b14d-f8340253c3b2.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=278&amp;id=uac262f4d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=1063&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uecb45efd-f557-48a5-b00f-d7bd73562f1&amp;title=&amp;width=635" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327142-fa9a9589-71a6-4d59-aa66-b7c33cee30c5.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u4c693001&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=1067&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2adf84f1-1a9b-4fe1-b0a8-886ae13e2cf&amp;title=&amp;width=564" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327723-c5a819e2-e219-4a73-a4fb-5d3e37bc01c7.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u59b410f0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1074&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u401cfdd3-d2fd-4b7e-9f90-aa11bcb92b4&amp;title=&amp;width=568" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268327914-13401c07-43a7-45f0-b9fb-be52bf672963.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u0fcb1059&amp;margin=%5Bobject%20Object%5D&amp;originHeight=478&amp;originWidth=1075&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u33092d65-5421-468c-961f-251f018357f&amp;title=&amp;width=562" alt=""><br>相等怎么办<br>可以一起结算<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328197-0ef67c95-b205-4b96-bb3b-4861e493c575.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=197&amp;id=u58c81a8a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=340&amp;originWidth=1038&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d5765fc-e857-484a-bb9b-b63c2ef9a07&amp;title=&amp;width=602" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328220-048d534c-040c-4157-851b-81ffab6e636e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=ub7259426&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud895d562-3d89-4df9-973d-e6e4a3153f3&amp;title=&amp;width=557" alt=""><br><strong>代码</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268328354-f6461e69-c9fc-464e-b55d-98e8f7a989f6.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2f50eac9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=381&amp;originWidth=433&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufd62e68c-e8d6-4953-ae67-65811a0750c&amp;title=" alt=""></p><h2 id="·-✊407-接雨水-II-H"><a href="#·-✊407-接雨水-II-H" class="headerlink" title="· ✊407. 接雨水 II [H]"></a>· ✊407. 接雨水 II [H]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652267310891-9ae51e62-eb36-4c3d-aecf-42757c8bc9da.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=424&amp;id=u4348eeb0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=633&amp;originWidth=921&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=167029&amp;status=done&amp;style=none&amp;taskId=u12c089cc-f48c-4fe5-b32a-f49a6ad36f5&amp;title=&amp;width=616.7999877929688" alt="image.png"><br><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567058-f79a7202-de25-40fb-a9e7-36ee14452e6c.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=uf198170f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=835&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc30f9554-6db3-457f-b0f2-32d091524b1&amp;title=&amp;width=489" alt=""><br><strong>题解</strong><br>这一圈的值放到小根堆去<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566883-18c6b4b4-30c6-4a82-a82a-59b43835a5db.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=u3d5807f8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=806&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u427cc3c0-49d7-4081-aa59-7229fad2c68&amp;title=&amp;width=542" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566896-0282f120-5392-4308-9d6e-ecdfee83e80e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=266&amp;id=u9d229db5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=449&amp;originWidth=1004&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u218c752a-31e6-48f8-919c-307b08a911f&amp;title=&amp;width=595" alt=""><br>都会以max做为瓶颈<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268567083-2497db05-4afd-4681-82b4-112847d15636.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=316&amp;id=u799526e3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=498&amp;originWidth=957&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc83a1690-d0de-4210-95ad-eb1fbc9439e&amp;title=&amp;width=608" alt=""><br>只要max不更新, 都是max的内湖区域<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268566876-7b3a2096-ce22-4ac5-90e4-10ffa818dc49.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=319&amp;id=u8728c50f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=480&amp;originWidth=916&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae7d39ad-2aa8-4dd3-922b-4deb1c5a810&amp;title=&amp;width=608" alt=""><br><strong>例子</strong><br>一个数进去的时候结算水量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568452-8d0329f2-01e6-457a-af5e-535b96a0aa9e.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=324&amp;id=u2d7d0a44&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=962&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2363d263-1b25-4389-b468-1c17f534e8d&amp;title=&amp;width=642" alt=""><br><strong>代码</strong><br>max不更新就说明出海口就没有变</p><p>| <strong>public static class </strong>Node <strong>{<br>   public int value</strong>;<br>   <strong>public int row</strong>;<br>   <strong>public int col</strong>;</p><p>   <strong>public </strong>Node<strong>(int </strong>v, <strong>int </strong>r, <strong>int </strong>c<strong>) {<br>      value </strong>= v;<br>      <strong>row </strong>= r;<br>      <strong>col </strong>= c;<br>   **}</p><p>}</p><p>public static int <strong>trapRainWater</strong>(int[][] <strong>heightMap</strong>) {<br>   if (<strong>heightMap == </strong>null <strong>&#124;&#124; heightMap.</strong>length <strong>== 0 &#124;&#124; heightMap</strong>[<strong>0</strong>] <strong>== </strong>null <strong>&#124;&#124; heightMap</strong>[<strong>0</strong>]<strong>.</strong>length <strong>== 0</strong>) {<br>      return <strong>0;   </strong>}<br>   int <strong>N = heightMap.</strong>length<strong>;   </strong>int <strong>M = heightMap</strong>[<strong>0</strong>]<strong>.</strong>length<strong>;   </strong>boolean[][] <strong>isEnter = </strong>new boolean[<strong>N</strong>][<strong>M</strong>]<strong>;<br>   PriorityQueue</strong>&lt;<strong>Node</strong>&gt; <strong>heap = </strong>new <strong>PriorityQueue</strong>&lt;&gt;((<strong>a, b</strong>) <strong>-&gt; a.</strong>value <strong>- b.</strong>value)<strong>;   </strong>for (int <strong>col = 0; col &lt; M - 1; col++</strong>) {<br>      <strong>isEnter</strong>[<strong>0</strong>][<strong>col</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>0</strong>][<strong>col</strong>]<strong>, 0, col</strong>))<strong>;   </strong>}<br>   for (int <strong>row = 0; row &lt; N - 1; row++</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>M - 1</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>M - 1</strong>]<strong>, row, M - 1</strong>))<strong>;   </strong>}<br>   for (int <strong>col = M - 1; col &gt; 0; col—</strong>) {<br>      <strong>isEnter</strong>[<strong>N - 1</strong>][<strong>col</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>N - 1</strong>][<strong>col</strong>]<strong>, N - 1, col</strong>))<strong>;   </strong>}<br>   for (int <strong>row = N - 1; row &gt; 0; row—</strong>) {<br>      <strong>isEnter</strong>[<strong>row</strong>][<strong>0</strong>] <strong>= </strong>true<strong>;<br>      heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>row</strong>][<strong>0</strong>]<strong>, row, 0</strong>))<strong>;   </strong>}<br>   int <strong>water = 0;   </strong>int <strong>max = 0;   </strong>while (<strong>!heap.isEmpty</strong>()) {<br>      <strong>Node cur = heap.poll</strong>()<strong>;<br>      max = Math.max</strong>(<strong>max, cur.</strong>value)<strong>;      </strong>int <strong>r = cur.</strong>row<strong>;      </strong>int <strong>c = cur.</strong>col<strong>;<br>      //上下左右去放<br>      //有上面      </strong>if (<strong>r &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>])<strong>;<br>         isEnter</strong>[<strong>r - 1</strong>][<strong>c</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r - 1</strong>][<strong>c</strong>]<strong>, r - 1, c</strong>))<strong>;      </strong>}<br>      <strong>//有下      </strong>if (<strong>r &lt; N - 1 &amp;&amp; !isEnter</strong>[<strong>r + 1</strong>][<strong>c</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r + 1</strong>][<strong>c</strong>])<strong>;<br>         isEnter</strong>[<strong>r + 1</strong>][<strong>c</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r + 1</strong>][<strong>c</strong>]<strong>, r + 1, c</strong>))<strong>;      </strong>}<br>      <strong>//有左      </strong>if (<strong>c &gt; 0 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>])<strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c - 1</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c - 1</strong>]<strong>, r, c - 1</strong>))<strong>;      </strong>}<br>      <strong>//有右      </strong>if (<strong>c &lt; M - 1 &amp;&amp; !isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>]) {<br>         <strong>water += Math.max</strong>(<strong>0, max - heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>])<strong>;<br>         isEnter</strong>[<strong>r</strong>][<strong>c + 1</strong>] <strong>= </strong>true<strong>;<br>         heap.add</strong>(new <strong>Node</strong>(<strong>heightMap</strong>[<strong>r</strong>][<strong>c + 1</strong>]<strong>, r, c + 1</strong>))<strong>;      </strong>}<br>   }<br>   return <strong>water;</strong>}** |<br>| —- |</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652268568940-16d91986-3ce5-4170-995b-25e5eb327a2d.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=333&amp;id=ua197f36f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=560&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5856214b-6641-45ba-838e-b397b8823c9&amp;title=&amp;width=378" alt=""></p><h2 id="·-找出最大的左部分最大值减去右部分最大值的绝对值"><a href="#·-找出最大的左部分最大值减去右部分最大值的绝对值" class="headerlink" title="· 找出最大的左部分最大值减去右部分最大值的绝对值"></a>· 找出最大的左部分最大值减去右部分最大值的绝对值</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652270318016-0e37cdc1-b8e3-47ba-bf01-6f42eb4e6247.png#clientId=u8f57a630-644c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=ua69a96f6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=816&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17778&amp;status=done&amp;style=none&amp;taskId=u26260abf-215f-42d6-9e95-5f6eace034c&amp;title=&amp;width=652.8" alt="image.png"><br><strong>题意</strong><br>所以你每切一刀都会有一个左部分的最大值，减去右部分的最大值的绝对值<br>一共有N-1种切法。那么哪一种切法下，这个值能最大, 把这个最大的结果返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009637-2441118c-f8dd-47dd-afef-1bf81668b74a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=pClpf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=1223&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5f94afae-e9f4-41ae-8f51-6fb3c2947e8&amp;title=&amp;width=485" alt=""><br><strong>题解</strong><br>暴力: 遍历<br>当我来到i位置的时候, 0~i是左部分, i+1~N-1是右部分, 枚举i, 遍历一下找左右部分的最大值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009601-259b07db-0b03-422c-aa80-7360e0e29474.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=zBUSt&amp;margin=%5Bobject%20Object%5D&amp;originHeight=525&amp;originWidth=1171&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u68d556cd-13fd-4bfa-b226-e655edba474&amp;title=&amp;width=605" alt=""><br><strong>辅助数组</strong><br>left数组: 记录0~i范围上的最大值<br>当前数跟前一个位置的数, 谁大拷贝谁</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009616-8360c1b6-bd21-47cf-b05a-4894b6301470.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=w2PrR&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=1020&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue3dd0bbc-0eb9-4eda-8708-0ac0d2dcf67&amp;title=&amp;width=656" alt=""><br>right数组:从右往左生成,i+1~N-1范围上的最大值<br>有了两个辅助数组, 再去枚举i的时候<br>0~i范围上的最大值直接从left数组里取, i+1~N-1范围上的最大值直接从right数组里拿<br>把O(N^2)的暴力解优化成O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009605-dbca0f91-6ad8-4748-9f10-8885d7311c83.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=337&amp;id=qF9iP&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1035&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8518c4be-731f-43bd-910f-44af73685c7&amp;title=&amp;width=690" alt=""></p><p>| <strong>public static int </strong>maxABS2<strong>(int[] </strong>arr<strong>) {<br>   int[] </strong>lArr = <strong>new int[</strong>arr.<strong>length]</strong>;<br>   <strong>int[] </strong>rArr = <strong>new int[</strong>arr.<strong>length]</strong>;<br>   lArr<strong>[</strong>0<strong>] </strong>= arr<strong>[</strong>0<strong>]</strong>;<br>   rArr<strong>[</strong>arr.<strong>length </strong>- 1<strong>] </strong>= arr<strong>[</strong>arr.<strong>length </strong>- 1<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>lArr<strong>[</strong>i<strong>] </strong>= Math.max<strong>(</strong>lArr<strong>[</strong>i - 1<strong>]</strong>, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   for (int </strong>i = arr.<strong>length </strong>- 2; i &gt; -1; i—<strong>) {      </strong>rArr<strong>[</strong>i<strong>] </strong>= Math.max<strong>(</strong>rArr<strong>[</strong>i + 1<strong>]</strong>, arr<strong>[</strong>i<strong>])</strong>;<br>   <strong>}<br>   int </strong>max = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length </strong>- 1; i++<strong>) {      </strong>max = Math.max<strong>(</strong>max, Math.abs<strong>(</strong>lArr<strong>[</strong>i<strong>] </strong>- rArr<strong>[</strong>i + 1<strong>]))</strong>;<br>   <strong>}<br>   return </strong>max;<br><strong>}</strong> |<br>| —- |</p><p><strong>最优解</strong><br>arr 遍历一遍找到全局最大值, 然后0位置数跟N-1位置数, 谁小减谁就是答案<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532009794-49174c11-7c15-4f33-86e2-e55388ed91d5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=cLoHI&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=885&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c009e6b-c545-4de7-913a-67aee64f8ad&amp;title=&amp;width=519" alt=""><br>可能性罗列<br>1) 全局max被划分到了左边<br>2) 全局max被划分到了右边</p><p>1) max - 右边的最大值就是答案<br>让右max尽量小<br>右部分一定要有数, 一定会包含N-1位置的数<br>右部分只包含最右边一个数是右边max最小的时候<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010132-31eed44f-ffcb-4639-bc25-e746726c22ef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=D4cKJ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=453&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3d6af354-eb1a-467a-8e6e-9faad6833e9&amp;title=" alt=""><br>2)<br>左max尽量小, 左部分一定会包含0位置的数<br>就让左部分只包含0位置的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532010235-2ac3a3a2-5e64-4573-90c1-1ce1513e4177.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=dhLOT&amp;margin=%5Bobject%20Object%5D&amp;originHeight=505&amp;originWidth=1030&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue7dd0c92-9bcb-4ee3-ae1f-c25a9700fb7&amp;title=" alt=""><br><strong>代码</strong></p><p>| //amazing！<br><strong>public static int </strong>maxABS3<strong>(int[] </strong>arr<strong>) {<br>   int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>max = Math.max<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, max<strong>)</strong>;<br>   <strong>}<br>   return </strong>max - Math.min<strong>(</strong>arr<strong>[</strong>0<strong>]</strong>, arr<strong>[</strong>arr.<strong>length </strong>- 1<strong>])</strong>;<br><strong>}</strong> |<br>| —- |</p><h2 id="·-✊最大可整合子数组的长度"><a href="#·-✊最大可整合子数组的长度" class="headerlink" title="· ✊最大可整合子数组的长度"></a>· ✊最大可整合子数组的长度</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532365836-3c8093cf-782d-4f0e-854a-8c3427e0a834.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=244&amp;id=u867734bf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61875&amp;status=done&amp;style=none&amp;taskId=u53f84319-b0b7-4cfb-9d4d-beafbf2b477&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题意</strong><br>排完序之后依次加1得到就是可整合<br>只要有重复值，它就没办法做可整合数组</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386766-8b1f7bae-ec0c-4109-bd44-011cacc7d351.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=289&amp;id=ua84eeb28&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=581&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u015f7cff-9f62-4bfc-954d-9440e8dd640&amp;title=&amp;width=396" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386782-0ba22845-7afc-4f9e-a81b-9283c470caba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=u3850d3b2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=438&amp;originWidth=728&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubb9990b4-f7ff-479c-94d4-943e8d57ac3&amp;title=&amp;width=449" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386975-f5f84998-bdcd-4f75-8fb4-702dc86cb261.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=udf385003&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=782&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1d425bbc-9f7b-4f84-bf26-d91fcd501fa&amp;title=&amp;width=462" alt=""><br>哪一个子数组是可整合的而且最长, 返回最长长度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386935-72cadf66-19f6-4562-b619-f95e67f91c55.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=212&amp;id=u6cceb4e0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=694&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4089eb32-f3bb-4b90-9c15-e35b315eb17&amp;title=&amp;width=491" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532386866-d20c76bd-4969-4bce-ad9b-c784eb6a76a2.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=224&amp;id=u7df7ee5c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=387&amp;originWidth=902&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua502ac2b-174e-47d6-b4d4-4187fa647f2&amp;title=&amp;width=521" alt=""><br>不能排序<br>因为他问的就是你原始arr的数据状况，最长可整合子数组是啥？<br>排完序0,1,2原数组没有这个子数组<br>原数据状况是不能够动的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387154-7c295c6a-1838-45a2-ae75-508ced86774f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=320&amp;id=u735cfd92&amp;margin=%5Bobject%20Object%5D&amp;originHeight=451&amp;originWidth=882&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0882a71c-1ed1-4ec5-bce0-e4fbd3b9685&amp;title=&amp;width=625" alt=""><br><strong>题解</strong><br>不能用滑动窗口, 没有单调性<br>因为如果一个窗口是可整合的, 它扩大或缩小不一定可整合<br>子数组范围这件事和可整合这件事建立不起单调性。<br>能用滑动窗口的最重要的性质就是某种范围上的单调性<br>子数组范围扩大了，或者子数组范围缩小了，对于可整合的东西，<br>它是有一定的单调性的，我菜可以去利用，而本题是没有的。<br>所以滑动窗口也用不了。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387319-f3df4fef-b417-4636-bfc4-b098e97ad628.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=325&amp;id=u07077d33&amp;margin=%5Bobject%20Object%5D&amp;originHeight=483&amp;originWidth=738&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6d45fb4c-a596-4283-a50a-b3b83d3dd28&amp;title=&amp;width=496" alt=""><br><strong>暴力解:</strong><br>枚举所有子数组<br>比如说我验证从L到R这一段是不是可整合的,<br>可以把它拷贝出来, 拍完序再验证是不是可整合的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387425-c3b5c57f-08b3-4119-a9d3-65813f51fc17.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=307&amp;id=uf7a760b5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=435&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u83b81b1d-d7d6-49c7-ac07-77c4d2696e1&amp;title=&amp;width=636" alt=""><br><strong>复杂度</strong><br>子数组数量O(N^2), 子数组平均长度N<br>把子数组拷贝一下O(N), 子数组排序O(N<em>logN), 排序后的验证O(N)<br>取最高阶O(N</em>logN), 最终复杂度O(N^3<em>logN)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387470-931d4e55-faee-4d65-aaf2-82ec28e91d09.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=332&amp;id=u9026a328&amp;margin=%5Bobject%20Object%5D&amp;originHeight=496&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89e7ad6f-b03b-4734-b328-39d568514d8&amp;title=&amp;width=625" alt=""><br><em>*重新定义可整合数组标准！！！</em></em><br>1) 没有重复值<br>2) 数组最大值-最小值=个数-1<br>满足这两个条件就是可整合数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532387491-c2cc6771-68b6-4a63-a0ab-83e7c4f0ed43.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u4220dfc8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=965&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u23575989-4df0-4efb-a468-212b66ddbef&amp;title=&amp;width=532" alt=""><br>简化的过程</p><p>| <strong>public static int </strong>maxLen<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>== 0<strong>) {<br>      return </strong>0;<br>   <strong>}<br>   int </strong>N = arr.<strong>length</strong>;<br>   HashSet<strong>&lt;</strong>Integer<strong>&gt; </strong>set = <strong>new </strong>HashSet<strong>&lt;&gt;()</strong>;<br>   <strong>int </strong>ans = 1;//答案至少是1<br>   <strong>for (int </strong>L = 0; L &lt; N; L++<strong>) {      </strong>set.clear<strong>()</strong>;//因为r要归为<br>      <strong>int </strong>min = arr<strong>[</strong>L<strong>]</strong>;<br>      <strong>int </strong>max = arr<strong>[</strong>L<strong>]</strong>;<br>      set.add<strong>(</strong>arr<strong>[</strong>L<strong>])</strong>;<br>      // L..R<br>      <strong>for (int </strong>R = L + 1; R &lt; N; R++<strong>) {         </strong>// L….R<br>         <strong>if(</strong>set.contains<strong>(</strong>arr<strong>[</strong>R<strong>])) {<br>            break</strong>;<br>         <strong>}         </strong>set.add<strong>(</strong>arr<strong>[</strong>R<strong>])</strong>;<br>         min = Math.min<strong>(</strong>min, arr<strong>[</strong>R<strong>])</strong>;//可能r的值更小<br>         max = Math.max<strong>(</strong>max, arr<strong>[</strong>R<strong>])</strong>;//也可能r的值更大<br>         //个数：R-L+1,再减个1<br>         <strong>if(</strong>max - min == R - L<strong>) {            </strong>ans = Math.max<strong>(</strong>ans, R - L + 1<strong>)</strong>;<br>         <strong>}<br>      }<br>   }<br>   return </strong>ans;</p><p><strong>}</strong> |<br>| —- |</p><p><strong>总结: 改题目的设定让它变得更简洁</strong><br>就是当你发现，比如说面试场上给了你一道题，它的定义部分让你求解的部分是如此之复杂。<br>你不要硬着头皮，就按照他的说法就硬上了，你要改成你自己的定义。比如说我们把这个就<br>拆分成了系统最大值减两头这样一个问题，把可整合数组重新写了定义之后，能让我们验证<br>可整合这个过程变快，这种就属于在面试场上遇到了一类，它给你来一个设定，但是你要改<br>它的设定让它变得更简洁的。要有这个心眼，你发现这道题目设定的部分写得特别的绕。<br>那说明它可能不够简洁，这时要有一个心眼，就是要改设定。这样改设定的题型很多，<br>我们以后遇到再说。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532543649-53d3de55-8561-4ff0-add7-817357bd81ac.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=u7ad3e556&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=1002&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ce4aaab-9297-47d3-9ce8-fbaa226b91f&amp;title=&amp;width=474" alt=""></p><h2 id="·-✊超级水王问题"><a href="#·-✊超级水王问题" class="headerlink" title="· ✊超级水王问题"></a>· ✊超级水王问题</h2><p><strong>题意</strong><br>我给你个数组，如果有水王数你打印出来，如果无水王数，你告诉用户没有<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564573-18f0aae5-4c48-4583-a5fc-908f05f918aa.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=246&amp;id=ub63ef09a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=475&amp;originWidth=946&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueb3f9d95-2385-4717-ab8a-502c4ce9c0f&amp;title=&amp;width=489" alt=""><br>要求时间复杂度O(N)<br>空间复杂度O(1)<br>把用hash表的路堵死了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564812-7f6017f2-4972-4dde-b65e-5065ad21c9b5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=252&amp;id=ua3b9fe6a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=455&amp;originWidth=963&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u345c305d-94e0-4908-a782-ea6311d8772&amp;title=&amp;width=533" alt=""><br><strong>题解</strong><br>一次删掉两个不同值的数, 如果arr中真的有水王的话, 这个水王数一定会剩下来<br>因为水王数是大于一半的次数的。哪怕其它所有的数字都跟水王数为敌<br>水王数也会活下来, 更不用说其它数字之间还会有内战的情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564621-4c4d07c4-1905-4d22-8161-ba7827127276.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=220&amp;id=ud9c14c93&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uac5cb9f7-4ed2-4d56-99bd-234e14ca061&amp;title=&amp;width=470" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564724-40df89be-6e7c-479d-b755-0479f9168ce6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1df2e5b3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=144&amp;originWidth=382&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u94cefb0a-39fc-4749-88dc-a340c7f447b&amp;title=" alt=""><br>arr一次删掉两个不同的数, 最后剩下的数一定是水王吗?<br>不一定是水王<br>如果有水王的话, 一定会剩下来<br>如果没有水王的话, 如果剩下来的数都不是水王，那就没有数是了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532564674-454bc6b4-a8ff-479c-938b-e6e9a24a390d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua49eec8c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=143&amp;originWidth=421&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1cb3b4b7-b9f8-4379-a900-ef09a62f703&amp;title=" alt=""><br><strong>思路</strong><br>1) arr 一次删除两个不同值的数, 看最终谁会剩下来</p><p>可能性<br>1: 没有数字剩下来: 无水王数<br>2: 有数剩下来<br>x剩下来, 再遍历看x真实出现的次数跟N/2对比</p><p><strong>怎么一次删除两个不同的数?</strong><br>时间复杂度O(N)<br>空间复杂度O(1)<br>两个变量<br>1) 候选cand<br>2) 血量hp<br>当血量=0, 认为没有候选人<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565245-13d042e9-15ce-451f-9d00-22fb6b8c37eb.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=228&amp;id=u22eda463&amp;margin=%5Bobject%20Object%5D&amp;originHeight=431&amp;originWidth=1026&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua04fdaf1-7f3e-4a6d-9286-dad2914a968&amp;title=&amp;width=542" alt=""><br><strong>流程</strong><br>一个一个数遍历, 三条规则:<br>1) 如果没有候选, 当前数立为候选, 血量+1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565228-0cb5c6f0-77d1-4a27-9618-82f95127135e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=229&amp;id=u3e918b1a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=399&amp;originWidth=1021&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8d87f13b-7fc7-4e50-aa59-77782c0c05d&amp;title=&amp;width=585" alt=""><br>2) 如果有候选<br>    1)当前数跟候选不一样,血量—<br>    2)当前数是候选,血量++<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565221-c7dde5a0-148c-4fc2-9ce8-9c33a38b526a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u9c9600a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=1032&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c27cf79-9f62-4684-95ac-0cb1bb50623&amp;title=&amp;width=571" alt=""><br>解释</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565427-1f53495a-7f90-4a2e-b08b-43af2f9f0147.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=296&amp;id=u1cb7e569&amp;margin=%5Bobject%20Object%5D&amp;originHeight=506&amp;originWidth=1011&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf9fba9e6-c81e-4f75-a1bc-54ac7326b4d&amp;title=&amp;width=592" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565702-b20446ee-a34b-4303-85dc-18bfb790a1ab.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=u81618e25&amp;margin=%5Bobject%20Object%5D&amp;originHeight=497&amp;originWidth=1022&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua102ae15-5ac8-4490-a8d4-6d41c0048d7&amp;title=&amp;width=623" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565738-f2a9bd97-215c-4362-9d4d-23af8dc985b1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=305&amp;id=u9538e7a3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=1009&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u72d5eca0-0819-455a-bb9a-c4de485e2ab&amp;title=&amp;width=634" alt=""><br>遍历完成后,如果血量=0,表示什么数也没有剩下来,如果血量不等于零，候选就是剩下来的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532565794-847db360-2964-4094-8ffe-a086883180e7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=u676fec88&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=904&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e114edf-2d28-4477-a82d-92b2a494048&amp;title=&amp;width=634" alt=""><br><strong>代码</strong></p><p>| <strong>public static void </strong>printHalfMajor<strong>(int[] </strong>arr<strong>) {<br>   int </strong>cand = 0;<br>   <strong>int </strong>HP = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>HP == 0<strong>) {         </strong>cand = arr<strong>[</strong>i<strong>]</strong>;<br>         HP = 1;<br>      <strong>} else if (</strong>arr<strong>[</strong>i<strong>] </strong>== cand<strong>) {         </strong>HP++;<br>      <strong>} else {         </strong>HP—;<br>      <strong>}<br>   }<br>   if(</strong>HP == 0<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“no such number.”)</strong>;<br>      <strong>return</strong>;<br>   <strong>}   </strong>HP = 0;<br>   <strong>for (int </strong>i = 0; i &lt; arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>== cand<strong>) {         </strong>HP++;<br>      <strong>}<br>   }<br>   if (</strong>HP &gt; arr.<strong>length </strong>/ 2<strong>) {      </strong>System.<strong>out</strong>.println<strong>(</strong>cand<strong>)</strong>;<br>   <strong>} else {      </strong>System.<strong>out</strong>.println<strong>(“no such number.”)</strong>;<br>   <strong>}<br>}</strong> |<br>| —- |</p><p><strong>扩展</strong><br>给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N/K，打印这些数，如果没有不打印</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692268-ec19fdb8-d919-4ff4-989b-a9441d09217c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u794e348d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=467&amp;originWidth=904&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c744658-4ae3-453a-95bc-6b4354a53a7&amp;title=&amp;width=532" alt=""><br>至多K-1个出现N/K次的数（假设k = 2，至多只有一个数字）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692364-02aa48c0-9e3a-4054-aaa4-0a8176783fbc.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=279&amp;id=u7c355bf8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=480&amp;originWidth=820&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u22b99e23-11f2-4517-ad75-24ab4f0e7ac&amp;title=&amp;width=477" alt=""><br><strong>例子</strong><br>K=4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692393-908c6f08-2bfa-4465-812d-6007cce170df.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=udfebc94e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=919&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c9dd817-5300-40b5-818b-31b809878ad&amp;title=&amp;width=563" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692292-a6252411-18f3-4e51-a21c-65ab7d2fe782.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=281&amp;id=uc29f6c64&amp;margin=%5Bobject%20Object%5D&amp;originHeight=490&amp;originWidth=907&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udfc00b4d-da71-4486-92cc-4c1ec0d3bb6&amp;title=&amp;width=521" alt=""><br>4来了, 所有人-1点血量<br>血量是0不要, 删掉, 一次删掉了4个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652532692349-175242d0-ebac-4c64-8c62-f814f64470dd.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u59831a71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=504&amp;originWidth=603&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub7fa5c34-2c6b-4a84-8c3a-dac5f6647df&amp;title=" alt=""><br><strong>代码</strong><br>必须验证真实次数<br>候选有什么，也不代表它就代表唯一考虑的集合<br>但它是不是, 不收集真实次数没人知道</p><p>| <strong>public static void </strong>printKMajor<strong>(int[] </strong>arr, <strong>int </strong>K<strong>) {<br>   if (</strong>K &lt; 2<strong>) {      </strong>System.<strong>out</strong>.println<strong>(“the value of K is invalid.”)</strong>;<br>      <strong>return</strong>;<br>   <strong>}   </strong>// 攒候选，cands，候选表，最多K-1条记录！ &gt; N / K次的数字，最多有K-1个<br>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>cands = <strong>new </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt;()</strong>;<br>   <strong>for (int </strong>i = 0; i != arr.<strong>length</strong>; i++<strong>) {<br>      if (</strong>cands.containsKey<strong>(</strong>arr<strong>[</strong>i<strong>])) {         </strong>cands.put<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, cands.get<strong>(</strong>arr<strong>[</strong>i<strong>]) </strong>+ 1<strong>)</strong>;<br>      <strong>} else { </strong>// arr[i] 不是候选<br>         <strong>if (</strong>cands.size<strong>() </strong>== K - 1<strong>) { </strong>// 当前数肯定不要！，每一个候选付出1点血量，血量变成0的候选，要删掉！<br>            allCandsMinusOne<strong>(</strong>cands<strong>)</strong>;<br>         <strong>} else {            </strong>cands.put<strong>(</strong>arr<strong>[</strong>i<strong>]</strong>, 1<strong>)</strong>;<br>         <strong>}<br>      }<br>   }   </strong>// 所有可能的候选，都在cands表中！遍历一遍arr，每个候选收集真实次数</p><p>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>reals = getReals<strong>(</strong>arr, cands<strong>)</strong>;<br>   <strong>boolean </strong>hasPrint = <strong>false</strong>;<br>   <strong>for (</strong>Entry<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>set : cands.entrySet<strong>()) {      </strong>Integer key = set.getKey<strong>()</strong>;<br>      <strong>if (</strong>reals.get<strong>(</strong>key<strong>) </strong>&gt; arr.<strong>length </strong>/ K<strong>) {         </strong>hasPrint = <strong>true</strong>;<br>         System.<strong>out</strong>.print<strong>(</strong>key + <strong>“ “)</strong>;<br>      <strong>}<br>   }   </strong>System.<strong>out</strong>.println<strong>(</strong>hasPrint ? <strong>“” </strong>: <strong>“no such number.”)</strong>;<br>**}</p><p>public static void <strong>allCandsMinusOne</strong>(<strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>map</strong>) {<br>   <strong>List</strong>&lt;<strong>Integer</strong>&gt; <strong>removeList = </strong>new <strong>LinkedList</strong>&lt;<strong>Integer</strong>&gt;()<strong>;   </strong>for (<strong>Entry</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>set : map.entrySet</strong>()) {<br>      <strong>Integer key = set.getKey</strong>()<strong>;<br>      Integer value = set.getValue</strong>()<strong>;      </strong>if (<strong>value == 1</strong>) {<br>         <strong>removeList.add</strong>(<strong>key</strong>)<strong>;      </strong>}<br>      <strong>map.put</strong>(<strong>key, value - 1</strong>)<strong>;   </strong>}<br>   for (<strong>Integer removeKey : removeList</strong>) {<br>      <strong>map.remove</strong>(<strong>removeKey</strong>)<strong>;   </strong>}<br>}</p><p>public static <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>getReals</strong>(int[] <strong>arr,<br>      HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>cands</strong>) {<br>   <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt; <strong>reals = </strong>new <strong>HashMap</strong>&lt;<strong>Integer, Integer</strong>&gt;()<strong>;   </strong>for (int <strong>i = 0; i != arr.</strong>length<strong>; i++</strong>) {<br>      int <strong>curNum = arr</strong>[<strong>i</strong>]<strong>;      </strong>if (<strong>cands.containsKey</strong>(<strong>curNum</strong>)) {<br>         if (<strong>reals.containsKey</strong>(<strong>curNum</strong>)) {<br>            <strong>reals.put</strong>(<strong>curNum, reals.get</strong>(<strong>curNum</strong>) <strong>+ 1</strong>)<strong>;         </strong>} else {<br>            <strong>reals.put</strong>(<strong>curNum, 1</strong>)<strong>;         </strong>}<br>      }<br>   }<br>   return <strong>reals;</strong>}** |<br>| —- |</p><h2 id="·-✊第k小的数值对"><a href="#·-✊第k小的数值对" class="headerlink" title="· ✊第k小的数值对"></a>· ✊第k小的数值对</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533451839-1dcc4f86-8175-4b98-bb2d-33fab076095b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=ucc6bd1e8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=231&amp;originWidth=837&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43310&amp;status=done&amp;style=none&amp;taskId=udbf48c7b-c5c2-41b0-807a-c792b021443&amp;title=&amp;width=669.6" alt="image.png"><br><strong>题解</strong><br><strong>暴力解</strong><br>两个for循环生成所有数值对, 放到数组里用比较器排序, 取出第K位的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574288-932f369b-6665-4975-870e-8d798fe5b12a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=280&amp;id=ue3aaa206&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1081&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1fb1f388-552d-4f2a-a109-a817c3ba4b9&amp;title=&amp;width=604" alt=""><br>复杂度 O(N^2<em>logN^2)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574337-82315d0f-95c8-492b-9c77-3fc02ea2091e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=314&amp;id=u7073562e&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1147&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6c9f817e-0dab-474c-857c-d4fef6c040a&amp;title=&amp;width=655" alt=""><br><strong>最优解</strong><br>最优解复杂度O(N)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574399-0f80a80f-e29a-446a-91ed-6eb65d947887.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ud6983707&amp;margin=%5Bobject%20Object%5D&amp;originHeight=323&amp;originWidth=806&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u84b6d280-143f-4d10-abd7-57f845288b9&amp;title=&amp;width=626" alt=""><br><em>*过程</em></em><br>根据第一维数据进行分组<br>第一维的数字是1的叫第1组里的数值对<br>第一维的数字是2的叫第2组里的数值对<br>第一维的数字是3的叫第3组里的数值对<br>第一维的数字是5的叫第4组里的数值对<br>大体上分块就这么多块<br>想知道第70个数是哪个数值对里的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574353-1821c432-0685-4133-b7b9-be12b0b00a2f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaf4e4a03&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=1148&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ded78e1-5092-4773-9c69-8dd1d9d867c&amp;title=" alt=""><br>假设第70个数是(a,b)这两维数据, 先定位a是谁, 数组长度是11<br>必须以0位置的1做为第一维数据的一共有11个<br>必须以1位置的1做为第一维数据的一共有11个<br>必须以2位置的1做为第一维数据的一共有11个<br>必须以3位置的2做为第一维数据的一共有11个<br>所以你想求第 70 个怎么定位这个a？你就看看它是哪一组里的, 说明它第一维就是那个位置的数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533574305-dac448dc-7170-485a-a101-f723d251e819.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ueab68af7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=407&amp;originWidth=1136&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u052e5313-afe0-43a7-8a72-428388a3bf1&amp;title=" alt=""><br>定位70是哪一组里的,<br>第70个数来自于3的组, 第一维数据是3<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575227-31b8ed61-55a5-4dfe-9627-7c7149d896d6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1a4f9244&amp;margin=%5Bobject%20Object%5D&amp;originHeight=540&amp;originWidth=1133&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucf6b52e7-70e5-4015-a29f-6c52f65ea6e&amp;title=" alt=""><br>怎么得到b<br>b肯定是3组里的数值对,<br>3之前一共搞定了55个, 所以你要第 70 个，它应该是三大组中的第 15 个。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575288-74bcd08a-9b14-434a-8bff-c504f8dabde3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=ufa15bced&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2db97466-6de6-4213-9d9d-840e2b29949&amp;title=&amp;width=635" alt=""><br>3大组中再细分,<br>必须以0位置的1做二维数据的有几个?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575449-630237a5-8e4c-44e5-8adf-02ebd9c41cf7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u2e30a4fd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=1129&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uca568bff-376a-4bb3-812f-4b3fa039d94&amp;title=&amp;width=527" alt=""><br>相求3大组中的第15个, 一共有4个3, 所以<br>必须0位置的1做第二维数据的, 4个<br>必须1位置的1做第二维数据的,4个<br>必须2位置的1做第二维数据的,4个<br>必须3位置的2做第二维数据的,4个<br>看看这第15个来自那一组, 就可以定位第二维的数字来自哪儿了</p><p><strong>例子</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575700-2e9c1dc6-1c5a-434e-8f4a-34e244c6162e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=239&amp;id=ue603987f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=390&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u494d13cd-e862-4e22-a402-187828b9bf6&amp;title=&amp;width=689" alt=""><br>第一维的数字是4<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533575882-6c7e9e5d-1b94-4951-841f-d623a6840864.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=322&amp;id=udeef2653&amp;margin=%5Bobject%20Object%5D&amp;originHeight=542&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u06579f25-1baa-49c4-81f0-bda6a471bfc&amp;title=&amp;width=667" alt=""><br>1,2,3开头的一共有70个<br>第一维是4的情况下,<br>4里的12<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576014-43be7fca-337b-4cbf-9dd6-ac93d054933f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6ae98023&amp;margin=%5Bobject%20Object%5D&amp;originHeight=542&amp;originWidth=1126&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufe456ad6-a016-4ec4-9226-9d0d844b402&amp;title=" alt=""><br>4的组细分<br>第二维数字是1,2,3,4的那些<br>第一维数字是 4 的情况下再往下细分组是啥?<br>第二维数据是 1 的那些<br>第二维数据是 2 的那些<br>第二维数据是 3 的那些<br>第二维数据是 4 的那些</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576961-4018a1d4-8795-402b-ad61-9094ebaf856f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=uc4ab67a7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=556&amp;originWidth=1135&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub026b4b3-619a-4a77-a4a5-ae1fc99b04f&amp;title=&amp;width=629" alt=""><br>第一维的数字已经确实是4了<br>第二维数据是 1 的那些分为<br>0位置的1做第二维的数据, 3个, 7,8,9位置的4都是<br>1位置的1做第二维的数据, 3个, 7,8,9位置的4都是</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577008-8175b831-2b92-4719-bc9c-ea5b8bf3434e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=372&amp;id=u8e3187a1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=547&amp;originWidth=873&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf2f6ca15-0d35-46b9-be0d-6928f79b21f&amp;title=&amp;width=594" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533576966-c18e528a-b6b0-4d36-b9ad-54ce913287a5.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u2b5ae72a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=1121&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uee646ef9-bab2-4946-9ef3-cdd53fb4f48&amp;title=&amp;width=627" alt=""><br><strong>抽象化</strong><br>假设一共有N个数,求第K小数值对<br>怎么定位第一维数据?<br>K/N的下标对应的值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577141-db303288-f81d-47eb-a691-3490f7349eeb.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u855fa134&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=1119&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8076f660-ae44-4486-a8c9-004532ef1a2&amp;title=&amp;width=563" alt=""><br>边界考虑<br>第一维数字的下标<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577309-cb5440cc-ec6c-42d0-a207-c3f531c35f16.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=242&amp;id=u3731a3d1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=530&amp;originWidth=1113&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue81e3ddb-626b-4ef0-b035-e2b5239cb4e&amp;title=&amp;width=508" alt=""><br>无序数组中找到第k小, bfprt<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577557-ad44f93d-e7d0-4003-ba23-3ae7897ccd42.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ud35ec140&amp;margin=%5Bobject%20Object%5D&amp;originHeight=557&amp;originWidth=1120&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u38e4bc18-5977-4562-9d02-123c3e64abe&amp;title=&amp;width=545" alt=""><br><strong>怎么定义第二维数字</strong><br>你必须数一下小于 7 的数字有几个你才能知道前面做的一位数字的组帮你搞定了几个，<br>然后拿k减去它才是属于7的组，在第一位数字是 7 的情况下，在这个内部组里面我是第几个呢？<br>这事怎么求?<br>你必须数一下前面小于 7 的数字有几个</p><p><strong>代码 </strong><br>必须搞清楚的第一维数字小于 5 的，之前的数字有几个<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577715-e66d1dd1-8985-476f-a263-11335040c1ba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u9c8a0bcd&amp;margin=%5Bobject%20Object%5D&amp;originHeight=524&amp;originWidth=1044&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uedae6774-6831-4395-9c5d-11ba2520332&amp;title=&amp;width=551" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533577892-e34c0223-de0d-4c47-88cc-c15cd07653ef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=301&amp;id=uc48d9a27&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=1134&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u939b5448-34f1-459a-a8cb-f98e841f015&amp;title=&amp;width=631" alt=""></p><p>| <strong>public static class </strong>Pair <strong>{<br>   public int x</strong>;<br>   <strong>public int y</strong>;</p><p>   Pair<strong>(int </strong>a, <strong>int </strong>b<strong>) {<br>      x </strong>= a;<br>      <strong>y </strong>= b;<br>   **}<br>}</p><p>public static class <strong>PairComparator </strong>implements <strong>Comparator</strong>&lt;<strong>Pair</strong>&gt; {</p><p>   <strong>@Override   </strong>public int <strong>compare</strong>(<strong>Pair arg0, Pair arg1</strong>) {<br>      return <strong>arg0.</strong>x <strong>!= arg1.</strong>x <strong>? arg0.</strong>x <strong>- arg1.</strong>x <strong>: arg0.</strong>y <strong>- arg1.</strong>y<strong>;   </strong>}</p><p>}</p><p><strong>// O(N^2 * log (N^2))的复杂度，你肯定过不了<br>// 返回的int[] 长度是2，{3,1} int[2] = [3,1]</strong>public static int[] <strong>kthMinPair1</strong>(int[] <strong>arr, </strong>int <strong>k</strong>) {<br>   int <strong>N = arr.</strong>length<strong>;   </strong>if (<strong>k &gt; N * N</strong>) {<br>      return null<strong>;   </strong>}<br>   <strong>Pair</strong>[] <strong>pairs = </strong>new <strong>Pair</strong>[<strong>N * N</strong>]<strong>;   </strong>int <strong>index = 0;   </strong>for (int <strong>i = 0; i &lt; N; i++</strong>) {<br>      for (int <strong>j = 0; j &lt; N; j++</strong>) {<br>         <strong>pairs</strong>[<strong>index++</strong>] <strong>= </strong>new <strong>Pair</strong>(<strong>arr</strong>[<strong>i</strong>]<strong>, arr</strong>[<strong>j</strong>])<strong>;      </strong>}<br>   }<br>   <strong>Arrays.sort</strong>(<strong>pairs, </strong>new <strong>PairComparator</strong>())<strong>;   </strong>return new int[] { <strong>pairs</strong>[<strong>k - 1</strong>]<strong>.</strong>x<strong>, pairs</strong>[<strong>k - 1</strong>]<strong>.</strong>y }<strong>;</strong>}</p><p>** |<br>| —- |</p><p>| // O(N<em>logN)的复杂度，你肯定过了<br><strong>public static int[] </strong>kthMinPair2<strong>(int[] </strong>arr, <strong>int </strong>k<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>if (</strong>k &gt; N </em> N<strong>) {<br>      return null</strong>;<br>   <strong>}   </strong>// O(N<em>logN)<br>   Arrays.sort<strong>(</strong>arr<strong>)</strong>;<br>   // 第K小的数值对，第一维数字，是什么 是arr中<br>   <strong>int </strong>fristNum = arr<strong>[(</strong>k - 1<strong>) </strong>/ N<strong>]</strong>;<br>   <strong>int </strong>lessFristNumSize = 0;// 数出比fristNum小的数有几个<br>   <strong>int </strong>fristNumSize = 0; // 数出==fristNum的数有几个<br>   // &lt;= fristNum<br>   <strong>for (int </strong>i = 0; i &lt; N &amp;&amp; arr<strong>[</strong>i<strong>] </strong>&lt;= fristNum; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&lt; fristNum<strong>) {         </strong>lessFristNumSize++;<br>      <strong>} else {         </strong>fristNumSize++;<br>      <strong>}<br>   }<br>   int </strong>rest = k - <strong>(</strong>lessFristNumSize </em> N<strong>)</strong>;<br>   <strong>return new int[] { </strong>fristNum, arr<strong>[(</strong>rest - 1<strong>) </strong>/ fristNumSize<strong>] }</strong>;<br><strong>}</strong> |<br>| —- |</p><p>| // O(N)的复杂度，你肯定蒙了<br><strong>public static int[] </strong>kthMinPair3<strong>(int[] </strong>arr, <strong>int </strong>k<strong>) {<br>   int </strong>N = arr.<strong>length</strong>;<br>   <strong>if (</strong>k &gt; N <em> N<strong>) {<br>      return null</strong>;<br>   <strong>}   </strong>// 在无序数组中，找到第K小的数（k表示下标），返回值<br>   // 第K小，以1作为开始<br>   <strong>int </strong>fristNum = getMinKth<strong>(</strong>arr, <strong>(</strong>k - 1<strong>) </strong>/ N<strong>)</strong>;<br>   // 第1维数字<br>   <strong>int </strong>lessFristNumSize = 0;<br>   <strong>int </strong>fristNumSize = 0;<br>   <strong>for (int </strong>i = 0; i &lt; N; i++<strong>) {<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>&lt; fristNum<strong>) {         </strong>lessFristNumSize++;<br>      <strong>}<br>      if (</strong>arr<strong>[</strong>i<strong>] </strong>== fristNum<strong>) {         </strong>fristNumSize++;<br>      <strong>}<br>   }   </strong>//切记不能死记硬背<br>   /*</em></p><pre><code>*  2 1 5 3 6 5 4 7 2 长度为9 求K = 58*  1 2 2 3 4 5 5 6 7   firstNum = 5(第6小的数)*  rest = 58 - 45 = 13*/</code></pre><p>   <strong>int </strong>rest = k - <strong>(</strong>lessFristNumSize <em> N<strong>)</strong>;<br>   System.<strong>out</strong>.println<strong>(“rest = “ </strong>+ rest<strong>)</strong>;<br>   <strong>return new int[] { </strong>fristNum, getMinKth<strong>(</strong>arr, <strong>(</strong>rest - 1<strong>) </strong>/ fristNumSize<strong>) }</strong>;<br>*</em>}</p><p><strong>// 改写快排，时间复杂度O(N)<br>// 在无序数组arr中，找到，如果排序的话，arr[index]的数是什么？</strong>public static int <strong>getMinKth</strong>(int[] <strong>arr, </strong>int <strong>index</strong>) {<br>   int <strong>L = 0;   </strong>int <strong>R = arr.</strong>length <strong>- 1;   </strong>int <strong>pivot = 0;   </strong>int[] <strong>range = </strong>null<strong>;   </strong>while (<strong>L &lt; R</strong>) {<br>      <strong>pivot = arr</strong>[<strong>L + </strong>(int) (<strong>Math.random</strong>() <strong>* </strong>(<strong>R - L + 1</strong>))]<strong>;<br>      range = partition</strong>(<strong>arr, L, R, pivot</strong>)<strong>;      </strong>if (<strong>index &lt; range</strong>[<strong>0</strong>]) {<br>         <strong>R = range</strong>[<strong>0</strong>] <strong>- 1;      </strong>} else if (<strong>index &gt; range</strong>[<strong>1</strong>]) {<br>         <strong>L = range</strong>[<strong>1</strong>] <strong>+ 1;      </strong>} else {<br>         return <strong>pivot;      </strong>}<br>   }<br>   return <strong>arr</strong>[<strong>L</strong>]<strong>;</strong>}</p><p>public static int[] <strong>partition</strong>(int[] <strong>arr, </strong>int <strong>L, </strong>int <strong>R, </strong>int <strong>pivot</strong>) {<br>   int <strong>less = L - 1;   </strong>int <strong>more = R + 1;   </strong>int <strong>cur = L;   </strong>while (<strong>cur &lt; more</strong>) {<br>      if (<strong>arr</strong>[<strong>cur</strong>] <strong>&lt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, ++less, cur++</strong>)<strong>;      </strong>} else if (<strong>arr</strong>[<strong>cur</strong>] <strong>&gt; pivot</strong>) {<br>         <strong>swap</strong>(<strong>arr, cur, —more</strong>)<strong>;      </strong>} else {<br>         <strong>cur++;      </strong>}<br>   }<br>   return new int[] { <strong>less + 1, more - 1 </strong>}<strong>;</strong>}</p><p>public static void <strong>swap</strong>(int[] <strong>arr, </strong>int <strong>i, </strong>int <strong>j</strong>) {<br>   int <strong>tmp = arr</strong>[<strong>i</strong>]<strong>;<br>   arr</strong>[<strong>i</strong>] <strong>= arr</strong>[<strong>j</strong>]<strong>;<br>   arr</strong>[<strong>j</strong>] <strong>= tmp;</strong>}** |<br>| —- |</p><h2 id="·-数组能不能分成4个相等的部分"><a href="#·-数组能不能分成4个相等的部分" class="headerlink" title="· 数组能不能分成4个相等的部分"></a>· 数组能不能分成4个相等的部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533468062-870ee3db-9ba1-438d-bfba-f1f0eaca5b6e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=139&amp;id=u21da3700&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=174&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31102&amp;status=done&amp;style=none&amp;taskId=u552b24ea-96ee-414d-8b28-0f5ce24cea0&amp;title=&amp;width=456.8" alt="image.png"><br><strong>题意</strong><br>N&gt;=7, 正数数组<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471540-fc6df3a7-1744-4cd5-abf5-c52f0a31e14f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=u3c662ee6&amp;margin=%5Bobject%20Object%5D&amp;originHeight=302&amp;originWidth=808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u91f5bb87-ba17-433f-954d-94343906014&amp;title=&amp;width=508" alt=""><br>你能不能切出四个部分，让四个部分累加和一样。但是切掉的数字是不算的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471734-ee7c3286-54dc-49c0-9841-5a6297def955.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=304&amp;id=ucc6800d7&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=900&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u02fc3a3e-8ed3-4c74-9bd3-99e837f2411&amp;title=&amp;width=578" alt=""><br><strong>题解</strong><br>做出前缀和数组, 假设来到i位置, 想问<br>i位置做第一刀的情况下有没有可能切出4个部分累加和一样<br><strong>例子</strong><br>找209的前缀和<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471524-5d3a4faa-2313-4e57-b4a0-f8c9f5f4cd8b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=329&amp;id=u24736741&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=651&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b0e8c1c-ddc2-4fac-829c-3118343a3af&amp;title=&amp;width=483" alt=""><br>14位置是第二刀<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471485-660cacba-56bd-4b13-a478-cf66a91eec8a.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=240&amp;id=uf0101aab&amp;margin=%5Bobject%20Object%5D&amp;originHeight=433&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uae1dd84f-46f8-46f8-af79-6a3c3d93766&amp;title=&amp;width=541" alt=""><br>验证7位置能不能第一刀, O(1), 然后验证每一个位置做为第一刀, 就可以了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534471488-436b2399-5728-40d0-8da9-e1a64ed33a89.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u97f20565&amp;margin=%5Bobject%20Object%5D&amp;originHeight=475&amp;originWidth=1079&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6f84d7de-0496-43f3-a6c5-e1cb29a148d&amp;title=" alt=""></p><p><strong>代码</strong></p><p>| <strong>public static boolean </strong>canSplits2<strong>(int[] </strong>arr<strong>) {<br>   if (</strong>arr == <strong>null </strong>&#124;&#124; arr.<strong>length </strong>&lt; 7<strong>) {<br>      return false</strong>;<br>   <strong>}   </strong>// key 某一个累加和， value出现的位置<br>   HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt; </strong>map = <strong>new </strong>HashMap<strong>&lt;</strong>Integer, Integer<strong>&gt;()</strong>;<br>   <strong>int </strong>sum = arr<strong>[</strong>0<strong>]</strong>;<br>   <strong>for (int </strong>i = 1; i &lt; arr.<strong>length</strong>; i++<strong>) {      </strong>map.put<strong>(</strong>sum, i<strong>)</strong>;<br>      sum += arr<strong>[</strong>i<strong>]</strong>;<br>   <strong>}<br>   int </strong>lsum = arr<strong>[</strong>0<strong>]</strong>; // 第一刀左侧的累加和<br>   <strong>for (int </strong>s1 = 1; s1 &lt; arr.<strong>length </strong>- 5; s1++<strong>) { </strong>// s1是第一刀的位置<br>      <strong>int </strong>checkSum = lsum <em> 2 + arr<strong>[</strong>s1<strong>]</strong>; // 100 x 100   100</em>2 + x<br>      <strong>if (</strong>map.containsKey<strong>(</strong>checkSum<strong>)) {<br>         int </strong>s2 = map.get<strong>(</strong>checkSum<strong>)</strong>; // j -&gt; y<br>         checkSum += (lsum + arr<strong>[</strong>s2<strong>])</strong>;<br>         <strong>if (</strong>map.containsKey<strong>(</strong>checkSum<strong>)) { </strong>// 100 <em> 3 + x + y<br>            <strong>int </strong>s3 = map.get<strong>(</strong>checkSum<strong>)</strong>; // k -&gt; z<br>            <strong>if (</strong>checkSum + (arr<strong>[</strong>s3<strong>] </strong>+ lsum) == sum<strong>) {<br>               return true</strong>;<br>            <strong>}<br>         }<br>      }      </strong>lsum += arr<strong>[</strong>s1<strong>]</strong>;<br>   <strong>}<br>   return false</strong>;<br><em>*}</em></em> |<br>| —- |</p><h2 id="·-✊316-去除重复字母-M"><a href="#·-✊316-去除重复字母-M" class="headerlink" title="· ✊316. 去除重复字母  [M]"></a>· ✊316. 去除重复字母  [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652533504865-a0411f35-f468-4fe7-ba62-98a6ffb066a1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=322&amp;id=udc341fe0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=402&amp;originWidth=828&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32042&amp;status=done&amp;style=none&amp;taskId=u83a362da-6605-45be-b799-61f01d3e0bb&amp;title=&amp;width=662.4" alt="image.png"><br><strong>题意</strong><br>每种字符只保留一个, 请你返回字典序最小的结果<br>相对次序不能乱<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940519-92d4b450-75f4-4738-b2fc-d448dabee78d.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=uc3a5dde1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=393&amp;originWidth=973&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7ea7df2e-ecc2-4679-8640-20a95c7d97c&amp;title=&amp;width=502" alt=""><br><strong>题解</strong><br>先建立词频统计表, 从左往右划线, 划线的词从词频表里删除</p><p>我如果在这线里面，这条线代表啥意思，我如果要选保留的第一个字符的话，我只能在这条线里选，<br>不能够再把右侧的字符考虑进来了。<br>当我决定保留一个字符的时候，我保留这个字符的同时，左侧字符全不要, 右侧字符可以继续选，<br>我在后面的字符里再选一个字符Y，那么 Y 左边的字符就不能再选了，在后面继续选，这是我的主流程。<br>选ascii码最小的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940426-5bd3de48-60bb-4186-b3f0-dafc220489fd.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=uec914f16&amp;margin=%5Bobject%20Object%5D&amp;originHeight=494&amp;originWidth=931&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9d28ade0-97a0-4e57-8028-5f5f382ea6d&amp;title=&amp;width=598" alt=""><br>因为如果我这个 C 作为我保留第一个字符的话，后面就没 A 了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940449-8ead876f-9228-42c5-9a3a-9e1da7419ba8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=318&amp;id=u7b220aee&amp;margin=%5Bobject%20Object%5D&amp;originHeight=498&amp;originWidth=918&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueb18526a-30cb-44be-9a19-beabfa28a43&amp;title=&amp;width=586" alt=""><br><strong>例子</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940483-a32ca227-5889-422a-a8a6-b692068da001.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u476f8fde&amp;margin=%5Bobject%20Object%5D&amp;originHeight=343&amp;originWidth=861&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua441ad0d-c491-4083-8559-fa70fc38f5b&amp;title=&amp;width=550" alt=""><br><strong>代码</strong></p><p>| //递归版本： 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回<br><strong>public static </strong>String removeDuplicateLetters1<strong>(</strong>String str<strong>) {<br>   if (</strong>str == <strong>null </strong>&#124;&#124; str.length<strong>() </strong>&lt; 2<strong>) {<br>      return </strong>str;<br>   <strong>}<br>   int[] </strong>map = <strong>new int[</strong>256<strong>]</strong>;<br>   <strong>for (int </strong>i = 0; i &lt; str.length<strong>()</strong>; i++<strong>) {      </strong>map<strong>[</strong>str.charAt<strong>(</strong>i<strong>)]</strong>++;<br>   <strong>}<br>   int </strong>minACSIndex = 0;<br>   <strong>for (int </strong>i = 0; i &lt; str.length<strong>()</strong>; i++<strong>) {      </strong>minACSIndex = str.charAt<strong>(</strong>minACSIndex<strong>) </strong>&gt; str.charAt<strong>(</strong>i<strong>) </strong>? i : minACSIndex;<br>      <strong>if (</strong>—map<strong>[</strong>str.charAt<strong>(</strong>i<strong>)] </strong>== 0<strong>) {<br>         break</strong>;<br>      <strong>}<br>   }   </strong>// 0…break(之前) minACSIndex<br>   // str[minACSIndex] 剩下的字符串str[minACSIndex+1…] -&gt; 去掉str[minACSIndex]字符 -&gt; s’<br>   // s’…<br>   <strong>return </strong>String.valueOf<strong>(</strong>str.charAt<strong>(</strong>minACSIndex<strong>)) </strong>+ removeDuplicateLetters1<strong>(         </strong>str.substring<strong>(</strong>minACSIndex + 1<strong>)</strong>.replaceAll<strong>(</strong>String.valueOf<strong>(</strong>str.charAt<strong>(</strong>minACSIndex<strong>))</strong>, <strong>“”))</strong>;<br><strong>}</strong> |<br>| —- |</p><p><strong>复杂度</strong><br>遍历一遍总会保留一个字符, 而且以后的字符串中是不含有这个字符的。<br>所以你str中如果含有 K 种字符，复杂度就是O(K*N)。这个 K 大写加小写也不就是 52 种字符, 所以O(N)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652534940987-5cb7a264-d11d-41c0-b9e1-8e61798e55c6.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=287&amp;id=u7ac43425&amp;margin=%5Bobject%20Object%5D&amp;originHeight=458&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69a4ec90-04ea-41f8-acde-5152dda5a2b&amp;title=&amp;width=586" alt=""></p><h2 id="·-15-三数之和-M"><a href="#·-15-三数之和-M" class="headerlink" title="· 15.三数之和 [M]"></a>· 15.三数之和 [M]</h2><p><strong>题意</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168720-6b744df4-7946-45c9-a331-a2bea7ca808b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=u91a5461c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=418&amp;originWidth=950&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u47aed55e-205d-42c8-b687-db174d78dfa&amp;title=&amp;width=466" alt=""><br>字面值都不一样，就算不同的，有几个三元组全返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168713-93b17778-7f67-446e-90c9-05862b57e449.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ubaf6ddac&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=964&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u18986bf3-72d6-45ce-9a40-801113f1696&amp;title=&amp;width=440" alt=""><br><strong>题解</strong><br>2sum<br>双指针<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168718-d3daae68-041e-4709-83d2-24ed9706dcf1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=161&amp;id=u3abbd115&amp;margin=%5Bobject%20Object%5D&amp;originHeight=244&amp;originWidth=1005&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u13162b89-c8f0-4a19-a91b-a82270cb67d&amp;title=&amp;width=665" alt=""><br><strong>去重复:</strong><br>1) 收集所有二元组, 过滤<br>2) 通过好的流程设计规避重复<br>L移动到下一个不同的数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168760-f5557fad-41a1-4981-9a4a-e7b1be9554d8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=251&amp;id=ue9ce0c40&amp;margin=%5Bobject%20Object%5D&amp;originHeight=471&amp;originWidth=1076&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1155980f-554e-48b9-9513-a53e4dfc988&amp;title=&amp;width=574" alt=""><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535168722-ed693ec3-17f3-40db-875b-40df7a3e3bc2.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc9bb16c8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=440&amp;originWidth=604&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue3cc0675-8fd4-41a6-82ad-5ab956d174d&amp;title=" alt=""><br><strong>题解</strong><br>你只要保证第1个数字不一样后面就是二元组的问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169245-eb3b0c0f-0f36-4691-9b6d-a4d24f65c0f9.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=ubddc1e46&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1017&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9cfee96b-8401-44c4-8bfc-7cbfccc2aa1&amp;title=&amp;width=623" alt=""><br>避免arrayList插到开头的代价有点高, 所以从右往左生成所有的三元组, 把一个数塞在最后<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169284-19a38708-e6da-4a5e-bb4a-20a29232ee3c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u9d26ce66&amp;margin=%5Bobject%20Object%5D&amp;originHeight=520&amp;originWidth=1064&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f65a980-7862-4577-af50-86a27112905&amp;title=&amp;width=614" alt=""><br><strong>代码</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652535169425-e3392844-3840-45f1-9ab5-46624ba97638.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue27c0fc3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=278&amp;originWidth=689&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc8ba67a7-38d3-4a72-af12-8e3c795c18e&amp;title=" alt=""></p><p>| <strong>public static </strong>List<List<Integer>&gt; threeSum(<strong>int</strong>[] nums) {<br>   Arrays.<em>sort</em>(nums);<br>   <strong>int </strong>N = nums.<strong>length</strong>;<br>   List<List<Integer>&gt; ans = <strong>new </strong>ArrayList&lt;&gt;();<br>   <strong>for </strong>(<strong>int </strong>i = N - 1; i &gt; 1; i—) { <em>// 三元组最后一个数，是arr[i]   之前….二元组 + arr[i]      </em><strong>if </strong>(i == N - 1 &#124;&#124; nums[i] != nums[i + 1]) {<br>         List<List<Integer>&gt; nexts = <em>twoSum</em>(nums, i - 1, -nums[i]);<br>         <strong>for </strong>(List<Integer> cur : nexts) {<br>            cur.add(nums[i]);<br>            ans.add(cur);<br>         }<br>      }<br>   }<br>   <strong>return </strong>ans;<br>}</p><p><em>// nums[0…end]这个范围上，有多少个不同二元组，相加==target，全返回<br>// {-1,5}     K = 4<br>// {1, 3}</em><strong>public static </strong>List<List<Integer>&gt; twoSum(<strong>int</strong>[] nums, <strong>int </strong>end, <strong>int </strong>target) {<br>   <strong>int </strong>L = 0;<br>   <strong>int </strong>R = end;<br>   List<List<Integer>&gt; ans = <strong>new </strong>ArrayList&lt;&gt;();<br>   <strong>while </strong>(L &lt; R) {<br>      <strong>if </strong>(nums[L] + nums[R] &gt; target) {<br>         R—;<br>      } <strong>else if </strong>(nums[L] + nums[R] &lt; target) {<br>         L++;<br>      } <strong>else </strong>{ <em>// nums[L] + nums[R] == target         </em><strong>if </strong>(L == 0 &#124;&#124; nums[L - 1] != nums[L]) {<br>            List<Integer> cur = <strong>new </strong>ArrayList&lt;&gt;();<br>            cur.add(nums[L]);<br>            cur.add(nums[R]);<br>            ans.add(cur);<br>         }<br>         L++;<br>      }<br>   }<br>   <strong>return </strong>ans;<br>} |<br>| —- |</p><h2 id="·-小朋友排队的最高分数"><a href="#·-小朋友排队的最高分数" class="headerlink" title="· 小朋友排队的最高分数"></a>· 小朋友排队的最高分数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652536502099-7223e529-c2d9-4f8f-a4a9-a6ab1fcd7ad3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=91&amp;id=u6ea2c2e9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=114&amp;originWidth=832&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22491&amp;status=done&amp;style=none&amp;taskId=u67386263-86db-4666-a03d-34b0bd10782&amp;title=&amp;width=665.6" alt="image.png"><br>暴力递归，把所有的全排列(N!)搞出来, 分数最大的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537096712-968d9c3d-2f9f-44bc-b6e9-a801cf34a8ba.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=330&amp;id=ue4cc4511&amp;margin=%5Bobject%20Object%5D&amp;originHeight=511&amp;originWidth=925&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub1f9f15f-045e-4823-bf05-f159007dd6a&amp;title=&amp;width=597" alt=""></p><p>| <strong>public static int </strong>process<strong>(int[][] </strong>matrix,<strong>int </strong>index,<strong>int </strong>score<strong>) {<br>    int </strong>max = Integer.<strong>MIN_VALUE</strong>;<br>    <strong>int </strong>ans = 0;<br>    <strong>if (</strong>index == matrix.<strong>length) {<br>        return </strong>score;<br>    <strong>} else {<br>        for (int </strong>i = index; i &lt; matrix.<strong>length</strong>; i++<strong>) {<br>            int </strong>num = 0;<br>            swap<strong>(</strong>matrix,index,i<strong>)</strong>;</p><pre><code>        **if (**i-1&gt;0 &amp;&amp; matrix**[**i**][**0**] **&gt; matrix**[**i-1**][**0**]) &#123;            **num += 1;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**]) &#123;            **num += 2;        **&#125;        if (**i+1&lt;matrix.**length **&amp;&amp; matrix**[**i+1**][**1**] **&gt; matrix**[**i**][**1**] **&amp;&amp; matrix**[**i+1**][**0**] **&gt; matrix**[**i**][**0**]) &#123;            **num += 5;        **&#125;        **ans = process**(**matrix,index+1,score+num**)**;        max = Math.max**(**max,ans**)**;        swap**(**matrix,index,i**)**;    **&#125;    return **max;**&#125;</code></pre><p>}<br>public static void <strong>swap</strong>(int[][] <strong>matrix,</strong>int <strong>i,</strong>int <strong>j</strong>) {<br>    int[] <strong>temp = matrix</strong>[<strong>i</strong>]<strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>0</strong>] <strong>= matrix</strong>[<strong>j</strong>][<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>i</strong>][<strong>1</strong>] <strong>= matrix</strong>[<strong>j</strong>][<strong>1</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>0</strong>] <strong>= temp</strong>[<strong>0</strong>]<strong>;<br>    matrix</strong>[<strong>j</strong>][<strong>1</strong>] <strong>= temp</strong>[<strong>1</strong>]<strong>;</strong>}** |<br>| —- |</p><h2 id="·-❓乐队演出的最少花费"><a href="#·-❓乐队演出的最少花费" class="headerlink" title="· ❓乐队演出的最少花费"></a>· ❓乐队演出的最少花费</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537423682-efe033ec-3f72-424f-bde7-e5014b897bef.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=165&amp;id=u4f042f4e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=845&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43808&amp;status=done&amp;style=none&amp;taskId=u0e6f551b-d211-4ea1-b57c-7c37cc19b72&amp;title=&amp;width=676" alt="image.png"><br>题意<br>乐队数量编号跟numbers*2是严格绑定的<br>nums=5, 乐队数量下标一定是0~9<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448658-3dab8950-a21f-43a1-b17b-7ed848f64840.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=300&amp;id=u7d539c9d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=533&amp;originWidth=1051&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uacdc5ae2-9463-4236-b703-588b8875dfa&amp;title=&amp;width=592" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448639-8358f990-06dd-4df5-92ae-7f64d89c5234.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=u8052bab1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=1124&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u76a2c942-9cfb-413c-87b0-e6c87ef102c&amp;title=&amp;width=585" alt=""><br>nums=1, 一定有0,1两支乐队<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448741-b140f77d-7e96-44c8-84b8-5fc2a709c6d8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=285&amp;id=u403bc2c5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=443&amp;originWidth=906&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucb4940ea-7279-443e-9b7d-0ae124ea889&amp;title=&amp;width=583" alt=""><br>nums=2, 一定有0,1, 2, 3 四支乐队<br>一个乐队只能在一个项目里被挑到，它不能同时为两个项目挑到, 把所有乐队都挑全, 返回最低报价</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448667-377bf58a-896b-4092-92b2-f8b2a5e09815.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=286&amp;id=u32fa3de3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=531&amp;originWidth=1106&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u65c2b037-7834-4cf3-ab10-f0b6e2bf05e&amp;title=&amp;width=596" alt=""><br>题解<br>乐队数量16只, 任何两个乐队的组合为C_16^2, 共120种情况, 现在题目中有500组,<br>有大量冗余项目, 只选报价低的, 剩余的删掉<br>如果某个乐队不在报价中返回-1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537448679-f9b98e3e-d745-4b02-bdae-869c77c67a26.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=u6948a087&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=1137&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucaf4f2e9-9d3d-4a61-975f-3175ffd7c66&amp;title=&amp;width=589" alt=""><br>洗数据<br>调整乐队编号, 两个乐队最小值放第一位, 最大值放第二位, 最后是花费<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449231-9d45d470-a1c6-43c9-9588-469ca0f1e264.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=262&amp;id=u46433d67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=419&amp;originWidth=1033&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8f5bb06b-f43c-4077-8a14-5d13c732d90&amp;title=&amp;width=647" alt=""><br>排序: 第一维小的排前面，第一维数据相等的，根据第二维数据小的排前面，前两维数据都相同的，<br>根据报价小的排前面<br>前两项一样的这一组，我只要第一个, 剩下的都删掉<br>把价格大的都删掉。两个乐队之间最低报价的留下来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449453-bf550b3c-8f14-4478-83d9-7deee2932b11.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=238&amp;id=ud0a23bf4&amp;margin=%5Bobject%20Object%5D&amp;originHeight=491&amp;originWidth=1118&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6ee4650d-6457-4fb0-9ab1-c041cd0877a&amp;title=&amp;width=541" alt=""><br>暴力递归<br>通过size控制<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449574-6cc51376-eedc-4492-9837-2b7fe7a5137b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=441&amp;id=u19699120&amp;margin=%5Bobject%20Object%5D&amp;originHeight=586&amp;originWidth=778&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue22b83d6-55e4-4b95-829f-40f960b64cd&amp;title=&amp;width=586" alt=""><br>可以用一个整数的二进制状态，表示哪个乐队挑了哪个没挑<br>一共就8组, 16个乐队<br>最低位就代表0号乐队挑没有挑, 上面如果是1代表挑了, 上面如果是 0 , 代表没挑</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449591-6da74ef6-513b-4524-9b3a-b672e0db5668.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=260&amp;id=u2fe508db&amp;margin=%5Bobject%20Object%5D&amp;originHeight=473&amp;originWidth=1006&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u94eb5d67-dd4e-4672-9456-0ae104e69b9&amp;title=&amp;width=554" alt=""><br>乐队全挑是啥样？<br>应该是某一个整数，后面 16 位全是1，前面 16 位全是0。这个状态就表示你所有的都挑到了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449813-4c4d0188-00e0-4d90-94b2-91dde3d4e2ee.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=291&amp;id=u2abab5d3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=424&amp;originWidth=808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7278723a-a0c2-4568-a86d-a0851da4baf&amp;title=&amp;width=555" alt=""><br>之前 5 位置的 5 乐队已经考虑过了，此时的项目无论如何不能考虑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537449921-dabce459-c444-48ca-9b0d-38842a88bea8.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=276&amp;id=u91c52048&amp;margin=%5Bobject%20Object%5D&amp;originHeight=543&amp;originWidth=1051&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69d7ed52-13ce-44af-b614-77ad78833ad&amp;title=&amp;width=534" alt=""><br>不能改动态规划, 可变参数太多了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450094-53b89c36-d138-4950-9855-9eb41da56b81.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uaefbf1e8&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1189&amp;originWidth=980&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f03743c-eabf-4d20-b806-7572874a0d2&amp;title=" alt=""><br>优化<br>可以省掉done参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450158-14d02b8e-1908-4948-8d94-927946c3838e.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4a13716a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=369&amp;originWidth=825&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf1a8774c-e654-4e8e-80e7-5bbedb5bdff&amp;title=" alt=""><br>复杂度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450320-12c34c5a-b718-43e3-b910-ce5cd6be6e48.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5fa9848d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=519&amp;originWidth=1110&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0d5c8479-84af-4bde-b87e-fdc85878b0a&amp;title=" alt=""><br><br>分治<br>复杂度<br>一共 120 个项目挑 8 个项目就停。<br>C_{120}^8_C_1208 超过 10^8了, 这个方法不行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450494-e0629605-12c2-45c0-ba4d-8981a6fc2e84.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ue97cf8a0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=527&amp;originWidth=1057&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u40393ab8-0e3f-4b26-ae96-d80c6c2c4d1&amp;title=" alt=""><br>特殊情况, num=7<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450801-bf9dd979-4d42-4c30-9acd-45c6b4e7f866.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u628d5bce&amp;margin=%5Bobject%20Object%5D&amp;originHeight=465&amp;originWidth=978&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u16e23e4a-120c-4887-adee-11b29cab4e1&amp;title=" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537450938-6f42c655-5387-4db9-b9db-d38ddc55848f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7ea57ad3&amp;margin=%5Bobject%20Object%5D&amp;originHeight=767&amp;originWidth=713&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u340a0fea-3523-4622-b767-bc6d89db7eb&amp;title=" alt=""></p><h2 id="·-❓题目2-企鹅的最少数量-781-森林中的兔子-M"><a href="#·-❓题目2-企鹅的最少数量-781-森林中的兔子-M" class="headerlink" title="· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]"></a>· ❓题目2: 企鹅的最少数量 | 781. 森林中的兔子 [M]</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537527351-44459aaf-41e1-458d-bae2-5ce71a0191b1.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=176&amp;id=u67946780&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=797&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40177&amp;status=done&amp;style=none&amp;taskId=u47ce9f2e-8b46-4f21-a705-0ea9eefe640&amp;title=&amp;width=637.6" alt="image.png"><br>题意</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-b877c03c-a285-4712-9615-258c243e8ed7.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u5b0b2b90&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufafc36af-a0b5-4e28-9db2-89eb9b6b178&amp;title=&amp;width=570" alt=""><br>a,b必然不同<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512800-25772203-c346-4bbe-8237-30518dbdb60b.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9a8e07f0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=183&amp;originWidth=228&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0c66b2ce-92ce-46a9-b14b-4a3751310b8&amp;title=" alt=""><br><br>题解<br><br>排序, 让说的一样数量的人在一起<br>自我消化<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512831-cf987f51-87b0-448b-ac46-e9d5faf98eb3.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=205&amp;id=uaaa8f52f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=392&amp;originWidth=1092&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud38b542a-cec3-4e17-b52e-70e2f50bd8f&amp;title=&amp;width=570" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512924-12bacc17-7f26-4686-85f0-7f71db1bfa89.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=uf697393a&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=1122&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7604ddcd-7966-4e3a-b5d3-8f4cabf5c5a&amp;title=&amp;width=573" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537512826-891ffc75-377e-4fc5-9d7a-da4028ceae6f.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u2a3485d2&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1088&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6df243e7-fbc7-4a92-ab5c-bae5a440dbc&amp;title=&amp;width=559" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513286-e4853f30-976d-4afb-a9c2-1c0843765303.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=uc338299f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=539&amp;originWidth=1109&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf7ddc6e6-1972-40c5-8878-9a5754d7b21&amp;title=&amp;width=553" alt=""><br>规律, 如果当前数是x, 有c个, 有几组?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513383-501045f8-319a-4179-b47c-9c0c02e0badf.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=277&amp;id=u5d11b8c0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=869&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c2f6b9e-c173-4c10-9c13-75c4fbdd5e3&amp;title=&amp;width=503" alt=""><br>a/b怎么向上取整<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513552-6e8d37f3-9848-4900-8eda-b864d1d22c3c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u20f90519&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=1146&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u396d7a21-be1d-44e9-877e-02a28b7fadc&amp;title=&amp;width=525" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513704-ac750a4e-7f0b-4700-8c7d-443c6aff347c.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=ucf35688f&amp;margin=%5Bobject%20Object%5D&amp;originHeight=545&amp;originWidth=1125&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u103b599a-2ac9-4946-ae00-a479d0b8f24&amp;title=&amp;width=560" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537513881-861b81c5-c61d-4e5d-92f4-e7f56b5dc042.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=150&amp;id=u74b861b9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=1088&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u75cc545e-f180-4c5d-90b8-b2e36446e6f&amp;title=&amp;width=544" alt=""><br>代码<br>不能约<br><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514082-45e66cf1-cbdf-48bd-80ce-7343743b8fca.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=250&amp;id=u32d23b83&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1010&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1f8888e6-27db-45fb-867a-dc516aff8af&amp;title=&amp;width=503" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21371548/1652537514370-fba438f5-6e52-45a9-b7ff-ffe1427d7e10.png#clientId=u1970c3f5-190b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udbfd29aa&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=447&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u877d5405-cfd1-4b2e-b825-ffe2521430e&amp;title=" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> -Markdown -外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
